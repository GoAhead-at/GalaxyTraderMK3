<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Search_Methods" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ========================================
         SEARCH METHODS
         Extracted from gt_trading_search.xml for better organization
         ======================================== -->

    <!-- Reset transient live-search state on game load.
         Live-search jobs (incremental radius search, offer-slice continuations, offer-collection tokens) are not safe to resume across save/load.
         Stale state can leave ships "waiting for live search/batch to complete" forever (no trades). -->
    <cue name="Init" instantiate="true">
      <conditions>
        <check_any>
          <event_game_loaded/>
          <event_player_created/>
        </check_any>
      </conditions>
      <actions>
        <!-- Clear in-flight live-search state -->
        <set_value name="global.$GT_SearchLiveTrades_State" exact="table[]"/>
        <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
        <set_value name="global.$GT_LiveOfferSliceBudget" exact="table[
          $NextStartTime = 0
        ]"/>
        <!-- Offer-slice fairness queue (prevents a single ship monopolizing the slice budget) -->
        <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
          $Ships = [],
          $Queued = table[],
          $Params = table[],
          $Processing = false
        ]"/>
        <set_value name="global.$GT_LiveOfferCollection" exact="table[
          $Active = 0,
          $MaxConcurrent = 1,
          $ActiveShip = null,
          $LastTouched = 0
        ]"/>
      </actions>
    </cue>
    <!-- SearchCachedTrades removed (cleanup).
         Cache queries now run via GT_TradeSearch_Scheduler (CacheQuery work items) calling GT_TS_CachePickBest.
         This stub exists only to avoid hard failures if something still signals this cue. -->
    <cue name="SearchCachedTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Cache] SearchCachedTrades called but removed; ignoring. (Use scheduler CacheQuery/GT_TS_CachePickBest)'" chance="100"/>
        </do_if>
        <cancel_cue cue="this"/>
      </actions>
    </cue>
<cue name="SearchLiveTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        
        <!-- CRITICAL FIX: Check if ship still has GT order before starting/continuing search -->
        <!-- Extract ship from params (works for both fresh and continuation) -->
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- Validate ship is actually a ship object (not a component) -->
        <!-- CRITICAL: Only ship classes are valid - components can have idcode too, so don't use idcode as fallback -->
        <set_value name="$isValidShip" exact="false"/>
        <do_if value="$ship? and $ship.exists">
          <!-- Check if it's actually a ship object (not a component) -->
          <!-- Use direct isclass access like gt_threat_intelligence.xml does -->
          <do_if value="$ship.isclass.ship_s or $ship.isclass.ship_m or $ship.isclass.ship_l or $ship.isclass.ship_xl">
            <set_value name="$isValidShip" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Exit if ship is invalid (component reference or destroyed ship) -->
        <do_if value="not $isValidShip">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchLiveTrades: Invalid ship object (component reference or destroyed ship) - cancelling search'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Check if ship still has GT order -->
        <set_value name="$hasGTOrder" exact="false"/>
        <do_if value="$ship.defaultorder? and @$ship.defaultorder.id == 'GalaxyTraderMK3'">
          <set_value name="$hasGTOrder" exact="true"/>
        </do_if>
        <do_else>
          <!-- Check if subordinate to GT commander -->
          <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
            <do_if value="$ship.commander.defaultorder? and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
              <set_value name="$hasGTOrder" exact="true"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- Exit if no GT order (prevents infinite loops after order removal) -->
        <do_if value="not $hasGTOrder">
          <!-- Clean up state if it exists -->
          <do_if value="global.$GT_SearchLiveTrades_State.{$ship}?">
            <set_value name="$homeSector" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$HomeSector"/>
            <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
            
            <!-- CRITICAL FIX: Clear home refresh marker if this ship was the initiator -->
            <!-- This prevents other ships from being blocked by a ship that lost its GT order -->
            <do_if value="$homeSector? and global.$GT_TS_LiveRefreshBySector? and global.$GT_TS_LiveRefreshBySector.{$homeSector}?">
              <set_value name="$refreshEntry" exact="global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
              <do_if value="$refreshEntry? and $refreshEntry.$Initiator? and $refreshEntry.$Initiator == $ship">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] SearchLiveTrades: Clearing home refresh marker (home=' + @$homeSector.knownname + ', initiator=' + $ship.idcode + ' lost GT order)'" chance="100"/>
                </do_if>
                <remove_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- CRITICAL FIX: Release lock when ship loses GT order -->
          <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
            <param name="ship" value="$ship"/>
            <param name="reason" value="'no_gt_order'"/>
          </run_actions>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchLiveTrades: Ship ' + $ship.idcode + ' no longer has GT order - cancelling search'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Check if this is a continuation from SearchLiveTrades_Resume -->
        <do_if value="$params.$ContinueFromSectorLists? and $params.$ContinueFromSectorLists == true">
          <!-- Continuation: Extract all state from params and skip to price range loading -->
          <!-- CRITICAL: Re-validate ship in continuation path (ship may have changed or become invalid) -->
          <set_value name="$ship" exact="$params.$Ship"/>
          <!-- Re-validate ship for continuation - use same pattern as initial validation -->
          <set_value name="$isValidShip" exact="false"/>
          <do_if value="$ship? and $ship.exists">
            <!-- Check if it's actually a ship object (not a component) -->
            <!-- Use direct isclass access like gt_threat_intelligence.xml does -->
            <do_if value="$ship.isclass.ship_s or $ship.isclass.ship_m or $ship.isclass.ship_l or $ship.isclass.ship_xl">
              <set_value name="$isValidShip" exact="true"/>
            </do_if>
          </do_if>
          <!-- Exit if ship is invalid in continuation -->
          <do_if value="not $isValidShip">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades: Invalid ship object in continuation (component reference or destroyed ship) - cancelling search'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
          <set_value name="$buyspaces" exact="$params.$BuySpaces"/>
          <set_value name="$sellspaces" exact="$params.$SellSpaces"/>
          <set_value name="$shipIsIsolated" exact="$params.$ShipIsIsolated"/>
          <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
          <set_value name="$originalMaxDistance" exact="$params.$OriginalMaxDistance"/>
          <set_value name="$minROI" exact="$params.$MinROI"/>
          <set_value name="$minAbsoluteProfit" exact="$params.$MinAbsoluteProfit"/>
          <set_value name="$factionPriority" exact="$params.$FactionPriority"/>
          <set_value name="$factionPriorityText" exact="$params.$FactionPriorityText"/>
          <set_value name="$distancePenaltyMultiplier" exact="$params.$DistancePenaltyMultiplier"/>
          <set_value name="$skillLevel" exact="$params.$SkillLevel"/>
          <set_value name="$gt_ThreatIntel" exact="$params.$ThreatIntel"/>
          <set_value name="$gt_FleetCoord" exact="$params.$FleetCoord"/>
          <set_value name="$gt_AdvancedAnalytics" exact="$params.$AdvancedAnalytics"/>
          <set_value name="$failedTrades" exact="$params.$FailedTrades"/>
          <set_value name="$tradeList" exact="$params.$TradeList"/>
          <set_value name="$maxTradesToReturn" exact="$params.$MaxTradesToReturn"/>
          <set_value name="$bestTrade" exact="$params.$BestTrade"/>
          
          <!-- CRITICAL FIX: Store BuySpaces/SellSpaces in state so SearchLiveTrades_AppendPendingOffers can access them -->
          <do_if value="$buyspaces? and $buyspaces != null">
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$BuySpaces" exact="$buyspaces"/>
          </do_if>
          <do_if value="$sellspaces? and $sellspaces != null">
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$SellSpaces" exact="$sellspaces"/>
          </do_if>
          <set_value name="$bestScore" exact="$params.$BestScore"/>
          <set_value name="$stationsEvaluated" exact="$params.$StationsEvaluated"/>
          <set_value name="$offersFound" exact="$params.$OffersFound"/>
          <set_value name="$homeBase" exact="$params.$HomeBase"/>
          <set_value name="$homeBaseSource" exact="$params.$HomeBaseSource"/>
          <set_value name="$homeSectorAnchor" exact="$params.$HomeSectorAnchor"/>
          <set_value name="$allowIllegal" exact="$params.$AllowIllegal"/>
          <set_value name="$wareBasket" exact="$params.$WareBasket"/>
          <set_value name="$ignoreTradeRules" exact="if $params.$IgnoreTradeRules? then $params.$IgnoreTradeRules else false"/>
          <set_value name="$blacklistgroup" exact="$params.$BlacklistGroup"/>
          <set_value name="$sellPriceMax" exact="$params.$SellPriceMax"/>
          <set_value name="$buyPriceMin" exact="$params.$BuyPriceMin"/>
          
          <!-- Skip to price range loading (already done in resume cue) -->
          <!-- Continue with trade finding logic - skip sector list building -->
          <!-- Note: Trade finding logic continues below after the normal flow check -->
        </do_if>
        
        <!-- Normal flow: Extract all parameters (only if not continuing) -->
        <do_if value="not ($params.$ContinueFromSectorLists? and $params.$ContinueFromSectorLists == true)">
          <set_value name="$ship" exact="$params.$Ship"/>
          <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
          <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance for normal searches -->
        <do_if value="$params.$OriginalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$params.$OriginalMaxDistance"/>  <!-- Fallback search: use original pilot maxDistance -->
        </do_if>
        <set_value name="$minROI" exact="$params.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="$params.$FactionPriority"/>
        <set_value name="$factionPriorityText" exact="$params.$FactionPriorityText"/>
        <set_value name="$distancePenaltyMultiplier" exact="$params.$DistancePenaltyMultiplier"/>
        <set_value name="$skillLevel" exact="$params.$SkillLevel"/>
        <set_value name="$gt_ThreatIntel" exact="$params.$ThreatIntel"/>
        <set_value name="$gt_FleetCoord" exact="$params.$FleetCoord"/>
        <set_value name="$gt_AdvancedAnalytics" exact="$params.$AdvancedAnalytics"/>
        
        <!-- Extract trace ID -->
        <set_value name="$traceId" exact="''"/>
        <do_if value="$params.$TraceId?">
          <set_value name="$traceId" exact="$params.$TraceId"/>
        </do_if>
        
        <!-- NOTE: Do NOT clear failed trades here - we need to check them AFTER finding best trade -->
        <!-- Failed trades are only cleared on success (in gt_trading_signals.xml) -->
        
        <!-- VERSION LOG - COMMENTED OUT (reduces log spam) -->
        <!-- <debug_text text="'[GT-Search] CODE VERSION: 2025-10-25-v5 (Score Bug Fixed) | Ship: ' + $ship.idcode" chance="100"/> -->
        
        <!-- Get failed sector pairs for ship's current sector (needed for filtering during best trade selection) -->
        <!-- Ships in the same sector share failed sector pairs (same connectivity/blacklist context) -->
        <!-- FIX: Clean expired entries (older than 30 minutes) to prevent deadlock -->
        <set_value name="$currentSector" exact="$ship.sector"/>
        <set_value name="$failedTrades" exact="[]"/>
        <do_if value="$currentSector? and $currentSector.exists and global.$GT_FailedSectorPairs? and global.$GT_FailedSectorPairs.{$currentSector}?">
          <set_value name="$failedTradesRaw" exact="global.$GT_FailedSectorPairs.{$currentSector}"/>
          <set_value name="$failedTradesExpired" exact="[]"/>
          <set_value name="$expirationTime" exact="1800s"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$FailedTradeExpirationSeconds?">
            <set_value name="$expirationTime" exact="global.$GT_GlobalSettings.$Performance.$FailedTradeExpirationSeconds * 1s"/>
          </do_if>
          
          <!-- Filter out expired entries -->
          <do_all exact="$failedTradesRaw.count" counter="$i">
            <set_value name="$failedTrade" exact="$failedTradesRaw.{$i}"/>
            <set_value name="$tradeAge" exact="player.age - $failedTrade.$Timestamp"/>
            <do_if value="$tradeAge le $expirationTime">
              <!-- Entry still valid - keep it -->
              <append_to_list name="$failedTrades" exact="$failedTrade"/>
            </do_if>
            <do_else>
              <!-- Entry expired - mark for removal -->
              <append_to_list name="$failedTradesExpired" exact="$i"/>
            </do_else>
          </do_all>
          
          <!-- Update global storage with cleaned list -->
          <do_if value="$failedTradesExpired.count gt 0">
            <set_value name="global.$GT_FailedSectorPairs.{$currentSector}" exact="$failedTrades"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$sectorName" exact="@$currentSector.knownname"/>
              <debug_text text="'[GT-Search] Cleaned ' + $failedTradesExpired.count + ' expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (older than 30 minutes)'" chance="100"/>
            </do_if>
          </do_if>
          <do_elseif value="$failedTrades.count == 0">
            <!-- All entries expired - clear the list entirely -->
            <remove_value name="global.$GT_FailedSectorPairs.{$currentSector}"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$sectorName" exact="@$currentSector.knownname"/>
              <debug_text text="'[GT-Search] Cleared all expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (all older than 30 minutes)'" chance="100"/>
            </do_if>
          </do_elseif>
        </do_if>
        
        <!-- NEW: Collect top trades instead of just best one -->
        <!-- Use global setting for max trades to return -->
        <set_value name="$tradeList" exact="[]"/>
        <set_value name="$maxTradesToReturn" exact="20"/> <!-- Default fallback - matches menu default -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn?">
          <set_value name="$maxTradesToReturn" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn"/>
        </do_if>
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$stationsEvaluated" exact="0"/>
        <set_value name="$offersFound" exact="0"/>
        
        <!-- ===== DETERMINE HOME SECTOR ===== -->
        <!-- CRITICAL: Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <set_value name="$homeBase" exact="null"/>
        <set_value name="$homeBaseSource" exact="'unknown'"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
              <do_if value="@$commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
              <set_value name="$homeBaseSource" exact="'commander (subordinate)'"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
          <set_value name="$homeBaseSource" exact="'defaultorder'"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
            <set_value name="$homeBaseSource" exact="'GT_AIParameters (fallback)'"/>
          </do_if>
          <do_else>
            <!-- REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null! This should never happen.'" chance="100"/>
            </do_if>
            <!-- Emergency fallback only - this should never happen -->
            <set_value name="$homeBase" exact="$ship.sector"/>
            <set_value name="$homeBaseSource" exact="'ship.sector (EMERGENCY - WILL CAUSE DRIFT!)'"/>
          </do_else>
        </do_if>
        
        <!-- Extract sector -->
        <set_value name="$homeSector" exact="null"/>
        <set_value name="$homeSectorAnchor" exact="null"/>
        <do_if value="@$homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
            <set_value name="$homeSectorAnchor" exact="$homeBase"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
            <set_value name="$homeSectorAnchor" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
          </do_if>
          <!-- Emergency fallback only - this should never happen -->
          <set_value name="$homeSector" exact="$ship.sector"/>
          <set_value name="$homeSectorAnchor" exact="$ship.sector"/>
        </do_if>
        
        <!-- PERFORMANCE OPTIMIZATION: Ensure homeSectorAnchor is set (for match_gate_distance) -->
        <do_if value="not $homeSectorAnchor? or not $homeSectorAnchor.exists">
          <set_value name="$homeSectorAnchor" exact="$homeSector"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ')  Home base: ' + @$homeBase.knownname + ' (sector: ' + $homeSector.knownname + ') [source: ' + $homeBaseSource + ']'" chance="100"/>
        </do_if>

        <!-- NATIVE ACTION REFACTORING: Use C++ trade offer search instead of MD loops  -->
        <!-- Replaces 2000+ station iterations with single galaxy-wide native C++ queries  -->
        <!-- Performance: 10-100— faster, ZERO stutter (C++ code executes in one frame)   -->
        
        <!-- Get AI parameters for filtering -->
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        <set_value name="$ignoreTradeRules" exact="false"/>
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreTradeRules?">
          <set_value name="$ignoreTradeRules" exact="global.$GT_AIParameters.{$ship}.$IgnoreTradeRules"/>
        </do_if>
        <!-- Persist onto params so slice-driven continuations carry it forward -->
        <set_value name="$params.$IgnoreTradeRules" exact="$ignoreTradeRules"/>
        
        <!-- CRITICAL: Initialize $wareBasket safely (using library function) -->
        <!-- Use library function for safe ware basket retrieval -->
        <run_actions ref="md.GT_Libraries_General.GT_GetWareBasketSafe" result="$wareBasket">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Determine ship's blacklistgroup -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Initialize global state table if it doesn't exist -->
        <do_if value="not global.$GT_SearchLiveTrades_State?">
          <set_value name="global.$GT_SearchLiveTrades_State" exact="table[]"/>
        </do_if>
        
        <!-- FIX: Check if a search is already in progress for this ship -->
        <!-- This prevents race conditions where multiple searches overwrite each other's state -->
        <!-- CRITICAL: Also check for stale state (similar to SearchTradeRoutes) to prevent deadlocks -->
        <set_value name="$shouldProceed" exact="true"/>
        <do_if value="global.$GT_SearchLiveTrades_State.{$ship}?">
          <!-- Dynamic stale detection:
               The live-search pipeline can legitimately take minutes under heavy fleets because:
               - offer slices are throttled by LiveOfferSliceInterval (ms),
               - slices are round-robin across all ships in LiveOfferSliceQueue,
               - each ship can have (BuySpaces.count + SellSpaces.count) sectors to query,
               - plus chunked append passes.
               Old logic used `$stateStarted?` (true even when null) and a fixed 60s threshold, which caused bogus huge ages and premature clears. -->
          <set_value name="$state" exact="@global.$GT_SearchLiveTrades_State.{$ship}"/>
          <set_value name="$stateStarted" exact="null"/>
          <do_if value="$state != null and $state.$Started? and $state.$Started != null">
            <set_value name="$stateStarted" exact="$state.$Started"/>
          </do_if>

          <!-- Age in seconds (numeric). If Started missing/null, leave as -1. -->
          <set_value name="$stateAgeSeconds" exact="-1"/>
          <do_if value="$stateStarted != null">
            <set_value name="$stateAgeSeconds" exact="(player.age - $stateStarted) / 1s"/>
          </do_if>
          
          <!-- CRITICAL: If a state exists but is missing .$Started (null), it is almost always a stale/legacy/partial state.
               Treat it as stale and restart; otherwise HomeSearch coalescing can deadlock forever waiting for a resume signal
               that will never arrive. -->
          <do_if value="$stateStarted == null">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades: Clearing stale state for ship ' + $ship.idcode + ' (reason=missing_started) - proceeding with new search'" chance="100"/>
            </do_if>
            <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
            <set_value name="$shouldProceed" exact="true"/>
          </do_if>
          <do_else>

          <!-- Load pacing settings -->
          <set_value name="$sliceIntervalMs" exact="500"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval?">
            <set_value name="$tmpMs" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval"/>
            <do_if value="$tmpMs? and $tmpMs != null and $tmpMs gt 0">
              <set_value name="$sliceIntervalMs" exact="$tmpMs"/>
            </do_if>
          </do_if>
          <do_if value="$sliceIntervalMs lt 5">
            <set_value name="$sliceIntervalMs" exact="5"/>
          </do_if>
          <do_if value="$sliceIntervalMs gt 2000">
            <set_value name="$sliceIntervalMs" exact="2000"/>
          </do_if>

          <set_value name="$appendChunkSize" exact="200"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferAppendChunkSize?">
            <set_value name="$tmpChunk" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferAppendChunkSize"/>
            <do_if value="$tmpChunk? and $tmpChunk != null and $tmpChunk gt 0">
              <set_value name="$appendChunkSize" exact="$tmpChunk"/>
            </do_if>
          </do_if>
          <do_if value="$appendChunkSize lt 50">
            <set_value name="$appendChunkSize" exact="50"/>
          </do_if>
          <do_if value="$appendChunkSize gt 2000">
            <set_value name="$appendChunkSize" exact="2000"/>
          </do_if>

          <!-- Approximate contention: how many ships are sharing the offer-slice queue right now -->
          <set_value name="$sliceQueueShips" exact="1"/>
          <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Ships?">
            <set_value name="$tmpQ" exact="@global.$GT_LiveOfferSliceQueue.$Ships.count"/>
            <do_if value="$tmpQ? and $tmpQ != null and $tmpQ gt 0">
              <set_value name="$sliceQueueShips" exact="$tmpQ"/>
            </do_if>
          </do_if>

          <!-- Remaining sector slices (if we have lists/indices); otherwise use a conservative fallback -->
          <set_value name="$buyCount" exact="0"/>
          <set_value name="$sellCount" exact="0"/>
          <do_if value="$state != null and $state.$BuySpaces? and $state.$BuySpaces != null">
            <set_value name="$buyCount" exact="$state.$BuySpaces.count"/>
          </do_if>
          <do_if value="$state != null and $state.$SellSpaces? and $state.$SellSpaces != null">
            <set_value name="$sellCount" exact="$state.$SellSpaces.count"/>
          </do_if>
          <set_value name="$buyIndex" exact="0"/>
          <do_if value="$state != null and $state.$BuyIndex? and $state.$BuyIndex != null">
            <set_value name="$buyIndex" exact="$state.$BuyIndex"/>
          </do_if>
          <set_value name="$sellIndex" exact="0"/>
          <do_if value="$state != null and $state.$SellIndex? and $state.$SellIndex != null">
            <set_value name="$sellIndex" exact="$state.$SellIndex"/>
          </do_if>
          <set_value name="$remainingBuy" exact="[$buyCount - $buyIndex, 0].max"/>
          <set_value name="$remainingSell" exact="[$sellCount - $sellIndex, 0].max"/>
          <set_value name="$remainingSectors" exact="$remainingBuy + $remainingSell"/>

          <!-- Pending append chunks remaining (if any) -->
          <set_value name="$pendingChunksRemaining" exact="0"/>
          <do_if value="$state != null and $state.$PendingOffers? and $state.$PendingOffers != null">
            <set_value name="$pendingOffersCount" exact="$state.$PendingOffers.count"/>
            <set_value name="$pendingIndex" exact="0"/>
            <do_if value="$state.$PendingIndex? and $state.$PendingIndex != null">
              <set_value name="$pendingIndex" exact="$state.$PendingIndex"/>
            </do_if>
            <set_value name="$pendingRemaining" exact="[$pendingOffersCount - $pendingIndex, 0].max"/>
            <!-- ceil(pendingRemaining / appendChunkSize) -->
            <do_if value="$pendingRemaining gt 0">
              <set_value name="$pendingChunksRemaining" exact="(($pendingRemaining + $appendChunkSize - 1) / $appendChunkSize)i"/>
            </do_if>
          </do_if>

          <!-- Compute dynamic stale threshold (seconds):
               - sector slice time scales with interval and queue contention,
               - append chunks add small overhead (50ms each avg, not contention-scaled),
               - add a safety buffer, clamp to a sane minimum. -->
          <set_value name="$baseStaleThreshold" exact="300"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$StaleThresholdSeconds?">
            <set_value name="$baseStaleThreshold" exact="global.$GT_GlobalSettings.$Performance.$StaleThresholdSeconds"/>
          </do_if>
          <set_value name="$staleThresholdSeconds" exact="$baseStaleThreshold"/>
          <do_if value="$remainingSectors gt 0">
            <set_value name="$sliceSeconds" exact="($remainingSectors * $sliceIntervalMs * $sliceQueueShips) / 1000.0"/>
            <set_value name="$appendSeconds" exact="$pendingChunksRemaining * 0.05"/>
            <set_value name="$staleThresholdSeconds" exact="[$sliceSeconds + $appendSeconds + 60, $baseStaleThreshold].max"/>
          </do_if>

          <!-- Clear stale state and proceed with new search -->
          <do_if value="$stateAgeSeconds ge 0 and $stateAgeSeconds gt $staleThresholdSeconds">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades: Clearing stale state for ship ' + $ship.idcode +
                ' (age=' + $stateAgeSeconds + 's, threshold=' + $staleThresholdSeconds + 's, remainingSectors=' + $remainingSectors +
                ', sliceIntervalMs=' + $sliceIntervalMs + ', sliceQueueShips=' + $sliceQueueShips + ', pendingChunks=' + $pendingChunksRemaining + ') - proceeding with new search'" chance="100"/>
            </do_if>
            <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
            <!-- Proceed with new search -->
            <set_value name="$shouldProceed" exact="true"/>
          </do_if>
          <do_else>
            <!-- State is fresh - search is genuinely in progress -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades: Search already in progress for ship ' + $ship.idcode +
                ' (age=' + (if $stateAgeSeconds ge 0 then $stateAgeSeconds + 's' else 'unknown') +
                ', threshold=' + $staleThresholdSeconds + 's) - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <!-- Exit immediately - SearchLiveTrades_Resume will signal SearchTradeRoutes when search completes -->
            <set_value name="$shouldProceed" exact="false"/>
            <cancel_cue cue="this"/>
          </do_else>
          
          </do_else>
        </do_if>
        
        <!-- Only proceed if search is NOT already in progress (or stale state was cleared) -->
        <do_if value="$shouldProceed">
          <!-- NEW: Async cue-based pattern with CPU yielding (replaces synchronous GT_BuildTradeSectorLists) -->
          <!-- Debug logging -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchLiveTrades: Storing state and signaling GT_IncrementalRadiusSearch - Ship=' + $ship.idcode + ', HomeSector=' + @$homeSector.knownname + ', MaxDistance=' + $maxDistance" chance="100"/>
          </do_if>
          <!-- Log live search pathfinding start -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'LiveSearch'"/>
              <param name="action" value="'PathfindingStart'"/>
              <param name="details" value="'homeSector=' + (if $homeSector? then @$homeSector.knownname else 'null') + ' maxDistance=' + $maxDistance"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          
          <!-- Extract IsIsolated flag from params if present -->
          <set_value name="$isIsolatedSearch" exact="false"/>
          <do_if value="$params.$IsIsolated? and $params.$IsIsolated == true">
            <set_value name="$isIsolatedSearch" exact="true"/>
          </do_if>
          <!-- Extract IsFallback flag from params if present -->
          <set_value name="$isFallbackSearch" exact="false"/>
          <do_if value="$params.$IsFallback? and $params.$IsFallback == true">
            <set_value name="$isFallbackSearch" exact="true"/>
          </do_if>
          
          <!-- Store state in global variables for resume cue -->
          <set_value name="global.$GT_SearchLiveTrades_State.{$ship}" exact="table[
          $Started = player.age,
          $Ship = $ship,
          $HomeSector = $homeSector,
          $MaxDistance = $maxDistance,
          $OriginalMaxDistance = $originalMaxDistance,
          $MinROI = $minROI,
          $MinAbsoluteProfit = $minAbsoluteProfit,
          $FactionPriority = $factionPriority,
          $FactionPriorityText = $factionPriorityText,
          $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
          $SkillLevel = $skillLevel,
          $ThreatIntel = $gt_ThreatIntel,
          $FleetCoord = $gt_FleetCoord,
          $AdvancedAnalytics = $gt_AdvancedAnalytics,
          $IsIsolated = $isIsolatedSearch,
          $IsFallback = $isFallbackSearch,
          $FailedTrades = $failedTrades,
          $TradeList = $tradeList,
          $MaxTradesToReturn = $maxTradesToReturn,
          $BestTrade = $bestTrade,
          $BestScore = $bestScore,
          $StationsEvaluated = $stationsEvaluated,
          $OffersFound = $offersFound,
          $HomeBase = $homeBase,
          $HomeBaseSource = $homeBaseSource,
          $HomeSectorAnchor = $homeSectorAnchor,
          $AllowIllegal = $allowIllegal,
          $WareBasket = $wareBasket,
          $BlacklistGroup = $blacklistgroup,
          $TraceId = $traceId
        ]"/>
        
          <!-- Signal pathfinding queue processor (enforces concurrency limits) -->
          <do_if value="not global.$GT_PathfindingQueue?">
            <set_value name="global.$GT_PathfindingQueue" exact="table[]"/>
          </do_if>
          <!-- IMPORTANT: `$Requests` can exist but be null (existence check `?` does NOT mean non-null). -->
          <do_if value="not global.$GT_PathfindingQueue.$Requests? or global.$GT_PathfindingQueue.$Requests == null">
            <set_value name="global.$GT_PathfindingQueue.$Requests" exact="[]"/>
          </do_if>
          <do_if value="not global.$GT_PathfindingQueue.$ActiveInstances? or global.$GT_PathfindingQueue.$ActiveInstances == null">
            <set_value name="global.$GT_PathfindingQueue.$ActiveInstances" exact="0"/>
          </do_if>
          <do_if value="not global.$GT_PathfindingQueue.$MaxConcurrent? or global.$GT_PathfindingQueue.$MaxConcurrent == null">
            <set_value name="global.$GT_PathfindingQueue.$MaxConcurrent" exact="2"/>
          </do_if>
          <do_if value="not global.$GT_PathfindingQueue.$ActiveShips? or global.$GT_PathfindingQueue.$ActiveShips == null">
            <set_value name="global.$GT_PathfindingQueue.$ActiveShips" exact="[]"/>
          </do_if>
          
          <append_to_list name="global.$GT_PathfindingQueue.$Requests" exact="table[
            $Ship = $ship,
            $HomeSector = $homeSector,
            $MaxDistance = $maxDistance,
            $BlacklistGroup = $blacklistgroup
          ]"/>
          
          <!-- PROOF: Confirm we actually queued a pathfinding request for this ship -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Pathfinding] Queued request for ' + $ship.idcode + ' (home=' + @$homeSector.knownname + ', maxDist=' + $maxDistance + ', queued=' + global.$GT_PathfindingQueue.$Requests.count + ')'" chance="100"/>
          </do_if>
          
          <signal_cue_instantly cue="md.GT_Libraries_Pathfinding.ProcessPathfindingQueue"/>

          <!-- PROOF: Confirm we signaled the queue processor -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Pathfinding] Signaled ProcessPathfindingQueue (ship=' + $ship.idcode + ')'" chance="100"/>
          </do_if>
          
          <!-- Cancel current cue - SearchLiveTrades_Resume will continue processing -->
          <cancel_cue cue="this"/>
        </do_if>
        <!-- Close shouldProceed check -->
        </do_if>
        <!-- Close normal flow check (not ContinueFromSectorLists) -->
        
        <!-- CONTINUATION: If continuing from SearchLiveTrades_Resume, process trade finding -->
        <!-- This code only executes when ContinueFromSectorLists is true -->
        <do_if value="$params.$ContinueFromSectorLists? and $params.$ContinueFromSectorLists == true">
          <!-- Debug logging -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchLiveTrades: CONTINUATION from SearchLiveTrades_Resume - Ship=' + $ship.idcode + ', BuySpaces=' + $buyspaces.count + ', SellSpaces=' + $sellspaces.count + ', Isolated=' + $shipIsIsolated" chance="100"/>
            <!-- CRITICAL DEBUG: Log if sector lists are empty -->
            <do_if value="$buyspaces.count == 0 and $sellspaces.count == 0">
              <debug_text text="'[GT-Search] ⚠️ WARNING: SearchLiveTrades continuation received EMPTY sector lists - Ship=' + $ship.idcode + ', HomeSector=' + (if $homeSector != null then @$homeSector.knownname else 'NULL') + ', CurrentSector=' + (if @$ship.sector != null then @$ship.sector.knownname else 'NULL') + ', MaxDistance=' + $maxDistance" chance="100"/>
            </do_if>
          </do_if>

          <!-- Live search range is capped by effective MaxDistance (order max jumps already clamped by pilot skill).
               Do NOT additionally cap by sector list size here, otherwise "max jumps" is silently ignored. -->
          <!-- CONTINUATION: Extract sector lists from params and continue with trade finding -->
          <!-- Price range already loaded in SearchLiveTrades_Resume -->
          <!-- This restricts native queries to pre-filtered sectors only (much more efficient) -->
          <!-- PERFORMANCE: Slice offer collection across frames (smooth gameplay > speed). -->
          <!-- NOTE: weights in analyze_timeline.ps1 show LiveOffers dominates expensive frames. -->
          <set_value name="$deferOfferSlice" exact="false"/>
          
          <!-- Load/initialize offer-collection state -->
          <set_value name="$state" exact="@global.$GT_SearchLiveTrades_State.{$ship}"/>
          <set_value name="$offerPhase" exact="@$state.$OfferPhase"/>
          <do_if value="$offerPhase == null">
            <set_value name="$offerPhase" exact="'selloffers'"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="$offerPhase"/>
          </do_if>
          
          <set_value name="$buyIndex" exact="@$state.$BuyIndex"/>
          <do_if value="$buyIndex == null">
            <set_value name="$buyIndex" exact="0"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$BuyIndex" exact="$buyIndex"/>
          </do_if>
          <set_value name="$sellIndex" exact="@$state.$SellIndex"/>
          <do_if value="$sellIndex == null">
            <set_value name="$sellIndex" exact="0"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$SellIndex" exact="$sellIndex"/>
          </do_if>
          
          <set_value name="$allSellOffers" exact="@$state.$AllSellOffers"/>
          <do_if value="$allSellOffers == null">
            <set_value name="$allSellOffers" exact="[]"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$AllSellOffers" exact="$allSellOffers"/>
          </do_if>
          <set_value name="$allBuyOffers" exact="@$state.$AllBuyOffers"/>
          <do_if value="$allBuyOffers == null">
            <set_value name="$allBuyOffers" exact="[]"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$AllBuyOffers" exact="$allBuyOffers"/>
          </do_if>
          
        <!-- CRITICAL SMOOTHNESS GATE:
             Do NOT run native offer queries unless this invocation was granted a slice by the global queue.
             Without this, many ships can enter this continuation simultaneously (after pathfinding resume)
             and each will do a "first slice" query in the same frame bucket (microstutter). -->
        <set_value name="$sliceGranted" exact="false"/>
        <do_if value="$params.$SliceGranted? and $params.$SliceGranted == true">
          <set_value name="$sliceGranted" exact="true"/>
        </do_if>
        <do_if value="($offerPhase == 'selloffers' or $offerPhase == 'buyoffers') and not $sliceGranted">
          <set_value name="$deferOfferSlice" exact="true"/>
          <!-- Enqueue via global fair queue (one ship per budget tick) -->
          <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
            <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
              $Ships = [],
              $Queued = table[],
              $Params = table[],
              $Processing = false
            ]"/>
          </do_if>
          <do_if value="not global.$GT_LiveOfferSliceScheduled?">
            <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
          </do_if>
          <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
            <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
            <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
            <!-- Ensure we don't accidentally carry a prior grant -->
            <set_value name="$params.$SliceGranted" exact="false"/>
            <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
            <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
              <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
              <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
            </do_if>
            <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>

          <!-- Smoothness > speed:
               keep slice work very small to prevent microstutter (large offer lists => many append_to_list ops).
               This is still globally throttled by LiveOfferSliceInterval + the fair slice queue.
               Consistent slicing regardless of jump distance for code simplicity. -->
          <set_value name="$sectorsPerSlice" exact="1"/>
          <!-- Use global setting if available -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$SectorsPerSlice?">
            <set_value name="$tmpSectors" exact="@global.$GT_GlobalSettings.$Performance.$SectorsPerSlice"/>
            <do_if value="$tmpSectors? and $tmpSectors != null and $tmpSectors ge 1 and $tmpSectors le 5">
              <set_value name="$sectorsPerSlice" exact="$tmpSectors"/>
            </do_if>
          </do_if>
          
          <!-- Phase 1: Collect SELL offers from buyspaces (ship buys FROM stations) -->
          <do_if value="$offerPhase == 'selloffers'">
            <set_value name="$sliceSectors" exact="[]"/>
            <set_value name="$remaining" exact="$buyspaces.count - $buyIndex"/>
            <set_value name="$sliceCount" exact="$sectorsPerSlice"/>
            <do_if value="$remaining lt $sliceCount">
              <set_value name="$sliceCount" exact="$remaining"/>
            </do_if>
            
            <do_all exact="$sliceCount" counter="$k">
              <set_value name="$idx" exact="$buyIndex + $k"/>
              <append_to_list name="$sliceSectors" exact="$buyspaces.{$idx}"/>
            </do_all>
            
            <do_all exact="$sliceSectors.count" counter="$i">
              <set_value name="$sector" exact="$sliceSectors.{$i}"/>
              <do_if value="not $sector? or not $sector.exists">
                <continue/>
              </do_if>
              
              <set_value name="$sectorSellOffers" exact="[]"/>
              <do_if value="$wareBasket? and $wareBasket != null and $wareBasket.count gt 0">
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-PERF] LiveOffersQuery START ship=' + $ship.idcode + ' phase=selloffers'" chance="100"/>
                </do_if>
                <do_if value="$ignoreTradeRules">
                  <find_sell_offer space="$sector" result="$sectorSellOffers" wares="$wareBasket" multiple="true">
                    <match_seller tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_seller>
                    <relativeprice max="$sellPriceMax"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_sell_offer>
                </do_if>
                <do_else>
                  <find_sell_offer tradepartner="$ship" space="$sector" result="$sectorSellOffers" wares="$wareBasket" multiple="true">
                    <match_seller tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_seller>
                    <relativeprice max="$sellPriceMax"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_sell_offer>
                </do_else>
              </do_if>
              <do_else>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-PERF] LiveOffersQuery START ship=' + $ship.idcode + ' phase=selloffers'" chance="100"/>
                </do_if>
                <do_if value="$ignoreTradeRules">
                  <find_sell_offer space="$sector" result="$sectorSellOffers" multiple="true">
                    <match_seller tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_seller>
                    <relativeprice max="$sellPriceMax"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_sell_offer>
                </do_if>
                <do_else>
                  <find_sell_offer tradepartner="$ship" space="$sector" result="$sectorSellOffers" multiple="true">
                    <match_seller tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_seller>
                    <relativeprice max="$sellPriceMax"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_sell_offer>
                </do_else>
              </do_else>
              
              <set_value name="$sectorSellOffersCount" exact="0"/>
              <do_if value="$sectorSellOffers?">
                <set_value name="$sectorSellOffersCountTemp" exact="@$sectorSellOffers.count"/>
                <do_if value="$sectorSellOffersCountTemp?">
                  <set_value name="$sectorSellOffersCount" exact="$sectorSellOffersCountTemp"/>
                </do_if>
              </do_if>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-PERF] LiveOffersQuery END ship=' + $ship.idcode + ' phase=selloffers offers=' + $sectorSellOffersCount" chance="100"/>
              </do_if>
              
              <!-- Smoothness > speed: do NOT append potentially thousands of offers in this frame. -->
              <set_value name="$pendingAppendScheduled" exact="false"/>
              <do_if value="$sectorSellOffersCount gt 0">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingTarget" exact="'sell'"/>
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingOffers" exact="$sectorSellOffers"/>
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingIndex" exact="0"/>
                <set_value name="$pendingAppendScheduled" exact="true"/>
              </do_if>
            </do_all>
            
            <set_value name="$buyIndex" exact="$buyIndex + $sliceSectors.count"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$BuyIndex" exact="$buyIndex"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$AllSellOffers" exact="$allSellOffers"/>
            
            <!-- If we captured pending offers to append, hand off to a dedicated chunked appender and exit. -->
            <do_if value="$pendingAppendScheduled">
              <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
              <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades_AppendPendingOffers" param="$params"/>
              <set_value name="$deferOfferSlice" exact="true"/>
            </do_if>
            <do_else>
            <!-- No early cutover: collect offer lists fully (slice paced), then proceed into filtering/matching. -->
            <do_if value="$buyIndex lt $buyspaces.count">
              <!-- Interleave phases: if the other side still has sectors, switch to buyoffers for the next slice. -->
              <do_if value="$sellIndex lt $sellspaces.count">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'buyoffers'"/>
              </do_if>
              <set_value name="$deferOfferSlice" exact="true"/>
              <!-- Enqueue next offer slice (global fair queue; one ship per budget tick) -->
              <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
                <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
                  $Ships = [],
                  $Queued = table[],
                  $Params = table[],
                  $Processing = false
                ]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled?">
                <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
                <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
                <!-- CRITICAL: Slice-driven continuations MUST preserve ContinueFromSectorLists,
                     otherwise SearchLiveTrades will enter normal-flow and immediately cancel due to "search already in progress". -->
                <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
                <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                  <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
                  <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                </do_if>
                <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- Move to Phase 2 next tick -->
              <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'buyoffers'"/>
              <set_value name="$deferOfferSlice" exact="true"/>
              <!-- Enqueue next offer slice (global fair queue; one ship per budget tick) -->
              <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
                <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
                  $Ships = [],
                  $Queued = table[],
                  $Params = table[],
                  $Processing = false
                ]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled?">
                <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
                <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
                <!-- CRITICAL: Slice-driven continuations MUST preserve ContinueFromSectorLists,
                     otherwise SearchLiveTrades will enter normal-flow and immediately cancel due to "search already in progress". -->
                <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
                <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                  <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
                  <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                </do_if>
                <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
              </do_if>
            </do_else>
            </do_else>
          </do_if>
          
          <!-- Phase 2: Collect BUY offers from sellspaces (ship sells TO stations) -->
          <do_elseif value="$offerPhase == 'buyoffers'">
            <set_value name="$sliceSectors" exact="[]"/>
            <set_value name="$remaining" exact="$sellspaces.count - $sellIndex"/>
            <set_value name="$sliceCount" exact="$sectorsPerSlice"/>
            <!-- Clamp to remaining sectors -->
            <do_if value="$sliceCount gt $remaining">
              <set_value name="$sliceCount" exact="$remaining"/>
            </do_if>
            
            <do_all exact="$sliceCount" counter="$k">
              <set_value name="$idx" exact="$sellIndex + $k"/>
              <append_to_list name="$sliceSectors" exact="$sellspaces.{$idx}"/>
            </do_all>
            
            <do_all exact="$sliceSectors.count" counter="$i">
              <set_value name="$sector" exact="$sliceSectors.{$i}"/>
              <do_if value="not $sector? or not $sector.exists">
                <continue/>
              </do_if>
              
              <set_value name="$sectorBuyOffers" exact="[]"/>
              <do_if value="$wareBasket? and $wareBasket != null and $wareBasket.count gt 0">
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-PERF] LiveOffersQuery START ship=' + $ship.idcode + ' phase=buyoffers'" chance="100"/>
                </do_if>
                <do_if value="$ignoreTradeRules">
                  <find_buy_offer space="$sector" result="$sectorBuyOffers" wares="$wareBasket" multiple="true">
                    <match_buyer tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_buyer>
                    <relativeprice min="$buyPriceMin"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <find_buy_offer tradepartner="$ship" space="$sector" result="$sectorBuyOffers" wares="$wareBasket" multiple="true">
                    <match_buyer tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_buyer>
                    <relativeprice min="$buyPriceMin"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_buy_offer>
                </do_else>
              </do_if>
              <do_else>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-PERF] LiveOffersQuery START ship=' + $ship.idcode + ' phase=buyoffers'" chance="100"/>
                </do_if>
                <do_if value="$ignoreTradeRules">
                  <find_buy_offer space="$sector" result="$sectorBuyOffers" multiple="true">
                    <match_buyer tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_buyer>
                    <relativeprice min="$buyPriceMin"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <find_buy_offer tradepartner="$ship" space="$sector" result="$sectorBuyOffers" multiple="true">
                    <match_buyer tradesknownto="$ship.owner">
                      <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                      <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                    </match_buyer>
                    <relativeprice min="$buyPriceMin"/>
                    <!-- IMPORTANT: Do not hard-filter small offers; it hides entire wares (e.g. low-volume high-tech wares) from live search + cache. -->
                    <amount min="1"/>
                    <totalvolume min="1"/>
                  </find_buy_offer>
                </do_else>
              </do_else>
              
              <set_value name="$sectorBuyOffersCount" exact="0"/>
              <do_if value="$sectorBuyOffers?">
                <set_value name="$sectorBuyOffersCountTemp" exact="@$sectorBuyOffers.count"/>
                <do_if value="$sectorBuyOffersCountTemp?">
                  <set_value name="$sectorBuyOffersCount" exact="$sectorBuyOffersCountTemp"/>
                </do_if>
              </do_if>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-PERF] LiveOffersQuery END ship=' + $ship.idcode + ' phase=buyoffers offers=' + $sectorBuyOffersCount" chance="100"/>
              </do_if>
              
              <!-- Smoothness > speed: do NOT append potentially thousands of offers in this frame. -->
              <set_value name="$pendingAppendScheduled" exact="false"/>
              <do_if value="$sectorBuyOffersCount gt 0">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingTarget" exact="'buy'"/>
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingOffers" exact="$sectorBuyOffers"/>
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingIndex" exact="0"/>
                <set_value name="$pendingAppendScheduled" exact="true"/>
              </do_if>
            </do_all>
            
            <set_value name="$sellIndex" exact="$sellIndex + $sliceSectors.count"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$SellIndex" exact="$sellIndex"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$AllBuyOffers" exact="$allBuyOffers"/>
            
            <!-- If we captured pending offers to append, hand off to a dedicated chunked appender and exit. -->
            <do_if value="$pendingAppendScheduled">
              <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
              <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades_AppendPendingOffers" param="$params"/>
              <set_value name="$deferOfferSlice" exact="true"/>
            </do_if>
            <do_else>
            <!-- No early cutover: collect offer lists fully (slice paced), then proceed into filtering/matching. -->
            <do_if value="$sellIndex lt $sellspaces.count">
              <!-- Interleave phases: if the other side still has sectors, switch back to selloffers for the next slice. -->
              <do_if value="$buyIndex lt $buyspaces.count">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'selloffers'"/>
              </do_if>
              <set_value name="$deferOfferSlice" exact="true"/>
              <!-- Enqueue next offer slice (global fair queue; one ship per budget tick) -->
              <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
                <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
                  $Ships = [],
                  $Queued = table[],
                  $Params = table[],
                  $Processing = false
                ]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled?">
                <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
                <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
                <!-- CRITICAL: Slice-driven continuations MUST preserve ContinueFromSectorLists,
                     otherwise SearchLiveTrades will enter normal-flow and immediately cancel due to "search already in progress". -->
                <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
                <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                  <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
                  <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                </do_if>
                <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- If sellspaces are complete but buyspaces are not, switch back to selloffers to finish remaining selloffer sectors.
                   Otherwise mark done and fall through to filtering/matching. -->
              <do_if value="$buyIndex lt $buyspaces.count">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'selloffers'"/>
                <set_value name="$deferOfferSlice" exact="true"/>
                <!-- Enqueue next offer slice -->
                <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
                  <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
                    $Ships = [],
                    $Queued = table[],
                    $Params = table[],
                    $Processing = false
                  ]"/>
                </do_if>
                <do_if value="not global.$GT_LiveOfferSliceScheduled?">
                  <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
                </do_if>
                <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
                  <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
                  <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                  <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
                  <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                    <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
                    <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                  </do_if>
                  <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- Offers complete; fall through to filtering/matching -->
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'done'"/>
                <!-- CRITICAL FIX: Clear deferOfferSlice so we can proceed to queue trade_matching work unit -->
                <set_value name="$deferOfferSlice" exact="false"/>
              </do_else>
            </do_else>
            </do_else>
          </do_elseif>
          
          <!-- If we scheduled the next slice, exit now (avoid doing heavy work in the same frame) -->
          <do_if value="$deferOfferSlice">
            <cancel_cue cue="this"/>
          </do_if>

          <!-- IMPORTANT: Some MD environments may still evaluate following actions after cancel.
               Guard the rest of the continuation so we NEVER run filtering/batching on partial offers. -->
          <do_if value="not $deferOfferSlice">

            <!-- Prevent repeated batch restarts:
                 once we begin filtering/matching, this ship must NOT remain enqueued for LiveOffer slices. -->
            <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue != null">
              <remove_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}"/>
              <remove_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>

              <!-- Remove from Ships list (explicit loop; avoid indexof/? pitfalls) -->
              <do_if value="global.$GT_LiveOfferSliceQueue.$Ships? and global.$GT_LiveOfferSliceQueue.$Ships.count gt 0">
                <set_value name="$tmpShips" exact="[]"/>
                <do_all exact="global.$GT_LiveOfferSliceQueue.$Ships.count" counter="$i">
                  <set_value name="$s" exact="global.$GT_LiveOfferSliceQueue.$Ships.{$i}"/>
                  <do_if value="$s != $ship">
                    <append_to_list name="$tmpShips" exact="$s"/>
                  </do_if>
                </do_all>
                <set_value name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$tmpShips"/>
              </do_if>
            </do_if>
            <do_if value="global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled != null">
              <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
            </do_if>

        <!-- REMOVED: Post-query distance filtering no longer needed -->
        <!-- Sector lists already restrict queries to in-range sectors -->
        <!-- Distance filtering is handled during sector list building (vanilla pattern) -->
        
        <!-- Initialize counters -->
        <set_value name="$totalFilteredIllegal" exact="0"/>
        <set_value name="$stationsSkipped" exact="0"/>
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <!-- OPTIMIZATION 1: $tradesRejectedBlacklist removed (safety net eliminated) -->
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$offersFound" exact="$allSellOffers.count + $allBuyOffers.count"/>
        <set_value name="$stationsEvaluated" exact="0"/>  <!-- Not applicable with native actions -->
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') NATIVE ACTIONS: Collected ' + $allSellOffers.count + ' sell + ' + $allBuyOffers.count + ' buy offers (instant C++ query)'" chance="100"/>
          <!-- DIAGNOSTIC: If native query returns 0 offers, test with minimal filters to find blocker -->
          <!-- PERFORMANCE OPTIMIZATION: Guard diagnostic queries behind dedicated flag (4 galaxy-wide scans are expensive!) -->
          <do_if value="$offersFound == 0 and @global.$GT_Config.$Debug.$DiagnosticQueries">
            <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Native query returned 0 offers with filters: dockable=true, enemy=false, amountâ‰¥100, totalvolumeâ‰¥100, sellPriceâ‰¤average, buyPriceâ‰¥average'" chance="100"/>
            <!-- Test query with ONLY tradesknownto (no other filters) to see if offers exist -->
            <set_value name="$testSellOffers" exact="[]"/>
            <set_value name="$testBuyOffers" exact="[]"/>
            <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$testSellOffers" multiple="true">
              <match_seller tradesknownto="$ship.owner"/>
              <!-- NO other filters - just test if offers exist -->
            </find_sell_offer>
            <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$testBuyOffers" multiple="true">
              <match_buyer tradesknownto="$ship.owner"/>
              <!-- NO other filters - just test if offers exist -->
            </find_buy_offer>
            <set_value name="$testOffersFound" exact="$testSellOffers.count + $testBuyOffers.count"/>
            <do_if value="$testOffersFound gt 0">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Found ' + $testOffersFound + ' offers with MINIMAL filters (tradesknownto only) - testing individual filters...'" chance="100"/>
              </do_if>
              
              <!-- Test 1: tradesknownto + dock (no enemy, no relativeprice) -->
              <set_value name="$test1Sell" exact="[]"/>
              <set_value name="$test1Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test1Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                </match_seller>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test1Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                </match_buyer>
              </find_buy_offer>
              <set_value name="$test1Found" exact="$test1Sell.count + $test1Buy.count"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 1 (tradesknownto+dock): ' + $test1Found + ' offers'" chance="100"/>
              </do_if>
              
              <!-- Test 2: tradesknownto + dock + enemy (no relativeprice) -->
              <set_value name="$test2Sell" exact="[]"/>
              <set_value name="$test2Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test2Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_seller>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test2Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_buyer>
              </find_buy_offer>
              <set_value name="$test2Found" exact="$test2Sell.count + $test2Buy.count"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 2 (+enemy filter): ' + $test2Found + ' offers'" chance="100"/>
              </do_if>
              
              <!-- Test 3: tradesknownto + dock + enemy + relativeprice -->
              <set_value name="$test3Sell" exact="[]"/>
              <set_value name="$test3Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test3Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_seller>
                <relativeprice max="0.0"/>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test3Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_buyer>
                <relativeprice min="0.0"/>
              </find_buy_offer>
              <set_value name="$test3Found" exact="$test3Sell.count + $test3Buy.count"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 3 (+relativeprice): ' + $test3Found + ' offers (BLOCKING FILTER IDENTIFIED!)'" chance="100"/>
              </do_if>
              
            </do_if>
            <do_else>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Even MINIMAL query (tradesknownto only) returns 0 offers - ship may not know about any stations'" chance="100"/>
              </do_if>
            </do_else>
          </do_if>
          <!-- PERFORMANCE OPTIMIZATION: End of diagnostic queries block (guarded by DiagnosticQueries flag) -->
          <do_elseif value="$offersFound == 0">
            <!-- Silent skip when diagnostic queries disabled (normal play) -->
          </do_elseif>
        </do_if>
        
        <!-- UNIVERSAL CACHE: Native actions filtered by:
             - known stations (tradesknownto)
             - docking relation (match_relation_to dock) - only dockable stations
             - faction relations (match_relation_to enemy not) - exclude enemy factions
             - sell price (relativeprice max=0.0) - average price or below (was 0.5 - too lenient)
             - buy price (relativeprice min=0.0) - at least average selling price (was 1.0 - too strict!)
             - amount (min=100) - minimum 100 items
             - total volume (min=100) - minimum total trade volume
             NO blacklist filtering (ship-specific, applied at retrieval)
             NO illegal ware filtering (ship-specific, applied at retrieval)
             Distance range filtering only (universal validation)
        -->
        
        <!-- ===== PRE-FILTER DISTANCE (RANGE-ONLY) ===== -->
        <!-- UNIVERSAL CACHE: Filter by distance range only (from home sector) -->
        <!-- FALLBACK SEARCH: For fallback search, use originalMaxDistance (pilot's maxDistance) instead of maxDistance (2) -->
        <!-- Path validation is ship-specific and happens during cache retrieval -->
        <do_if value="($allSellOffers.count gt 0 or $allBuyOffers.count gt 0) and $maxDistance? and $maxDistance gt 0">
          <set_value name="$sellOffersDistanceFiltered" exact="0"/>
          <set_value name="$buyOffersDistanceFiltered" exact="0"/>
          
          <!-- FALLBACK SEARCH: Use originalMaxDistance for filtering from home sector if available -->
          <set_value name="$homeSectorMaxDistance" exact="$maxDistance"/>
          <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
            <set_value name="$homeSectorMaxDistance" exact="$originalMaxDistance"/>
          </do_if>
          
          <!-- Filter sell offers by distance range (using library function) -->
          <do_if value="$allSellOffers.count gt 0">
            <run_actions ref="md.GT_Libraries_General.GT_FilterOffersByDistance" result="$sellFilterResult">
              <param name="offersList" value="$allSellOffers"/>
              <param name="homeSector" value="$homeSector"/>
              <param name="maxDistance" value="$homeSectorMaxDistance"/>
            </run_actions>
            <set_value name="$allSellOffers" exact="$sellFilterResult.$FilteredOffers"/>
            <set_value name="$sellOffersDistanceFiltered" exact="$sellFilterResult.$FilteredCount"/>
          </do_if>
          
          <!-- Filter buy offers by distance range (using library function) -->
          <do_if value="$allBuyOffers.count gt 0">
            <run_actions ref="md.GT_Libraries_General.GT_FilterOffersByDistance" result="$buyFilterResult">
              <param name="offersList" value="$allBuyOffers"/>
              <param name="homeSector" value="$homeSector"/>
              <param name="maxDistance" value="$homeSectorMaxDistance"/>
            </run_actions>
            <set_value name="$allBuyOffers" exact="$buyFilterResult.$FilteredOffers"/>
            <set_value name="$buyOffersDistanceFiltered" exact="$buyFilterResult.$FilteredCount"/>
          </do_if>
          
          <!-- Debug logging -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <do_if value="$sellOffersDistanceFiltered gt 0 or $buyOffersDistanceFiltered gt 0">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') PRE-FILTERED distance (range-only): ' + $sellOffersDistanceFiltered + ' sell, ' + $buyOffersDistanceFiltered + ' buy (max: ' + $homeSectorMaxDistance + ' jumps from home)'" chance="100"/>
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Offers within range: ' + $allSellOffers.count + ' sell, ' + $allBuyOffers.count + ' buy'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- ===== CROSS-STATION TRADE MATCHING ===== -->
        <do_if value="$allSellOffers.count gt 0 and $allBuyOffers.count gt 0">
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Total offers before indexing: ' + $allSellOffers.count + ' sell, ' + $allBuyOffers.count + ' buy'" chance="100"/>
          </do_if>
          
          <!-- OPTIMIZATION: Calculate available money ONCE (before loops, not inside) -->
          <set_value name="$availableMoney" exact="player.money"/>
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
          <do_if value="@$homeBase.exists and @$homeBase.isclass.station">
            <set_value name="$availableMoney" exact="$homeBase.money"/>
          </do_if>
          
          <!--  -->
          <!-- CRITICAL OPTIMIZATION: Index & Limit BEFORE Distance Calculation -->
          <!-- OLD: Calculate gatedistance for 3,859 stations, THEN limit to top 5 per ware -->
          <!-- NEW: Limit to top 5 per ware FIRST, THEN calculate gatedistance for ~250 stations -->
          <!-- Impact: 3,859   250 pathfinding calls = 93.5% reduction = ELIMINATES STUTTER! -->
          <!--  -->
          
          <!-- STEP 1: Index offers by ware (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_IndexOffersByWare" result="$sellOffersByWare">
            <param name="offersList" value="$allSellOffers"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_IndexOffersByWare" result="$buyOffersByWare">
            <param name="offersList" value="$allBuyOffers"/>
          </run_actions>
          
          <!-- STEP 2: Per-ware sort & limit (reduces to ~5 per ware Ã— 50 wares = ~250 stations) -->
          <!-- Use global setting for max offers per ware -->
          <set_value name="$maxOffersPerWare" exact="200"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare?">
            <set_value name="$maxOffersPerWare" exact="global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare"/>
          </do_if>
          <set_value name="$limitedSellOffers" exact="[]"/>
          <set_value name="$limitedBuyOffers" exact="[]"/>
          
          <!-- Process each ware's sell offers (using library function) -->
          <do_all exact="$sellOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$sellOffersByWare.keys.{$wareIdx}"/>
            <set_value name="$offersForWare" exact="$sellOffersByWare.{$ware}"/>
            
            <!-- Sort and limit (ascending = lowest price for buy offers) -->
            <run_actions ref="md.GT_Libraries_General.GT_SortAndLimitOffers" result="$limitedForWare">
              <param name="offersList" value="$offersForWare"/>
              <param name="maxCount" value="$maxOffersPerWare"/>
              <param name="sortAscending" value="true"/>
            </run_actions>
            <do_all exact="$limitedForWare.count" counter="$idx">
              <append_to_list name="$limitedSellOffers" exact="$limitedForWare.{$idx}"/>
            </do_all>
          </do_all>
          
          <!-- Process each ware's buy offers (using library function) -->
          <do_all exact="$buyOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$buyOffersByWare.keys.{$wareIdx}"/>
            <set_value name="$offersForWare" exact="$buyOffersByWare.{$ware}"/>
            
            <!-- Sort and limit (descending = highest price for sell offers) -->
            <run_actions ref="md.GT_Libraries_General.GT_SortAndLimitOffers" result="$limitedForWare">
              <param name="offersList" value="$offersForWare"/>
              <param name="maxCount" value="$maxOffersPerWare"/>
              <param name="sortAscending" value="false"/>
            </run_actions>
            <do_all exact="$limitedForWare.count" counter="$idx">
              <append_to_list name="$limitedBuyOffers" exact="$limitedForWare.{$idx}"/>
            </do_all>
          </do_all>
          
          <!-- Replace original lists with limited lists -->
          <set_value name="$allSellOffers" exact="$limitedSellOffers"/>
          <set_value name="$allBuyOffers" exact="$limitedBuyOffers"/>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') OPTIMIZED: Limited to ' + $allSellOffers.count + ' sell + ' + $allBuyOffers.count + ' buy offers (top ' + $maxOffersPerWare + ' per ware)'" chance="100"/>
          </do_if>
          
          <!-- STEP 3: NOW calculate distances for LIMITED set only (93.5% fewer calls!) -->
          <!-- Re-index limited offers by ware for matching (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_IndexOffersByWare" result="$sellOffersByWare">
            <param name="offersList" value="$allSellOffers"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_IndexOffersByWare" result="$buyOffersByWare">
            <param name="offersList" value="$allBuyOffers"/>
          </run_actions>
          
          <!-- STEP 4: Calculate distances for LIMITED offers only (using library function) -->
          <run_actions ref="md.GT_Libraries_Pathfinding.GT_BuildStationDistanceCache" result="$stationDistanceCache">
            <param name="sellOffers" value="$allSellOffers"/>
            <param name="buyOffers" value="$allBuyOffers"/>
            <param name="homeSector" value="$homeSector"/>
          </run_actions>
          
          <!--  -->
          <!-- BATCH PROCESSOR PREPARATION: Build data structures for per-ware processing -->
          <!-- Trade matching will be done by batch processor (one ware per batch, 10ms delay) -->
          <!--  -->
          
          <!-- Get failed trades and reserved routes -->
          <!-- FIX: Clean expired entries (older than 30 minutes) to prevent deadlock -->
          <!-- Get failed sector pairs for ship's current sector (not per-ship) -->
          <!-- Ships in the same sector share failed sector pairs (same connectivity/blacklist context) -->
          <set_value name="$currentSector" exact="$ship.sector"/>
          <set_value name="$failedTrades" exact="[]"/>
          <do_if value="$currentSector? and $currentSector.exists and global.$GT_FailedSectorPairs? and global.$GT_FailedSectorPairs.{$currentSector}?">
            <set_value name="$failedTradesRaw" exact="global.$GT_FailedSectorPairs.{$currentSector}"/>
            <set_value name="$failedTradesExpired" exact="[]"/>
            <set_value name="$expirationTime" exact="1800s"/> <!-- 30 minutes -->
            
            <!-- Filter out expired entries -->
            <do_all exact="$failedTradesRaw.count" counter="$i">
              <set_value name="$failedTrade" exact="$failedTradesRaw.{$i}"/>
              <set_value name="$tradeAge" exact="player.age - $failedTrade.$Timestamp"/>
              <do_if value="$tradeAge le $expirationTime">
                <!-- Entry still valid - keep it -->
                <append_to_list name="$failedTrades" exact="$failedTrade"/>
              </do_if>
              <do_else>
                <!-- Entry expired - mark for removal -->
                <append_to_list name="$failedTradesExpired" exact="$i"/>
              </do_else>
            </do_all>
            
            <!-- Update global storage with cleaned list -->
            <do_if value="$failedTradesExpired.count gt 0">
              <set_value name="global.$GT_FailedSectorPairs.{$currentSector}" exact="$failedTrades"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$sectorName" exact="@$currentSector.knownname"/>
                <debug_text text="'[GT-Search] Cleaned ' + $failedTradesExpired.count + ' expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (older than 30 minutes)'" chance="100"/>
              </do_if>
            </do_if>
            <do_elseif value="$failedTrades.count == 0">
              <!-- All entries expired - clear the list entirely -->
              <remove_value name="global.$GT_FailedSectorPairs.{$currentSector}"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$sectorName" exact="@$currentSector.knownname"/>
                <debug_text text="'[GT-Search] Cleared all expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (all older than 30 minutes)'" chance="100"/>
              </do_if>
            </do_elseif>
          </do_if>
          
          <set_value name="$reservedRoutes" exact="[]"/>
          <do_if value="global.$GT_ActiveTradeReservations? and global.$GT_GlobalSettings.$Fleet.$EnableFleetCoordination">
            <do_all exact="global.$GT_ActiveTradeReservations.keys.count" counter="$resIdx">
              <set_value name="$otherShip" exact="global.$GT_ActiveTradeReservations.keys.{$resIdx}"/>
              <do_if value="$otherShip != $ship and $otherShip.exists">
                <set_value name="$otherRoute" exact="global.$GT_ActiveTradeReservations.{$otherShip}"/>
                <do_if value="$otherRoute.$BuyStation? and $otherRoute.$SellStation? and $otherRoute.$Ware?">
                  <do_if value="$otherRoute.$BuyStation.idcode? and $otherRoute.$SellStation.idcode?">
                    <set_value name="$cacheKey" exact="$otherRoute.$BuyStation.idcode + '_' + $otherRoute.$SellStation.idcode + '_' + $otherRoute.$Ware"/>
                    <append_to_list name="$reservedRoutes" exact="$cacheKey"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- Build list of wares that have BOTH sell and buy offers -->
          <set_value name="$wareKeysList" exact="[]"/>
          <do_all exact="$sellOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$sellOffersByWare.keys.{$wareIdx}"/>
            <do_if value="$buyOffersByWare.{$ware}?">
              <append_to_list name="$wareKeysList" exact="$ware"/>
            </do_if>
          </do_all>

          <!-- DEBUG: Log what live search actually found/matched by ware (compare to cache snapshot) -->
          <!-- This runs once per live search completion (after distance filter + per-ware limiting). -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$basketCount" exact="0"/>
            <do_if value="$wareBasket? and $wareBasket != null">
              <set_value name="$basketCount" exact="$wareBasket.count"/>
            </do_if>
            <debug_text text="'[GT-LiveOffers] (' + $ship.idcode + ') Summary: sellOffers=' + $allSellOffers.count + ', buyOffers=' + $allBuyOffers.count +
              ', basketCount=' + $basketCount + ' (0 = all wares), maxOffersPerWare=' + $maxOffersPerWare +
              ', matchableWares=' + $wareKeysList.count" chance="100"/>

            <!-- Build union of wares seen on either side (sell/buy). -->
            <set_value name="$unionWares" exact="[]"/>
            <do_all exact="$sellOffersByWare.keys.count" counter="$ui">
              <append_to_list name="$unionWares" exact="$sellOffersByWare.keys.{$ui}"/>
            </do_all>
            <do_all exact="$buyOffersByWare.keys.count" counter="$ui">
              <set_value name="$w" exact="$buyOffersByWare.keys.{$ui}"/>
              <set_value name="$found" exact="false"/>
              <do_all exact="$unionWares.count" counter="$fj">
                <do_if value="$unionWares.{$fj} == $w">
                  <set_value name="$found" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="not $found">
                <append_to_list name="$unionWares" exact="$w"/>
              </do_if>
            </do_all>

            <set_value name="$dumpLimit" exact="300"/>
            <set_value name="$dumpCount" exact="[$unionWares.count, $dumpLimit].min"/>
            <do_all exact="$dumpCount" counter="$wi">
              <set_value name="$w" exact="$unionWares.{$wi}"/>
              <set_value name="$sc" exact="0"/>
              <set_value name="$bc" exact="0"/>
              <do_if value="$sellOffersByWare.{$w}?">
                <set_value name="$sc" exact="$sellOffersByWare.{$w}.count"/>
              </do_if>
              <do_if value="$buyOffersByWare.{$w}?">
                <set_value name="$bc" exact="$buyOffersByWare.{$w}.count"/>
              </do_if>

              <!-- Sample illegal-to-police (vanilla pattern) for this ware, based on first sell offer's zone. -->
              <set_value name="$illegalSample" exact="'n/a'"/>
              <do_if value="$sc gt 0">
                <set_value name="$sampleOffer" exact="$sellOffersByWare.{$w}.{1}"/>
                <set_value name="$police" exact="@$sampleOffer.owner.zone.policefaction"/>
                <do_if value="$police? and $police != null and ($police != $ship.owner)">
                  <do_if value="$w.illegalto.{$police}.{$ship.owner}">
                    <set_value name="$illegalSample" exact="'true'"/>
                  </do_if>
                  <do_else>
                    <set_value name="$illegalSample" exact="'false'"/>
                  </do_else>
                </do_if>
              </do_if>

              <debug_text text="'[GT-LiveOffers] (' + $ship.idcode + ') Ware=' + @$w.name +
                ' sell=' + $sc + ' buy=' + $bc +
                ' matchable=' + (if ($sc gt 0 and $bc gt 0) then 'true' else 'false') +
                ' illegalToPoliceSample=' + $illegalSample" chance="100"/>
            </do_all>
            <do_if value="$unionWares.count gt $dumpLimit">
              <debug_text text="'[GT-LiveOffers] (' + $ship.idcode + ') Ware list truncated: ' + $dumpLimit + ' / ' + $unionWares.count" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Build sell offers list (one entry per ware) -->
          <set_value name="$sellOffersList" exact="[]"/>
          <do_all exact="$wareKeysList.count" counter="$i">
            <set_value name="$ware" exact="$wareKeysList.{$i}"/>
            <append_to_list name="$sellOffersList" exact="table[
              $ware = $ware,
              $offers = $sellOffersByWare.{$ware}
            ]"/>
          </do_all>
          
          <!-- Build buy offers list (one entry per ware) -->
          <set_value name="$buyOffersList" exact="[]"/>
          <do_all exact="$wareKeysList.count" counter="$i">
            <set_value name="$ware" exact="$wareKeysList.{$i}"/>
            <append_to_list name="$buyOffersList" exact="table[
              $ware = $ware,
              $offers = $buyOffersByWare.{$ware}
            ]"/>
          </do_all>
          
          <!-- Generate unique batch index (use ship object as key - X4 supports object keys) -->
          <set_value name="$batchIndex" exact="'' + player.age + $ship.idcode"/>
          
          <!-- CRITICAL: Ensure global.$GT_BatchDataList is initialized as TABLE (not list) -->
          <!-- Previous versions initialized this as a list - must always ensure it's a table -->
          <!-- Strategy: Check migration flag, if not migrated yet, clear and convert -->
          <!-- After migration, it's safe to assume it's a table (SystemInit ensures it) -->
          <do_if value="not global.$GT_BatchDataListMigrated?">
            <!-- First time in this session - clear if exists (might be list from old save) -->
            <do_if value="global.$GT_BatchDataList?">
              <remove_value name="global.$GT_BatchDataList"/>
            </do_if>
            <!-- Initialize as table -->
            <set_value name="global.$GT_BatchDataList" exact="table[]"/>
            <!-- Also ensure results list is a table -->
            <do_if value="global.$GT_BatchResultsList?">
              <remove_value name="global.$GT_BatchResultsList"/>
            </do_if>
            <set_value name="global.$GT_BatchResultsList" exact="table[]"/>
            <!-- Mark as migrated -->
            <set_value name="global.$GT_BatchDataListMigrated" exact="true"/>
          </do_if>
          
          <!-- Store state for batch processor - build state table first, then assign -->
          <!-- CRITICAL: Use ship object as key (not string) - X4 supports object keys in tables -->
          <!-- Use global settings for batch processing limits -->
          <set_value name="$maxTradesPerWare" exact="20"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare?">
            <set_value name="$maxTradesPerWare" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare"/>
          </do_if>
          <!-- Keep batch matching bounded so ships don't hit AI timeout under load.
               CRITICAL: Require real data from global settings - no fallback to prevent silent failures. -->
          <set_value name="$earlyExitThreshold" exact="null"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold?">
            <set_value name="$earlyExitThreshold" exact="global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold"/>
          </do_if>
          <do_if value="not $earlyExitThreshold? or $earlyExitThreshold == null">
            <debug_text text="'[GT-ERROR] EarlyExitThreshold not found in global settings for ' + $ship.idcode + ' - batch processing cannot proceed. This should never happen if global settings are initialized correctly.'" chance="100"/>
            <cancel_cue cue="this"/>
          </do_if>
          <!-- FIX #3: Extract pilot skill max distance if available (for result filtering) -->
          <set_value name="$pilotSkillMaxDistance" exact="null"/>
          <do_if value="$params.$PilotSkillMaxDistance?">
            <set_value name="$pilotSkillMaxDistance" exact="$params.$PilotSkillMaxDistance"/>
          </do_if>
          
          <!-- CRITICAL OPTIMIZATION: Increase batch size for small maxDistance searches -->
          <!-- For maxDistance=1, process all wares in one batch to complete within 1 second -->
          <!-- For larger searches, use smaller batches to prevent CPU overload -->
          <set_value name="$optimizedBatchSize" exact="1"/>
          <do_if value="$maxDistance? and $maxDistance le 1">
            <!-- Small search: Process all wares in one batch (or at least 10 at a time) -->
            <set_value name="$optimizedBatchSize" exact="[$wareKeysList.count, 10].min"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') OPTIMIZED BATCH SIZE: maxDistance=' + $maxDistance + ' (small search) -> batchSize=' + $optimizedBatchSize + ' (processing ' + $wareKeysList.count + ' wares)'" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <do_if value="$maxDistance? and $maxDistance le 2">
              <!-- Medium search: Process 5 wares per batch -->
              <set_value name="$optimizedBatchSize" exact="5"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') OPTIMIZED BATCH SIZE: maxDistance=' + $maxDistance + ' (medium search) -> batchSize=' + $optimizedBatchSize + ' (processing ' + $wareKeysList.count + ' wares)'" chance="100"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- Large search: Process 1 ware per batch (original behavior) -->
              <set_value name="$optimizedBatchSize" exact="1"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') OPTIMIZED BATCH SIZE: maxDistance=' + (if $maxDistance? then $maxDistance else 'NULL') + ' (large search) -> batchSize=' + $optimizedBatchSize + ' (processing ' + $wareKeysList.count + ' wares)'" chance="100"/>
              </do_if>
            </do_else>
          </do_else>
          
          <!-- Extract trace ID from state for batch data -->
          <set_value name="$batchTraceId" exact="''"/>
          <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}? and global.$GT_SearchLiveTrades_State.{$ship}.$TraceId?">
            <set_value name="$batchTraceId" exact="global.$GT_SearchLiveTrades_State.{$ship}.$TraceId"/>
          </do_if>

          <!-- CRITICAL: Prevent repeated batch re-initialization while a prior batch is still queued/active for this ship.
               Re-preparing batch data resets global.$GT_BatchDataList.{$ship} mid-search and can prevent HomeSearch from ever completing. -->
          <set_value name="$skipPrepareBatch" exact="false"/>
          <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
            <set_value name="$inBatchQueueOrActive" exact="false"/>
            <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveShips? and global.$GT_BatchProcessorQueue.$ActiveShips.count gt 0">
              <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$i">
                <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips.{$i} == $ship">
                  <set_value name="$inBatchQueueOrActive" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            <do_if value="not $inBatchQueueOrActive and global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
              <do_all exact="global.$GT_BatchProcessorQueue.$Ships.count" counter="$i">
                <do_if value="global.$GT_BatchProcessorQueue.$Ships.{$i} == $ship">
                  <set_value name="$inBatchQueueOrActive" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            <do_if value="$inBatchQueueOrActive">
              <set_value name="$skipPrepareBatch" exact="true"/>
            </do_if>
          </do_if>

          <!-- CRITICAL FIX: Filter illegal wares BEFORE queuing trade_matching work unit -->
          <!-- If ship doesn't allow illegal trades, filter them out here so they don't end up in cache -->
          <!-- Illegal trades should be filtered during search, not during execution -->
          <set_value name="$filteredSellOffers" exact="$allSellOffers"/>
          <set_value name="$filteredBuyOffers" exact="$allBuyOffers"/>
          <set_value name="$illegalSellOffersFiltered" exact="0"/>
          <set_value name="$illegalBuyOffersFiltered" exact="0"/>
          
          <do_if value="not $allowIllegal">
            <!-- Filter sell offers (remove illegal wares) -->
            <do_if value="$allSellOffers? and $allSellOffers.count gt 0">
              <set_value name="$filteredSellOffers" exact="[]"/>
              <do_all exact="$allSellOffers.count" counter="$i">
                <set_value name="$offer" exact="$allSellOffers.{$i}"/>
                <do_if value="$offer? and $offer.ware?">
                  <do_if value="not @$offer.ware.isillegal">
                    <append_to_list name="$filteredSellOffers" exact="$offer"/>
                  </do_if>
                  <do_else>
                    <set_value name="$illegalSellOffersFiltered" exact="$illegalSellOffersFiltered + 1"/>
                  </do_else>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Filter buy offers (remove illegal wares) -->
            <do_if value="$allBuyOffers? and $allBuyOffers.count gt 0">
              <set_value name="$filteredBuyOffers" exact="[]"/>
              <do_all exact="$allBuyOffers.count" counter="$i">
                <set_value name="$offer" exact="$allBuyOffers.{$i}"/>
                <do_if value="$offer? and $offer.ware?">
                  <do_if value="not @$offer.ware.isillegal">
                    <append_to_list name="$filteredBuyOffers" exact="$offer"/>
                  </do_if>
                  <do_else>
                    <set_value name="$illegalBuyOffersFiltered" exact="$illegalBuyOffersFiltered + 1"/>
                  </do_else>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Debug logging -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <do_if value="$illegalSellOffersFiltered gt 0 or $illegalBuyOffersFiltered gt 0">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Filtered illegal wares: ' + $illegalSellOffersFiltered + ' sell, ' + $illegalBuyOffersFiltered + ' buy (AllowIllegal=' + $allowIllegal + ')'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- MIGRATION: Queue AI work unit for trade matching instead of batch processor -->
          <!-- Note: skipPrepareBatch check removed - work units handle their own state management -->
          <!-- Store FILTERED offers in state for work unit -->
          <!-- CRITICAL: Ship validation done at cue start, but verify again before using as table key -->
          <do_if value="$isValidShip and $ship? and $ship.exists">
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$SellOffers" exact="$filteredSellOffers"/>
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$BuyOffers" exact="$filteredBuyOffers"/>
          </do_if>
          
          <!-- DEBUG: Log before queuing trade matching work unit -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Queuing trade_matching work unit: sellOffers=' + (if $filteredSellOffers? then $filteredSellOffers.count else 'null') + ', buyOffers=' + (if $filteredBuyOffers? then $filteredBuyOffers.count else 'null')" chance="100"/>
          </do_if>
          
          <!-- Queue trade matching work unit -->
          <!-- CRITICAL: Use FILTERED offers (illegal wares already removed) -->
          <set_value name="$workUnit" exact="table[
            $WorkType = 'trade_matching',
            $Ship = $ship,
            $SellOffers = $filteredSellOffers,
            $BuyOffers = $filteredBuyOffers,
            $HomeSector = $homeSector,
            $MaxDistance = $maxDistance,
            $MinROI = $minROI,
            $MinAbsoluteProfit = $minAbsoluteProfit,
            $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
            $FactionPriority = $factionPriority
          ]"/>
          
          <!-- Queue work unit via coordinator -->
          <signal_cue_instantly cue="md.GT_WorkUnit_Coordinator.QueueWorkUnit" param="$workUnit"/>
          
          <!-- DEBUG: Log after queuing -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Trade matching work unit QUEUED successfully'" chance="100"/>
          </do_if>
          
          <!-- Mark as waiting for work unit completion -->
          <!-- CRITICAL: Ship validation already done at cue start, but double-check here for safety -->
          <!-- Only ship classes are valid - components can have idcode too, so don't use idcode as fallback -->
          <set_value name="$isValidShip" exact="false"/>
          <do_if value="$ship? and $ship.exists">
            <!-- Check if it's actually a ship object (not a component) -->
            <!-- CRITICAL: Cannot combine @ and ? operators - check existence first, then use @ for access -->
            <set_value name="$isShip" exact="false"/>
            <set_value name="$hasShipClass" exact="false"/>
            <do_if value="$ship.isclass?">
              <do_if value="@$ship.isclass.ship_s or @$ship.isclass.ship_m or @$ship.isclass.ship_l or @$ship.isclass.ship_xl">
                <set_value name="$hasShipClass" exact="true"/>
              </do_if>
            </do_if>
            <!-- Additional safety: verify we can access ship-specific properties -->
            <do_if value="$hasShipClass">
              <set_value name="$testPilot" exact="@$ship.pilot"/>
              <!-- If we can access pilot property (even if null), it's a ship -->
              <set_value name="$isValidShip" exact="true"/>
            </do_if>
          </do_if>
          <do_if value="$isValidShip">
            <do_if value="not global.$GT_SearchResult?">
              <set_value name="global.$GT_SearchResult" exact="table[]"/>
            </do_if>
            <!-- Use ship object as key - validated above to ensure it's a real ship object -->
            <!-- Additional safety: verify ship still exists before using as key -->
            <do_if value="$ship? and $ship.exists">
              <set_value name="global.$GT_SearchResult.{$ship}.$WaitingForBatch" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Exit - work unit will signal completion -->
          <cancel_cue cue="this"/>
        </do_if>
          </do_if>
        </do_if>
      </actions>
    </cue>

    <!-- Offer-collection slice driver.
         Adds a global frame budget between slices so expensive native offer queries are spread across frames. -->
    <cue name="SearchLiveTrades_OfferSlice" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- Ensure budget table exists -->
        <do_if value="not global.$GT_LiveOfferSliceBudget? or global.$GT_LiveOfferSliceBudget == null">
          <set_value name="global.$GT_LiveOfferSliceBudget" exact="table[
            $NextStartTime = 0
          ]"/>
        </do_if>
        
        <!-- Compute delay until next allowed slice start -->
        <set_value name="this.$DelayTime" exact="0ms"/>
        <set_value name="$nextStart" exact="@global.$GT_LiveOfferSliceBudget.$NextStartTime"/>
        <do_if value="$nextStart? and $nextStart != null and player.age lt $nextStart">
          <set_value name="this.$DelayTime" exact="$nextStart - player.age"/>
        </do_if>
      </actions>
      <delay exact="this.$DelayTime"/>
      <actions>
        <!-- Live offer slice interval - configurable via global settings -->
        <!-- CRITICAL: Require real data from global settings - no fallback to prevent silent failures. -->
        <set_value name="$sliceIntervalMs" exact="null"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval?">
          <set_value name="$sliceIntervalMs" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval"/>
        </do_if>
        <do_if value="not $sliceIntervalMs? or $sliceIntervalMs == null">
          <debug_text text="'[GT-ERROR] LiveOfferSliceInterval not found in global settings for ' + $ship.idcode + ' - live offer slice processing cannot proceed. This should never happen if global settings are initialized correctly.'" chance="100"/>
          <cancel_cue cue="this"/>
        </do_if>
        <set_value name="global.$GT_LiveOfferSliceBudget.$NextStartTime" exact="player.age + ($sliceIntervalMs * 1ms)"/>

        <!-- Clear per-ship scheduling marker (allows the next slice to be queued) -->
        <do_if value="$ship? and global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled.{$ship}?">
          <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
        </do_if>
        
        <!-- Continue offer collection via SearchLiveTrades continuation path -->
        <!-- CRITICAL: Slice-driven continuations MUST force ContinueFromSectorLists=true -->
        <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
        <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$params"/>
      </actions>
    </cue>

    <!-- Offer-slice queue kick (de-dupe)
         Problem: many ships can signal ProcessLiveOfferSliceQueue in the same frame, creating multiple instances
                  that may each dequeue a ship and grant a slice (microstutter).
         Fix: route all kicks through this deduped + delayed cue. -->
    <cue name="KickLiveOfferSliceQueue" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
          <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
            $Ships = [],
            $Queued = table[],
            $Params = table[],
            $Processing = false
          ]"/>
        </do_if>
        <do_if value="not global.$GT_LiveOfferSliceQueue.$KickScheduled?">
          <set_value name="global.$GT_LiveOfferSliceQueue.$KickScheduled" exact="false"/>
        </do_if>

        <do_if value="global.$GT_LiveOfferSliceQueue.$KickScheduled">
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
          <set_value name="global.$GT_LiveOfferSliceQueue.$KickScheduled" exact="true"/>
          <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue_Delayed"/>
        </do_else>
      </actions>
    </cue>

    <cue name="KickLiveOfferSliceQueue_Delayed" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <!-- Smoothness > speed: ensure cross-frame execution -->
      <delay min="20ms" max="80ms"/>
      <actions>
        <do_if value="global.$GT_LiveOfferSliceQueue?">
          <set_value name="global.$GT_LiveOfferSliceQueue.$KickScheduled" exact="false"/>
        </do_if>
        <signal_cue_instantly cue="md.GT_Search_Methods.ProcessLiveOfferSliceQueue"/>
      </actions>
    </cue>

    <!-- Global offer-slice fairness queue.
         Why: per-ship slice scheduling can starve other ships (one ship dominates the global budget),
              leading to "only one ship gets trades" even though others are stuck in continuations.
         This processor starts at most ONE ship slice per budget interval (configurable via LiveOfferSliceInterval, default 500ms), round-robin. -->
    <cue name="ProcessLiveOfferSliceQueue" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- cancel_cue does NOT stop actions in X4 MD, so we use an explicit proceed flag to prevent fallthrough. -->
        <set_value name="$proceed" exact="true"/>

        <!-- Ensure queue table exists -->
        <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
          <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
            $Ships = [],
            $Queued = table[],
            $Params = table[],
            $Processing = false
          ]"/>
        </do_if>

        <!-- single-thread -->
        <do_if value="global.$GT_LiveOfferSliceQueue.$Processing">
          <set_value name="$proceed" exact="false"/>
        </do_if>
        <do_if value="$proceed">
          <set_value name="global.$GT_LiveOfferSliceQueue.$Processing" exact="true"/>
        </do_if>

        <do_if value="$proceed and global.$GT_LiveOfferSliceQueue.$Ships.count le 0">
          <set_value name="global.$GT_LiveOfferSliceQueue.$Processing" exact="false"/>
          <set_value name="$proceed" exact="false"/>
        </do_if>

        <do_if value="not $proceed">
          <cancel_cue cue="this"/>
        </do_if>

        <!-- Ensure budget table exists -->
        <do_if value="not global.$GT_LiveOfferSliceBudget? or global.$GT_LiveOfferSliceBudget == null">
          <set_value name="global.$GT_LiveOfferSliceBudget" exact="table[
            $NextStartTime = 0
          ]"/>
        </do_if>

        <!-- Compute delay until next allowed slice start -->
        <set_value name="this.$DelayTime" exact="0ms"/>
        <set_value name="$nextStart" exact="@global.$GT_LiveOfferSliceBudget.$NextStartTime"/>
        <do_if value="$nextStart? and $nextStart != null and player.age lt $nextStart">
          <set_value name="this.$DelayTime" exact="$nextStart - player.age"/>
        </do_if>
      </actions>
      <delay exact="this.$DelayTime"/>
      <actions>
        <!-- Live offer slice interval - configurable via global settings -->
        <!-- CRITICAL: Require real data from global settings - no fallback to prevent silent failures. -->
        <set_value name="$sliceIntervalMs" exact="null"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval?">
          <set_value name="$sliceIntervalMs" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval"/>
        </do_if>
        <do_if value="not $sliceIntervalMs? or $sliceIntervalMs == null">
          <debug_text text="'[GT-ERROR] LiveOfferSliceInterval not found in global settings for ' + $ship.idcode + ' - live offer slice processing cannot proceed. This should never happen if global settings are initialized correctly.'" chance="100"/>
          <cancel_cue cue="this"/>
        </do_if>
        <set_value name="global.$GT_LiveOfferSliceBudget.$NextStartTime" exact="player.age + ($sliceIntervalMs * 1ms)"/>

        <!-- Dequeue one ship -->
        <set_value name="$ship" exact="global.$GT_LiveOfferSliceQueue.$Ships.{1}"/>
        <remove_from_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
        <remove_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}"/>
        <set_value name="$params" exact="@global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>
        <!-- Only remove params if present; missing params would drop the slice completely and stall that ship. -->
        <do_if value="global.$GT_LiveOfferSliceQueue.$Params.{$ship}?">
          <remove_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>
        </do_if>

        <!-- Clear per-ship scheduling marker (allows the ship to enqueue another slice) -->
        <do_if value="$ship? and global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled.{$ship}?">
          <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
        </do_if>

        <!-- Continue offer collection -->
        <do_if value="$params != null and $ship? and $ship.exists">
          <!-- CRITICAL: Slice-driven continuations MUST force ContinueFromSectorLists=true -->
          <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
          <!-- Grant exactly one slice worth of offer-query work to this invocation -->
          <set_value name="$params.$SliceGranted" exact="true"/>
          <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$params"/>
        </do_if>
        <do_else>
          <!-- DIAGNOSTIC: params unexpectedly missing; this would cause "no progress" for this ship. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] ERROR: LiveOfferSliceQueue dequeued ship without params (ship=' + (if $ship != null then @$ship.idcode else 'NULL') + ') - slice dropped'" chance="100"/>
          </do_if>
        </do_else>

        <!-- Continue queue if still pending -->
        <set_value name="global.$GT_LiveOfferSliceQueue.$Processing" exact="false"/>
        <do_if value="global.$GT_LiveOfferSliceQueue.$Ships.count gt 0">
          <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
        </do_if>
      </actions>
    </cue>

    <!-- Chunked offer appender (smoothness > speed).
         Purpose: avoid appending thousands of native offers into a list in a single frame. -->
    <cue name="SearchLiveTrades_AppendPendingOffers" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <delay min="20ms" max="80ms"/>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="@$params.$Ship"/>
        <do_if value="not $ship? or not $ship.exists">
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>

        <set_value name="$state" exact="@global.$GT_SearchLiveTrades_State.{$ship}"/>
        <set_value name="$pendingOffers" exact="@$state.$PendingOffers"/>
        <set_value name="$pendingTarget" exact="@$state.$PendingTarget"/>
        <set_value name="$pendingIndex" exact="@$state.$PendingIndex"/>

        <do_if value="$pendingOffers == null or $pendingTarget == null">
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>

        <do_if value="$pendingIndex == null">
          <set_value name="$pendingIndex" exact="0"/>
        </do_if>

        <set_value name="$chunkSize" exact="200"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferAppendChunkSize?">
          <set_value name="$tmpChunk" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferAppendChunkSize"/>
          <do_if value="$tmpChunk? and $tmpChunk != null and $tmpChunk gt 0">
            <set_value name="$chunkSize" exact="$tmpChunk"/>
          </do_if>
        </do_if>
        <do_if value="$chunkSize lt 50">
          <set_value name="$chunkSize" exact="50"/>
        </do_if>
        <do_if value="$chunkSize gt 2000">
          <set_value name="$chunkSize" exact="2000"/>
        </do_if>

        <set_value name="$total" exact="$pendingOffers.count"/>
        <set_value name="$end" exact="[$pendingIndex + $chunkSize, $total].min"/>

        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-PERF] LiveOffersAppend ship=' + $ship.idcode + ' target=' + $pendingTarget + ' idx=' + $pendingIndex + ' end=' + $end + ' total=' + $total" chance="100"/>
        </do_if>

        <set_value name="$allSellOffers" exact="@$state.$AllSellOffers"/>
        <do_if value="$allSellOffers == null">
          <set_value name="$allSellOffers" exact="[]"/>
        </do_if>
        <set_value name="$allBuyOffers" exact="@$state.$AllBuyOffers"/>
        <do_if value="$allBuyOffers == null">
          <set_value name="$allBuyOffers" exact="[]"/>
        </do_if>

        <do_all exact="$end - $pendingIndex" counter="$k">
          <set_value name="$i" exact="$pendingIndex + $k"/>
          <do_if value="$pendingTarget == 'sell'">
            <append_to_list name="$allSellOffers" exact="$pendingOffers.{$i}"/>
          </do_if>
          <do_else>
            <append_to_list name="$allBuyOffers" exact="$pendingOffers.{$i}"/>
          </do_else>
        </do_all>

        <set_value name="$pendingIndex" exact="$end"/>
        <set_value name="$state.$PendingIndex" exact="$pendingIndex"/>
        <set_value name="$state.$AllSellOffers" exact="$allSellOffers"/>
        <set_value name="$state.$AllBuyOffers" exact="$allBuyOffers"/>
        <set_value name="global.$GT_SearchLiveTrades_State.{$ship}" exact="$state"/>

        <do_if value="$pendingIndex lt $total">
          <!-- Continue appending next chunk -->
          <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
          <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades_AppendPendingOffers" param="$params"/>
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
          <!-- Finished pending append -->
          <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingOffers" exact="null"/>
          <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingTarget" exact="null"/>
          <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$PendingIndex" exact="0"/>

          <!-- Resume offer slicing or finalize -->
          <set_value name="$offerPhase" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase"/>
          <set_value name="$buyIndex" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$BuyIndex"/>
          <set_value name="$sellIndex" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$SellIndex"/>
          
          <!-- CRITICAL FIX: Ensure indices are initialized (not null) -->
          <do_if value="$buyIndex == null">
            <set_value name="$buyIndex" exact="0"/>
          </do_if>
          <do_if value="$sellIndex == null">
            <set_value name="$sellIndex" exact="0"/>
          </do_if>
          
          <set_value name="$allSellOffers" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$AllSellOffers"/>
          <set_value name="$allBuyOffers" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$AllBuyOffers"/>
          
          <!-- CRITICAL FIX: Get BuySpaces/SellSpaces from state (not params) since they're stored there -->
          <set_value name="$buyspaces" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$BuySpaces"/>
          <set_value name="$sellspaces" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$SellSpaces"/>
          <set_value name="$buyspacesCount" exact="0"/>
          <set_value name="$sellspacesCount" exact="0"/>
          <do_if value="$buyspaces? and $buyspaces != null">
            <set_value name="$buyspacesCount" exact="$buyspaces.count"/>
          </do_if>
          <do_if value="$sellspaces? and $sellspaces != null">
            <set_value name="$sellspacesCount" exact="$sellspaces.count"/>
          </do_if>

          <!-- DEBUG: Log index values to diagnose completion detection -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] AppendPendingOffers completion check: ship=' + $ship.idcode + ', phase=' + $offerPhase + ', buyIndex=' + $buyIndex + '/' + $buyspacesCount + ', sellIndex=' + $sellIndex + '/' + $sellspacesCount" chance="100"/>
          </do_if>

          <!-- Helper: enqueue next offer slice via global fair queue -->
          <set_value name="$queueNextSlice" exact="false"/>
          <do_if value="$offerPhase == 'selloffers'">
            <!-- CRITICAL FIX: In 'selloffers' phase, we process $buyspaces using $buyIndex.
                 So check $buyIndex to see if we've finished processing $buyspaces. -->
            <do_if value="$buyIndex lt $buyspacesCount">
              <!-- Still have buy sectors to process (for selloffers) -->
              <!-- Interleave: if sell side also has work, flip to buyoffers for the next slice -->
              <do_if value="$sellIndex lt $sellspacesCount">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'buyoffers'"/>
              </do_if>
              <set_value name="$queueNextSlice" exact="true"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] AppendPendingOffers: Queuing next slice (selloffers phase, buyIndex=' + $buyIndex + ' lt ' + $buyspacesCount + ')'" chance="100"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- Buy sectors complete (selloffers done) - check if sell sectors remain (buyoffers) -->
              <do_if value="$sellIndex lt $sellspacesCount">
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'buyoffers'"/>
                <set_value name="$queueNextSlice" exact="true"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] AppendPendingOffers: Buy sectors complete, switching to buyoffers (sellIndex=' + $sellIndex + ' lt ' + $sellspacesCount + ')'" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- Both buy and sell sectors complete - offer collection is done -->
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] AppendPendingOffers: ALL SECTORS COMPLETE! Setting OfferPhase=done (buyIndex=' + $buyIndex + '/' + $buyspacesCount + ', sellIndex=' + $sellIndex + '/' + $sellspacesCount + ')'" chance="100"/>
                </do_if>
                <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'done'"/>
                <!-- Continue SearchLiveTrades to proceed into filtering/matching -->
                <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$params"/>
                <cancel_cue cue="this"/>
              </do_else>
            </do_else>
          </do_if>
          <do_else>
            <do_if value="$offerPhase == 'buyoffers'">
              <!-- CRITICAL FIX: In 'buyoffers' phase, we process $sellspaces using $sellIndex.
                   So check $sellIndex to see if we've finished processing $sellspaces. -->
              <do_if value="$sellIndex lt $sellspacesCount">
                <!-- Still have sell sectors to process (for buyoffers) -->
                <!-- Interleave: if buy side also has work, flip back to selloffers for the next slice -->
                <do_if value="$buyIndex lt $buyspacesCount">
                  <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'selloffers'"/>
                </do_if>
                <set_value name="$queueNextSlice" exact="true"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] AppendPendingOffers: Queuing next slice (buyoffers phase, sellIndex=' + $sellIndex + ' lt ' + $sellspacesCount + ')'" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- Sell sectors complete (buyoffers done) - check if buy sectors remain (selloffers) -->
                <do_if value="$buyIndex lt $buyspacesCount">
                  <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'selloffers'"/>
                  <set_value name="$queueNextSlice" exact="true"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] AppendPendingOffers: Sell sectors complete, switching to selloffers (buyIndex=' + $buyIndex + ' lt ' + $buyspacesCount + ')'" chance="100"/>
                  </do_if>
                </do_if>
                <do_else>
                  <!-- Both buy and sell sectors complete - offer collection is done -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] AppendPendingOffers: ALL SECTORS COMPLETE! Setting OfferPhase=done (buyIndex=' + $buyIndex + '/' + $buyspacesCount + ', sellIndex=' + $sellIndex + '/' + $sellspacesCount + ')'" chance="100"/>
                  </do_if>
                  <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$OfferPhase" exact="'done'"/>
                  <!-- Continue SearchLiveTrades to proceed into filtering/matching -->
                  <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
                  <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$params"/>
                  <cancel_cue cue="this"/>
                </do_else>
              </do_else>
            </do_if>
          </do_else>
          
          <do_if value="$queueNextSlice">
            <do_if value="not global.$GT_LiveOfferSliceQueue? or global.$GT_LiveOfferSliceQueue == null">
              <set_value name="global.$GT_LiveOfferSliceQueue" exact="table[
                $Ships = [],
                $Queued = table[],
                $Params = table[],
                $Processing = false
              ]"/>
            </do_if>
            <do_if value="not global.$GT_LiveOfferSliceScheduled?">
              <set_value name="global.$GT_LiveOfferSliceScheduled" exact="table[]"/>
            </do_if>
            <do_if value="not global.$GT_LiveOfferSliceScheduled.{$ship}?">
              <set_value name="global.$GT_LiveOfferSliceScheduled.{$ship}" exact="player.age"/>
              <set_value name="$params.$ContinueFromSectorLists" exact="true"/>
              <set_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}" exact="$params"/>
              <do_if value="not global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                <set_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}" exact="true"/>
                <append_to_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
              </do_if>
              <signal_cue_instantly cue="md.GT_Search_Methods.KickLiveOfferSliceQueue"/>
            </do_if>
          </do_if>
        </do_else>

        </do_else>
        </do_else>
      </actions>
    </cue>
    <cue name="SearchFallbackTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- FALLBACK PROFIT RELAXATION: Reduce profit thresholds to allow lower-profit trades -->
        <!-- Fallback is last resort, so accept lower profits to find ANY trade -->
        <!-- FIX: Fallback uses fixed 100 Cr threshold regardless of pilot level -->
        <set_value name="$fallbackMinROI" exact="[$params.$MinROI / 2, 0].max"/>  <!-- Half of normal ROI, minimum 0% -->
        <set_value name="$fallbackMinAbsoluteProfit" exact="10000"/>  <!-- Fixed 100 Cr for all levels -->
        
        <!-- Call SearchLiveTrades with MaxDistance set to maxJumps/3 and relaxed profit thresholds -->
        <!-- DESIGN: Fallback uses lower profit thresholds, so we compensate by restricting travel distance -->
        <!-- Use maxJumps / 3 to balance: closer trades (less travel time) but still within reasonable range -->
        <!-- Formula: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
        <!-- FilterTradeList_Resume will then filter by home distance and sort by current distance -->
        <!-- All other parameters are inherited from original search request -->
        <!-- Use library function for fallback distance calculation -->
        <set_value name="$fallbackMaxDistance" exact="1"/>  <!-- Default fallback to 1 if originalMaxDistance not available -->
        <do_if value="$params.$OriginalMaxDistance?">
          <set_value name="$skillLevel" exact="1"/>  <!-- Default skill level -->
          <do_if value="$params.$SkillLevel?">
            <set_value name="$skillLevel" exact="$params.$SkillLevel"/>
          </do_if>
          <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackDistance" result="$fallbackMaxDistance">
            <param name="maxDistance" value="$params.$OriginalMaxDistance"/>
            <param name="skillLevel" value="$skillLevel"/>
          </run_actions>
        </do_if>
        
        <!-- DEBUG: Log fallback search trigger -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback search triggered: MaxDistance=' + $fallbackMaxDistance + ', Ship not isolated'" chance="100"/>
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback profit thresholds relaxed: ROI ' + $params.$MinROI + '% ' + $fallbackMinROI + '%, Profit fixed at 100 Cr (all levels)'" chance="100"/>
        </do_if>
        <!-- FIX: Check if a search is already in progress before starting fallback search -->
        <!-- This prevents race conditions where fallback search overwrites the original search's state -->
        <set_value name="$searchInProgress" exact="false"/>
        <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <set_value name="$searchInProgress" exact="true"/>
        </do_if>
        
        <do_if value="$searchInProgress">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ')   Fallback search blocked - search already in progress (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
          </do_if>
          <!-- Exit - SearchLiveTrades_Resume will signal SearchTradeRoutes again when search completes -->
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
          <!-- Only proceed if search is NOT in progress -->
          <set_value name="$liveSearchParams" exact="table[
            $Ship = $ship,
            $MaxDistance = $fallbackMaxDistance,
            $OriginalMaxDistance = $params.$OriginalMaxDistance,
            $MinROI = $fallbackMinROI,
            $MinAbsoluteProfit = $fallbackMinAbsoluteProfit,
            $FactionPriority = $params.$FactionPriority,
            $FactionPriorityText = $params.$FactionPriorityText,
            $DistancePenaltyMultiplier = $params.$DistancePenaltyMultiplier,
            $SkillLevel = $params.$SkillLevel,
            $ThreatIntel = $params.$ThreatIntel,
            $FleetCoord = $params.$FleetCoord,
            $AdvancedAnalytics = $params.$AdvancedAnalytics,
            $IsFallback = true
          ]"/>
          <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$liveSearchParams"/>
          
          <!-- Exit immediately after signaling SearchLiveTrades -->
          <!-- SearchLiveTrades_Resume will signal SearchTradeRoutes again when search completes -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ')   Fallback SearchLiveTrades signaled - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_else>
        
        <!-- SearchLiveTrades will handle the rest (signals SearchLiveTrades_Resume, which signals SearchTradeRoutes) -->
        <!-- Results will be processed the same way as normal live search -->
      </actions>
    </cue>
    
    <!-- Isolated Search Method -->
    <!-- Triggered when ship is isolated and normal search fails -->
    <!-- Uses most relaxed restrictions: 0% ROI, 0 Cr profit, 1-sector only -->
    <cue name="SearchIsolatedTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- ISOLATED PROFIT RELAXATION: Most relaxed thresholds to allow ANY profitable trade -->
        <!-- Isolated ships are trapped - accept any trade that makes profit -->
        <set_value name="$isolatedMinROI" exact="0"/>  <!-- 0% ROI - accept any profitable trade -->
        <set_value name="$isolatedMinAbsoluteProfit" exact="0"/>  <!-- 0 Cr - accept any positive profit -->
        
        <!-- Isolated search is limited to 1 sector only (current sector) -->
        <!-- Rationale: Isolated ships can't travel through blacklisted sectors, so only search current sector -->
        <set_value name="$isolatedMaxDistance" exact="1"/>
        
        <!-- DEBUG: Log isolated search trigger -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Isolated search triggered: MaxDistance=1 (current sector only), Ship is isolated'" chance="100"/>
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Isolated profit thresholds: ROI=0%, Profit=0 Cr (accept any profitable trade)'" chance="100"/>
        </do_if>
        
        <!-- FIX: Check if a search is already in progress before starting isolated search -->
        <!-- This prevents race conditions where isolated search overwrites the original search's state -->
        <set_value name="$searchInProgress" exact="false"/>
        <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <set_value name="$searchInProgress" exact="true"/>
        </do_if>
        
        <do_if value="$searchInProgress">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ')   Isolated search blocked - search already in progress (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
          </do_if>
          <!-- Exit - SearchLiveTrades_Resume will signal SearchTradeRoutes again when search completes -->
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
          <!-- Only proceed if search is NOT in progress -->
          <set_value name="$liveSearchParams" exact="table[
            $Ship = $ship,
            $MaxDistance = $isolatedMaxDistance,
            $OriginalMaxDistance = $params.$OriginalMaxDistance,
            $MinROI = $isolatedMinROI,
            $MinAbsoluteProfit = $isolatedMinAbsoluteProfit,
            $FactionPriority = $params.$FactionPriority,
            $FactionPriorityText = $params.$FactionPriorityText,
            $DistancePenaltyMultiplier = $params.$DistancePenaltyMultiplier,
            $SkillLevel = $params.$SkillLevel,
            $ThreatIntel = $params.$ThreatIntel,
            $FleetCoord = $params.$FleetCoord,
            $AdvancedAnalytics = $params.$AdvancedAnalytics,
            $IsIsolated = true
          ]"/>
          <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$liveSearchParams"/>
          
          <!-- Exit immediately after signaling SearchLiveTrades -->
          <!-- SearchLiveTrades_Resume will signal SearchTradeRoutes again when search completes -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ')   Isolated SearchLiveTrades signaled - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_else>
        
        <!-- SearchLiveTrades will handle the rest (signals SearchLiveTrades_Resume, which signals SearchTradeRoutes) -->
        <!-- Results will be processed with searchState='isolated' -->
      </actions>
    </cue>

    <!-- Resume Cue: SearchLiveTrades_Resume (signaled when incremental search completes) -->
    <cue name="SearchLiveTrades_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Extract results from signal -->
        <set_value name="$sectorLists" exact="event.param"/>
        <set_value name="$ship" exact="$sectorLists.$Ship"/>
        
        <!-- Debug logging -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$debugShip" exact="@$ship"/>
          <set_value name="$debugBuySpaces" exact="0"/>
          <set_value name="$debugSellSpaces" exact="0"/>
          <set_value name="$debugBuySpaces" exact="if @$sectorLists.$BuySpaces != null then @$sectorLists.$BuySpaces.count else 0"/>
          <set_value name="$debugSellSpaces" exact="if @$sectorLists.$SellSpaces != null then @$sectorLists.$SellSpaces.count else 0"/>
          <debug_text text="'[GT-Search] SearchLiveTrades_Resume: Received results from GT_IncrementalRadiusSearch - Ship=' + (if $debugShip != null then @$debugShip.idcode else 'NULL') + ', BuySpaces=' + $debugBuySpaces + ', SellSpaces=' + $debugSellSpaces + ', Isolated=' + $sectorLists.$ShipIsIsolated" chance="100"/>
        </do_if>
        
        <!-- Extract state from global storage -->
        <set_value name="$buyspaces" exact="[]"/>
        <set_value name="$sellspaces" exact="[]"/>
        <set_value name="$shipIsIsolated" exact="false"/>
        
        <!-- If ship found in state, restore state and continue -->
        <do_if value="$ship? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <!-- Debug logging -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchLiveTrades_Resume: State found for ship ' + $ship.idcode + ' - restoring state and continuing trade search'" chance="100"/>
          </do_if>
          <set_value name="$state" exact="global.$GT_SearchLiveTrades_State.{$ship}"/>
          
          <!-- IMPORTANT: With sliced offer-collection, live-search state must persist beyond this resume step.
               Guard against duplicate completion signals without deleting the state. -->
          <set_value name="$resumeProcessed" exact="@$state.$ResumeProcessed"/>
          <set_value name="$doResume" exact="true"/>
          <do_if value="$resumeProcessed? and $resumeProcessed == true">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades_Resume: Duplicate completion signal for ' + $ship.idcode + ' - resume already processed (ignoring)'" chance="10"/>
            </do_if>
            <set_value name="$doResume" exact="false"/>
          </do_if>
          
          <do_if value="$doResume">
            <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$ResumeProcessed" exact="true"/>
          
          <!-- Restore all state variables -->
          <set_value name="$homeSector" exact="$state.$HomeSector"/>
          <set_value name="$maxDistance" exact="$state.$MaxDistance"/>
          <set_value name="$originalMaxDistance" exact="$state.$OriginalMaxDistance"/>
          <set_value name="$minROI" exact="$state.$MinROI"/>
          <set_value name="$minAbsoluteProfit" exact="$state.$MinAbsoluteProfit"/>
          <set_value name="$factionPriority" exact="$state.$FactionPriority"/>
          <set_value name="$factionPriorityText" exact="$state.$FactionPriorityText"/>
          <set_value name="$distancePenaltyMultiplier" exact="$state.$DistancePenaltyMultiplier"/>
          <set_value name="$skillLevel" exact="$state.$SkillLevel"/>
          <set_value name="$gt_ThreatIntel" exact="$state.$ThreatIntel"/>
          <set_value name="$gt_FleetCoord" exact="$state.$FleetCoord"/>
          <set_value name="$gt_AdvancedAnalytics" exact="$state.$AdvancedAnalytics"/>
          <set_value name="$failedTrades" exact="$state.$FailedTrades"/>
          <set_value name="$tradeList" exact="$state.$TradeList"/>
          <set_value name="$maxTradesToReturn" exact="$state.$MaxTradesToReturn"/>
          <set_value name="$bestTrade" exact="$state.$BestTrade"/>
          <set_value name="$bestScore" exact="$state.$BestScore"/>
          <set_value name="$stationsEvaluated" exact="$state.$StationsEvaluated"/>
          <set_value name="$offersFound" exact="$state.$OffersFound"/>
          <set_value name="$homeBase" exact="$state.$HomeBase"/>
          <set_value name="$homeBaseSource" exact="$state.$HomeBaseSource"/>
          <set_value name="$homeSectorAnchor" exact="$state.$HomeSectorAnchor"/>
          <set_value name="$allowIllegal" exact="$state.$AllowIllegal"/>
          <set_value name="$wareBasket" exact="$state.$WareBasket"/>
          <set_value name="$blacklistgroup" exact="$state.$BlacklistGroup"/>
          
          <!-- Extract sector lists from incremental search results -->
          <set_value name="$buyspaces" exact="$sectorLists.$BuySpaces"/>
          <set_value name="$sellspaces" exact="$sectorLists.$SellSpaces"/>
          <set_value name="$shipIsIsolated" exact="$sectorLists.$ShipIsIsolated"/>
          <!-- DO NOT remove live-search state here (needed for sliced offer collection + in-progress gating) -->
          
          <!-- Continue with existing trade finding logic (from line 1365+) -->
          <!-- Price range: Load from global config with defaults (using library function) -->
          <!-- Use library function for price range loading (handles isolation automatically) -->
          <run_actions ref="md.GT_Libraries_General.GT_GetPriceRange" result="$priceRange">
            <param name="shipIsIsolated" value="$shipIsIsolated"/>
          </run_actions>
          <set_value name="$sellPriceMax" exact="$priceRange.$SellPriceMax"/>
          <set_value name="$buyPriceMin" exact="$priceRange.$BuyPriceMin"/>
          
          <!-- CRITICAL FIX: Check if ship still has GT order before signaling continuation -->
          <!-- This prevents infinite loops after GT order is removed -->
          <set_value name="$hasGTOrder" exact="false"/>
          <do_if value="$ship.defaultorder? and @$ship.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$hasGTOrder" exact="true"/>
          </do_if>
          <do_else>
            <!-- Check if subordinate to GT commander -->
            <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
              <do_if value="$ship.commander.defaultorder? and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
                <set_value name="$hasGTOrder" exact="true"/>
              </do_if>
            </do_if>
          </do_else>
          
          <!-- Only signal continuation if ship still has GT order -->
          <do_if value="not $hasGTOrder">
            <!-- CRITICAL FIX: Clear home refresh marker if this ship was the initiator -->
            <do_if value="$homeSector? and global.$GT_TS_LiveRefreshBySector? and global.$GT_TS_LiveRefreshBySector.{$homeSector}?">
              <set_value name="$refreshEntry" exact="global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
              <do_if value="$refreshEntry? and $refreshEntry.$Initiator? and $refreshEntry.$Initiator == $ship">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] SearchLiveTrades_Resume: Clearing home refresh marker (home=' + @$homeSector.knownname + ', initiator=' + $ship.idcode + ' lost GT order)'" chance="100"/>
                </do_if>
                <remove_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
              </do_if>
            </do_if>
            
            <!-- CRITICAL FIX: Release lock when ship loses GT order -->
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'no_gt_order'"/>
            </run_actions>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] SearchLiveTrades_Resume: Ship ' + $ship.idcode + ' no longer has GT order - cancelling search continuation'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- Continue with rest of SearchLiveTrades logic -->
            <!-- Signal SearchLiveTrades with continuation flag to skip sector list building -->
            <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="table[
            $Ship = $ship,
            $MaxDistance = $maxDistance,
            $OriginalMaxDistance = $originalMaxDistance,
            $MinROI = $minROI,
            $MinAbsoluteProfit = $minAbsoluteProfit,
            $FactionPriority = $factionPriority,
            $FactionPriorityText = $factionPriorityText,
            $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
            $SkillLevel = $skillLevel,
            $ThreatIntel = $gt_ThreatIntel,
            $FleetCoord = $gt_FleetCoord,
            $AdvancedAnalytics = $gt_AdvancedAnalytics,
            $ContinueFromSectorLists = true,
            $BuySpaces = $buyspaces,
            $SellSpaces = $sellspaces,
            $ShipIsIsolated = $shipIsIsolated,
            $FailedTrades = $failedTrades,
            $TradeList = $tradeList,
            $MaxTradesToReturn = $maxTradesToReturn,
            $BestTrade = $bestTrade,
            $BestScore = $bestScore,
            $StationsEvaluated = $stationsEvaluated,
            $OffersFound = $offersFound,
            $HomeBase = $homeBase,
            $HomeBaseSource = $homeBaseSource,
            $HomeSectorAnchor = $homeSectorAnchor,
            $AllowIllegal = $allowIllegal,
            $WareBasket = $wareBasket,
            $BlacklistGroup = $blacklistgroup,
            $SellPriceMax = $sellPriceMax,
            $BuyPriceMin = $buyPriceMin
          ]"/>
          </do_else>
          </do_if>
        </do_if>
        <do_else>
          <!-- Ship not found in state - this is a duplicate completion signal -->
          <!-- The first resume already processed the search and cleaned up the state -->
          <!-- This can happen when multiple pathfinding instances complete simultaneously -->
          <!-- Just cancel silently - search already completed -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$debugShip" exact="@$ship"/>
            <debug_text text="'[GT-Search] SearchLiveTrades_Resume: Duplicate completion signal for ' + (if $debugShip != null then @$debugShip.idcode else 'NULL') + ' - state already cleaned up (search completed)'" chance="10"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_else>
      </actions>
    </cue>
    
  </cues>
</mdscript>
