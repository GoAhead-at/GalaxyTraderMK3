<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_TradeSearch_Scheduler" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- =====================================================================
         Trade-search Scheduler (Hard Frame Budget)

         Purpose:
         - Single entrypoint for starting new trade searches.
         - Enforces a hard minimum interval between starting expensive searches.
         - Avoids same-frame stampedes: only one search start per tick.

         External contract:
         - Accepts canonical request tables from GT_TradingAI (Ship + parameters).
         - Starts the existing search engine by signalling md.GT_Trading_Search.SearchTradeRoutes.
         - AI still receives GT_Trade_Found / GT_No_Trade_Found via existing execution/signals.

         NOTE: This is step 1 of the full rewrite. It strictly limits *starts*.
               Later steps will convert cache/live/match into true work-unit steppers.
         ===================================================================== -->

    <cue name="Init" instantiate="true">
      <conditions>
        <check_any>
          <event_game_loaded/>
          <event_player_created/>
        </check_any>
      </conditions>
      <actions>
        <do_if value="not global.$GT_TS?">
          <set_value name="global.$GT_TS" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Queue? or global.$GT_TS.$Queue == null">
          <set_value name="global.$GT_TS.$Queue" exact="[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Queued? or global.$GT_TS.$Queued == null">
          <set_value name="global.$GT_TS.$Queued" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Requests? or global.$GT_TS.$Requests == null">
          <set_value name="global.$GT_TS.$Requests" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Processing?">
          <set_value name="global.$GT_TS.$Processing" exact="false"/>
        </do_if>
        <do_if value="not global.$GT_TS.$NextStartTime?">
          <set_value name="global.$GT_TS.$NextStartTime" exact="0s"/>
        </do_if>

        <!-- Reset transient coalescing / output queues on load (not safe to resume across save/load) -->
        <set_value name="global.$GT_TS_LiveRefreshBySector" exact="table[]"/>
        <do_if value="global.$GT_TS_OutputQueue?">
          <set_value name="global.$GT_TS_OutputQueue" exact="table[
            $TradeFoundQueue = [],
            $TradeFoundQueued = table[],
            $TradeFoundProcessing = false
          ]"/>
        </do_if>

        <!-- Legacy queue cleanup (safe): SearchQueue is no longer used for scheduling starts -->
        <do_if value="global.$GT_SearchQueue?">
          <remove_value name="global.$GT_SearchQueue.$Ships"/>
          <remove_value name="global.$GT_SearchQueue.$QueuedShips"/>
          <remove_value name="global.$GT_SearchQueue.$Processing"/>
          <remove_value name="global.$GT_SearchQueue.$NextSearchStartTime"/>
        </do_if>
      </actions>
    </cue>

    <!-- Enqueue a trade-search request (canonical request table) -->
    <cue name="Enqueue" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$req" exact="event.param"/>
        <set_value name="$ship" exact="$req.$Ship"/>

        <do_if value="not $ship? or not $ship.exists">
          <cancel_cue cue="this"/>
        </do_if>

        <!-- Ensure global structures exist -->
        <do_if value="not global.$GT_TS?">
          <set_value name="global.$GT_TS" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Queue? or global.$GT_TS.$Queue == null">
          <set_value name="global.$GT_TS.$Queue" exact="[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Queued? or global.$GT_TS.$Queued == null">
          <set_value name="global.$GT_TS.$Queued" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TS.$Requests? or global.$GT_TS.$Requests == null">
          <set_value name="global.$GT_TS.$Requests" exact="table[]"/>
        </do_if>

        <!-- Overwrite latest request for ship (idempotent) -->
        <set_value name="global.$GT_TS.$Requests.{$ship}" exact="$req"/>

        <!-- Initialize EnqueuedAt table if needed -->
        <do_if value="not global.$GT_TS.$EnqueuedAt? or global.$GT_TS.$EnqueuedAt == null">
          <set_value name="global.$GT_TS.$EnqueuedAt" exact="table[]"/>
        </do_if>

        <!-- O(1) de-dupe -->
        <do_if value="not global.$GT_TS.$Queued.{$ship}?">
          <set_value name="global.$GT_TS.$Queued.{$ship}" exact="true"/>
          <!-- Track when ship was enqueued (for stale entry detection) -->
          <set_value name="global.$GT_TS.$EnqueuedAt.{$ship}" exact="player.age"/>
          <append_to_list name="global.$GT_TS.$Queue" exact="$ship"/>
        </do_if>
        <do_else>
          <!-- Ship already queued - update enqueue time (prevents timeout if ship re-requests) -->
          <set_value name="global.$GT_TS.$EnqueuedAt.{$ship}" exact="player.age"/>
        </do_else>

        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-TS] Enqueue: ' + $ship.idcode + ' (queue=' + global.$GT_TS.$Queue.count + ')'" chance="100"/>
        </do_if>

        <!-- Kick scheduler -->
        <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.Tick"/>
      </actions>
    </cue>

    <!-- Single-threaded scheduler tick -->
    <cue name="Tick" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <do_if value="not global.$GT_TS? or not global.$GT_TS.$Queue?">
          <cancel_cue cue="this"/>
        </do_if>

        <!-- Prevent stampede -->
        <do_if value="global.$GT_TS.$Processing">
          <cancel_cue cue="this"/>
        </do_if>
        <set_value name="global.$GT_TS.$Processing" exact="true"/>

        <!-- Initialize EnqueuedAt table if needed -->
        <do_if value="not global.$GT_TS.$EnqueuedAt? or global.$GT_TS.$EnqueuedAt == null">
          <set_value name="global.$GT_TS.$EnqueuedAt" exact="table[]"/>
        </do_if>

        <!-- SAFEGUARD: Remove stale queue entries (older than 60 seconds) -->
        <!-- Prevents ships from being stuck in queue indefinitely -->
        <set_value name="$staleThreshold" exact="60s"/>
        <set_value name="$staleShips" exact="[]"/>
        <do_all exact="global.$GT_TS.$Queue.count" counter="$i">
          <set_value name="$queuedShip" exact="global.$GT_TS.$Queue.{$i}"/>
          <set_value name="$enqueuedAt" exact="@global.$GT_TS.$EnqueuedAt.{$queuedShip}"/>
          <do_if value="$enqueuedAt? and $enqueuedAt != null">
            <set_value name="$queueAge" exact="player.age - $enqueuedAt"/>
            <do_if value="$queueAge gt $staleThreshold">
              <!-- Ship has been queued for more than 60 seconds - remove and signal busy -->
              <append_to_list name="$staleShips" exact="$queuedShip"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Missing enqueue timestamp - treat as stale (shouldn't happen, but handle gracefully) -->
            <append_to_list name="$staleShips" exact="$queuedShip"/>
          </do_else>
        </do_all>
        
        <!-- Remove stale ships from queue and signal busy -->
        <do_all exact="$staleShips.count" counter="$j">
          <set_value name="$staleShip" exact="$staleShips.{$j}"/>
          <!-- Store age before removing timestamp (for logging) -->
          <set_value name="$staleAge" exact="0s"/>
          <set_value name="$staleEnqueuedAt" exact="@global.$GT_TS.$EnqueuedAt.{$staleShip}"/>
          <do_if value="$staleEnqueuedAt? and $staleEnqueuedAt != null">
            <set_value name="$staleAge" exact="player.age - $staleEnqueuedAt"/>
          </do_if>
          <remove_from_list name="global.$GT_TS.$Queue" exact="$staleShip"/>
          <remove_value name="global.$GT_TS.$Queued.{$staleShip}"/>
          <remove_value name="global.$GT_TS.$EnqueuedAt.{$staleShip}"/>
          <do_if value="$staleShip? and $staleShip.exists">
            <!-- Release request registry lock -->
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$staleShip"/>
              <param name="reason" value="'busy'"/>
            </run_actions>
            <!-- Signal ship that system is busy (AI will retry after 10s) -->
            <signal_objects object="$staleShip" param="'GT_No_Trade_Found'" param2="'busy'"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-TS] SAFEGUARD: Removed stale queue entry for ' + $staleShip.idcode + ' (queued for ' + ($staleAge / 1s) + 's, threshold=60s) - signaling busy retry'" chance="100"/>
            </do_if>
          </do_if>
        </do_all>

        <!-- If no pending ships after cleanup, stop -->
        <do_if value="global.$GT_TS.$Queue.count le 0">
          <set_value name="global.$GT_TS.$Processing" exact="false"/>
          <cancel_cue cue="this"/>
        </do_if>

        <!-- Hard budget: enforce min interval between starting searches -->
        <set_value name="this.$DelayTime" exact="0ms"/>
        <set_value name="$nextStart" exact="@global.$GT_TS.$NextStartTime"/>
        <do_if value="$nextStart? and $nextStart != null and player.age lt $nextStart">
          <set_value name="this.$DelayTime" exact="$nextStart - player.age"/>
        </do_if>

        <do_if value="this.$DelayTime gt 0ms and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-TS] Budget: delaying next start by ' + (this.$DelayTime / 1ms) + 'ms (queue=' + global.$GT_TS.$Queue.count + ')'" chance="100"/>
        </do_if>
      </actions>
      <delay exact="this.$DelayTime"/>
      <actions>
        <!-- ROOT CAUSE FIX: Create multiple work items per tick to fill queue faster -->
        <!-- Tick was creating 1 work item per 25ms, causing bottleneck with large queues -->
        <!-- ProcessWorkQueue can process 10 items per tick, so Tick should create multiple items per call -->
        <!-- Creating work items is cheap (just data structures), so we can create 5-10 per call without stutter -->
        <set_value name="$startIntervalMs" exact="25"/>
        <set_value name="global.$GT_TS.$NextStartTime" exact="player.age + ($startIntervalMs * 1ms)"/>
        
        <!-- Process multiple ships per tick (up to reasonable limit to prevent stutter) -->
        <!-- Limit to 5 ships per tick to balance throughput vs frame time -->
        <set_value name="$maxShipsPerTick" exact="5"/>
        <set_value name="$shipsProcessed" exact="0"/>
        
        <do_while value="global.$GT_TS.$Queue.count gt 0 and $shipsProcessed lt $maxShipsPerTick">
          <!-- Dequeue one ship -->
          <set_value name="$ship" exact="global.$GT_TS.$Queue.{1}"/>
          
          <!-- CRITICAL FIX: Validate ship exists BEFORE clearing timestamp (preserves diagnostic info) -->
          <do_if value="not $ship? or not $ship.exists">
            <!-- Ship destroyed - remove from queue but preserve timestamp for diagnostics -->
            <remove_from_list name="global.$GT_TS.$Queue" exact="$ship"/>
            <remove_value name="global.$GT_TS.$Queued.{$ship}"/>
            <!-- Note: Keep $EnqueuedAt for diagnostics (shows how long destroyed ship was queued) -->
            <set_value name="$shipsProcessed" operation="add"/>
            <continue/>
          </do_if>
          
          <!-- Ship is valid - proceed with dequeue and timestamp cleanup -->
          <remove_from_list name="global.$GT_TS.$Queue" exact="$ship"/>
          <remove_value name="global.$GT_TS.$Queued.{$ship}"/>
          <!-- Clear enqueue timestamp (ship is being processed) -->
          <remove_value name="global.$GT_TS.$EnqueuedAt.{$ship}"/>

          <!-- Load latest request -->
          <set_value name="$req" exact="@global.$GT_TS.$Requests.{$ship}"/>
          <do_if value="$req == null">
            <!-- Request cleared - skip this ship -->
            <set_value name="$shipsProcessed" operation="add"/>
            <continue/>
          </do_if>

          <!-- Start the search engine -->
          <!-- CRITICAL FIX: Create CacheQuery work item directly instead of signaling SearchTradeRoutes -->
          <!-- This prevents concurrent SearchTradeRoutes instances (up to 22 per frame) causing stutter -->
          <!-- SearchTradeRoutes will be signaled by scheduler when cache query completes -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-TS] Start: ' + $ship.idcode + ' (queue_remaining=' + global.$GT_TS.$Queue.count + ') - creating CacheQuery work item'" chance="100"/>
          </do_if>
          
          <!-- Extract parameters from request (same as SearchTradeRoutes does) -->
          <set_value name="$traceId" exact="if $req.$TraceId? then $req.$TraceId else '0'"/>
          
          <!-- CRITICAL FIX: Determine home sector using GT_GetHomeSector (same as SearchTradeRoutes) -->
          <!-- $req.$HomeSector may not exist - SearchTradeRoutes determines it dynamically -->
          <set_value name="$homeSector" exact="null"/>
          <run_actions ref="md.GT_Libraries_General.GT_GetHomeSector" result="$homeSector">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <set_value name="$maxDistance" exact="@$req.$MaxDistance"/>
          <set_value name="$minROI" exact="@$req.$MinROI"/>
          <set_value name="$minAbsoluteProfit" exact="@$req.$MinAbsoluteProfit"/>
          <set_value name="$ignoreBuildStorage" exact="if $req.$IgnoreBuildStorage? then $req.$IgnoreBuildStorage else false"/>
          <set_value name="$ignoreCarrierAux" exact="if $req.$IgnoreCarrierAux? then $req.$IgnoreCarrierAux else false"/>
          
          <!-- CRITICAL FIX: Validate home sector before creating work item (prevents invalid_params errors) -->
          <do_if value="not $homeSector? or not $homeSector.exists">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=cannot_determine_home_sector ship=' + $ship.idcode + ' - skipping cache query'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
            <!-- CRITICAL FIX: Release lock and signal AI (terminal failure routine) -->
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'cannot_determine_home_sector'"/>
            </run_actions>
            <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'busy'"/>
            <set_value name="$shipsProcessed" operation="add"/>
            <continue/>
          </do_if>
          
          <!-- Create CacheQuery work item directly (bypasses SearchTradeRoutes initial entry) -->
          <run_actions ref="md.GT_Libraries_General.GT_CreateWorkItem" result="$cacheWorkItem">
            <param name="type" value="'CacheQuery'"/>
            <param name="key" value="$ship.idcode + '_CacheQuery'"/>
            <param name="traceId" value="$traceId"/>
            <param name="payload" value="table[
              $Ship = $ship,
              $HomeSector = $homeSector,
              $MaxDistance = $maxDistance,
              $MinROI = $minROI,
              $MinAbsoluteProfit = $minAbsoluteProfit,
              $IgnoreBuildStorage = $ignoreBuildStorage,
              $IgnoreCarrierAux = $ignoreCarrierAux,
              $ResumeParams = $req
            ]"/>
          </run_actions>
          
          <!-- Enqueue work item to scheduler -->
          <run_actions ref="md.GT_Libraries_General.GT_EnqueueWorkItem">
            <param name="workItem" value="$cacheWorkItem"/>
          </run_actions>
          
          <set_value name="$shipsProcessed" operation="add"/>
        </do_while>

        <!-- Continue if more work exists -->
        <set_value name="global.$GT_TS.$Processing" exact="false"/>
        <do_if value="global.$GT_TS.$Queue.count gt 0">
          <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.Tick"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- =====================================================================
         Central Work Queue Processor (Phase 2)
         
         Purpose:
         - Processes work items from global.$GT_Scheduler.$WorkQueue
         - Respects budgets for different work types
         - Updates work item states
         - Logs scheduler operations
         
         Work Item Types:
         - 'Request': Initial trade search request
         - 'CacheQuery': Cache lookup work
         - 'HomeSearch': Home sector pathfinding work
         - 'OfferCollect': Offer collection work
         - 'Match': Trade matching/batch processing work
         - 'Finalize': Finalization work
         ===================================================================== -->
    
    <!-- Process Work Queue -->
    <cue name="ProcessWorkQueue" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Validate scheduler exists - ERROR if missing -->
        <do_if value="not global.$GT_Scheduler?">
          <debug_text text="'[GT-ERROR] ProcessWorkQueue: Scheduler not initialized'" chance="100"/>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Prevent concurrent processing -->
        <do_if value="global.$GT_Scheduler.$Processing">
          <cancel_cue cue="this"/>
        </do_if>
        <set_value name="global.$GT_Scheduler.$Processing" exact="true"/>
        
        <!-- If no work, stop -->
        <do_if value="not global.$GT_Scheduler.$WorkQueue? or global.$GT_Scheduler.$WorkQueue.count le 0">
          <set_value name="global.$GT_Scheduler.$Processing" exact="false"/>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- CRITICAL: Ensure ActiveWork is a table (not a list) - MUST be checked BEFORE counting active work -->
        <!-- ROOT CAUSE: Accessing .keys.count on an empty table might corrupt it in X4 MD -->
        <!-- SOLUTION: Store the count in a variable BEFORE the do_all loop to prevent corruption -->
        <do_if value="not global.$GT_Scheduler.$ActiveWork?">
          <set_value name="global.$GT_Scheduler.$ActiveWork" exact="table[]"/>
        </do_if>
        <!-- Ensure ActiveWork is a table - if it's not, reinitialize it (should never happen, but defensive) -->
        <do_else>
          <do_if value="typeof global.$GT_Scheduler.$ActiveWork != datatype.table">
            <!-- ActiveWork is not a table - reinitialize (this should never happen, indicates a bug) -->
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="0"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=ActiveWork_not_table_reinitializing'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
            <set_value name="global.$GT_Scheduler.$ActiveWork" exact="table[]"/>
          </do_if>
        </do_else>
        
        <!-- Initialize budgets if missing, using global settings if available, otherwise defaults -->
        <do_if value="not global.$GT_Scheduler.$Budgets?">
          <!-- Try to read from global settings first -->
          <set_value name="$defaultCacheSearches" exact="5"/>
          <set_value name="$defaultLiveSearches" exact="1"/>
          <set_value name="$defaultMatches" exact="1"/>
          
          <!-- Load from global settings if available -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance?">
            <do_if value="global.$GT_GlobalSettings.$Performance.$MaxConcurrentCacheSearches?">
              <set_value name="$defaultCacheSearches" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentCacheSearches"/>
            </do_if>
            <do_if value="global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
              <set_value name="$defaultLiveSearches" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
            </do_if>
          </do_if>
          
          <set_value name="global.$GT_Scheduler.$Budgets" exact="table[
            $CheapOpsPerTick = $defaultCacheSearches,
            $OfferOpsPerTick = 5,
            $MatchOpsPerTick = $defaultMatches,
            $MaxActiveHomeSearches = $defaultLiveSearches
          ]"/>
        </do_if>
        <do_else>
          <!-- Budgets exist - reload from global settings every tick to pick up changes -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance?">
            <do_if value="global.$GT_GlobalSettings.$Performance.$MaxConcurrentCacheSearches?">
              <set_value name="global.$GT_Scheduler.$Budgets.$CheapOpsPerTick" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentCacheSearches"/>
            </do_if>
            <do_if value="global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
              <set_value name="global.$GT_Scheduler.$Budgets.$MaxActiveHomeSearches" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- Count active work by type -->
        <set_value name="$activeCacheQueries" exact="0"/>
        <set_value name="$activeHomeSearches" exact="0"/>
        <set_value name="$activeMatches" exact="0"/>
        
        <!-- CRITICAL: Only count active work if ActiveWork is a table (has .keys property) -->
        <!-- ROOT CAUSE FIX: Store .keys.count in a variable BEFORE do_all to prevent corruption -->
        <!-- Accessing .keys.count directly in do_all might corrupt the table in X4 MD -->
        <set_value name="$activeWorkKeysCount" exact="0"/>
        <do_if value="global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.keys?">
          <set_value name="$activeWorkKeysCount" exact="global.$GT_Scheduler.$ActiveWork.keys.count"/>
          <do_all exact="$activeWorkKeysCount" counter="$i">
            <set_value name="$key" exact="global.$GT_Scheduler.$ActiveWork.keys.{$i}"/>
            <set_value name="$workItem" exact="global.$GT_Scheduler.$ActiveWork.{$key}"/>
            <do_if value="$workItem? and $workItem.$Type? and $workItem.$State == 'active'">
              <do_if value="$workItem.$Type == 'CacheQuery'">
                <set_value name="$activeCacheQueries" operation="add"/>
              </do_if>
              <do_elseif value="$workItem.$Type == 'HomeSearch'">
                <set_value name="$activeHomeSearches" operation="add"/>
              </do_elseif>
              <do_elseif value="$workItem.$Type == 'Match'">
                <set_value name="$activeMatches" operation="add"/>
              </do_elseif>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Process work items respecting budgets -->
        <set_value name="$processed" exact="0"/>
        <!-- CRITICAL FIX: Cache queries complete synchronously, so they're never "active" when counted -->
        <!-- Instead, track how many cache queries we START in this tick (not how many are active) -->
        <!-- This allows continuous processing: process 5 cache queries, they complete immediately, budget resets, process 5 more -->
        <set_value name="$cacheQueriesStartedThisTick" exact="0"/>
        <set_value name="$budgetCheapOps" exact="global.$GT_Scheduler.$Budgets.$CheapOpsPerTick"/>
        <set_value name="$budgetHomeSearches" exact="global.$GT_Scheduler.$Budgets.$MaxActiveHomeSearches - $activeHomeSearches"/>
        <set_value name="$budgetMatches" exact="global.$GT_Scheduler.$Budgets.$MatchOpsPerTick - $activeMatches"/>
        
        <!-- Log scheduler tick -->
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="0"/>
          <param name="stage" value="'Scheduler'"/>
          <param name="action" value="'Tick'"/>
          <param name="details" value="'queue=' + global.$GT_Scheduler.$WorkQueue.count + ' active=' + (if global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.keys? then global.$GT_Scheduler.$ActiveWork.keys.count else 0) + ' cacheStarted=' + $cacheQueriesStartedThisTick + '/' + global.$GT_Scheduler.$Budgets.$CheapOpsPerTick + ' budgetHome=' + $budgetHomeSearches + ' budgetMatch=' + $budgetMatches"/>
          <param name="logLevel" value="3"/>
        </run_actions>
        
        <!-- Process work items from queue - process up to budget limit per tick to prevent frame blocking -->
        <!-- CRITICAL: Frame distribution - process items per tick, then yield to prevent stutter with large fleets -->
        <!-- Cache queries are cheap (synchronous, complete immediately) but we limit to prevent tight loops -->
        <!-- Live searches and matches are expensive - limit more strictly -->
        <!-- Reduced from 20 to 5 to prevent stutter - ProcessWorkQueue will signal itself to continue if more work exists -->
        <!-- ROOT CAUSE FIX: Process multiple cache queries per tick since they complete synchronously -->
        <!-- Cache queries are cheap and complete immediately, so we can process more per tick -->
        <!-- For stutter reduction: reduce maxItemsPerTick for large fleets, increase delay -->
        <set_value name="$maxItemsPerTick" exact="10"/>
        <!-- CRITICAL FIX: Track rotations to prevent infinite rotation when all items are unprocessable -->
        <set_value name="$rotationsThisTick" exact="0"/>
        <set_value name="$maxRotationsPerTick" exact="global.$GT_Scheduler.$WorkQueue.count"/>
        <do_while value="global.$GT_Scheduler.$WorkQueue.count gt 0 and $processed lt $maxItemsPerTick and $rotationsThisTick lt $maxRotationsPerTick">
          <set_value name="$workItem" exact="global.$GT_Scheduler.$WorkQueue.{1}"/>
          
          <!-- Validate work item - ERROR if invalid -->
          <do_if value="not $workItem? or not $workItem.$Type? or not $workItem.$Key?">
            <remove_from_list name="global.$GT_Scheduler.$WorkQueue" exact="$workItem"/>
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="0"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=invalid_workItem'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
            <continue/>
          </do_if>
          
          <!-- Check budget for this work type -->
          <!-- CRITICAL FIX: Cache queries complete synchronously, so track how many we START per tick -->
          <!-- Since they complete immediately, we can process many per tick, but limit concurrent starts -->
          <set_value name="$canProcess" exact="false"/>
          <do_if value="$workItem.$Type == 'CacheQuery'">
            <!-- Check if we've started fewer than MaxConcurrentCacheSearches cache queries this tick -->
            <do_if value="$cacheQueriesStartedThisTick lt global.$GT_Scheduler.$Budgets.$CheapOpsPerTick">
              <set_value name="$canProcess" exact="true"/>
              <set_value name="$cacheQueriesStartedThisTick" operation="add"/>
              <!-- Note: Cache queries complete synchronously, so they don't stay "active" -->
              <!-- We track starts per tick to limit concurrent processing, but allow continuous flow -->
            </do_if>
          </do_if>
          <do_elseif value="$workItem.$Type == 'HomeSearch' and $budgetHomeSearches gt 0">
            <set_value name="$canProcess" exact="true"/>
            <set_value name="$budgetHomeSearches" operation="subtract"/>
          </do_elseif>
          <do_elseif value="$workItem.$Type == 'Match' and $budgetMatches gt 0">
            <set_value name="$canProcess" exact="true"/>
            <set_value name="$budgetMatches" operation="subtract"/>
          </do_elseif>
          <do_elseif value="$workItem.$Type == 'Request' or $workItem.$Type == 'OfferCollect' or $workItem.$Type == 'Finalize'">
            <!-- These types don't have strict budgets yet -->
            <set_value name="$canProcess" exact="true"/>
          </do_elseif>
          
          <!-- Process if budget allows -->
          <do_if value="$canProcess">
            <!-- Remove from queue -->
            <remove_from_list name="global.$GT_Scheduler.$WorkQueue" exact="$workItem"/>
            
            <!-- Extract ship from payload to use as ActiveWork key (ship object, not string key) -->
            <!-- NOTE: ActiveWork type check moved to start of ProcessWorkQueue to avoid clearing active work during processing -->
            <set_value name="$payload" exact="$workItem.$Payload"/>
            <set_value name="$ship" exact="@$payload.$Ship"/>
            
            <!-- CRITICAL FIX: Validate ship exists and is valid before processing work item -->
            <do_if value="not $ship? or not $ship.exists">
              <!-- Invalid ship - mark work item as failed and skip processing -->
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="stage" value="'Scheduler'"/>
                <param name="action" value="'Error'"/>
                <param name="details" value="'reason=invalid_ship_in_payload type=' + $workItem.$Type + ' key=' + (if $workItem.$Key? then $workItem.$Key else 'unknown')"/>
                <param name="logLevel" value="0"/>
              </run_actions>
              <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
                <param name="key" value="$workItem.$Key"/>
                <param name="newState" value="'failed'"/>
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="reason" value="'invalid_ship'"/>
                <param name="workItem" value="$workItem"/>
              </run_actions>
              <continue/>
            </do_if>
            
            <!-- Ship is valid - proceed with processing -->
            <!-- Add to ActiveWork BEFORE updating state (keyed by ship object, not string key) -->
            <set_value name="global.$GT_Scheduler.$ActiveWork.{$ship}" exact="$workItem"/>
            
            <!-- Update state to active (pass work item to avoid lookup issues) -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="$workItem.$Key"/>
              <param name="newState" value="'active'"/>
              <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            
            <!-- Dispatch to appropriate handler -->
            <do_if value="$workItem.$Type == 'CacheQuery'">
              <!-- Process CacheQuery work item -->
              <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessCacheQueryWork" param="$workItem"/>
            </do_if>
            <do_elseif value="$workItem.$Type == 'HomeSearch'">
              <!-- Process HomeSearch work item -->
              <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessHomeSearchWork" param="$workItem"/>
            </do_elseif>
            <do_elseif value="$workItem.$Type == 'Match'">
              <!-- Process Match work item -->
              <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessMatchWork" param="$workItem"/>
            </do_elseif>
            <do_elseif value="$workItem.$Type == 'Request'">
              <!-- Process Request work item (start search) -->
              <!-- For now, keep using existing flow - will migrate later -->
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="stage" value="'Scheduler'"/>
                <param name="action" value="'WorkItemActivated'"/>
                <param name="details" value="'type=' + $workItem.$Type + ' key=' + $workItem.$Key + ' note=handler_not_implemented_yet'"/>
                <param name="logLevel" value="2"/>
              </run_actions>
              <!-- Mark as completed for now (will implement handler later) -->
              <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
              <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
                <param name="key" value="$workItem.$Key"/>
                <param name="newState" value="'completed'"/>
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="workItem" value="$workItem"/>
              </run_actions>
              <!-- Remove from ActiveWork using ship key -->
              <do_if value="$ship?">
                <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
              </do_if>
            </do_elseif>
            <do_else>
              <!-- Other work types (OfferCollect, Finalize) - log and mark as completed (handlers will be implemented in later phases) -->
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="stage" value="'Scheduler'"/>
                <param name="action" value="'WorkItemActivated'"/>
                <param name="details" value="'type=' + $workItem.$Type + ' key=' + $workItem.$Key + ' note=handler_not_implemented_yet'"/>
                <param name="logLevel" value="2"/>
              </run_actions>
              <!-- Mark as completed for now (will implement handlers later) -->
              <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
              <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
                <param name="key" value="$workItem.$Key"/>
                <param name="newState" value="'completed'"/>
                <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
                <param name="workItem" value="$workItem"/>
              </run_actions>
              <!-- Remove from ActiveWork using ship key -->
              <do_if value="$ship?">
                <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
              </do_if>
            </do_else>
            
            <set_value name="$processed" operation="add"/>
          </do_if>
          <do_else>
            <!-- CRITICAL FIX: Budget exhausted for this type - rotate item to end of queue to prevent infinite loop -->
            <!-- This allows us to scan for processable items while preserving queue order -->
            <!-- Only break if ALL budgets are exhausted (no more work can be processed this tick) -->
            <set_value name="$cacheBudgetExhausted" exact="$cacheQueriesStartedThisTick ge global.$GT_Scheduler.$Budgets.$CheapOpsPerTick"/>
            <do_if value="$cacheBudgetExhausted and $budgetHomeSearches le 0 and $budgetMatches le 0">
              <!-- All budgets exhausted - break to prevent infinite loop -->
              <break/>
            </do_if>
            <do_else>
              <!-- Some budgets still available - rotate unprocessable item to end of queue -->
              <!-- This prevents infinite loop when head item can't be processed but other items can -->
              <!-- CRITICAL FIX: Track rotations to prevent rotating entire queue multiple times -->
              <set_value name="$rotationsThisTick" operation="add"/>
              <remove_from_list name="global.$GT_Scheduler.$WorkQueue" exact="$workItem"/>
              <append_to_list name="global.$GT_Scheduler.$WorkQueue" exact="$workItem"/>
              <!-- Continue to next item (might be different type with available budget) -->
              <!-- If we've rotated as many times as queue size, all items are likely unprocessable - break to prevent infinite rotation -->
              <do_if value="$rotationsThisTick ge $maxRotationsPerTick">
                <break/>
              </do_if>
            </do_else>
          </do_else>
        </do_while>
        
        <!-- Periodic statistics logging and cleanup (every 10 seconds) -->
        <set_value name="$timeSinceLastStats" exact="player.age - global.$GT_Scheduler.$LastStatsLog"/>
        <do_if value="$timeSinceLastStats ge 10s">
          <set_value name="global.$GT_Scheduler.$LastStatsLog" exact="player.age"/>
          
          <!-- Cleanup expired reservations -->
          <run_actions ref="md.GT_Libraries_General.GT_CleanupExpiredReservations" result="$cleanupResult">
            <param name="traceId" value="0"/>
          </run_actions>
          
          <!-- Collect statistics -->
          <set_value name="$counters" exact="global.$GT_Scheduler.$Counters"/>
          <set_value name="$cacheHitRate" exact="0.0"/>
          <do_if value="$counters.$Completed gt 0">
            <!-- TODO: Calculate actual cache hit rate from completed work items -->
            <set_value name="$cacheHitRate" exact="0.0"/>
          </do_if>
          
          <!-- Reservation statistics -->
          <set_value name="$reservationStats" exact="table[$Active = 0, $Expired = 0, $Conflicts = 0]"/>
          <do_if value="global.$GT_ReservationStats?">
            <set_value name="$reservationStats" exact="global.$GT_ReservationStats"/>
          </do_if>
          
          <!-- Log combined statistics -->
          <set_value name="$statsDetails" exact="'queue=' + global.$GT_Scheduler.$WorkQueue.count + ' active=' + (if global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.keys? then global.$GT_Scheduler.$ActiveWork.keys.count else 0) + ' completed=' + (if $counters.$Completed? then $counters.$Completed else 0) + ' failed=' + (if $counters.$Failed? then $counters.$Failed else 0) + ' cacheHitRate=' + ($cacheHitRate * 100) + '% reservations=' + (if $reservationStats.$Active? then $reservationStats.$Active else 0) + ' expired=' + (if $reservationStats.$Expired? then $reservationStats.$Expired else 0) + ' conflicts=' + (if $reservationStats.$Conflicts? then $reservationStats.$Conflicts else 0)"/>
          
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="0"/>
            <param name="stage" value="'Scheduler'"/>
            <param name="action" value="'Stats'"/>
            <param name="details" value="$statsDetails"/>
            <param name="logLevel" value="1"/>
          </run_actions>
        </do_if>
        
        <!-- Continue processing if more work exists -->
        <!-- CRITICAL FIX: Use delayed cue instead of instant self-signal to ensure frame distribution -->
        <!-- signal_cue_instantly can run in same frame, defeating "5 items per tick" limit -->
        <!-- Using a separate delayed cue ensures proper frame distribution -->
        <set_value name="global.$GT_Scheduler.$Processing" exact="false"/>
        <do_if value="global.$GT_Scheduler.$WorkQueue.count gt 0">
          <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessWorkQueueDelayed"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- Process CacheQuery Work Item -->
    <!-- Handles cache query work items by calling GT_TS_CachePickBest -->
    <cue name="ProcessCacheQueryWork" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$workItem" exact="event.param"/>
        
        <!-- Validate work item - ERROR if missing -->
        <do_if value="not $workItem? or not $workItem.$Payload?">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="if $workItem? and $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
            <param name="stage" value="'Scheduler'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_cachequery_workitem key=' + (if $workItem? and $workItem.$Key? then $workItem.$Key else 'unknown')"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- Extract ship from payload for ActiveWork key -->
          <set_value name="$payload" exact="$workItem.$Payload"/>
          <set_value name="$workShip" exact="@$payload.$Ship"/>
          <do_if value="$workItem? and $workItem.$Key?">
            <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="$workItem.$Key"/>
              <param name="newState" value="'failed'"/>
              <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
              <param name="reason" value="'invalid_payload'"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            <!-- Remove from ActiveWork using ship key -->
            <do_if value="$workShip?">
              <remove_value name="global.$GT_Scheduler.$ActiveWork.{$workShip}"/>
            </do_if>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <set_value name="$payload" exact="$workItem.$Payload"/>
        <set_value name="$ship" exact="@$payload.$Ship"/>
        <set_value name="$homeSector" exact="@$payload.$HomeSector"/>
        <set_value name="$maxDistance" exact="@$payload.$MaxDistance"/>
        <set_value name="$minROI" exact="@$payload.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="@$payload.$MinAbsoluteProfit"/>
        <set_value name="$ignoreBuildStorage" exact="@$payload.$IgnoreBuildStorage"/>
        <set_value name="$ignoreCarrierAux" exact="@$payload.$IgnoreCarrierAux"/>
        <set_value name="$traceId" exact="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
        
        <!-- Validate required parameters - ERROR if missing -->
        <do_if value="not $ship? or not $ship.exists or not $homeSector? or not $homeSector.exists">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'CacheQuery'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_params ship=' + (if $ship? then $ship.idcode else 'null') + ' homeSector=' + (if $homeSector? then 'valid' else 'null')"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
          <!-- Work item is already in ActiveWork, not in WorkQueue, so lookup by key would fail -->
          <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
            <param name="key" value="$workItem.$Key"/>
            <param name="newState" value="'failed'"/>
            <param name="traceId" value="$traceId"/>
            <param name="reason" value="'invalid_params'"/>
            <param name="workItem" value="$workItem"/>
          </run_actions>
          <!-- CRITICAL FIX: Release lock and signal AI (terminal failure routine) -->
          <do_if value="$ship? and $ship.exists">
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'invalid_params'"/>
            </run_actions>
            <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'busy'"/>
          </do_if>
          <!-- Remove from ActiveWork using ship key -->
          <do_if value="$ship?">
            <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Execute cache query -->
        <set_value name="$startTime" exact="player.age"/>
        <run_actions ref="md.GT_Libraries_General.GT_TS_CachePickBest" result="$cacheResult">
          <param name="ship" value="$ship"/>
          <param name="homeSector" value="$homeSector"/>
          <param name="maxDistance" value="$maxDistance"/>
          <param name="minROI" value="$minROI"/>
          <param name="minAbsoluteProfit" value="$minAbsoluteProfit"/>
          <param name="ignoreBuildStorage" value="$ignoreBuildStorage"/>
          <param name="ignoreCarrierAux" value="$ignoreCarrierAux"/>
          <param name="traceId" value="$traceId"/>
        </run_actions>
        <set_value name="$duration" exact="player.age - $startTime"/>
        
        <!-- Store result in payload for continuation -->
        <set_value name="$workItem.$Payload.$Result" exact="$cacheResult"/>
        
        <!-- NOTE: Work item is already in ActiveWork (added by ProcessWorkQueue before signaling this cue) -->
        <!-- No need to check or re-add it here - ProcessWorkQueue ensures ActiveWork is a table -->
        
        <!-- Log cache query result -->
        <set_value name="$resultAction" exact="if $cacheResult? and $cacheResult.$Found then 'Hit' else 'Miss'"/>
        <set_value name="$resultDetails" exact="'trades=' + (if $cacheResult? and $cacheResult.$Trades? then $cacheResult.$Trades.count else 0) + ' score=' + (if $cacheResult? and $cacheResult.$BestScore? then $cacheResult.$BestScore else 0) + ' duration=' + ($duration / 1ms) + 'ms'"/>
        
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$traceId"/>
          <param name="stage" value="'CacheQuery'"/>
          <param name="action" value="$resultAction"/>
          <param name="details" value="$resultDetails"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <!-- Mark work item as completed -->
        <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
          <param name="key" value="$workItem.$Key"/>
          <param name="newState" value="'completed'"/>
          <param name="traceId" value="$traceId"/>
          <param name="workItem" value="$workItem"/>
        </run_actions>
        
        <!-- Remove from ActiveWork using ship key -->
        <do_if value="$ship?">
          <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
        </do_if>
        
        <!-- NOTE: Do NOT signal ProcessWorkQueue here - it causes multiple concurrent instances and stutter -->
        <!-- ProcessWorkQueue processes up to $maxItemsPerTick items per tick, then signals itself at the end -->
        <!-- This allows proper frame distribution and prevents tight loops -->
        
        <!-- Signal continuation handler if provided -->
        <!-- CRITICAL: X4 doesn't support variable cue names in cue attribute - must use explicit cue reference -->
        <set_value name="$continuationHandled" exact="false"/>
        <do_if value="$payload.$ContinuationCue?">
          <set_value name="$continuationCueName" exact="$payload.$ContinuationCue"/>
          <!-- Check for known continuation cues and signal appropriately -->
          <do_if value="$continuationCueName == 'md.GT_TradeSearch_Scheduler.SearchTradeRoutes_CacheContinuation'">
            <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.SearchTradeRoutes_CacheContinuation" param="$workItem"/>
            <set_value name="$continuationHandled" exact="true"/>
          </do_if>
          <do_else>
            <!-- Unknown continuation cue - log error and fall back to default -->
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=unknown_continuation_cue cue=' + $continuationCueName + ' - falling back to default'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_else>
        </do_if>
        
        <!-- CRITICAL FIX: If continuation cue was not handled (missing or unknown), use default continuation -->
        <!-- This ensures SearchTradeRoutes always resumes, preventing ships from waiting indefinitely -->
        <do_if value="not $continuationHandled">
          <!-- Default continuation: queue SearchTradeRoutes continuation with cache results -->
          <!-- ROOT CAUSE FIX: Use EnqueueSearchTradeRoutes instead of signal_cue_instantly -->
          <!-- This prevents 10+ concurrent SearchTradeRoutes instances in same frame (causing stutter) -->
          <!-- EnqueueSearchTradeRoutes has 0-30ms jitter delay and proper pacing -->
          <!-- CRITICAL FIX: Extract cacheResult from workItem payload (it was stored there at line 797) -->
          <set_value name="$extractedCacheResult" exact="@$workItem.$Payload.$Result"/>
          <do_if value="$payload.$ResumeParams?">
            <set_value name="$resumeParams" exact="$payload.$ResumeParams"/>
            <set_value name="$resumeParams.$CacheContinuation" exact="true"/>
            <set_value name="$resumeParams.$CacheResult" exact="$extractedCacheResult"/>
            <!-- ROOT CAUSE FIX: Keep SearchState as 'fresh' so cache result extraction logic runs -->
            <!-- CacheContinuation flag ensures SearchTradeRoutes proceeds past cache check gate -->
            <!-- Setting to 'cache' causes cache extraction block to be skipped (line 814 requires 'fresh') -->
            <set_value name="$resumeParams.$SearchState" exact="'fresh'"/>
            <!-- CRITICAL FIX: Signal SearchTradeRoutes directly instead of EnqueueSearchTradeRoutes -->
            <!-- EnqueueSearchTradeRoutes routes through scheduler again, creating another CacheQuery work item -->
            <!-- We already have cache results, so call SearchTradeRoutes directly to process them -->
            <signal_cue_instantly cue="md.GT_Trading_Search.SearchTradeRoutes" param="$resumeParams"/>
          </do_if>
          <do_else>
            <!-- CRITICAL: No continuation params - signal ship with 'busy' to trigger retry -->
            <!-- Extract ship from payload to signal -->
            <set_value name="$resumeShip" exact="@$payload.$Ship"/>
            <do_if value="$resumeShip? and $resumeShip.exists">
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="$traceId"/>
                <param name="stage" value="'Scheduler'"/>
                <param name="action" value="'Error'"/>
                <param name="details" value="'reason=missing_continuation_params ship=' + $resumeShip.idcode + ' - signaling busy retry'"/>
                <param name="logLevel" value="0"/>
              </run_actions>
              <!-- Release lock and signal busy -->
              <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                <param name="ship" value="$resumeShip"/>
                <param name="reason" value="'missing_continuation_params'"/>
              </run_actions>
              <signal_objects object="$resumeShip" param="'GT_No_Trade_Found'" param2="'busy'"/>
            </do_if>
          </do_else>
        </do_if>
      </actions>
    </cue>
    
    <!-- Process HomeSearch Work Item -->
    <!-- Handles home sector pathfinding and sector collection for live searches -->
    <cue name="ProcessHomeSearchWork" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$workItem" exact="event.param"/>
        
        <!-- Validate work item - ERROR if missing -->
        <do_if value="not $workItem? or not $workItem.$Payload?">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="if $workItem? and $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
            <param name="stage" value="'Scheduler'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_homesearch_workitem key=' + (if $workItem? and $workItem.$Key? then $workItem.$Key else 'unknown')"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- Extract ship from payload for ActiveWork key -->
          <set_value name="$payload" exact="$workItem.$Payload"/>
          <set_value name="$workShip" exact="@$payload.$Ship"/>
          <do_if value="$workItem? and $workItem.$Key?">
            <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="$workItem.$Key"/>
              <param name="newState" value="'failed'"/>
              <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
              <param name="reason" value="'invalid_payload'"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            <!-- Remove from ActiveWork using ship key -->
            <do_if value="$workShip?">
              <remove_value name="global.$GT_Scheduler.$ActiveWork.{$workShip}"/>
            </do_if>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <set_value name="$payload" exact="$workItem.$Payload"/>
        <set_value name="$ship" exact="@$payload.$Ship"/>
        <set_value name="$traceId" exact="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
        
        <!-- Validate required parameters - ERROR if missing -->
        <do_if value="not $ship? or not $ship.exists">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'HomeSearch'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_ship'"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
          <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
            <param name="key" value="$workItem.$Key"/>
            <param name="newState" value="'failed'"/>
            <param name="traceId" value="$traceId"/>
            <param name="reason" value="'invalid_ship'"/>
            <param name="workItem" value="$workItem"/>
          </run_actions>
          <!-- Remove from ActiveWork using ship key -->
          <do_if value="$ship?">
            <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Execute home search by signaling SearchLiveTrades -->
        <!-- This is async - SearchLiveTrades will handle pathfinding and sector collection -->
        <set_value name="$startTime" exact="player.age"/>
        
        <!-- Build params table for SearchLiveTrades -->
        <set_value name="$searchParams" exact="table[]"/>
        <do_if value="$payload.$Ship?">
          <set_value name="$searchParams.$Ship" exact="$payload.$Ship"/>
        </do_if>
        <do_if value="$payload.$MaxDistance?">
          <set_value name="$searchParams.$MaxDistance" exact="$payload.$MaxDistance"/>
        </do_if>
        <do_if value="$payload.$OriginalMaxDistance?">
          <set_value name="$searchParams.$OriginalMaxDistance" exact="$payload.$OriginalMaxDistance"/>
        </do_if>
        <do_if value="$payload.$PilotSkillMaxDistance?">
          <set_value name="$searchParams.$PilotSkillMaxDistance" exact="$payload.$PilotSkillMaxDistance"/>
        </do_if>
        <do_if value="$payload.$MinROI?">
          <set_value name="$searchParams.$MinROI" exact="$payload.$MinROI"/>
        </do_if>
        <do_if value="$payload.$MinAbsoluteProfit?">
          <set_value name="$searchParams.$MinAbsoluteProfit" exact="$payload.$MinAbsoluteProfit"/>
        </do_if>
        <do_if value="$payload.$FactionPriority?">
          <set_value name="$searchParams.$FactionPriority" exact="$payload.$FactionPriority"/>
        </do_if>
        <do_if value="$payload.$FactionPriorityText?">
          <set_value name="$searchParams.$FactionPriorityText" exact="$payload.$FactionPriorityText"/>
        </do_if>
        <do_if value="$payload.$DistancePenaltyMultiplier?">
          <set_value name="$searchParams.$DistancePenaltyMultiplier" exact="$payload.$DistancePenaltyMultiplier"/>
        </do_if>
        <do_if value="$payload.$SkillLevel?">
          <set_value name="$searchParams.$SkillLevel" exact="$payload.$SkillLevel"/>
        </do_if>
        <do_if value="$payload.$ThreatIntel?">
          <set_value name="$searchParams.$ThreatIntel" exact="$payload.$ThreatIntel"/>
        </do_if>
        <do_if value="$payload.$FleetCoord?">
          <set_value name="$searchParams.$FleetCoord" exact="$payload.$FleetCoord"/>
        </do_if>
        <do_if value="$payload.$AdvancedAnalytics?">
          <set_value name="$searchParams.$AdvancedAnalytics" exact="$payload.$AdvancedAnalytics"/>
        </do_if>
        <do_if value="$payload.$TraceId?">
          <set_value name="$searchParams.$TraceId" exact="$payload.$TraceId"/>
        </do_if>
        <do_else>
          <set_value name="$searchParams.$TraceId" exact="$traceId"/>
        </do_else>
        
        <!-- Store work item reference in state for continuation -->
        <do_if value="not global.$GT_SearchLiveTrades_State?">
          <set_value name="global.$GT_SearchLiveTrades_State" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_SearchLiveTrades_State.{$ship}?">
          <set_value name="global.$GT_SearchLiveTrades_State.{$ship}" exact="table[]"/>
        </do_if>
        <!-- Store WorkItemKey (for logging) and WorkItemShip (for ActiveWork lookup) -->
        <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$WorkItemKey" exact="$workItem.$Key"/>
        <set_value name="global.$GT_SearchLiveTrades_State.{$ship}.$WorkItemShip" exact="$ship"/>
        
        <!-- Signal SearchLiveTrades (async operation) -->
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$traceId"/>
          <param name="stage" value="'HomeSearch'"/>
          <param name="action" value="'Start'"/>
          <param name="details" value="'ship=' + $ship.idcode + ' maxDistance=' + (if $searchParams.$MaxDistance? then $searchParams.$MaxDistance else 'unknown')"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="$searchParams"/>
        
        <!-- Note: Work item remains active until SearchLiveTrades completes -->
        <!-- Completion will be handled by SearchLiveTrades_Resume or error handler -->
      </actions>
    </cue>
    
    <!-- Process Match Work Item -->
    <!-- Handles batch trade matching work -->
    <cue name="ProcessMatchWork" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$workItem" exact="event.param"/>
        
        <!-- Validate work item - ERROR if missing -->
        <do_if value="not $workItem? or not $workItem.$Payload?">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="if $workItem? and $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
            <param name="stage" value="'Scheduler'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_match_workitem key=' + (if $workItem? and $workItem.$Key? then $workItem.$Key else 'unknown')"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- Extract ship from payload for ActiveWork key -->
          <set_value name="$payload" exact="$workItem.$Payload"/>
          <set_value name="$workShip" exact="@$payload.$Ship"/>
          <do_if value="$workItem? and $workItem.$Key?">
            <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="$workItem.$Key"/>
              <param name="newState" value="'failed'"/>
              <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
              <param name="reason" value="'invalid_payload'"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            <!-- Remove from ActiveWork using ship key -->
            <do_if value="$workShip?">
              <remove_value name="global.$GT_Scheduler.$ActiveWork.{$workShip}"/>
            </do_if>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <set_value name="$payload" exact="$workItem.$Payload"/>
        <set_value name="$ship" exact="@$payload.$Ship"/>
        <set_value name="$traceId" exact="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
        
        <!-- Validate required parameters - ERROR if missing -->
        <do_if value="not $ship? or not $ship.exists">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'Match'"/>
            <param name="action" value="'Error'"/>
            <param name="details" value="'reason=invalid_ship'"/>
            <param name="logLevel" value="0"/>
          </run_actions>
          <!-- CRITICAL FIX: Pass workItem parameter so GT_UpdateWorkItemState doesn't need to look it up -->
          <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
            <param name="key" value="$workItem.$Key"/>
            <param name="newState" value="'failed'"/>
            <param name="traceId" value="$traceId"/>
            <param name="reason" value="'invalid_ship'"/>
            <param name="workItem" value="$workItem"/>
          </run_actions>
          <!-- Remove from ActiveWork using ship key -->
          <do_if value="$ship?">
            <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Execute batch matching by signaling ProcessTradeMatchingBatch -->
        <!-- This is async - ProcessTradeMatchingBatch will handle chunked processing -->
        <set_value name="$startTime" exact="player.age"/>
        
        <!-- Store work item reference in batch state for continuation -->
        <do_if value="not global.$GT_BatchDataList?">
          <set_value name="global.$GT_BatchDataList" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_BatchDataList.{$ship}?">
          <set_value name="global.$GT_BatchDataList.{$ship}" exact="table[]"/>
        </do_if>
        <!-- Store WorkItemKey (for logging) and WorkItemShip (for ActiveWork lookup) -->
        <set_value name="global.$GT_BatchDataList.{$ship}.$WorkItemKey" exact="$workItem.$Key"/>
        <set_value name="global.$GT_BatchDataList.{$ship}.$WorkItemShip" exact="$ship"/>
        
        <!-- Signal ProcessTradeMatchingBatch (async operation) -->
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$traceId"/>
          <param name="stage" value="'Match'"/>
          <param name="action" value="'Start'"/>
          <param name="details" value="'ship=' + $ship.idcode + ' wares=' + (if $payload.$WareCount? then $payload.$WareCount else 'unknown')"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessTradeMatchingBatch" param="$ship"/>
        
        <!-- Note: Work item remains active until ProcessTradeMatchingBatch completes -->
        <!-- Completion will be handled by batch processor completion handler -->
      </actions>
    </cue>
    
    <!-- Delayed Work Queue Processor (Frame Distribution) -->
    <!-- Purpose: Ensures ProcessWorkQueue is called with frame delay to prevent tight loops -->
    <cue name="ProcessWorkQueueDelayed" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <!-- ROOT CAUSE FIX: Increase delay to reduce stutter with large fleets -->
      <!-- 1ms was too short - multiple ProcessWorkQueue instances could run in same frame -->
      <!-- 5ms ensures proper frame distribution and prevents tight loops -->
      <delay exact="5ms"/>
      <actions>
        <!-- Signal ProcessWorkQueue with frame delay -->
        <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessWorkQueue"/>
      </actions>
    </cue>
  </cues>
</mdscript>
