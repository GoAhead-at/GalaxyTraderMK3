<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Trading_Batch_Processor" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ===================================================================== -->
    <!-- Continuation Scheduler (de-dupe) -->
    <!-- ===================================================================== -->
    <!-- Problem: Under load, multiple batch continuations can get signalled for the SAME ship in the same time window.
         Because continuation batches don't increment ActiveProcessors, they can overlap and overwrite state, causing the
         batch to re-process the same chunks/ware repeatedly and never reach the "Complete" branch (=> no tradeorders).
         Fix: route ALL continuations through a tiny scheduler that de-dupes per ship and introduces a tiny delay. -->
    <cue name="ScheduleBatchContinuation" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <delay exact="1ms"/>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        <!-- Clear scheduled marker -->
        <do_if value="not global.$GT_BatchContinuationScheduled?">
          <set_value name="global.$GT_BatchContinuationScheduled" exact="table[]"/>
        </do_if>
        <remove_value name="global.$GT_BatchContinuationScheduled.{$ship}"/>
        
        <!-- Only continue if batch state still exists -->
        <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
          <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessTradeMatchingBatch" param="$ship"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- Reset transient batch-processing state on game load.
         Batch jobs are not safe to resume across save/load, and stale counters can block all trade matching. -->
    <cue name="Init" instantiate="true">
      <conditions>
        <check_any>
          <event_game_loaded/>
          <event_player_created/>
        </check_any>
      </conditions>
      <actions>
        <!-- Ensure data structures exist and are clean -->
        <set_value name="global.$GT_BatchDataList" exact="table[]"/>
        <set_value name="global.$GT_BatchResultsList" exact="table[]"/>
        <set_value name="global.$GT_BatchDataListMigrated" exact="true"/>

        <!-- Initialize batch processor queue with correct concurrency -->
        <set_value name="$maxConcurrentFromSettings" exact="1"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
        </do_if>
        <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
          <!-- Backwards compatibility -->
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
        </do_elseif>
        <do_if value="$maxConcurrentFromSettings lt 1">
          <set_value name="$maxConcurrentFromSettings" exact="1"/>
        </do_if>
        <do_if value="$maxConcurrentFromSettings gt 10">
          <set_value name="$maxConcurrentFromSettings" exact="10"/>
        </do_if>

        <set_value name="global.$GT_BatchProcessorQueue" exact="table[
          $ActiveProcessors = 0,
          $MaxConcurrent = $maxConcurrentFromSettings,
          $ActiveShips = [],
          $Ships = []
        ]"/>
      </actions>
    </cue>

    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    <!-- BATCHED TRADE MATCHING PROCESSOR -->
    <!-- Pattern inspired by TaterTrader's tick-based cooperative multitasking -->
    <!-- Adapted for MD scripts: processes trades in batches with delays between -->
    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    
    <cue name="ProcessTradeMatchingBatch" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- CRITICAL PERFORMANCE FIX: Check concurrency BEFORE delay to prevent race conditions -->
        <!-- Retrieve ship object from signal (used as table key) -->
        <set_value name="$ship" exact="event.param"/>
        
        <!-- OPTIMIZATION: Initialize batch processor queue structure in one block -->
        <do_if value="not global.$GT_BatchProcessorQueue?">
          <!-- Read MaxConcurrent from global settings (defaults to 1 if not set) -->
          <set_value name="$maxConcurrentFromSettings" exact="1"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
          </do_if>
          <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
            <!-- Backwards compatibility -->
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
            <!-- Validate range (1-10) -->
            <do_if value="$maxConcurrentFromSettings lt 1">
              <set_value name="$maxConcurrentFromSettings" exact="1"/>
            </do_if>
            <do_if value="$maxConcurrentFromSettings gt 10">
              <set_value name="$maxConcurrentFromSettings" exact="10"/>
            </do_if>
          </do_elseif>
          <set_value name="global.$GT_BatchProcessorQueue" exact="table[
            $ActiveProcessors = 0,
            $MaxConcurrent = $maxConcurrentFromSettings,
            $ActiveShips = [],
            $Ships = []
          ]"/>
        </do_if>
        <!-- Ensure all required properties exist (defensive programming for save game compatibility) -->
        <do_if value="not global.$GT_BatchProcessorQueue.$ActiveProcessors?">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="0"/>
        </do_if>
        <do_if value="not global.$GT_BatchProcessorQueue.$MaxConcurrent?">
          <!-- Read MaxConcurrent from global settings (defaults to 1 if not set) -->
          <set_value name="$maxConcurrentFromSettings" exact="1"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
          </do_if>
          <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
            <!-- Backwards compatibility -->
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
            <!-- Validate range (1-10) -->
            <do_if value="$maxConcurrentFromSettings lt 1">
              <set_value name="$maxConcurrentFromSettings" exact="1"/>
            </do_if>
            <do_if value="$maxConcurrentFromSettings gt 10">
              <set_value name="$maxConcurrentFromSettings" exact="10"/>
            </do_if>
          </do_elseif>
          <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
        </do_if>
        <!-- Update MaxConcurrent from global settings if it exists (allows runtime changes) -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
          <!-- Validate range (1-10) -->
          <do_if value="$maxConcurrentFromSettings lt 1">
            <set_value name="$maxConcurrentFromSettings" exact="1"/>
          </do_if>
          <do_if value="$maxConcurrentFromSettings gt 10">
            <set_value name="$maxConcurrentFromSettings" exact="10"/>
          </do_if>
          <!-- Update if different from current value -->
          <do_if value="global.$GT_BatchProcessorQueue.$MaxConcurrent != $maxConcurrentFromSettings">
            <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
          </do_if>
        </do_if>
        <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
          <!-- Backwards compatibility -->
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
          <!-- Validate range (1-10) -->
          <do_if value="$maxConcurrentFromSettings lt 1">
            <set_value name="$maxConcurrentFromSettings" exact="1"/>
          </do_if>
          <do_if value="$maxConcurrentFromSettings gt 10">
            <set_value name="$maxConcurrentFromSettings" exact="10"/>
          </do_if>
          <!-- Update if different from current value -->
          <do_if value="global.$GT_BatchProcessorQueue.$MaxConcurrent != $maxConcurrentFromSettings">
            <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
          </do_if>
        </do_elseif>
        <do_if value="not global.$GT_BatchProcessorQueue.$ActiveShips?">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="[]"/>
        </do_if>
        <do_if value="not global.$GT_BatchProcessorQueue.$Ships?">
          <set_value name="global.$GT_BatchProcessorQueue.$Ships" exact="[]"/>
        </do_if>
        
        <!-- OPTIMIZATION: Check if this is a continuation batch (same ship) -->
        <!-- Since continuation batches are now queued, they'll arrive through the queue processor -->
        <!-- This check is mainly for tracking/debugging purposes -->
        <!-- Control flow: MD <cancel_cue/> does NOT stop the current actions block. -->
        <!-- Use an explicit flag to prevent fallthrough into state validation / ActiveProcessors increment. -->
        <set_value name="$shouldProceed" exact="true"/>
        <set_value name="$isContinuation" exact="false"/>
        <set_value name="$hasActiveProcessor" exact="false"/>
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips? and global.$GT_BatchProcessorQueue.$ActiveShips.count gt 0">
          <!-- Check if this ship already has an active processor -->
          <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$i">
            <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips.{$i} == $ship">
              <set_value name="$hasActiveProcessor" exact="true"/>
              <set_value name="$isContinuation" exact="true"/>
              <break/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- CRITICAL FIX: Check concurrency for ALL batches -->
        <!-- With MaxConcurrent=1, only ONE batch processor should run at a time -->
        <!-- Continuation batches for the same ship can proceed immediately if their ship is already active -->
        <!-- New batches must respect the concurrency limit -->
        <set_value name="$shouldQueue" exact="false"/>
        <do_if value="$isContinuation">
          <!-- Continuation batch: Only queue if ship is NOT in ActiveShips (shouldn't happen, but defensive) -->
          <do_if value="not $hasActiveProcessor">
            <!-- Ship not in ActiveShips - not a real continuation, queue it -->
            <set_value name="$shouldQueue" exact="true"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Continuation batch but ship not in ActiveShips - queuing (active: ' + global.$GT_BatchProcessorQueue.$ActiveProcessors + '/' + global.$GT_BatchProcessorQueue.$MaxConcurrent + ')'" chance="100"/>
            </do_if>
          </do_if>
          <!-- Otherwise, continuation batch proceeds immediately (doesn't increment ActiveProcessors) -->
        </do_if>
        <do_else>
          <!-- New batch: Check overall concurrency limit -->
          <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors ge global.$GT_BatchProcessorQueue.$MaxConcurrent">
            <set_value name="$shouldQueue" exact="true"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') New batch - max concurrent reached (' + global.$GT_BatchProcessorQueue.$ActiveProcessors + '/' + global.$GT_BatchProcessorQueue.$MaxConcurrent + ') - queuing'" chance="100"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- Queue request if needed -->
        <do_if value="$shouldQueue">
          <set_value name="$shouldProceed" exact="false"/>
          <do_if value="not global.$GT_BatchProcessorQueue.$Ships?">
            <set_value name="global.$GT_BatchProcessorQueue.$Ships" exact="[]"/>
          </do_if>
          <set_value name="$alreadyInQueue" exact="false"/>
          <do_if value="global.$GT_BatchProcessorQueue.$Ships?">
            <do_all exact="global.$GT_BatchProcessorQueue.$Ships.count" counter="$i">
              <do_if value="global.$GT_BatchProcessorQueue.$Ships.{$i} == $ship">
                <set_value name="$alreadyInQueue" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="not $alreadyInQueue">
            <append_to_list name="global.$GT_BatchProcessorQueue.$Ships" exact="$ship"/>
            <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>

        <do_if value="$shouldProceed">
          <!-- CRITICAL FIX: Check GT order status BEFORE processing -->
          <!-- If ship no longer has GT order, cancel immediately to prevent blocking queue -->
          <run_actions ref="md.GT_Ship_State_Utilities.GT_IsGTControlled" result="$hasGTOrder">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- CRITICAL FIX: Check if ship is in maintenance BEFORE processing -->
          <!-- Ships in maintenance shouldn't process batch data (waste CPU, blocks queue) -->
          <run_actions ref="md.GT_Ship_State_Utilities.GT_IsShipInMaintenance" result="$isInMaintenance">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Cancel if ship no longer has GT order OR is in maintenance -->
          <do_if value="not $hasGTOrder or $isInMaintenance">
            <set_value name="$shouldProceed" exact="false"/>
            <!-- CRITICAL FIX: Check if ship is in ActiveShips BEFORE removing -->
            <!-- If ship is in ActiveShips, it means ActiveProcessors was incremented -->
            <!-- We MUST decrement ActiveProcessors when removing from ActiveShips -->
            <set_value name="$wasInActiveShips" exact="false"/>
            <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveShips?">
              <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$i">
                <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips.{$i} == $ship">
                  <set_value name="$wasInActiveShips" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Remove ship from active ships list FIRST -->
            <do_if value="$wasInActiveShips and global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveShips?">
              <remove_from_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
            </do_if>
            
            <!-- CRITICAL FIX: Decrement ActiveProcessors if ship was in ActiveShips -->
            <do_if value="$wasInActiveShips and global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0">
              <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="subtract"/>
            </do_if>
            
            <!-- Process next queued batch processor if any -->
            <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
            </do_if>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$cancelReason" exact="if not $hasGTOrder then 'no GT order' else 'in maintenance'"/>
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Cancelling batch processor - ' + $cancelReason + ' (wasInActiveShips: ' + $wasInActiveShips + ', ActiveProcessors: ' + (if global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? then global.$GT_BatchProcessorQueue.$ActiveProcessors else 0) + ')'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
        </do_if>

        <do_if value="$shouldProceed">
          <!-- Early validation: Check if batch data exists BEFORE delay -->
          <!-- Retrieve state from GLOBAL TABLE using ship object as key (persists after SearchLiveTrades ends) -->
          <set_value name="$state" exact="@global.$GT_BatchDataList.{$ship}"/>
          
          <!-- Check if state exists and has expected batch fields -->
          <set_value name="$stateValid" exact="false"/>
          <set_value name="$stateBatchIdTest" exact="null"/>
          <do_if value="$state">
            <set_value name="$stateBatchIdTest" exact="@$state.$batchId"/>
            <do_if value="$stateBatchIdTest?">
              <set_value name="$stateValid" exact="true"/>
            </do_if>
          </do_if>
          <do_if value="not $stateValid">
            <set_value name="$shouldProceed" exact="false"/>
            <!-- Ship was never added to ActiveShips at this point, so no decrement needed -->
            <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
            </do_if>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] Batch state not found/invalid for ship ' + $ship.idcode + ' - cancelling (state: ' + $state + ', batchId: ' + $stateBatchIdTest + ')'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
        </do_if>

        <do_if value="$shouldProceed">
          <!-- Store $ship and $state in this.* so they persist across delay -->
          <set_value name="this.$ship" exact="$ship"/>
          <set_value name="this.$state" exact="$state"/>
          
          <!-- Increment active processors counter and track active ship (only if proceeding) -->
          <do_if value="not $isContinuation">
            <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="add"/>
            <do_if value="not global.$GT_BatchProcessorQueue.$ActiveShips?">
              <set_value name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="[]"/>
            </do_if>
            <append_to_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') BATCH PROCESSOR STARTING (active: ' + global.$GT_BatchProcessorQueue.$ActiveProcessors + '/' + global.$GT_BatchProcessorQueue.$MaxConcurrent + ', queued: ' + (if global.$GT_BatchProcessorQueue.$Ships? then global.$GT_BatchProcessorQueue.$Ships.count else 0) + ')'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Calculate delay from global Performance settings -->
          <set_value name="$batchDelay" exact="50"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay?">
            <set_value name="$batchDelay" exact="@global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay"/>
          </do_if>
          <set_value name="$batchDelayJitter" min="0" max="20"/>
          <set_value name="this.$batchDelayTime" exact="($batchDelay + $batchDelayJitter) * 1ms"/>
        </do_if>
      </actions>
      <delay exact="this.$batchDelayTime"/>
      <actions>
        <!-- All validation passed - proceed with batch processing -->
        <!-- CRITICAL FIX: Restore $ship and $state from this.* (they don't persist across delay) -->
        <set_value name="$ship" exact="this.$ship"/>
        <set_value name="$state" exact="this.$state"/>

        <!-- Control flow: MD <cancel_cue/> does NOT stop the current actions block. -->
        <!-- Use an explicit flag to prevent "fallthrough" after scheduling chunk continuations. -->
        <set_value name="$scheduledChunkContinuation" exact="false"/>
        
        <!-- Extract all state variables (use safe operator @ for all extractions) -->
        <set_value name="$batchId" exact="@$state.$batchId"/>
        <set_value name="$waitingCue" exact="@$state.$waitingCue"/>
        <!-- Note: $ship already set from event.param above -->
        <!-- No blacklistgroup - blacklist filtering happens at retrieval -->
        <set_value name="$wareKeysList" exact="@$state.$wareKeysList"/>
        <set_value name="$sellOffersList" exact="@$state.$sellOffersList"/>
        <set_value name="$buyOffersList" exact="@$state.$buyOffersList"/>
        
        <!-- DEBUG: Verify lists were received correctly -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$keysCount" exact="0"/>
          <set_value name="$sellCount" exact="0"/>
          <set_value name="$buyCount" exact="0"/>
          <do_if value="$wareKeysList?">
            <set_value name="$keysCountTemp" exact="@$wareKeysList.count"/>
            <do_if value="$keysCountTemp?">
              <set_value name="$keysCount" exact="$keysCountTemp"/>
            </do_if>
          </do_if>
          <do_if value="$sellOffersList?">
            <set_value name="$sellCountTemp" exact="@$sellOffersList.count"/>
            <do_if value="$sellCountTemp?">
              <set_value name="$sellCount" exact="$sellCountTemp"/>
            </do_if>
          </do_if>
          <do_if value="$buyOffersList?">
            <set_value name="$buyCountTemp" exact="@$buyOffersList.count"/>
            <do_if value="$buyCountTemp?">
              <set_value name="$buyCount" exact="$buyCountTemp"/>
            </do_if>
          </do_if>
          <!-- Commented out to reduce log spam -->
          <!-- <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') Received state: keys=' + $keysCount + ', sellEntries=' + $sellCount + ', buyEntries=' + $buyCount" chance="100"/> -->
          <do_if value="not $wareKeysList?">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') WARNING wareKeysList is NULL!'" chance="100"/>
            </do_if>
          </do_if>
          <do_if value="$wareKeysList?">
            <set_value name="$wareKeysListCountTemp" exact="@$wareKeysList.count"/>
            <do_if value="$wareKeysListCountTemp? and $wareKeysListCountTemp == 0">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') WARNING wareKeysList is EMPTY count=0!'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Use safe operator @ for all property access to prevent null errors -->
        <set_value name="$stationDistanceCache" exact="@$state.$stationDistanceCache"/>
        <set_value name="$tradeList" exact="@$state.$tradeList"/>
        <set_value name="$crossStationBestScore" exact="@$state.$crossStationBestScore"/>
        <set_value name="$crossStationBestTrade" exact="@$state.$crossStationBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="@$state.$nonConflictedBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="@$state.$nonConflictedBestTrade"/>
        <set_value name="$reservedRoutes" exact="@$state.$reservedRoutes"/>
        <set_value name="$failedTrades" exact="@$state.$failedTrades"/>
        <!-- No escape sectors or current sector blacklist - removed for universal processing -->
        <set_value name="$currentWareIndex" exact="@$state.$currentWareIndex"/>
        <!-- Extract home sector for cache indexing -->
        <set_value name="$homeSector" exact="@$state.$homeSector"/>
        <!-- Use library function to validate table safely -->
        <set_value name="$existingTradesPerWare" exact="@$state.$tradesPerWare"/>
        <run_actions ref="md.GT_Libraries_General.GT_ValidateTableSafe" result="$tradesPerWare">
          <param name="table" value="$existingTradesPerWare"/>
        </run_actions>
        <!-- Use safe operator @ for all property access to prevent null errors -->
        <set_value name="$maxTradesPerWare" exact="@$state.$maxTradesPerWare"/>
        <set_value name="$batchSize" exact="@$state.$batchSize"/>
        <set_value name="$earlyExitThreshold" exact="@$state.$earlyExitThreshold"/>
        <set_value name="$maxDistance" exact="@$state.$maxDistance"/>
        <set_value name="$distancePenaltyMultiplier" exact="@$state.$distancePenaltyMultiplier"/>
        <set_value name="$factionPriority" exact="@$state.$factionPriority"/>
        <set_value name="$minROI" exact="@$state.$minROI"/>
        <set_value name="$minAbsoluteProfit" exact="@$state.$minAbsoluteProfit"/>
        <set_value name="$gt_AdvancedAnalytics" exact="@$state.$gt_AdvancedAnalytics"/>
        
        <!-- Log thresholds being used for this batch -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Batch thresholds: MinROI=' + $minROI + '%, MinAbsoluteProfit=' + ($minAbsoluteProfit/100) + ' Cr, MaxDistance=' + $maxDistance" chance="100"/>
          <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Profit threshold breakdown: Base=' + ($minAbsoluteProfit / 100) + ' Cr (raw: ' + $minAbsoluteProfit + ') | Intra-sector (50%): ' + (($minAbsoluteProfit / 2) / 100) + ' Cr | Isolated intra-sector (25%): ' + (($minAbsoluteProfit * 25 / 100) / 100) + ' Cr'" chance="100"/>
        </do_if>
        <!-- Use safe operator @ for all property access to prevent null errors -->
        <set_value name="$availableMoney" exact="@$state.$availableMoney"/>
        <set_value name="$tradesRejectedProfit" exact="@$state.$tradesRejectedProfit"/>
        <set_value name="$tradesRejectedDocking" exact="@$state.$tradesRejectedDocking"/>
        <set_value name="$tradesRejectedAmount" exact="@$state.$tradesRejectedAmount"/>
        <set_value name="$tradesRejectedDistance" exact="@$state.$tradesRejectedDistance"/>
        <!-- No tradesRejectedBlacklist - blacklist filtering happens at retrieval -->
        <set_value name="$bestRejectedProfit" exact="@$state.$bestRejectedProfit"/>
        <set_value name="$bestRejectedTrade" exact="@$state.$bestRejectedTrade"/>
        
        <!-- PERFORMANCE: Chunked processing - process offers in 5×5 chunks to reduce CPU load -->
        <!-- Initialize chunk tracking variables if not present -->
        <!-- Smaller chunks reduce per-frame CPU spikes when many ships are searching -->
        <set_value name="$chunkSize" exact="4"/> <!-- Process 4×4 = 16 combinations per chunk -->
        <set_value name="$sellOfferChunkStart" exact="0"/>
        <set_value name="$buyOfferChunkStart" exact="0"/>
        <set_value name="$currentWareChunkStart" exact="0"/>
        <do_if value="$state.$sellOfferChunkStart?">
          <set_value name="$sellOfferChunkStart" exact="@$state.$sellOfferChunkStart"/>
        </do_if>
        <do_if value="$state.$buyOfferChunkStart?">
          <set_value name="$buyOfferChunkStart" exact="@$state.$buyOfferChunkStart"/>
        </do_if>
        <do_if value="$state.$currentWareChunkStart?">
          <set_value name="$currentWareChunkStart" exact="@$state.$currentWareChunkStart"/>
        </do_if>
        
        <!-- No sector blacklist cache building - removed for universal processing -->
        <!-- Blacklist filtering happens per-ship during cache retrieval, not during cache building -->
        
        <!-- Check ONCE per ship BEFORE processing any wares -->
        <!-- This ensures Phase 2 (cross-sector trades) is skipped immediately if isolated -->
        <!-- Uses GT_CheckAndHandleIsolation library for maintainability -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
          <param name="ship" value="$ship"/>
          <param name="state" value="$state"/>
        </run_actions>
        <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
        <!-- Validate returned UpdatedState before overwriting $state -->
        <!-- If isolation function returns null UpdatedState, keep original $state -->
        <set_value name="$returnedState" exact="@$isolationResult.$UpdatedState"/>
        <set_value name="$returnedStateValid" exact="false"/>
        <do_if value="$returnedState?">
          <set_value name="$returnedStateKeysTest" exact="@$returnedState.keys"/>
          <do_if value="$returnedStateKeysTest?">
            <set_value name="$returnedStateCountTest" exact="@$returnedStateKeysTest.count"/>
            <do_if value="$returnedStateCountTest? and $returnedStateCountTest ge 0">
              <set_value name="$returnedStateValid" exact="true"/>
            </do_if>
          </do_if>
        </do_if>
        <do_if value="$returnedStateValid">
          <!-- Returned state is valid - use it -->
          <set_value name="$state" exact="$returnedState"/>
        </do_if>
        <do_else>
          <!-- Returned state is null or invalid - keep original $state (already validated above) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] Isolation function returned null/invalid UpdatedState for ship ' + $ship.idcode + ' - keeping original state'" chance="100"/>
          </do_if>
        </do_else>
        <set_value name="global.$GT_BatchDataList.{$ship}" exact="$state"/>
        
        <!-- Use global setting for max offers per ware for matching -->
        <set_value name="$maxOffersPerWareForMatching" exact="20"/> <!-- Default fallback (can be changed via global settings menu) -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxOffersPerWareForMatching?">
          <set_value name="$maxOffersPerWareForMatching" exact="global.$GT_GlobalSettings.$Performance.$MaxOffersPerWareForMatching"/>
        </do_if>
        
        <!-- Calculate batch boundaries using wareKeysList (list, not table) -->
        <set_value name="$wareCount" exact="0"/>
        <do_if value="$wareKeysList?">
          <set_value name="$wareCountTemp" exact="@$wareKeysList.count"/>
          <do_if value="$wareCountTemp?">
            <set_value name="$wareCount" exact="$wareCountTemp"/>
          </do_if>
        </do_if>
        
        <!-- CRITICAL: Lists are 1-based, so batchStart should be 1-based too -->
        <!-- $currentWareIndex is 0-based (starts at 0), convert to 1-based for list access -->
        <set_value name="$batchStart1Based" exact="$currentWareIndex + 1"/>
        <set_value name="$batchEnd1Based" exact="[$currentWareIndex + $batchSize + 1, $wareCount + 1].min"/>
        
        <!-- Commented out to reduce log spam -->
        <!-- <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Processing batch: list indices ' + $batchStart1Based + '-' + ($batchEnd1Based - 1) + ' of ' + $wareCount" chance="100"/>
        </do_if> -->
        
        <!-- Process this batch of wares -->
        <!-- NOTE: Lists in X4 are 1-based! $batchOffset starts at 1 -->
        <!-- batchStart1Based is already 1-based, so we just add offset-1 -->
        <do_if value="$batchStart1Based le $wareCount">
          <do_all exact="$batchEnd1Based - $batchStart1Based" counter="$batchOffset">
            <!-- $batchOffset starts at 1, batchStart1Based is 1-based -->
            <!-- For first item: batchStart1Based=1, batchOffset=1 wareIdx=1+1-1=1 ✓ -->
            <set_value name="$wareIdx" exact="$batchStart1Based + $batchOffset - 1"/>
            
            <!-- Early exit if we have enough trades -->
            <do_if value="$tradeList.count ge $earlyExitThreshold">
              <break/>
            </do_if>
            
            <!-- Get ware from list -->
            <set_value name="$ware" exact="$wareKeysList.{$wareIdx}"/>
            
            <!-- PERFORMANCE: Reset chunk positions when moving to a new ware -->
            <do_if value="$wareIdx != $currentWareChunkStart">
              <set_value name="$sellOfferChunkStart" exact="0"/>
              <set_value name="$buyOfferChunkStart" exact="0"/>
              <set_value name="$currentWareChunkStart" exact="$wareIdx"/>
            </do_if>
            
            <!-- ═══════════════════════════════════════════════════════════════════════════ -->
            <!-- WARE QUOTA CHECK: Skip this ware if we've already collected enough trades for it -->
            <!-- This ensures diversity by preventing one ware from monopolizing all trade slots -->
            <!-- ═══════════════════════════════════════════════════════════════════════════ -->
            <set_value name="$tradesForThisWare" exact="0"/>
            <!-- CRITICAL: Check if table is valid before accessing (prevents null errors) -->
            <set_value name="$tradesPerWareKeys" exact="@$tradesPerWare.keys"/>
            <do_if value="$tradesPerWareKeys? and $tradesPerWare.{$ware}?">
              <set_value name="$tradesForThisWare" exact="$tradesPerWare.{$ware}"/>
            </do_if>
            
            <!-- Skip to next ware if quota reached -->
            <do_if value="$tradesForThisWare ge $maxTradesPerWare">
              <!-- Reset chunk positions when skipping ware -->
              <set_value name="$sellOfferChunkStart" exact="0"/>
              <set_value name="$buyOfferChunkStart" exact="0"/>
              <set_value name="$currentWareChunkStart" exact="$wareIdx + 1"/>
              <continue/>
            </do_if>
            
            <!-- PERF: This line can execute on every chunk continuation. Only log once per ware (first chunk) and at low chance. -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $wareIdx lt 2 and $sellOfferChunkStart == 0 and $buyOfferChunkStart == 0">
              <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') Processing ware #' + $wareIdx + ': ' + (if $ware? then @$ware.name else 'NULL') + ' (quota: ' + $tradesForThisWare + '/' + $maxTradesPerWare + ')'" chance="10"/>
            </do_if>
            
            <!-- Find sell offers for this ware in list -->
            <set_value name="$sellOffersForWare" exact="[]"/>
            <do_if value="$sellOffersList?">
              <set_value name="$sellOffersListCount" exact="@$sellOffersList.count"/>
              <do_if value="$sellOffersListCount? and $sellOffersListCount gt 0">
                <do_all exact="$sellOffersListCount" counter="$i">
                  <set_value name="$entry" exact="$sellOffersList.{$i}"/>
                  <do_if value="$entry.$ware == $ware">
                    <set_value name="$sellOffersForWare" exact="$entry.$offers"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_if>
            </do_if>
            
            <!-- Find buy offers for this ware in list -->
            <set_value name="$buyOffersForWare" exact="[]"/>
            <do_if value="$buyOffersList?">
              <set_value name="$buyOffersListCount" exact="@$buyOffersList.count"/>
              <do_if value="$buyOffersListCount? and $buyOffersListCount gt 0">
                <do_all exact="$buyOffersListCount" counter="$i">
                  <set_value name="$entry" exact="$buyOffersList.{$i}"/>
                  <do_if value="$entry.$ware == $ware">
                    <set_value name="$buyOffersForWare" exact="$entry.$offers"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $wareIdx lt 2 and $sellOfferChunkStart == 0 and $buyOfferChunkStart == 0">
              <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') Found: ' + $sellOffersForWare.count + ' sell, ' + $buyOffersForWare.count + ' buy offers for ' + (if $ware? then @$ware.name else 'NULL')" chance="10"/>
            </do_if>
            
            <!-- Process this ware if both sell and buy offers exist -->
            <!-- LINE 194: Opens do_if - must be closed at line 998 -->
            <do_if value="$sellOffersForWare.count gt 0 and $buyOffersForWare.count gt 0">
              
              <!-- ═══════════════════════════════════════════════════════════════════════════ -->
              <!-- Limit offers BEFORE nested loops to reduce iterations -->
              <!-- Reduces from 50×100 = 5,000 to 20×20 = 400 iterations per ware (92% reduction) -->
              <!-- Use global setting for max offers per ware for matching -->
              <!-- ═══════════════════════════════════════════════════════════════════════════ -->
              <!-- Note: $maxOffersPerWareForMatching is set at the start of ProcessTradeMatchingBatch cue -->
              
              <!-- Store original offer lists BEFORE limiting (needed for intra-sector inclusion) -->
              <set_value name="$originalSellOffers" exact="$sellOffersForWare"/>
              <set_value name="$originalBuyOffers" exact="$buyOffersForWare"/>
              
              <!-- For isolated ships, filter offers to current sector ONLY -->
              <!-- Isolated ships can't reach other sectors, so only look at offers in current sector -->
              <set_value name="$currentSector" exact="$ship.sector"/>
              <do_if value="$shipIsIsolated and $currentSector?">
                <!-- Filter sell offers to current sector only -->
                <set_value name="$filteredSellOffers" exact="[]"/>
                <set_value name="$currentSectorName" exact="@$currentSector.knownname"/>
                <do_all exact="$sellOffersForWare.count" counter="$idx">
                  <set_value name="$offer" exact="$sellOffersForWare.{$idx}"/>
                  <set_value name="$offerSector" exact="@$offer.owner.sector"/>
                  <do_if value="$offerSector?">
                    <set_value name="$offerSectorName" exact="@$offerSector.knownname"/>
                    <do_if value="$offerSector == $currentSector">
                      <append_to_list name="$filteredSellOffers" exact="$offer"/>
                    </do_if>
                    <do_elseif value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $idx le 3">
                      <!-- Debug first 3 offers to verify sector comparison -->
                      <debug_text text="'[GT-Batch] (' + $ship.idcode + ') SELL OFFER #' + $idx + ': Offer sector=' + (if $offerSectorName? then $offerSectorName else 'NULL') + ', Current sector=' + (if $currentSectorName? then $currentSectorName else 'NULL') + ', Match=' + ($offerSector == $currentSector)" chance="100"/>
                    </do_elseif>
                  </do_if>
                </do_all>
                <set_value name="$sellOffersForWare" exact="$filteredSellOffers"/>
                
                <!-- Filter buy offers to current sector only -->
                <set_value name="$filteredBuyOffers" exact="[]"/>
                <do_all exact="$buyOffersForWare.count" counter="$idx">
                  <set_value name="$offer" exact="$buyOffersForWare.{$idx}"/>
                  <set_value name="$offerSector" exact="@$offer.owner.sector"/>
                  <do_if value="$offerSector?">
                    <set_value name="$offerSectorName" exact="@$offerSector.knownname"/>
                    <do_if value="$offerSector == $currentSector">
                      <append_to_list name="$filteredBuyOffers" exact="$offer"/>
                    </do_if>
                    <do_elseif value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $idx le 3">
                      <!-- Debug first 3 offers to verify sector comparison -->
                      <debug_text text="'[GT-Batch] (' + $ship.idcode + ') BUY OFFER #' + $idx + ': Offer sector=' + (if $offerSectorName? then $offerSectorName else 'NULL') + ', Current sector=' + (if $currentSectorName? then $currentSectorName else 'NULL') + ', Match=' + ($offerSector == $currentSector)" chance="100"/>
                    </do_elseif>
                  </do_if>
                </do_all>
                <set_value name="$buyOffersForWare" exact="$filteredBuyOffers"/>
                
                <!-- Debug log filtered counts -->
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                  <debug_text text="'[GT-Batch] (' + $ship.idcode + ') ISOLATED FILTER: ' + $wareName + ' in ' + (if $currentSectorName? then $currentSectorName else 'NULL') + ' - Filtered to ' + $sellOffersForWare.count + ' sell, ' + $buyOffersForWare.count + ' buy (current sector only)'" chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Limit sell offers BEFORE nested loop (take first N = cheapest = best buyers) -->
              <do_if value="$sellOffersForWare.count gt $maxOffersPerWareForMatching">
                <!-- Simple approach: Take first N offers (they're already ordered by relativeprice from batch) -->
                <set_value name="$limitedSellOffers" exact="[]"/>
                <do_all exact="$maxOffersPerWareForMatching" counter="$idx">
                  <append_to_list name="$limitedSellOffers" exact="$sellOffersForWare.{$idx}"/>
                </do_all>
                <set_value name="$sellOffersForWare" exact="$limitedSellOffers"/>
              </do_if>
              
              <!-- Limit buy offers BEFORE nested loop (take last N = highest payers = best profit) -->
              <do_if value="$buyOffersForWare.count gt $maxOffersPerWareForMatching">
                <!-- Take last N offers (highest payers = best profit) -->
                <set_value name="$limitedBuyOffers" exact="[]"/>
                <set_value name="$startIndex" exact="$buyOffersForWare.count - $maxOffersPerWareForMatching"/>
                <do_all exact="$maxOffersPerWareForMatching" counter="$idx">
                  <set_value name="$actualIndex" exact="$startIndex + $idx"/>
                  <append_to_list name="$limitedBuyOffers" exact="$buyOffersForWare.{$actualIndex}"/>
                </do_all>
                <set_value name="$buyOffersForWare" exact="$limitedBuyOffers"/>
              </do_if>
              
              <!-- Always include intra-sector offers for matching (even if not top-priced) -->
              <!-- Scenario: Ship in non-blacklisted sector, but all routes to other sectors blocked by blacklist -->
              <!-- Solution: Ensure intra-sector trades are always considered for matching -->
              <!-- Do NOT include intra-sector offers if ship is in blacklisted sector (escape priority) -->
              <!-- Note: $currentSector already set above for isolated filter -->
              <do_if value="not $currentSector?">
                <set_value name="$currentSector" exact="$ship.sector"/>
              </do_if>
              <set_value name="$currentSectorIsBlacklisted" exact="false"/>
              <do_if value="$currentSector?">
                <!-- Check if current sector is blacklisted (if yes, skip intra-sector offers to force escape) -->
                <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
                  <param name="ship" value="$ship"/>
                </run_actions>
                <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$currentSectorIsBlacklisted">
                  <param name="sector" value="$currentSector"/>
                  <param name="ship" value="$ship"/>
                  <param name="blacklistgroup" value="$blacklistgroup"/>
                </run_actions>
              </do_if>
              <!-- Use library function to add intra-sector offers -->
              <run_actions ref="md.GT_Libraries_General.GT_AddIntraSectorOffers" result="$intraSectorResult">
                <param name="originalSellOffers" value="$originalSellOffers"/>
                <param name="originalBuyOffers" value="$originalBuyOffers"/>
                <param name="limitedSellOffers" value="$sellOffersForWare"/>
                <param name="limitedBuyOffers" value="$buyOffersForWare"/>
                <param name="currentSector" value="$currentSector"/>
                <param name="currentSectorIsBlacklisted" value="$currentSectorIsBlacklisted"/>
              </run_actions>
              <set_value name="$sellOffersForWare" exact="$intraSectorResult.$UpdatedSellOffers"/>
              <set_value name="$buyOffersForWare" exact="$intraSectorResult.$UpdatedBuyOffers"/>
              
              <!-- DEBUG: Log if intra-sector offers were added -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and ($intraSectorResult.$AddedSellCount gt 0 or $intraSectorResult.$AddedBuyCount gt 0)">
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Added intra-sector offers for ' + (if $ware? then @$ware.name else 'NULL') + ' in ' + @$currentSector.knownname + ': ' + $intraSectorResult.$AddedSellCount + ' sell, ' + $intraSectorResult.$AddedBuyCount + ' buy (beyond top ' + $maxOffersPerWareForMatching + ')'" chance="100"/>
              </do_if>
              
              <!-- ═══════════════════════════════════════════════════════════════════════════ -->
              <!-- Pre-cache docking permissions BEFORE nested loops -->
              <!-- Reduces property lookups from 400,000+ to ~40-100 (99.98% reduction) -->
              <!-- ═══════════════════════════════════════════════════════════════════════════ -->
              <run_actions ref="md.GT_Libraries_General.GT_BuildDockingCache" result="$dockingCache">
                <param name="sellOffers" value="$sellOffersForWare"/>
                <param name="buyOffers" value="$buyOffersForWare"/>
                <param name="ship" value="$ship"/>
              </run_actions>
              
              <!-- Separate intra-sector offers for prioritized matching -->
              <!-- This ensures intra-sector offers match with each other to create true intra-sector trades -->
              <run_actions ref="md.GT_Libraries_General.GT_SeparateOffersBySector" result="$separatedOffers">
                <param name="sellOffers" value="$sellOffersForWare"/>
                <param name="buyOffers" value="$buyOffersForWare"/>
                <param name="currentSector" value="$currentSector"/>
              </run_actions>
              <set_value name="$intraSectorSellOffers" exact="$separatedOffers.$IntraSectorSell"/>
              <set_value name="$intraSectorBuyOffers" exact="$separatedOffers.$IntraSectorBuy"/>
              <set_value name="$crossSectorSellOffers" exact="$separatedOffers.$CrossSectorSell"/>
              <set_value name="$crossSectorBuyOffers" exact="$separatedOffers.$CrossSectorBuy"/>
              
              <!-- Log separation results for isolated ships -->
              <!-- PERF: This is high frequency under chunk continuations; reduce spam. -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $shipIsIsolated and $sellOfferChunkStart == 0 and $buyOfferChunkStart == 0">
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                <set_value name="$sectorName" exact="if $currentSector? then @$currentSector.knownname else 'NULL'"/>
                <debug_text text="'[GT-Batch-DEBUG] (' + $ship.idcode + ') SEPARATION for ' + $wareName + ' in ' + $sectorName + ': Total=' + $sellOffersForWare.count + ' sell, ' + $buyOffersForWare.count + ' buy | Intra=' + $intraSectorSellOffers.count + ' sell, ' + $intraSectorBuyOffers.count + ' buy | Cross=' + $crossSectorSellOffers.count + ' sell, ' + $crossSectorBuyOffers.count + ' buy'" chance="10"/>
              </do_if>
              
              <!-- NOW run nested loops: PRIORITIZE intra-sector matches first -->
              <!-- Phase 1: Match intra-sector sell offers with intra-sector buy offers (TRUE intra-sector trades) -->
              <!-- Log Phase 1 availability -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                <set_value name="$sectorName" exact="if $currentSector? then @$currentSector.knownname else 'NULL'"/>
                <set_value name="$isolationLabel" exact="if $shipIsIsolated then ' [ISOLATED]' else ''"/>
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Phase 1 (INTRA-SECTOR)' + $isolationLabel + ' for ' + $wareName + ' in ' + $sectorName + ': ' + $intraSectorSellOffers.count + ' sell, ' + $intraSectorBuyOffers.count + ' buy offers' + (if ($intraSectorSellOffers.count == 0 or $intraSectorBuyOffers.count == 0) then '  MISSING ONE TYPE!' else '')" chance="100"/>
              </do_if>
              <do_if value="$intraSectorSellOffers.count gt 0 and $intraSectorBuyOffers.count gt 0">
                <!-- PERFORMANCE: Process intra-sector offers in 5×5 chunks -->
                <set_value name="$intraSellChunkEnd" exact="[$sellOfferChunkStart + $chunkSize, $intraSectorSellOffers.count].min"/>
                <set_value name="$intraBuyChunkEnd" exact="[$buyOfferChunkStart + $chunkSize, $intraSectorBuyOffers.count].min"/>
                
                <do_all exact="$intraSellChunkEnd - $sellOfferChunkStart" counter="$chunkOffset">
                  <set_value name="$i" exact="$sellOfferChunkStart + $chunkOffset"/>
                  <set_value name="$sellOffer" exact="$intraSectorSellOffers.{$i}"/>
                
                <do_all exact="$intraBuyChunkEnd - $buyOfferChunkStart" counter="$chunkOffset2">
                  <set_value name="$j" exact="$buyOfferChunkStart + $chunkOffset2"/>
                  <set_value name="$buyOffer" exact="$intraSectorBuyOffers.{$j}"/>
                  
                  <!-- OPTIMIZATION: Use library function to validate offer pair -->
                  <run_actions ref="md.GT_Libraries_General.GT_ValidateTradeOfferPair" result="$isValidPair">
                    <param name="sellOffer" value="$sellOffer"/>
                    <param name="buyOffer" value="$buyOffer"/>
                  </run_actions>
                  <do_if value="not $isValidPair">
                    <continue/>
                  </do_if>
                  
                  <!-- Extract offer properties after validation -->
                  <set_value name="$sellOfferOwner" exact="@$sellOffer.owner"/>
                  <set_value name="$sellOfferPrice" exact="@$sellOffer.unitprice"/>
                  <set_value name="$buyOfferOwner" exact="@$buyOffer.owner"/>
                  <set_value name="$buyOfferPrice" exact="@$buyOffer.unitprice"/>
                  
                  <!-- Full trade creation logic for true intra-sector matches -->
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- OPTIMIZATION 3: Early profit rejection (skip impossible trades instantly) -->
                    <set_value name="$buyPrice" exact="$sellOfferPrice"/>
                    <set_value name="$sellPrice" exact="$buyOfferPrice"/>
                    
                    <do_if value="$sellPrice le $buyPrice">
                      <set_value name="$tradesRejectedProfit" operation="add"/>
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                        <set_value name="$buyStationName" exact="if $sellOfferOwner? then @$sellOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$sellStationName" exact="if $buyOfferOwner? then @$buyOfferOwner.knownname else 'NULL'"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') INTRA-SECTOR REJECTED (no profit): ' + $wareName + ' (Buy: ' + $buyStationName + ' @ ' + ($buyPrice/100) + ' Cr, Sell: ' + $sellStationName + ' @ ' + ($sellPrice/100) + ' Cr - sellPrice le buyPrice)'" chance="1"/>
                      </do_if>
                      <continue/>
                    </do_if>
                    
                    <!-- OPTIMIZATION #2: Use CACHED docking permissions (pre-cached before loop) -->
                    <set_value name="$canDockAtBuyStation" exact="@$dockingCache.{$sellOfferOwner}"/>
                    <set_value name="$canDockAtSellStation" exact="@$dockingCache.{$buyOfferOwner}"/>
                    
                    <do_if value="not $canDockAtBuyStation or not $canDockAtSellStation">
                      <set_value name="$tradesRejectedDocking" operation="add"/>
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                        <set_value name="$buyStationName" exact="if $sellOfferOwner? then @$sellOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$sellStationName" exact="if $buyOfferOwner? then @$buyOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$dockBuy" exact="if $canDockAtBuyStation then 'YES' else 'NO'"/>
                        <set_value name="$dockSell" exact="if $canDockAtSellStation then 'YES' else 'NO'"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') INTRA-SECTOR REJECTED (docking): ' + $wareName + ' (Buy: ' + $buyStationName + ' dock=' + $dockBuy + ', Sell: ' + $sellStationName + ' dock=' + $dockSell + ')'" chance="1"/>
                      </do_if>
                      <continue/>
                    </do_if>
                    
                    <!-- OPTIMIZATION: Use library function to calculate max tradeable amount -->
                    <set_value name="$sellOfferWare" exact="@$sellOffer.ware"/>
                    <set_value name="$sellOfferAmount" exact="@$sellOffer.amount"/>
                    <set_value name="$buyOfferAmount" exact="@$buyOffer.amount"/>
                    <do_if value="not $sellOfferWare? or not $sellOfferAmount? or not $buyOfferAmount?">
                      <continue/>
                    </do_if>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateMaxTradeableAmount" result="$maxAmount">
                      <param name="ship" value="$ship"/>
                      <param name="ware" value="$sellOfferWare"/>
                      <param name="buyOfferAmount" value="$buyOfferAmount"/>
                      <param name="sellOfferAmount" value="$sellOfferAmount"/>
                      <param name="availableMoney" value="$availableMoney"/>
                      <param name="buyPrice" value="$buyPrice"/>
                    </run_actions>
                    
                    <do_if value="$maxAmount le 0">
                      <set_value name="$tradesRejectedAmount" operation="add"/>
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                        <set_value name="$buyStationName" exact="if $sellOfferOwner? then @$sellOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$sellStationName" exact="if $buyOfferOwner? then @$buyOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$offerAmount" exact="if $sellOfferAmount? then $sellOfferAmount else 0"/>
                        <set_value name="$buyAmount" exact="if $buyOfferAmount? then $buyOfferAmount else 0"/>
                        <set_value name="$cargoCap" exact="if $maxCargoCapacity? then $maxCargoCapacity else 0"/>
                        <set_value name="$affordable" exact="if $maxAffordable? then $maxAffordable else 0"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') INTRA-SECTOR REJECTED (zero amount): ' + $wareName + ' (maxAmount=' + $maxAmount + ', offer=' + $offerAmount + ', buy=' + $buyAmount + ', cargo=' + $cargoCap + ', money=' + $affordable + ')'" chance="1"/>
                      </do_if>
                      <continue/>
                    </do_if>
                    
                    <!-- OPTIMIZATION: Use library functions to calculate profit, ROI, and thresholds -->
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateProfit" result="$profit">
                      <param name="buyPrice" value="$buyPrice"/>
                      <param name="sellPrice" value="$sellPrice"/>
                      <param name="amount" value="$maxAmount"/>
                    </run_actions>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateROI" result="$roi">
                      <param name="investment" value="$buyPrice * $maxAmount"/>
                      <param name="profit" value="$profit"/>
                    </run_actions>
                    
                    <!-- OPTIMIZATION: Use library function to calculate trade thresholds -->
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateTradeThresholds" result="$thresholds">
                      <param name="minROI" value="$minROI"/>
                      <param name="minAbsoluteProfit" value="$minAbsoluteProfit"/>
                      <param name="useAdvancedAnalytics" value="$gt_AdvancedAnalytics"/>
                      <param name="isIntraSector" value="true"/>
                      <param name="isIsolated" value="$shipIsIsolated"/>
                    </run_actions>
                    <set_value name="$roiThreshold" exact="$thresholds.$ROIThreshold"/>
                    <set_value name="$profitThreshold" exact="$thresholds.$ProfitThreshold"/>
                    
                    <do_if value="$roi lt $roiThreshold or $profit lt $profitThreshold">
                      <set_value name="$tradesRejectedProfit" operation="add"/>
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                        <set_value name="$buyStationName" exact="if $sellOfferOwner? then @$sellOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$sellStationName" exact="if $buyOfferOwner? then @$buyOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$thresholdLabel" exact="if $shipIsIsolated then ' (25% threshold for ISOLATED)' else ' (50% threshold for intra-sector)'"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') INTRA-SECTOR REJECTED (profit/ROI too low)' + $thresholdLabel + ': ' + $wareName + ' (Profit: ' + ($profit/100) + ' Cr lt ' + ($profitThreshold/100) + ' Cr, ROI: ' + ($roi/1) + '% lt ' + ($roiThreshold/1) + '%, BaseMinProfit: ' + ($minAbsoluteProfit/100) + ' Cr)'" chance="1"/>
                      </do_if>
                      <continue/>
                    </do_if>
                    
                    <!-- INTRA-SECTOR: Distance is always 0 (both in same sector) -->
                    <set_value name="$buyDistance" exact="0"/>
                    <set_value name="$sellDistance" exact="0"/>
                    <set_value name="$routeDistance" exact="0"/>
                    
                    <!-- OPTIMIZATION: Use library function to calculate trade efficiency -->
                    <set_value name="$sellOfferOwnerOwner" exact="@$sellOfferOwner.owner"/>
                    <set_value name="$buyOfferOwnerOwner" exact="@$buyOfferOwner.owner"/>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateTradeEfficiency" result="$efficiency">
                      <param name="profit" value="$profit"/>
                      <param name="distance" value="0"/>
                      <param name="distancePenaltyMultiplier" value="1.0"/>
                      <param name="factionPriority" value="$factionPriority"/>
                      <param name="buyStationOwner" value="$sellOfferOwnerOwner"/>
                      <param name="sellStationOwner" value="$buyOfferOwnerOwner"/>
                    </run_actions>
                    
                    <!-- Extract sectors (both are current sector for intra-sector trades) -->
                    <set_value name="$buySector" exact="@$sellOfferOwner.sector"/>
                    <set_value name="$sellSector" exact="@$buyOfferOwner.sector"/>
                    
                    <!-- OPTIMIZATION: Use library function to check failed sector pair -->
                    <run_actions ref="md.GT_Libraries_General.GT_CheckFailedSectorPair" result="$isFailedSectorPair">
                      <param name="buySector" value="$buySector"/>
                      <param name="sellSector" value="$sellSector"/>
                      <param name="failedTrades" value="$failedTrades"/>
                    </run_actions>
                    
                    <!-- INTRA-SECTOR: Create trade (respect ware quota) -->
                    <do_if value="not $isFailedSectorPair and $tradesForThisWare lt $maxTradesPerWare">
                      <!-- DEBUG: Log price verification before storing -->
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') PRICE VERIFICATION for intra-sector trade:' + 
                          '\n  sellOfferPrice (RAW): ' + $sellOfferPrice + ' = ' + ($sellOfferPrice/100) + ' Cr' +
                          '\n  buyOfferPrice (RAW): ' + $buyOfferPrice + ' = ' + ($buyOfferPrice/100) + ' Cr' +
                          '\n  $buyPrice (stored, RAW): ' + $buyPrice + ' = ' + ($buyPrice/100) + ' Cr' +
                          '\n  $sellPrice (stored, RAW): ' + $sellPrice + ' = ' + ($sellPrice/100) + ' Cr' +
                          '\n  Profit (RAW): ' + $profit + ' = ' + ($profit/100) + ' Cr' +
                          '\n  Calculated profit check: (' + ($sellPrice/100) + ' - ' + ($buyPrice/100) + ') * ' + $maxAmount + ' = ' + (($sellPrice - $buyPrice) * $maxAmount / 100) + ' Cr'" chance="100"/>
                      </do_if>
                      <!-- OPTIMIZATION: Use library function to create trade object -->
                      <run_actions ref="md.GT_Libraries_General.GT_CreateTradeObject" result="$trade">
                        <param name="sellOffer" value="$sellOffer"/>
                        <param name="buyOffer" value="$buyOffer"/>
                        <param name="sellStation" value="$sellOfferOwner"/>
                        <param name="buyStation" value="$buyOfferOwner"/>
                        <param name="amount" value="$maxAmount"/>
                        <param name="profit" value="$profit"/>
                        <param name="roi" value="$roi"/>
                        <param name="efficiency" value="$efficiency"/>
                        <param name="buyPrice" value="$buyPrice"/>
                        <param name="sellPrice" value="$sellPrice"/>
                        <param name="distance" value="$routeDistance"/>
                        <param name="risk" value="0"/>
                      </run_actions>
                      
                      <append_to_list name="$tradeList" exact="$trade"/>
                      
                      <!-- OPTIMIZATION: Use library function to update trade quota -->
                      <run_actions ref="md.GT_Libraries_General.GT_UpdateTradeQuota" result="$quotaResult">
                        <param name="tradesPerWare" value="$tradesPerWare"/>
                        <param name="ware" value="$ware"/>
                        <param name="increment" value="1"/>
                      </run_actions>
                      <set_value name="$tradesPerWare" exact="$quotaResult.$UpdatedTable"/>
                      <set_value name="$tradesForThisWare" exact="$quotaResult.$NewCount"/>
                      
                      <do_if value="$tradesForThisWare ge $maxTradesPerWare">
                        <break/>
                      </do_if>
                      
                      <do_if value="$efficiency gt $crossStationBestScore">
                        <set_value name="$crossStationBestScore" exact="$efficiency"/>
                        <set_value name="$crossStationBestTrade" exact="$trade"/>
                      </do_if>
                      
                      <!-- OPTIMIZATION: Use library function to check route conflict -->
                      <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$routeConflicted">
                        <param name="sellStation" value="$sellOfferOwner"/>
                        <param name="buyStation" value="$buyOfferOwner"/>
                        <param name="ware" value="$sellOfferWare"/>
                        <param name="reservedRoutes" value="$reservedRoutes"/>
                      </run_actions>
                      
                      <do_if value="not $routeConflicted and not $isFailedSectorPair and $efficiency gt $nonConflictedBestScore">
                        <set_value name="$nonConflictedBestScore" exact="$efficiency"/>
                        <set_value name="$nonConflictedBestTrade" exact="$trade"/>
                      </do_if>
                      
                      <!-- DEBUG: Log intra-sector trade creation -->
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$isolationLabel" exact="if $shipIsIsolated then ' [ISOLATED - routes blocked]' else ''"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') INTRA-SECTOR trade created' + $isolationLabel + ': ' + (if $sellOfferWare? then @$sellOfferWare.name else 'NULL') + ' in ' + @$currentSector.knownname + ' (Profit: ' + ($profit/100) + ' Cr, ROI: ' + ($roi/1) + '%, Score: ' + ($efficiency/1) + ')'" chance="100"/>
                      </do_if>
                    </do_if>
                </do_all>
                
                <do_if value="$tradesForThisWare ge $maxTradesPerWare">
                  <break/>
                </do_if>
              </do_all>
              
              <!-- PERFORMANCE: Check if more intra-sector chunks remain -->
              <set_value name="$hasMoreIntraChunks" exact="false"/>
              <do_if value="$intraBuyChunkEnd lt $intraSectorBuyOffers.count">
                <!-- More buy offer chunks remain -->
                <set_value name="$buyOfferChunkStart" exact="$intraBuyChunkEnd"/>
                <set_value name="$hasMoreIntraChunks" exact="true"/>
              </do_if>
              <do_else>
                <!-- Move to next sell offer chunk -->
                <do_if value="$intraSellChunkEnd lt $intraSectorSellOffers.count">
                  <set_value name="$sellOfferChunkStart" exact="$intraSellChunkEnd"/>
                  <set_value name="$buyOfferChunkStart" exact="0"/>
                  <set_value name="$hasMoreIntraChunks" exact="true"/>
                </do_if>
              </do_else>
              
              <!-- PERFORMANCE: If more intra-sector chunks remain, signal continuation and STOP further work in THIS instance.
                   IMPORTANT: We must not fall through into Phase 2 (cross-sector) after scheduling a continuation, otherwise
                   the current instance keeps doing heavy work and we end up with multiple overlapping instances per ship. -->
              <do_if value="$hasMoreIntraChunks and $tradesForThisWare lt $maxTradesPerWare">
                <!-- Save state and continue processing this ware's intra-sector chunks -->
                <set_value name="$state.$sellOfferChunkStart" exact="$sellOfferChunkStart"/>
                <set_value name="$state.$buyOfferChunkStart" exact="$buyOfferChunkStart"/>
                <set_value name="$state.$currentWareChunkStart" exact="$currentWareChunkStart"/>
                <set_value name="$state.$currentWareIndex" exact="$wareIdx - 1"/> <!-- Will be incremented to same ware -->
                <set_value name="$state.$tradesPerWare" exact="$tradesPerWare"/>
                <set_value name="$state.$tradeList" exact="$tradeList"/>
                <set_value name="$state.$crossStationBestScore" exact="$crossStationBestScore"/>
                <set_value name="$state.$crossStationBestTrade" exact="$crossStationBestTrade"/>
                <set_value name="$state.$nonConflictedBestScore" exact="$nonConflictedBestScore"/>
                <set_value name="$state.$nonConflictedBestTrade" exact="$nonConflictedBestTrade"/>
                <set_value name="$state.$tradesRejectedProfit" exact="$tradesRejectedProfit"/>
                <set_value name="$state.$tradesRejectedDocking" exact="$tradesRejectedDocking"/>
                <set_value name="$state.$tradesRejectedAmount" exact="$tradesRejectedAmount"/>
                <set_value name="$state.$tradesRejectedDistance" exact="$tradesRejectedDistance"/>
                <set_value name="$state.$bestRejectedProfit" exact="$bestRejectedProfit"/>
                <set_value name="$state.$bestRejectedTrade" exact="$bestRejectedTrade"/>
                <!-- Progress heartbeat for watchdog: indicates this processor is making forward progress -->
                <set_value name="$state.$batchLastProgress" exact="player.age"/>
                <set_value name="global.$GT_BatchDataList.{$ship}" exact="$state"/>
                <!-- Signal continuation for this ware's intra-sector chunks -->
                <set_value name="$scheduledChunkContinuation" exact="true"/>
                <!-- De-duped continuation scheduling (prevents overlapping continuation instances for same ship) -->
                <do_if value="not global.$GT_BatchContinuationScheduled?">
                  <set_value name="global.$GT_BatchContinuationScheduled" exact="table[]"/>
                </do_if>
                <do_if value="not global.$GT_BatchContinuationScheduled.{$ship}?">
                  <set_value name="global.$GT_BatchContinuationScheduled.{$ship}" exact="true"/>
                  <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ScheduleBatchContinuation" param="$ship"/>
                </do_if>
                <!-- CRITICAL: Stop processing further wares in this instance.
                     Without this break, the current instance continues iterating other wares but does NOT commit state
                     (because $scheduledChunkContinuation prevents finalize), causing infinite re-processing of ware #1
                     and blocking all batch completion. -->
                <break/>
              </do_if>
              <do_else>
                <!-- All intra-sector chunks processed - reset chunk positions for cross-sector -->
                <set_value name="$sellOfferChunkStart" exact="0"/>
                <set_value name="$buyOfferChunkStart" exact="0"/>
              </do_else>
            </do_if>
            <do_else>
              <!-- DEBUG: Log when Phase 1 can't run -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $shipIsIsolated">
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                <set_value name="$sectorName" exact="if $currentSector? then @$currentSector.knownname else 'NULL'"/>
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Phase 1 (INTRA-SECTOR) SKIPPED [ISOLATED]: ' + $wareName + ' in ' + $sectorName + ' - ' + $intraSectorSellOffers.count + ' sell, ' + $intraSectorBuyOffers.count + ' buy (need BOTH > 0)'" chance="100"/>
              </do_if>
            </do_else>
            
            <!-- Phase 2: Match all remaining offers (cross-sector with cross-sector, or mixed)
                 SKIP if we already scheduled a chunk continuation OR ship is isolated. -->
            <do_if value="not $scheduledChunkContinuation and not $shipIsIsolated">
              <!-- CRITICAL PERF/PROGRESS FIX:
                   If ONE side is empty for this ware (0 sell OR 0 buy), Phase 2 chunking does no work but can still
                   schedule many chunk continuations (because it will "walk" through the non-empty list in 5×5 chunks).
                   Under time-slicing/yielding, this can take > AI timeout and look like "ship never gets tradeorder".
                   Instead, short-circuit and advance to next ware immediately. -->
              <set_value name="$skipCrossMatching" exact="false"/>
              <do_if value="$sellOffersForWare.count == 0 or $buyOffersForWare.count == 0">
                <set_value name="$skipCrossMatching" exact="true"/>
                <!-- Reset chunk pointers and advance to next ware -->
                <set_value name="$sellOfferChunkStart" exact="0"/>
                <set_value name="$buyOfferChunkStart" exact="0"/>
                <set_value name="$currentWareChunkStart" exact="$wareIdx + 1"/>
              </do_if>

              <do_if value="not $skipCrossMatching">
              <!-- PERFORMANCE: Process cross-sector offers in 5×5 chunks -->
              <set_value name="$crossSellChunkEnd" exact="[$sellOfferChunkStart + $chunkSize, $sellOffersForWare.count].min"/>
              <set_value name="$crossBuyChunkEnd" exact="[$buyOfferChunkStart + $chunkSize, $buyOffersForWare.count].min"/>
              
              <!-- NOW run nested loops on LIMITED offers with CACHED docking -->
              <do_all exact="$crossSellChunkEnd - $sellOfferChunkStart" counter="$chunkOffset">
                <set_value name="$i" exact="$sellOfferChunkStart + $chunkOffset"/>
                <set_value name="$sellOffer" exact="$sellOffersForWare.{$i}"/>
                
                <do_all exact="$crossBuyChunkEnd - $buyOfferChunkStart" counter="$chunkOffset2">
                  <set_value name="$j" exact="$buyOfferChunkStart + $chunkOffset2"/>
                  <set_value name="$buyOffer" exact="$buyOffersForWare.{$j}"/>
                  
                  <!-- OPTIMIZATION: Use library function to validate offer pair -->
                  <run_actions ref="md.GT_Libraries_General.GT_ValidateTradeOfferPair" result="$isValidPair">
                    <param name="sellOffer" value="$sellOffer"/>
                    <param name="buyOffer" value="$buyOffer"/>
                  </run_actions>
                  <do_if value="not $isValidPair">
                    <continue/>
                  </do_if>
                  
                  <!-- Extract offer properties after validation -->
                  <set_value name="$sellOfferOwner" exact="@$sellOffer.owner"/>
                  <set_value name="$sellOfferPrice" exact="@$sellOffer.unitprice"/>
                  <set_value name="$buyOfferOwner" exact="@$buyOffer.owner"/>
                  <set_value name="$buyOfferPrice" exact="@$buyOffer.unitprice"/>
                  
                  <!-- Skip if this is already an intra-sector match (we processed those separately) -->
                    <set_value name="$sellOfferSector" exact="@$sellOfferOwner.sector"/>
                    <set_value name="$buyOfferSector" exact="@$buyOfferOwner.sector"/>
                    <do_if value="$sellOfferSector? and $buyOfferSector? and $currentSector?">
                      <do_if value="$sellOfferSector == $currentSector and $buyOfferSector == $currentSector">
                        <!-- This is an intra-sector match - skip since we already processed these -->
                        <continue/>
                      </do_if>
                    </do_if>
                    
                    <!-- Process cross-sector or mixed trade -->
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- OPTIMIZATION 3: Early profit rejection (skip impossible trades instantly) -->
                    <!-- Use already-extracted safe values -->
                    <set_value name="$buyPrice" exact="$sellOfferPrice"/>
                    <set_value name="$sellPrice" exact="$buyOfferPrice"/>
                    
                    <!-- OPTIMIZATION: Use library function to calculate max tradeable amount -->
                    <!-- Use @ operator for safe property access -->
                    <set_value name="$sellOfferWare" exact="@$sellOffer.ware"/>
                    <set_value name="$sellOfferAmount" exact="@$sellOffer.amount"/>
                    <set_value name="$buyOfferAmount" exact="@$buyOffer.amount"/>
                    <do_if value="not $sellOfferWare? or not $sellOfferAmount? or not $buyOfferAmount?">
                      <continue/>
                    </do_if>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateMaxTradeableAmount" result="$maxAmount">
                      <param name="ship" value="$ship"/>
                      <param name="ware" value="$sellOfferWare"/>
                      <param name="buyOfferAmount" value="$buyOfferAmount"/>
                      <param name="sellOfferAmount" value="$sellOfferAmount"/>
                      <param name="availableMoney" value="$availableMoney"/>
                      <param name="buyPrice" value="$buyPrice"/>
                    </run_actions>
                    
                    <do_if value="$maxAmount le 0">
                      <set_value name="$tradesRejectedAmount" operation="add"/>
                      <continue/>
                    </do_if>
                    
                    <!-- OPTIMIZATION: Use library functions to calculate profit and ROI -->
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateProfit" result="$profit">
                      <param name="buyPrice" value="$buyPrice"/>
                      <param name="sellPrice" value="$sellPrice"/>
                      <param name="amount" value="$maxAmount"/>
                    </run_actions>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateROI" result="$roi">
                      <param name="investment" value="$buyPrice * $maxAmount"/>
                      <param name="profit" value="$profit"/>
                    </run_actions>
                    
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- CACHE FIRST: Cache ALL profitable trades BEFORE any filtering -->
                    <!-- This ensures cache contains all trades that ANY ship might accept -->
                    <!-- Blacklist filtering happens when READING from cache (SearchCachedTrades) -->
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- Cache trade if enabled and meets global cache threshold -->
                    <!-- CRITICAL: Cache respects global CacheProfitThreshold setting -->
                    <!-- Universal cache: no ship-specific filters, but must meet global minimum -->
                    <do_if value="global.$GT_GlobalSettings.$Fleet.$EnableTradeCache">
                      <!-- Get cache threshold from global settings (default 20%) -->
                      <set_value name="$cacheThreshold" exact="20"/>
                      <do_if value="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold?">
                        <set_value name="$cacheThreshold" exact="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold"/>
                      </do_if>
                      
                      <!-- DIAGNOSTIC: Log why trades aren't being cached (only if cache is empty) -->
                      <!-- PERFORMANCE OPTIMIZATION v5: Calculate total cache count from all home sectors -->
                      <!-- Use library function for cache count calculation -->
                      <run_actions ref="md.GT_Libraries_General.GT_CalculateTotalCacheCount" result="$currentCacheCount"/>
                      <do_if value="$currentCacheCount == 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <!-- Cache is empty - log why trades aren't meeting cache requirements -->
                        <do_if value="$profit le 0">
                          <debug_text text="'[GT-Cache-DIAG] Trade NOT cached: Profit le 0 (Profit=' + ($profit/100) + ' Cr, ROI=' + ($roi/1) + '%)'" chance="10"/>
                        </do_if>
                        <do_elseif value="$roi lt $cacheThreshold">
                          <debug_text text="'[GT-Cache-DIAG] Trade NOT cached: ROI below threshold (ROI=' + ($roi/1) + '% lt Threshold=' + ($cacheThreshold/1) + '%, Profit=' + ($profit/100) + ' Cr)'" chance="10"/>
                        </do_elseif>
                      </do_if>
                      
                      <!-- Only cache trades that meet global cache profit threshold -->
                      <!-- IMPORTANT: Cache must be SHIP-AGNOSTIC. Do NOT use per-ship max tradeable amount here. -->
                      <!-- Use offer-limited amounts and per-unit economics so any ship can benefit from the cache. -->
                      <set_value name="$cacheSellOfferAmount" exact="@$sellOffer.amount"/>
                      <set_value name="$cacheBuyOfferAmount" exact="@$buyOffer.amount"/>
                      <set_value name="$cacheOfferMaxAmount" exact="[$cacheSellOfferAmount, $cacheBuyOfferAmount].min"/>
                      <set_value name="$cacheProfitPerUnit" exact="$sellPrice - $buyPrice"/>
                      <set_value name="$cacheVolumePerUnit" exact="$sellOfferWare.volume"/>
                      <set_value name="$cacheTotalVolume" exact="$cacheOfferMaxAmount * $cacheVolumePerUnit"/>
                      <set_value name="$cacheProfit" exact="$cacheProfitPerUnit * $cacheOfferMaxAmount"/>
                      <!-- ROI is price-only (independent of amount) -->
                      <run_actions ref="md.GT_Libraries_General.GT_CalculateROIFromPrices" result="$cacheROI">
                        <param name="buyPrice" value="$buyPrice"/>
                        <param name="sellPrice" value="$sellPrice"/>
                      </run_actions>
                      <do_if value="$cacheOfferMaxAmount gt 0 and $cacheProfitPerUnit gt 0 and $cacheROI ge $cacheThreshold">
                        <!-- Validate required data exists before caching -->
                        <!-- Debug: Log why trades aren't cached -->
                        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and not ($sellOfferWare? and $sellOfferOwner? and $buyOfferOwner?)">
                          <debug_text text="'[GT-Cache-DEBUG] ⚠ Trade NOT cached (validation failed): ROI=' + ($roi/1) + '%, Profit=' + ($profit/100) + ' Cr, sellOfferWare=' + ($sellOfferWare? and 'OK' or 'NULL') + ', sellOfferOwner=' + ($sellOfferOwner? and 'OK' or 'NULL') + ', buyOfferOwner=' + ($buyOfferOwner? and 'OK' or 'NULL')" chance="20"/>
                        </do_if>
                        <do_if value="$sellOfferWare? and $sellOfferOwner? and $buyOfferOwner?">
                          <!-- SIMPLIFIED: Initialization guarantees global.$GT_TradeCache exists -->
                          <!-- Extract sectors for route distance (needed for cache entry) -->
                          <set_value name="$buySector" exact="@$sellOfferOwner.sector"/>
                          <set_value name="$sellSector" exact="@$buyOfferOwner.sector"/>
                          <set_value name="$routeDistance" exact="0"/>
                          <do_if value="$buySector? and $sellSector?">
                            <do_if value="$buySector == $sellSector">
                              <set_value name="$routeDistance" exact="0"/>
                            </do_if>
                            <do_else>
                              <!-- UNIVERSAL CACHE: Use range-only distance (NO blacklist params) -->
                              <set_value name="$routeDistance" exact="$buySector.gatedistance.{$sellSector}"/>
                              <do_if value="$routeDistance lt 0">
                                <!-- No path available - distance invalid -->
                                <set_value name="$routeDistance" exact="-1"/>
                              </do_if>
                            </do_else>
                          </do_if>
                          
                          <!-- PERFORMANCE OPTIMIZATION v5: Per-home-sector cache with pre-computed distances -->
                          <!-- Only cache if home sector is valid -->
                          <do_if value="@$homeSector.exists">
                            <!-- Initialize home sector cache if needed -->
                            <do_if value="not global.$GT_TradeCache.{$homeSector}?">
                              <set_value name="global.$GT_TradeCache.{$homeSector}" exact="[]"/>
                            </do_if>
                            
                            <!-- CACHE DIVERSITY: Per-ware limit of 50 entries (per home sector) -->
                            <!-- Count existing entries for this ware in THIS home sector's cache -->
                            <set_value name="$wareEntryCount" exact="0"/>
                            <set_value name="$oldestWareEntryIdx" exact="-1"/>
                            <set_value name="$oldestWareEntryTimestamp" exact="player.age"/>
                            <set_value name="$homeSectorCache" exact="global.$GT_TradeCache.{$homeSector}"/>
                            <do_all exact="$homeSectorCache.count" counter="$cacheIdx">
                              <set_value name="$cachedEntry" exact="$homeSectorCache.{$cacheIdx}"/>
                              <do_if value="$cachedEntry? and $cachedEntry.$WareId == $sellOfferWare.id">
                                <set_value name="$wareEntryCount" exact="$wareEntryCount + 1"/>
                                <!-- Track oldest entry for this ware (for replacement if at limit) -->
                                <do_if value="$cachedEntry.$Timestamp? and $cachedEntry.$Timestamp lt $oldestWareEntryTimestamp">
                                  <set_value name="$oldestWareEntryTimestamp" exact="$cachedEntry.$Timestamp"/>
                                  <set_value name="$oldestWareEntryIdx" exact="$cacheIdx"/>
                                </do_if>
                              </do_if>
                            </do_all>
                            
                            <!-- If this ware already has 50 entries in this home sector, replace the oldest one -->
                            <do_if value="$wareEntryCount ge 50">
                              <do_if value="$oldestWareEntryIdx ge 0">
                                <!-- Remove oldest entry for this ware from this home sector's cache -->
                                <remove_value name="global.$GT_TradeCache.{$homeSector}.{$oldestWareEntryIdx}"/>
                              </do_if>
                            </do_if>
                            
                            <!-- Cache entry volume uses OFFER-limited amount (ship-agnostic) -->
                            <set_value name="$totalVolume" exact="$cacheTotalVolume"/>
                            
                            <!-- PERFORMANCE OPTIMIZATION: Pre-compute distances from home sector ONCE during caching -->
                            <!-- These distances are the same for all ships with this home sector -->
                            <set_value name="$homeToBuyDistance" exact="-1"/>
                            <set_value name="$homeToSellDistance" exact="-1"/>
                            <do_if value="$buySector? and $sellSector?">
                              <set_value name="$homeToBuyDistance" exact="$homeSector.gatedistance.{$buySector}"/>
                              <set_value name="$homeToSellDistance" exact="$homeSector.gatedistance.{$sellSector}"/>
                              <!-- Handle invalid distances -->
                              <do_if value="$homeToBuyDistance lt 0">
                                <set_value name="$homeToBuyDistance" exact="-1"/>
                              </do_if>
                              <do_if value="$homeToSellDistance lt 0">
                                <set_value name="$homeToSellDistance" exact="-1"/>
                              </do_if>
                            </do_if>
                            
                            <!-- Cache target types (for cache-side filtering) -->
                            <!-- Buy target = owner of $BuyOffer (= $sellOfferOwner) -->
                            <!-- Sell target = owner of $SellOffer (= $buyOfferOwner) -->
                            <set_value name="$buyTargetType" exact="'Station'"/>
                            <do_if value="$sellOfferOwner.isclass.buildstorage">
                              <set_value name="$buyTargetType" exact="'Buildstorage'"/>
                            </do_if>
                            <do_elseif value="$sellOfferOwner.isclass.station">
                              <set_value name="$buyPrimaryPurpose" exact="@$sellOfferOwner.primarypurpose"/>
                              <do_if value="$buyPrimaryPurpose == purpose.auxiliary">
                                <set_value name="$buyTargetType" exact="'Aux'"/>
                              </do_if>
                              <do_elseif value="$buyPrimaryPurpose == purpose.fight">
                                <set_value name="$buyTargetType" exact="'Carrier'"/>
                              </do_elseif>
                            </do_elseif>
                            
                            <set_value name="$sellTargetType" exact="'Station'"/>
                            <do_if value="$buyOfferOwner.isclass.buildstorage">
                              <set_value name="$sellTargetType" exact="'Buildstorage'"/>
                            </do_if>
                            <do_elseif value="$buyOfferOwner.isclass.station">
                              <set_value name="$sellPrimaryPurpose" exact="@$buyOfferOwner.primarypurpose"/>
                              <do_if value="$sellPrimaryPurpose == purpose.auxiliary">
                                <set_value name="$sellTargetType" exact="'Aux'"/>
                              </do_if>
                              <do_elseif value="$sellPrimaryPurpose == purpose.fight">
                                <set_value name="$sellTargetType" exact="'Carrier'"/>
                              </do_elseif>
                            </do_elseif>
                            
                            <!-- Cache docking capability profile (physical docks by size) -->
                            <!-- Used by cache search to skip trades that cannot physically dock for a ship's docksize -->
                            <!-- NOTE: This is physical capability only (no relation/permission). -->
                            <do_if value="not global.$GT_DockCapsCache?">
                              <set_value name="global.$GT_DockCapsCache" exact="table[]"/>
                            </do_if>
                            
                            <!-- Buy station (= seller of BuyOffer / $sellOfferOwner) -->
                            <set_value name="$buyDockCaps" exact="null"/>
                            <do_if value="global.$GT_DockCapsCache.{$sellOfferOwner}?">
                              <set_value name="$buyDockCaps" exact="global.$GT_DockCapsCache.{$sellOfferOwner}"/>
                            </do_if>
                            <do_else>
                              <set_value name="$buyDockCaps" exact="table[$S=false, $M=false, $L=false, $XL=false]"/>
                              
                              <find_dockingbay name="$buyDockS" object="$sellOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_s" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$buyDockS">
                                <set_value name="$buyDockCaps.$S" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$buyDockM" object="$sellOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_m" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$buyDockM">
                                <set_value name="$buyDockCaps.$M" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$buyDockL" object="$sellOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_l" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$buyDockL">
                                <set_value name="$buyDockCaps.$L" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$buyDockXL" object="$sellOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_xl" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$buyDockXL">
                                <set_value name="$buyDockCaps.$XL" exact="true"/>
                              </do_if>
                              
                              <set_value name="global.$GT_DockCapsCache.{$sellOfferOwner}" exact="$buyDockCaps"/>
                            </do_else>
                            
                            <!-- Sell station (= buyer of SellOffer / $buyOfferOwner) -->
                            <set_value name="$sellDockCaps" exact="null"/>
                            <do_if value="global.$GT_DockCapsCache.{$buyOfferOwner}?">
                              <set_value name="$sellDockCaps" exact="global.$GT_DockCapsCache.{$buyOfferOwner}"/>
                            </do_if>
                            <do_else>
                              <set_value name="$sellDockCaps" exact="table[$S=false, $M=false, $L=false, $XL=false]"/>
                              
                              <find_dockingbay name="$sellDockS" object="$buyOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_s" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$sellDockS">
                                <set_value name="$sellDockCaps.$S" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$sellDockM" object="$buyOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_m" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$sellDockM">
                                <set_value name="$sellDockCaps.$M" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$sellDockL" object="$buyOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_l" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$sellDockL">
                                <set_value name="$sellDockCaps.$L" exact="true"/>
                              </do_if>
                              
                              <find_dockingbay name="$sellDockXL" object="$buyOfferOwner" checkoperational="true" multiple="false">
                                <match_dock size="tag.dock_xl" storage="false"/>
                              </find_dockingbay>
                              <do_if value="$sellDockXL">
                                <set_value name="$sellDockCaps.$XL" exact="true"/>
                              </do_if>
                              
                              <set_value name="global.$GT_DockCapsCache.{$buyOfferOwner}" exact="$sellDockCaps"/>
                            </do_else>
                            
                            <!-- Insert trade entry into THIS home sector's cache list, maintaining sorted order by Profit (descending) -->
                            <!-- CRITICAL: Store route distance (buy station sell station) for position-independent validation -->
                            <!-- PERFORMANCE OPTIMIZATION: Pre-computed distances from home sector -->
                            <!-- OPTIMIZATION: Insert in sorted order (by profit) so validation can use top N entries without sorting -->
                            <set_value name="$newCacheEntry" exact="table[
                              $WareId = $sellOfferWare.id,
                              $WareName = $sellOfferWare.name,
                              $SellStationId = $buyOfferOwner.idcode,
                              $BuyStationId = $sellOfferOwner.idcode,
                              $BuyOffer = $sellOffer,
                              $SellOffer = $buyOffer,
                              $BuyTargetType = $buyTargetType,
                              $SellTargetType = $sellTargetType,
                              $BuyDockCaps = $buyDockCaps,
                              $SellDockCaps = $sellDockCaps,
                              $OfferMaxAmount = $cacheOfferMaxAmount,
                              $ProfitPerUnit = $cacheProfitPerUnit,
                              $VolumePerUnit = $cacheVolumePerUnit,
                              $Amount = $cacheOfferMaxAmount,
                              $TotalVolume = $totalVolume,
                              $Profit = $cacheProfit,
                              $ROI = $cacheROI,
                              $BuyPrice = $buyPrice,
                              $SellPrice = $sellPrice,
                              $Distance = $routeDistance,
                              $Timestamp = player.age,
                              $HomeSector = $homeSector,
                              $HomeToBuyDistance = $homeToBuyDistance,
                              $HomeToSellDistance = $homeToSellDistance
                            ]"/>
                            
                            <!-- Find insertion position: insert where profit > existing profit (maintain descending order) -->
                            <!-- Example: cache has [300, 200, 100], new entry has 150 -> insert at index 2 (between 200 and 100) -->
                            <set_value name="$insertIndex" exact="0"/>
                            <set_value name="$homeSectorCache" exact="global.$GT_TradeCache.{$homeSector}"/>
                            <set_value name="$insertionFound" exact="false"/>
                            <do_if value="$homeSectorCache.count gt 0">
                              <!-- Linear search: find first entry with profit < new profit -->
                              <do_all exact="$homeSectorCache.count" counter="$i">
                                <set_value name="$existingProfit" exact="if $homeSectorCache.{$i}.$Profit? then $homeSectorCache.{$i}.$Profit else 0"/>
                                <do_if value="$cacheProfit gt $existingProfit">
                                  <!-- Found insertion point: insert before this entry (it has lower profit) -->
                                  <set_value name="$insertIndex" exact="$i"/>
                                  <set_value name="$insertionFound" exact="true"/>
                                  <break/>
                                </do_if>
                              </do_all>
                            </do_if>
                            
                            <!-- Insert at calculated position (or append if at end) -->
                            <do_if value="$insertionFound">
                              <set_value name="global.$GT_TradeCache.{$homeSector}.{$insertIndex}" exact="$newCacheEntry" operation="insert"/>
                            </do_if>
                            <do_else>
                              <!-- Append if insertion point is at end (new entry has lowest profit) -->
                              <append_to_list name="global.$GT_TradeCache.{$homeSector}" exact="$newCacheEntry"/>
                            </do_else>
                          </do_if>
                          
                          <!-- Debug logging for cache population -->
                          <!-- DIAGNOSTIC: Always log first few cache entries (helps diagnose empty cache issues) -->
                          <set_value name="$homeSectorCache" exact="global.$GT_TradeCache.{$homeSector}"/>
                          <set_value name="$cacheCount" exact="$homeSectorCache.count"/>
                          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                            <!-- Log first 5 entries and every 10th entry after that (calculate remainder using division) -->
                            <set_value name="$shouldLog" exact="false"/>
                            <do_if value="$cacheCount le 5">
                              <set_value name="$shouldLog" exact="true"/>
                            </do_if>
                            <do_else>
                              <!-- Calculate remainder: cacheCount - (cacheCount / 10) * 10 -->
                              <set_value name="$remainder" exact="$cacheCount - (($cacheCount / 10) * 10)"/>
                              <do_if value="$remainder == 0">
                                <set_value name="$shouldLog" exact="true"/>
                              </do_if>
                            </do_else>
                            <do_if value="$shouldLog">
                              <debug_text text="'[GT-Cache] Trade cached: ' + $sellOfferWare.name + ', ROI=' + ($cacheROI/1) + '%, Profit=' + ($cacheProfit/100) + ' Cr, Distance=' + $routeDistance + ' jumps (cache now: ' + $cacheCount + ' entries)'" chance="100"/>
                            </do_if>
                          </do_if>
                        </do_if>
                      </do_if>
                    </do_if>
                    
                    <!-- OPTIMIZATION: Use library function to calculate trade thresholds -->
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateTradeThresholds" result="$thresholds">
                      <param name="minROI" value="$minROI"/>
                      <param name="minAbsoluteProfit" value="$minAbsoluteProfit"/>
                      <param name="useAdvancedAnalytics" value="$gt_AdvancedAnalytics"/>
                      <param name="isIntraSector" value="false"/>
                      <param name="isIsolated" value="false"/>
                    </run_actions>
                    <set_value name="$roiThreshold" exact="$thresholds.$ROIThreshold"/>
                    <set_value name="$profitThreshold" exact="$thresholds.$ProfitThreshold"/>
                    
                    <do_if value="$roi lt $roiThreshold or $profit lt $profitThreshold">
                      <set_value name="$tradesRejectedProfit" operation="add"/>
                      
                      <!-- Track best rejected trade -->
                      <do_if value="not $bestRejectedProfit? or $profit gt $bestRejectedProfit">
                        <set_value name="$bestRejectedProfit" exact="$profit"/>
                        <set_value name="$bestRejectedTrade" exact="table[
                          $ware = $sellOfferWare,
                          $buyFrom = $sellOfferOwner,
                          $sellTo = $buyOfferOwner,
                          $buyPrice = $buyPrice,
                          $sellPrice = $sellPrice,
                          $profit = $profit,
                          $roi = $roi
                        ]"/>
                      </do_if>
                      <!-- This log line can fire *extremely* often under high MinAbsoluteProfit (lots of rejections),
                           which slows batch processing and indirectly causes AI timeouts. Keep it, but heavily sample it. -->
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <set_value name="$wareName" exact="if $sellOfferWare? then @$sellOfferWare.name else 'NULL'"/>
                        <set_value name="$buyStationName" exact="if $sellOfferOwner? then @$sellOfferOwner.knownname else 'NULL'"/>
                        <set_value name="$sellStationName" exact="if $buyOfferOwner? then @$buyOfferOwner.knownname else 'NULL'"/>
                        <debug_text text="'[GT-Batch] (' + $ship.idcode + ') CROSS-SECTOR REJECTED (profit/ROI too low): ' + $wareName + ' (Profit: ' + ($profit/100) + ' Cr lt ' + ($profitThreshold/100) + ' Cr, ROI: ' + ($roi/1) + '% lt ' + ($roiThreshold/1) + '%, BaseMinProfit: ' + ($minAbsoluteProfit/100) + ' Cr)'" chance="1"/>
                      </do_if>
                      <continue/>
                    </do_if>
                    
                    <!-- Use cached distances -->
                    <set_value name="$buyDistance" exact="@$stationDistanceCache.{$sellOfferOwner}"/>
                    <do_if value="not $buyDistance? or typeof $buyDistance != datatype.integer">
                      <set_value name="$buyDistance" exact="-1"/>
                    </do_if>
                    
                    <set_value name="$sellDistance" exact="@$stationDistanceCache.{$buyOfferOwner}"/>
                    <do_if value="not $sellDistance? or typeof $sellDistance != datatype.integer">
                      <set_value name="$sellDistance" exact="-1"/>
                    </do_if>
                    
                    <!-- Filter unreachable trades -->
                    <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
                      <set_value name="$tradesRejectedDistance" operation="add"/>
                      <continue/>
                    </do_if>
                    
                    <!-- Check distance constraints -->
                    <do_if value="$buyDistance gt $maxDistance or $sellDistance gt $maxDistance">
                      <set_value name="$tradesRejectedDistance" operation="add"/>
                      <continue/>
                    </do_if>
                    
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- OPTIMIZATION: Use cached sector blacklist status (fast table lookup) -->
                    <!-- Extract sectors for distance calculation and caching -->
                    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
                    <!-- Use safe extracted station values -->
                    <set_value name="$buySector" exact="@$sellOfferOwner.sector"/>
                    <set_value name="$sellSector" exact="@$buyOfferOwner.sector"/>
                    <do_if value="not $buySector? or not $sellSector?">
                      <continue/>
                    </do_if>
                    
                    <!-- Calculate route distance (buy station sell station) for cache validation -->
                    <!-- This is position-independent and will detect if blacklists block the route -->
                    <set_value name="$routeDistance" exact="0"/>
                    <do_if value="$buySector == $sellSector">
                      <!-- Same sector: route distance is 0 -->
                      <set_value name="$routeDistance" exact="0"/>
                    </do_if>
                    <do_else>
                      <!-- UNIVERSAL CACHE: Use range-only distance (NO blacklist params) -->
                      <set_value name="$buyStationSector" exact="$buySector"/>
                      <set_value name="$sellStationSector" exact="$sellSector"/>
                      <set_value name="$routeDistance" exact="$buyStationSector.gatedistance.{$sellStationSector}"/>
                    </do_else>
                    
                    <!-- OPTIMIZATION: Use library function to calculate trade efficiency -->
                    <set_value name="$totalDistance" exact="$buyDistance + $sellDistance"/>
                    <set_value name="$sellOfferOwnerOwner" exact="@$sellOfferOwner.owner"/>
                    <set_value name="$buyOfferOwnerOwner" exact="@$buyOfferOwner.owner"/>
                    <run_actions ref="md.GT_Libraries_General.GT_CalculateTradeEfficiency" result="$efficiency">
                      <param name="profit" value="$profit"/>
                      <param name="distance" value="$totalDistance"/>
                      <param name="distancePenaltyMultiplier" value="$distancePenaltyMultiplier"/>
                      <param name="factionPriority" value="$factionPriority"/>
                      <param name="buyStationOwner" value="$sellOfferOwnerOwner"/>
                      <param name="sellStationOwner" value="$buyOfferOwnerOwner"/>
                    </run_actions>
                    
                    <!-- UNIVERSAL CACHE: No blacklist filtering - removed for universal processing -->
                    <!-- Blacklist filtering happens per-ship during cache retrieval -->
                    
                    <!-- OPTIMIZATION: Use library function to check failed sector pair -->
                    <run_actions ref="md.GT_Libraries_General.GT_CheckFailedSectorPair" result="$isFailedSectorPair">
                      <param name="buySector" value="$buySector"/>
                      <param name="sellSector" value="$sellSector"/>
                      <param name="failedTrades" value="$failedTrades"/>
                    </run_actions>
                    
                    <!-- UNIVERSAL CACHE: Collect ALL valid trades (no blacklist filtering) -->
                    <!-- Respect ware quota to ensure diversity -->
                    <do_if value="not $isFailedSectorPair and $tradesForThisWare lt $maxTradesPerWare">
                      <!-- OPTIMIZATION: Use library function to create trade object -->
                      <run_actions ref="md.GT_Libraries_General.GT_CreateTradeObject" result="$trade">
                        <param name="sellOffer" value="$sellOffer"/>
                        <param name="buyOffer" value="$buyOffer"/>
                        <param name="sellStation" value="$sellOfferOwner"/>
                        <param name="buyStation" value="$buyOfferOwner"/>
                        <param name="amount" value="$maxAmount"/>
                        <param name="profit" value="$profit"/>
                        <param name="roi" value="$roi"/>
                        <param name="efficiency" value="$efficiency"/>
                        <param name="buyPrice" value="$buyPrice"/>
                        <param name="sellPrice" value="$sellPrice"/>
                        <param name="distance" value="$routeDistance"/>
                        <param name="risk" value="0"/>
                      </run_actions>
                      
                      <append_to_list name="$tradeList" exact="$trade"/>
                      
                      <!-- OPTIMIZATION: Use library function to update trade quota -->
                      <run_actions ref="md.GT_Libraries_General.GT_UpdateTradeQuota" result="$quotaResult">
                        <param name="tradesPerWare" value="$tradesPerWare"/>
                        <param name="ware" value="$ware"/>
                        <param name="increment" value="1"/>
                      </run_actions>
                      <set_value name="$tradesPerWare" exact="$quotaResult.$UpdatedTable"/>
                      <set_value name="$tradesForThisWare" exact="$quotaResult.$NewCount"/>
                      
                      <!-- OPTIMIZATION #3: Early exit when quota reached -->
                      <!-- Break from inner loop (buy offers) when we have enough trades for this ware -->
                      <do_if value="$tradesForThisWare ge $maxTradesPerWare">
                        <break/>  <!-- Exit buy offers loop -->
                      </do_if>
                      
                      <!-- Track overall best -->
                      <do_if value="$efficiency gt $crossStationBestScore">
                        <set_value name="$crossStationBestScore" exact="$efficiency"/>
                        <set_value name="$crossStationBestTrade" exact="$trade"/>
                      </do_if>
                      
                      <!-- OPTIMIZATION: Use library function to check route conflict -->
                      <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$routeConflicted">
                        <param name="sellStation" value="$sellOfferOwner"/>
                        <param name="buyStation" value="$buyOfferOwner"/>
                        <param name="ware" value="$sellOfferWare"/>
                        <param name="reservedRoutes" value="$reservedRoutes"/>
                      </run_actions>
                      
                      <!-- Track best non-conflicted -->
                      <do_if value="not $routeConflicted and not $isFailedSectorPair and $efficiency gt $nonConflictedBestScore">
                        <set_value name="$nonConflictedBestScore" exact="$efficiency"/>
                        <set_value name="$nonConflictedBestTrade" exact="$trade"/>
                      </do_if>
                    </do_if>
                </do_all>
                
                <!-- OPTIMIZATION #3: Early exit from outer loop if quota reached -->
                <do_if value="$tradesForThisWare ge $maxTradesPerWare">
                  <break/>  <!-- Exit sell offers loop -->
                  </do_if>
              </do_all>
              
              <!-- PERFORMANCE: Check if more cross-sector chunks remain -->
              <set_value name="$hasMoreCrossChunks" exact="false"/>
              <do_if value="$crossBuyChunkEnd lt $buyOffersForWare.count">
                <!-- More buy offer chunks remain -->
                <set_value name="$buyOfferChunkStart" exact="$crossBuyChunkEnd"/>
                <set_value name="$hasMoreCrossChunks" exact="true"/>
              </do_if>
              <do_else>
                <!-- Move to next sell offer chunk -->
                <do_if value="$crossSellChunkEnd lt $sellOffersForWare.count">
                  <set_value name="$sellOfferChunkStart" exact="$crossSellChunkEnd"/>
                  <set_value name="$buyOfferChunkStart" exact="0"/>
                  <set_value name="$hasMoreCrossChunks" exact="true"/>
                </do_if>
                <do_else>
                  <!-- All cross-sector chunks processed - reset for next ware -->
                  <set_value name="$sellOfferChunkStart" exact="0"/>
                  <set_value name="$buyOfferChunkStart" exact="0"/>
                  <set_value name="$currentWareChunkStart" exact="$wareIdx + 1"/>
                </do_else>
              </do_else>
              
              <!-- PERFORMANCE: If more chunks remain, signal continuation and exit -->
              <do_if value="$hasMoreCrossChunks and $tradesForThisWare lt $maxTradesPerWare">
                <!-- Save state and continue processing this ware's chunks -->
                <set_value name="$state.$sellOfferChunkStart" exact="$sellOfferChunkStart"/>
                <set_value name="$state.$buyOfferChunkStart" exact="$buyOfferChunkStart"/>
                <set_value name="$state.$currentWareChunkStart" exact="$currentWareChunkStart"/>
                <set_value name="$state.$currentWareIndex" exact="$wareIdx - 1"/> <!-- Will be incremented to same ware -->
                <set_value name="$state.$tradesPerWare" exact="$tradesPerWare"/>
                <set_value name="$state.$tradeList" exact="$tradeList"/>
                <set_value name="$state.$crossStationBestScore" exact="$crossStationBestScore"/>
                <set_value name="$state.$crossStationBestTrade" exact="$crossStationBestTrade"/>
                <set_value name="$state.$nonConflictedBestScore" exact="$nonConflictedBestScore"/>
                <set_value name="$state.$nonConflictedBestTrade" exact="$nonConflictedBestTrade"/>
                <set_value name="$state.$tradesRejectedProfit" exact="$tradesRejectedProfit"/>
                <set_value name="$state.$tradesRejectedDocking" exact="$tradesRejectedDocking"/>
                <set_value name="$state.$tradesRejectedAmount" exact="$tradesRejectedAmount"/>
                <set_value name="$state.$tradesRejectedDistance" exact="$tradesRejectedDistance"/>
                <set_value name="$state.$bestRejectedProfit" exact="$bestRejectedProfit"/>
                <set_value name="$state.$bestRejectedTrade" exact="$bestRejectedTrade"/>
                <!-- Progress heartbeat for watchdog -->
                <set_value name="$state.$batchLastProgress" exact="player.age"/>
                <!-- ROOT-CAUSE FIX: Prevent one ship from monopolizing the batch slot under long chunk continuations.
                     After a few continuation slices, yield by re-queueing this ship and releasing the active slot.
                     This avoids fleet-wide starvation → AI MD-response timeouts. -->
                <set_value name="$continuationSlices" exact="0"/>
                <do_if value="$state.$continuationSlices?">
                  <set_value name="$continuationSlices" exact="@$state.$continuationSlices"/>
                </do_if>
                <set_value name="$continuationSlices" exact="$continuationSlices + 1"/>
                <set_value name="$state.$continuationSlices" exact="$continuationSlices"/>
                <set_value name="global.$GT_BatchDataList.{$ship}" exact="$state"/>

                <set_value name="$hasQueuedShipsWaiting" exact="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0"/>
                <set_value name="$maxSlicesBeforeYield" exact="3"/>
                <do_if value="$hasQueuedShipsWaiting and $continuationSlices ge $maxSlicesBeforeYield">
                  <!-- Re-queue this ship (de-dupe) -->
                  <do_if value="not global.$GT_BatchProcessorQueue?">
                    <set_value name="global.$GT_BatchProcessorQueue" exact="table[]"/>
                  </do_if>
                  <do_if value="not global.$GT_BatchProcessorQueue.$Ships?">
                    <set_value name="global.$GT_BatchProcessorQueue.$Ships" exact="[]"/>
                  </do_if>
                  <set_value name="$alreadyInQueue" exact="false"/>
                  <do_all exact="global.$GT_BatchProcessorQueue.$Ships.count" counter="$qi">
                    <do_if value="global.$GT_BatchProcessorQueue.$Ships.{$qi} == $ship">
                      <set_value name="$alreadyInQueue" exact="true"/>
                      <break/>
                    </do_if>
                  </do_all>
                  <do_if value="not $alreadyInQueue">
                    <append_to_list name="global.$GT_BatchProcessorQueue.$Ships" exact="$ship"/>
                  </do_if>

                  <!-- Release active slot and remove from active ships -->
                  <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips?">
                    <remove_from_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
                  </do_if>
                  <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0">
                    <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="subtract"/>
                  </do_if>

                  <!-- Reset slice counter so next time it gets a fresh timeslice budget -->
                  <set_value name="global.$GT_BatchDataList.{$ship}.$continuationSlices" exact="0"/>

                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Yielding batch slot after ' + $continuationSlices + ' continuation slices (queued ships waiting: ' + global.$GT_BatchProcessorQueue.$Ships.count + ')'" chance="100"/>
                  </do_if>

                  <!-- Kick queue processing -->
                  <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
                </do_if>
                <do_else>
                  <!-- Continue immediately (de-duped) -->
                  <set_value name="$scheduledChunkContinuation" exact="true"/>
                  <do_if value="not global.$GT_BatchContinuationScheduled?">
                    <set_value name="global.$GT_BatchContinuationScheduled" exact="table[]"/>
                  </do_if>
                  <do_if value="not global.$GT_BatchContinuationScheduled.{$ship}?">
                    <set_value name="global.$GT_BatchContinuationScheduled.{$ship}" exact="true"/>
                    <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ScheduleBatchContinuation" param="$ship"/>
                  </do_if>
                </do_else>

                <!-- Exit current processing cleanly (don't fall through into state update / finalize) -->
                <set_value name="$scheduledChunkContinuation" exact="true"/>
                <break/>
              </do_if>
              </do_if>
            </do_if>
            <!-- LINE 998: Closes do_if from line 194 -->
            </do_if>
          </do_all>

          <!-- If we scheduled a chunk-continuation, do NOT fall through into state update/finalize. -->
          <do_if value="not $scheduledChunkContinuation">
            <!-- Update state with new progress -->
            <!-- Convert 1-based batchEnd back to 0-based for storage -->
            <set_value name="$state.$currentWareIndex" exact="$batchEnd1Based - 1"/>
            <!-- Save chunk positions (reset for next ware since we're moving to next ware) -->
            <set_value name="$state.$sellOfferChunkStart" exact="0"/>
            <set_value name="$state.$buyOfferChunkStart" exact="0"/>
            <set_value name="$state.$currentWareChunkStart" exact="$batchEnd1Based"/>
            <set_value name="$state.$tradeList" exact="$tradeList"/>
            <set_value name="$state.$crossStationBestScore" exact="$crossStationBestScore"/>
            <set_value name="$state.$crossStationBestTrade" exact="$crossStationBestTrade"/>
            <set_value name="$state.$nonConflictedBestScore" exact="$nonConflictedBestScore"/>
            <set_value name="$state.$nonConflictedBestTrade" exact="$nonConflictedBestTrade"/>
            <set_value name="$state.$tradesRejectedProfit" exact="$tradesRejectedProfit"/>
            <set_value name="$state.$tradesRejectedDocking" exact="$tradesRejectedDocking"/>
            <set_value name="$state.$tradesRejectedAmount" exact="$tradesRejectedAmount"/>
            <set_value name="$state.$tradesRejectedDistance" exact="$tradesRejectedDistance"/>
            <!-- UNIVERSAL CACHE: No tradesRejectedBlacklist or sectorBlacklistCache - removed for universal processing -->
            <!-- OPTIMIZATION: Use library function to validate table before saving -->
            <run_actions ref="md.GT_Libraries_General.GT_ValidateTableSafe" result="$validTradesPerWare">
              <param name="table" value="$tradesPerWare"/>
            </run_actions>
            <set_value name="$state.$tradesPerWare" exact="$validTradesPerWare"/>
            <set_value name="$state.$bestRejectedProfit" exact="$bestRejectedProfit"/>
            <set_value name="$state.$bestRejectedTrade" exact="$bestRejectedTrade"/>
            
            <!-- Progress heartbeat for watchdog -->
            <set_value name="$state.$batchLastProgress" exact="player.age"/>

            <!-- Update global state using ship object as key -->
            <set_value name="global.$GT_BatchDataList.{$ship}" exact="$state"/>
            
            <!-- Check if more batches needed -->
            <!-- batchEnd1Based is exclusive (can be wareCount+1). If it's <= wareCount, there is more work. -->
            <do_if value="$batchEnd1Based le $wareCount and $tradeList.count lt $earlyExitThreshold">
              <!-- IMPORTANT: Always signal continuation directly.
                   Continuation handling is already done at the top of ProcessTradeMatchingBatch via ActiveShips,
                   and queueing here can deadlock when ActiveProcessors == MaxConcurrent (active ship can never finish). -->
              <!-- De-duped continuation scheduling (prevents overlapping continuation instances for same ship) -->
              <do_if value="not global.$GT_BatchContinuationScheduled?">
                <set_value name="global.$GT_BatchContinuationScheduled" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_BatchContinuationScheduled.{$ship}?">
                <set_value name="global.$GT_BatchContinuationScheduled.{$ship}" exact="true"/>
                <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ScheduleBatchContinuation" param="$ship"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- All batches complete - decrement active processors counter -->
              <!-- CRITICAL FIX: Decrement BEFORE removing from ActiveShips to maintain counter accuracy -->
              <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0">
                <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="subtract"/>
              </do_if>
              <!-- Remove ship from active ships list -->
              <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveShips?">
                <remove_from_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
              </do_if>
              <!-- Process next queued batch processor if any -->
              <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
                <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
              </do_if>
              
              <!-- All batches complete - signal completion -->
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Complete. Total: ' + $tradeList.count + ' trades (active: ' + (if global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? then global.$GT_BatchProcessorQueue.$ActiveProcessors else 0) + '/' + (if global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$MaxConcurrent? then global.$GT_BatchProcessorQueue.$MaxConcurrent else 1) + ')'" chance="100"/>
              </do_if>
              
              <!-- Pack results -->
              <set_value name="$results" exact="table[
                $ship = $ship,
                $tradeList = $tradeList,
                $crossStationBestTrade = $crossStationBestTrade,
                $crossStationBestScore = $crossStationBestScore,
                $nonConflictedBestTrade = $nonConflictedBestTrade,
                $nonConflictedBestScore = $nonConflictedBestScore,
                $tradesRejectedProfit = $tradesRejectedProfit,
                $tradesRejectedDocking = $tradesRejectedDocking,
                $tradesRejectedAmount = $tradesRejectedAmount,
                $tradesRejectedDistance = $tradesRejectedDistance,
                $bestRejectedProfit = $bestRejectedProfit,
                $bestRejectedTrade = $bestRejectedTrade
              ]"/>
              
              <!-- Store results in global TABLE for SearchLiveTrades_Resume to retrieve -->
              <!-- SIMPLIFIED: Initialization guarantees global.$GT_BatchResultsList exists -->
              <set_value name="global.$GT_BatchResultsList.{$ship}" exact="$results"/>
              
              <!-- NOTE: Don't clean up batch data yet - resume cue needs ship reference -->
              <!-- Cleanup happens in resume cue after extracting ship -->
              
              <!-- Signal SearchLiveTrades_Resume cue to continue processing (pass ship object) -->
              <signal_cue_instantly cue="md.GT_Trading_Search.SearchLiveTrades_Resume" param="$ship"/>
              
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Signalled waiting cue to resume'" chance="100"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>
      </actions>
    </cue>
    
    <!-- PERFORMANCE FIX: Process Batch Processor Queue - Use ActiveProcessors as atomic lock -->
    <cue name="ProcessBatchProcessorQueue" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- SERIALIZATION LOCK:
             Under large fleets, this cue can be signalled many times in the same frame.
             If multiple instances pass the "ActiveProcessors < MaxConcurrent" check before the started batch increments,
             ActiveProcessors can race to 2/1 and permanently block the queue.
             Lock ensures only one queue-processor instance runs its critical section at a time. -->
        <do_if value="not global.$GT_BatchProcessorQueue?">
          <set_value name="global.$GT_BatchProcessorQueue" exact="table[]"/>
        </do_if>
        <do_if value="global.$GT_BatchProcessorQueue.$QueueLock? and global.$GT_BatchProcessorQueue.$QueueLock == true">
          <cancel_cue cue="this"/>
        </do_if>
        <set_value name="global.$GT_BatchProcessorQueue.$QueueLock" exact="true"/>
        <set_value name="$lockAcquired" exact="true"/>

        <!-- CRITICAL FIX: Ensure global.$GT_BatchProcessorQueue exists and initialize required properties -->
        <!-- (queue already ensured above for lock) -->
        
        <do_if value="not global.$GT_BatchProcessorQueue.$Ships?">
          <set_value name="global.$GT_BatchProcessorQueue.$Ships" exact="[]"/>
        </do_if>
        
        <do_if value="not global.$GT_BatchProcessorQueue.$ActiveProcessors?">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="0"/>
        </do_if>
        <!-- Fix corrupted state from older versions (negative counter breaks concurrency gating) -->
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors lt 0">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="0"/>
        </do_if>
        
        <do_if value="not global.$GT_BatchProcessorQueue.$MaxConcurrent?">
          <!-- Read MaxConcurrent from global settings (defaults to 1 if not set) -->
          <set_value name="$maxConcurrentFromSettings" exact="1"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
          </do_if>
          <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
            <!-- Backwards compatibility -->
            <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
            <!-- Validate range (1-10) -->
            <do_if value="$maxConcurrentFromSettings lt 1">
              <set_value name="$maxConcurrentFromSettings" exact="1"/>
            </do_if>
            <do_if value="$maxConcurrentFromSettings gt 10">
              <set_value name="$maxConcurrentFromSettings" exact="10"/>
            </do_if>
          </do_elseif>
          <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
        </do_if>
        <!-- Update MaxConcurrent from global settings if it exists (allows runtime changes) -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
          <!-- Validate range (1-10) -->
          <do_if value="$maxConcurrentFromSettings lt 1">
            <set_value name="$maxConcurrentFromSettings" exact="1"/>
          </do_if>
          <do_if value="$maxConcurrentFromSettings gt 10">
            <set_value name="$maxConcurrentFromSettings" exact="10"/>
          </do_if>
          <!-- Update if different from current value -->
          <do_if value="global.$GT_BatchProcessorQueue.$MaxConcurrent != $maxConcurrentFromSettings">
            <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
          </do_if>
        </do_if>
        <do_elseif value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches?">
          <!-- Backwards compatibility -->
          <set_value name="$maxConcurrentFromSettings" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentSearches"/>
          <!-- Validate range (1-10) -->
          <do_if value="$maxConcurrentFromSettings lt 1">
            <set_value name="$maxConcurrentFromSettings" exact="1"/>
          </do_if>
          <do_if value="$maxConcurrentFromSettings gt 10">
            <set_value name="$maxConcurrentFromSettings" exact="10"/>
          </do_if>
          <!-- Update if different from current value -->
          <do_if value="global.$GT_BatchProcessorQueue.$MaxConcurrent != $maxConcurrentFromSettings">
            <set_value name="global.$GT_BatchProcessorQueue.$MaxConcurrent" exact="$maxConcurrentFromSettings"/>
          </do_if>
        </do_elseif>
        
        <do_if value="not global.$GT_BatchProcessorQueue.$ActiveShips?">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="[]"/>
        </do_if>
        
        <!-- CRITICAL FIX: Clean up stale entries proactively (ships without GT orders) -->
        <!-- This prevents queue from accumulating stale entries from save games -->
        <set_value name="$staleEntriesRemoved" exact="0"/>
        <do_if value="global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
          <do_all exact="global.$GT_BatchProcessorQueue.$Ships.count" counter="$i" reverse="true">
            <set_value name="$queuedShip" exact="global.$GT_BatchProcessorQueue.$Ships.{$i}"/>
            
            <!-- Check if ship is GT-controlled -->
            <run_actions ref="md.GT_Ship_State_Utilities.GT_IsGTControlled" result="$hasGTOrder">
              <param name="ship" value="$queuedShip"/>
            </run_actions>
            
            <!-- Remove stale entries (ships without GT orders) -->
            <do_if value="not $hasGTOrder">
              <remove_from_list name="global.$GT_BatchProcessorQueue.$Ships" exact="$queuedShip"/>
              <set_value name="$staleEntriesRemoved" operation="add"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Log cleanup if any stale entries were removed -->
        <do_if value="$staleEntriesRemoved gt 0">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] Cleaned up ' + $staleEntriesRemoved + ' stale queue entries (ships without GT orders)'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- CRITICAL FIX: Verify active processors are still valid -->
        <!-- Check if ActiveShips list contains ships that no longer have batch data or GT orders -->
        <set_value name="$staleActiveProcessorsRemoved" exact="0"/>
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips? and global.$GT_BatchProcessorQueue.$ActiveShips.count gt 0">
          <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$i" reverse="true">
            <set_value name="$activeShip" exact="global.$GT_BatchProcessorQueue.$ActiveShips.{$i}"/>
            <set_value name="$isValidActive" exact="false"/>
            
            <!-- DEBUG: Log which ship is being validated -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] Validating active processor: ' + $activeShip.idcode" chance="100"/>
            </do_if>
            
            <!-- Check if ship is GT-controlled -->
            <run_actions ref="md.GT_Ship_State_Utilities.GT_IsGTControlled" result="$hasGTOrder">
              <param name="ship" value="$activeShip"/>
            </run_actions>
            
            <!-- Check if ship still has batch data (processor is actually running) -->
            <set_value name="$hasBatchData" exact="false"/>
            <set_value name="$batchStartTime" exact="null"/>
            <do_if value="$hasGTOrder and global.$GT_BatchDataList? and global.$GT_BatchDataList.{$activeShip}?">
              <set_value name="$batchState" exact="@global.$GT_BatchDataList.{$activeShip}"/>
              <do_if value="$batchState?">
                <set_value name="$batchIdTest" exact="@$batchState.$batchId"/>
                <set_value name="$batchStartTime" exact="@$batchState.$batchStartTime"/>
                <do_if value="$batchIdTest?">
                  <set_value name="$hasBatchData" exact="true"/>
                  <set_value name="$isValidActive" exact="true"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- CRITICAL FIX: Check if ship is in maintenance -->
            <!-- Ships in maintenance shouldn't process batch data -->
            <set_value name="$isInMaintenance" exact="false"/>
            <do_if value="$isValidActive">
              <run_actions ref="md.GT_Ship_State_Utilities.GT_IsShipInMaintenance" result="$isInMaintenance">
                <param name="ship" value="$activeShip"/>
              </run_actions>
              <do_if value="$isInMaintenance">
                <set_value name="$isValidActive" exact="false"/>
              </do_if>
            </do_if>
            
            <!-- CRITICAL FIX: Detect truly-stuck processors (NO PROGRESS), not just "running for a long time".
                 Under big fleets, a valid batch can exceed 60s. Killing it while it still runs causes ships to wait forever
                 and triggers mass AI timeouts. We now track $batchLastProgress and only time out if there was no progress. -->
            <set_value name="$isTimedOut" exact="false"/>
            <do_if value="$isValidActive">
              <!-- Self-heal batchStartTime if missing -->
              <do_if value="(not $batchStartTime?) or ($batchStartTime == null)">
                <set_value name="global.$GT_BatchDataList.{$activeShip}.$batchStartTime" exact="player.age"/>
                <set_value name="$batchStartTime" exact="player.age"/>
              </do_if>

              <!-- Read last-progress heartbeat (written whenever state is saved) -->
              <set_value name="$batchLastProgress" exact="@$batchState.$batchLastProgress"/>
              <do_if value="(not $batchLastProgress?) or ($batchLastProgress == null)">
                <!-- Backwards compatibility: treat start time as last progress -->
                <set_value name="$batchLastProgress" exact="$batchStartTime"/>
                <set_value name="global.$GT_BatchDataList.{$activeShip}.$batchLastProgress" exact="$batchLastProgress"/>
              </do_if>

              <do_if value="$batchLastProgress? and $batchLastProgress != null">
                <set_value name="$elapsedNoProgress" exact="player.age - $batchLastProgress"/>
                <do_if value="$elapsedNoProgress gt 60s">
                  <set_value name="$isTimedOut" exact="true"/>
                  <set_value name="$isValidActive" exact="false"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Batch] Active processor TIMEOUT: ' + $activeShip.idcode + ' has made no progress for ' + ($elapsedNoProgress / 1s) + ' seconds - removing from active processors'" chance="100"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Remove stale active processors (no GT order, no batch data, in maintenance, or timed out) -->
            <do_if value="not $isValidActive">
              <remove_from_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$activeShip"/>
              <set_value name="$staleActiveProcessorsRemoved" operation="add"/>
              <!-- Decrement ActiveProcessors counter -->
              <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0">
                <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="subtract"/>
              </do_if>
              <!-- Clean up batch data for stale processor -->
              <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$activeShip}?">
                <remove_value name="global.$GT_BatchDataList.{$activeShip}"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Log cleanup if any stale active processors were removed -->
        <do_if value="$staleActiveProcessorsRemoved gt 0">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] Cleaned up ' + $staleActiveProcessorsRemoved + ' stale active processors (no GT order, no batch data, or in maintenance)'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- CRITICAL FIX: Ensure ActiveProcessors counter matches ActiveShips.count -->
        <!-- This MUST run BEFORE the concurrency check, otherwise stuck counters block the queue -->
        <!-- This prevents counter from getting stuck if cleanup logic fails -->
        <set_value name="$actualActiveCount" exact="0"/>
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips?">
          <set_value name="$actualActiveCount" exact="global.$GT_BatchProcessorQueue.$ActiveShips.count"/>
        </do_if>
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors != $actualActiveCount">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] Counter mismatch detected - ActiveProcessors=' + global.$GT_BatchProcessorQueue.$ActiveProcessors + ', ActiveShips.count=' + $actualActiveCount + ' - correcting'" chance="100"/>
          </do_if>
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="$actualActiveCount"/>
        </do_if>
        
        <!-- ATOMIC LOCK: Process if below max concurrent processors (prevents race conditions) -->
        <!-- NOTE: Counter validation above ensures ActiveProcessors is accurate before this check -->
        <do_if value="global.$GT_BatchProcessorQueue.$ActiveProcessors lt global.$GT_BatchProcessorQueue.$MaxConcurrent and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
          
          <!-- Get first ship from queue -->
          <set_value name="$ship" exact="global.$GT_BatchProcessorQueue.$Ships.{1}"/>
          <remove_from_list name="global.$GT_BatchProcessorQueue.$Ships" exact="$ship"/>
          
          <!-- PERFORMANCE FIX: Check GT order status before processing -->
          <!-- Skip ships that no longer have GT orders (prevents processing stale queue entries) -->
          <run_actions ref="md.GT_Ship_State_Utilities.GT_IsGTControlled" result="$isGTControlled">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Skip ships without GT orders and process next queued ship -->
          <do_if value="not $isGTControlled">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Skipping - ship no longer has GT order (queued: ' + global.$GT_BatchProcessorQueue.$Ships.count + ')'" chance="100"/>
            </do_if>
            <!-- Process next queued ship if any -->
            <do_if value="global.$GT_BatchProcessorQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship IS GT-controlled - proceed with batch processing -->
            <!-- ATOMIC RESERVATION:
                 Reserve the concurrency slot HERE (before signalling ProcessTradeMatchingBatch), so no other queue instance
                 can start another processor in the same frame. We also pre-add to ActiveShips so ProcessTradeMatchingBatch
                 treats this as a "continuation" and will NOT increment again. -->
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] (' + $ship.idcode + ') BATCH PROCESSOR QUEUED - starting (active: ' + global.$GT_BatchProcessorQueue.$ActiveProcessors + '/' + global.$GT_BatchProcessorQueue.$MaxConcurrent + ', queued: ' + global.$GT_BatchProcessorQueue.$Ships.count + ')'" chance="100"/>
            </do_if>

            <!-- Increment + mark active (dedupe ship in ActiveShips) -->
            <do_if value="not global.$GT_BatchProcessorQueue.$ActiveShips?">
              <set_value name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="[]"/>
            </do_if>
            <set_value name="$alreadyActive" exact="false"/>
            <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$i">
              <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips.{$i} == $ship">
                <set_value name="$alreadyActive" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            <do_if value="not $alreadyActive">
              <append_to_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
              <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="add"/>
            </do_if>
            
            <!-- Start the batch processor (will NOT increment again because ship is already active) -->
            <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessTradeMatchingBatch" param="$ship"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- Queue is blocked - check if counter is actually correct -->
          <!-- If ActiveProcessors >= MaxConcurrent but ActiveShips is empty or has invalid ships, counter is wrong -->
          <!-- Counter validation runs before the concurrency gate (1601+). If we get here, queue is legitimately blocked. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0 and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
            <debug_text text="'[GT-Batch] Batch processor in progress, skipping (active: ' + global.$GT_BatchProcessorQueue.$ActiveProcessors + ', queued: ' + global.$GT_BatchProcessorQueue.$Ships.count + ')'" chance="100"/>
          </do_if>
        </do_else>

        <!-- Release queue lock -->
        <do_if value="$lockAcquired">
          <set_value name="global.$GT_BatchProcessorQueue.$QueueLock" exact="false"/>
        </do_if>
      </actions>
    </cue>
    
  </cues>
</mdscript>