<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Trading_Search" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ========================================
         GALAXY TRADER MK3 - SEARCH ENGINE
         Core trade route search and matching logic
         ======================================== -->
    
    <!-- Search for Trade Routes (MAIN SEARCH ENGINE) -->
    <cue name="SearchTradeRoutes" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Receive parameters directly from event to prevent race conditions -->
        <!-- Handle case where SearchLiveTrades_Resume signals again after batch completion -->
        <set_value name="$params" exact="event.param"/>
        <do_if value="not $params?">
          <!-- Parameters not provided - try to get from search queue or batch data -->
          <!-- Note: With per-ship storage, we can't reconstruct ship from global.$GT_SearchResult -->
          <!-- Must rely on search queue params or batch data -->
          <set_value name="$shipFromQueue" exact="null"/>
          
          <do_if value="$shipFromQueue?">
            <!-- Try to get params from search queue -->
            <!-- Initialization guarantees global.$GT_SearchQueue exists -->
            <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$shipFromQueue}?">
              <set_value name="$params" exact="global.$GT_SearchQueue.$Params.{$shipFromQueue}"/>
            </do_if>
            <do_else>
              <!-- Reconstruct params from batch data (if still available) -->
              <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$shipFromQueue}"/>
              <do_if value="$batchData?">
                <set_value name="$allowIllegalDefault" exact="false"/>
                <set_value name="$params" exact="table[
                  $Ship = $shipFromQueue,
                  $MaxDistance = @$batchData.$maxDistance,
                  $MinROI = @$batchData.$minROI,
                  $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                  $FactionPriority = @$batchData.$factionPriority,
                  $AllowIllegal = $allowIllegalDefault
                ]"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>
        
        <!-- CRITICAL: Extract concurrency flags BEFORE validating params.
             If params are invalid, we still need to check if a counter was used and clean it up.
             This prevents counter leaks when ProcessSearchQueue increments ActiveSearches before calling SearchTradeRoutes. -->
        <set_value name="$useSearchQueueCounter" exact="false"/>
        <do_if value="$params? and $params.$UseSearchQueueCounter?">
          <set_value name="$useSearchQueueCounter" exact="$params.$UseSearchQueueCounter"/>
        </do_if>
        <set_value name="$fromLiveQueue" exact="false"/>
        <do_if value="$params? and $params.$FromLiveQueue? and $params.$FromLiveQueue == true">
          <set_value name="$fromLiveQueue" exact="true"/>
        </do_if>
        <!-- Extract ship reference safely for cleanup (may be null if params invalid) -->
        <set_value name="$shipForCleanup" exact="null"/>
        <do_if value="$params? and $params.$Ship?">
          <set_value name="$shipForCleanup" exact="$params.$Ship"/>
        </do_if>
        
        <!-- Validate params exist and are not null -->
        <!-- Check if $params exists AND has required $Ship property (handles null case) -->
        <set_value name="$paramsValid" exact="false"/>
        <do_if value="$params?">
          <set_value name="$testShip" exact="@$params.$Ship"/>
          <do_if value="$testShip?">
            <set_value name="$paramsValid" exact="true"/>
          </do_if>
        </do_if>
        
        <do_if value="not $paramsValid">
          <!-- Only log when debug is enabled -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchTradeRoutes called without valid parameters - cannot proceed'" chance="100"/>
          </do_if>
          
          <!-- CRITICAL FIX: Release search lock if ship is valid (lock was acquired before SearchTradeRoutes was called) -->
          <do_if value="$params? and $params.$Ship? and $params.$Ship.exists">
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$params.$Ship"/>
              <param name="reason" value="'invalid_params'"/>
            </run_actions>
          </do_if>
          
          <!-- CRITICAL FIX: If counter was used, decrement it before canceling to prevent leak -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] Invalid params - decremented ActiveSearches counter (was: ' + (if global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? then global.$GT_SearchQueue.$ActiveSearches + 1 else 'unknown') + ')'" chance="100"/>
            </do_if>
          </do_if>
          
          <cancel_cue cue="this"/>
        </do_if>

        <!-- IMPORTANT: In X4 MD, cancel_cue does NOT reliably stop the current actions block.
             Gate the remainder of this cue on $paramsValid to prevent fallthrough on invalid params. -->
        <do_if value="$paramsValid">
        
        <!-- CRITICAL: Extract ship for GT order validation -->
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- Extract trace ID for logging -->
        <set_value name="$traceId" exact="''"/>
        <do_if value="$params? and $params.$TraceId?">
          <set_value name="$traceId" exact="$params.$TraceId"/>
        </do_if>
        
        <!-- CRITICAL: Validate ship has GT order BEFORE any search processing -->
        <!-- Trade searches should NEVER happen if ship isn't GT controlled -->
        <set_value name="$hasGTOrder" exact="false"/>
        <do_if value="$ship.defaultorder? and @$ship.defaultorder.id == 'GalaxyTraderMK3'">
          <set_value name="$hasGTOrder" exact="true"/>
        </do_if>
        <do_else>
          <!-- Check if ship is subordinate with commander that has GT order -->
          <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
            <do_if value="$ship.commander.defaultorder? and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
              <set_value name="$hasGTOrder" exact="true"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- Abort search if ship doesn't have GT order -->
        <do_if value="not $hasGTOrder">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Ship does not have GT order - aborting search immediately'" chance="100"/>
          </do_if>
          
          <!-- Release search lock -->
          <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
            <param name="ship" value="$ship"/>
            <param name="reason" value="'no_gt_order'"/>
          </run_actions>
          
          <!-- CRITICAL FIX: If counter was used, decrement it before canceling to prevent leak -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
          </do_if>
          
          <!-- Signal no trade found to AI script -->
          <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'no_gt_order'"/>
          
          <cancel_cue cue="this"/>
        </do_if>

        <!-- IMPORTANT: In X4 MD, cancel_cue does NOT reliably stop the current actions block.
             Gate the remainder of this cue on $hasGTOrder to prevent fallthrough after aborting. -->
        <do_if value="$hasGTOrder">
        
        <!-- Check batch status FIRST, before ANY other processing -->
        <!-- If batch is in progress FOR THIS SHIP, exit IMMEDIATELY - don't do ANY processing -->
        <!-- This prevents race conditions where SearchTradeRoutes continues executing after SearchLiveTrades starts batch processing -->
        <!-- Use library function for batch status checking -->
        <run_actions ref="md.GT_Libraries_General.GT_CheckBatchStatus" result="$batchStatus">
          <param name="ship" value="$params.$Ship"/>
        </run_actions>
        <set_value name="$waitingForBatch" exact="$batchStatus.$IsBatchActive"/>
        <set_value name="$batchShip" exact="$batchStatus.$BatchShip"/>
        <set_value name="$shouldProceed" exact="$batchStatus.$ShouldProceed"/>

        <!-- CRITICAL:
             If a live search is already in progress for this ship, do NOT proceed with a fresh SearchTradeRoutes run.
             Reason: In MD, cancel_cue does not abort the current actions block immediately; the cue can still fall through
             and incorrectly signal GT_No_Trade_Found during the cache-miss cooldown window (seen for EDS-278).
             Live completion runs with explicit SearchState='live'/'fallback' and will not have live-state present. -->
        <set_value name="$searchStateParam" exact="@$params.$SearchState"/>
        <do_if value="$shouldProceed and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$params.$Ship}? and not ($searchStateParam == 'live' or $searchStateParam == 'fallback')">
          <!-- Distinguish real in-progress live search from stale leftover state.
               Real in-progress searches can be in multiple phases:
               - pathfinding queued/running (before batch markers exist),
               - batch work queued/running,
               - waiting for batch completion marker.
               Only clear state if it's OLD and there are no progress markers. -->
          <set_value name="$hasWaitingForBatchMarker" exact="false"/>
          <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.{$params.$Ship}? and global.$GT_SearchResult.{$params.$Ship}.$WaitingForBatch? and global.$GT_SearchResult.{$params.$Ship}.$WaitingForBatch == true">
            <set_value name="$hasWaitingForBatchMarker" exact="true"/>
          </do_if>
          <set_value name="$hasBatchData" exact="false"/>
          <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$params.$Ship}?">
            <set_value name="$hasBatchData" exact="true"/>
          </do_if>
          <set_value name="$hasPathfinding" exact="false"/>
          <do_if value="global.$GT_PathfindingQueue? and global.$GT_PathfindingQueue.$ActiveShips?">
            <do_all exact="global.$GT_PathfindingQueue.$ActiveShips.count" counter="$i">
              <do_if value="global.$GT_PathfindingQueue.$ActiveShips.{$i} == $params.$Ship">
                <set_value name="$hasPathfinding" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="not $hasPathfinding and global.$GT_PathfindingQueue? and global.$GT_PathfindingQueue.$Requests?">
            <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$i">
              <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$i}"/>
              <do_if value="$req? and $req.$Ship? and $req.$Ship == $params.$Ship">
                <set_value name="$hasPathfinding" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>

          <set_value name="$stateStarted" exact="null"/>
          <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$params.$Ship}? and global.$GT_SearchLiveTrades_State.{$params.$Ship}.$Started?">
            <set_value name="$stateStarted" exact="global.$GT_SearchLiveTrades_State.{$params.$Ship}.$Started"/>
          </do_if>
          <set_value name="$stateAge" exact="-1"/>
          <do_if value="$stateStarted?">
            <set_value name="$stateAge" exact="player.age - $stateStarted"/>
          </do_if>
          
          <!-- STALE GUARD (MISSING START TIME):
               Some stuck live-search states can retain progress markers but lose/never set .$Started.
               Without a valid $stateAge, the normal stale guards won't fire, causing permanent "in progress" blocking.
               Treat "no Started timestamp" as stale and clear the state so the ship can start a fresh search. -->
          <do_if value="$stateAge lt 0">
            <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
            
            <!-- Also clear any stale pathfinding markers for this ship (queue entries can outlive the state and block new searches) -->
            <do_if value="global.$GT_PathfindingQueue?">
              <!-- Remove from active ships and decrement counter if needed -->
              <do_if value="global.$GT_PathfindingQueue.$ActiveShips?">
                <do_all exact="global.$GT_PathfindingQueue.$ActiveShips.count" counter="$pi" reverse="true">
                  <do_if value="global.$GT_PathfindingQueue.$ActiveShips.{$pi} == $params.$Ship">
                    <remove_from_list name="global.$GT_PathfindingQueue.$ActiveShips" exact="$params.$Ship"/>
                    <do_if value="global.$GT_PathfindingQueue.$ActiveInstances? and global.$GT_PathfindingQueue.$ActiveInstances gt 0">
                      <set_value name="global.$GT_PathfindingQueue.$ActiveInstances" operation="subtract"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
              <!-- Remove queued requests for this ship -->
              <do_if value="global.$GT_PathfindingQueue.$Requests?">
                <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$qi" reverse="true">
                  <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$qi}"/>
                  <do_if value="$req? and $req.$Ship? and $req.$Ship == $params.$Ship">
                    <remove_from_list name="global.$GT_PathfindingQueue.$Requests" exact="$req"/>
                  </do_if>
                </do_all>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Clearing STALE live-search state (pre-gate) - missing .$Started timestamp (was blocking new requests)'" chance="100"/>
            </do_if>
          </do_if>

          <!-- HARD STALE GUARD:
               Even if progress markers exist, a live-search state can get stuck (e.g. lost completion signal).
               If it's too old, clear it so fresh requests don't stall indefinitely. -->
          <do_if value="$stateAge gt 300s">
            <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
            
            <!-- Also clear stale pathfinding queue/markers for this ship.
                 Otherwise $hasPathfinding stays true and the pre-gate will still treat it as "in progress" forever. -->
            <do_if value="global.$GT_PathfindingQueue?">
              <do_if value="global.$GT_PathfindingQueue.$ActiveShips?">
                <do_all exact="global.$GT_PathfindingQueue.$ActiveShips.count" counter="$pi" reverse="true">
                  <do_if value="global.$GT_PathfindingQueue.$ActiveShips.{$pi} == $params.$Ship">
                    <remove_from_list name="global.$GT_PathfindingQueue.$ActiveShips" exact="$params.$Ship"/>
                    <do_if value="global.$GT_PathfindingQueue.$ActiveInstances? and global.$GT_PathfindingQueue.$ActiveInstances gt 0">
                      <set_value name="global.$GT_PathfindingQueue.$ActiveInstances" operation="subtract"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
              <do_if value="global.$GT_PathfindingQueue.$Requests?">
                <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$qi" reverse="true">
                  <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$qi}"/>
                  <do_if value="$req? and $req.$Ship? and $req.$Ship == $params.$Ship">
                    <remove_from_list name="global.$GT_PathfindingQueue.$Requests" exact="$req"/>
                  </do_if>
                </do_all>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Clearing STALE live-search state (pre-gate HARD) - stateAge=' + $stateAge + ' (was blocking new requests)'" chance="100"/>
            </do_if>
          </do_if>

          <!-- If no markers: only clear if state is old enough to be genuinely stale. -->
          <do_if value="not $hasWaitingForBatchMarker and not $hasBatchData and not $hasPathfinding and ($stateAge lt 0 or $stateAge gt 120s)">
            <!-- Stale: clear and continue normally -->
            <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Clearing STALE live-search state (pre-gate) - no progress markers (pathfinding/batch) and stateAge=' + $stateAge" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Real in-progress: skip this fresh SearchTradeRoutes run -->
            <!-- CRITICAL: Do NOT release the lock here - live search is still running and needs it to signal back -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Live search already in progress (pre-gate) - skipping SearchTradeRoutes execution (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>

            <!-- IMPORTANT: If this invocation consumed a cache-search queue slot, release it immediately.
                 We must NOT delete per-ship params here because live search/batch needs them for continuation. -->
            <do_if value="$useSearchQueueCounter">
              <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
                <param name="clampToZero" value="true"/>
                <param name="triggerQueueProcessor" value="true"/>
              </run_actions>
              <!-- Prevent any later cleanup block (if reached) from double-decrementing -->
              <set_value name="$useSearchQueueCounter" exact="false"/>
            </do_if>

            <set_value name="$shouldProceed" exact="false"/>
            
            <!-- CRITICAL: Do NOT release lock here - live search is genuinely in progress and needs the lock
                 to signal back to SearchTradeRoutes when it completes. The lock will be released when:
                 - Live search completes (FilterTradeList_Resume signals SearchTradeRoutes with results)
                 - Live search fails (SearchLiveTrades_Resume signals GT_No_Trade_Found)
                 - State becomes stale (handled in stale guard blocks above) -->
            
            <cancel_cue cue="this"/>
          </do_else>
        </do_if>
        
        <!-- Only exit if batch is in progress FOR THIS SHIP -->
        <!-- If batch is for a different ship, proceed normally -->
        <do_if value="$waitingForBatch and $batchStatus.$IsForThisShip">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ')    Batch processing in progress FOR THIS SHIP - waiting for completion (will resume when batch completes)'" chance="100"/>
          </do_if>

          <!-- IMPORTANT: If this invocation consumed a cache-search queue slot, release it immediately.
               This branch can be hit by duplicate signals while the batch processor is working, and without releasing
               the cache-search slot we can leak ActiveSearches → ProcessSearchQueue pins at max (active: 5) and stalls. -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
            <!-- Prevent any later cleanup (if reached) from double-decrementing -->
            <set_value name="$useSearchQueueCounter" exact="false"/>
          </do_if>

          <!-- CRITICAL FIX: Check for stale lock before retaining for async continuation -->
          <set_value name="$lockTime" exact="null"/>
          <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$params.$Ship}?">
            <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$params.$Ship}"/>
          </do_if>
          <set_value name="$lockStale" exact="false"/>
          <do_if value="$lockTime?">
            <set_value name="$lockAge" exact="player.age - $lockTime"/>
            <do_if value="$lockAge gt 60">
              <!-- Lock is stale - release it instead of retaining for continuation -->
              <set_value name="$lockStale" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ')    Lock is stale (age: ' + $lockAge + 's) - releasing instead of waiting for batch'" chance="100"/>
              </do_if>
              <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
              <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                <param name="ship" value="$params.$Ship"/>
                <param name="reason" value="'stale_lock_before_batch'"/>
              </run_actions>
            </do_if>
          </do_if>
          
          <!-- Exit - SearchLiveTrades_Resume will signal this cue again when results are ready (unless lock is stale) -->
          <do_if value="not $lockStale">
            <cancel_cue cue="this"/>
          </do_if>
        </do_if>
        <do_elseif value="$waitingForBatch and not $batchStatus.$IsForThisShip">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Batch processing in progress FOR DIFFERENT SHIP (' + (if $batchShip != null then @$batchShip.idcode else 'UNKNOWN') + ') - proceeding normally'" chance="100"/>
          </do_if>
        </do_elseif>
        
        <do_if value="$shouldProceed">
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="@$params.$MaxDistance"/>
        <set_value name="$minROI" exact="@$params.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="@$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="@$params.$FactionPriority"/>

        <!-- Concurrency flags -->
        <!-- Cache concurrency is managed by GT_SearchQueue; live searches are scheduled via scheduler HomeSearch work items (per-home-sector exclusivity) -->
        <set_value name="$useSearchQueueCounter" exact="false"/>
        <!-- IMPORTANT:
             Do NOT infer "slot acquired" from presence of global.$GT_SearchQueue.$Params.{$ship}.
             $Params can exist for queued ships that never acquired a slot; decrementing ActiveSearches in those cases
             will drive it negative over time (seen: active: -47630/10). -->
        <do_if value="$params.$UseSearchQueueCounter?">
          <set_value name="$useSearchQueueCounter" exact="$params.$UseSearchQueueCounter"/>
        </do_if>
        <set_value name="$fromLiveQueue" exact="false"/>
        <do_if value="$params.$FromLiveQueue? and $params.$FromLiveQueue == true">
          <set_value name="$fromLiveQueue" exact="true"/>
        </do_if>
        
        <!-- Validate maxDistance - must not be null (fail loudly, no fallback) -->
        <do_if value="$maxDistance == null">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] ERROR: (' + $ship.idcode + ') MaxDistance is null or invalid (' + $maxDistance + ') - cannot proceed without valid distance parameter!'" chance="100"/>
          </do_if>
          <!-- CRITICAL FIX: Release search lock before exiting -->
          <do_if value="$ship? and $ship.exists">
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'invalid_maxdistance'"/>
            </run_actions>
          </do_if>
          <!-- CRITICAL: If this run consumed a cache-search queue slot, release it now (prevents ActiveSearches leaks). -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
            <set_value name="$useSearchQueueCounter" exact="false"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        <do_elseif value="$maxDistance lt 0">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] ERROR: (' + $ship.idcode + ') MaxDistance is null or invalid (' + $maxDistance + ') - cannot proceed without valid distance parameter!'" chance="100"/>
          </do_if>
          <!-- CRITICAL FIX: Release search lock before exiting -->
          <do_if value="$ship? and $ship.exists">
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'invalid_maxdistance'"/>
            </run_actions>
          </do_if>
          <!-- CRITICAL: If this run consumed a cache-search queue slot, release it now (prevents ActiveSearches leaks). -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
            <set_value name="$useSearchQueueCounter" exact="false"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_elseif>
        
        <!-- Log profit threshold from params -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Profit threshold from params: ' + ($minAbsoluteProfit / 100) + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- EXPLICIT STATE ENUM: Determine search state from params or infer from context -->
        <!-- SearchState values: 'fresh' (new search), 'cache' (cache results), 'live' (live search continuation), 'fallback' (fallback continuation) -->
        <!-- IMPORTANT: In MD, "var?" can behave as true even when the value is null (it means "is defined"),
             so explicitly normalize null → treat as missing and infer state. -->
        <set_value name="$searchState" exact="@$params.$SearchState"/>
        <do_if value="$searchState == null">
          <remove_value name="$searchState"/>
        </do_if>
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance -->
        <do_if value="$params.$OriginalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$params.$OriginalMaxDistance"/>
        </do_if>
        
        <!-- If SearchState not provided, infer from context (backward compatibility) -->
        <do_if value="not $searchState?">
          <!-- Check if we're continuing from live search completion -->
          <set_value name="$savedWaitingForBatch" exact="true"/>
          <do_if value="global.$GT_SearchResult.{$ship}?">
            <set_value name="$shipResults" exact="global.$GT_SearchResult.{$ship}"/>
            <set_value name="$savedWaitingForBatch" exact="@$shipResults.$WaitingForBatch"/>
            <do_if value="not $savedWaitingForBatch">
              <!-- Live search just completed - check if fallback -->
              <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                <set_value name="$searchState" exact="'fallback'"/>
              </do_if>
              <do_else>
                <set_value name="$searchState" exact="'live'"/>
              </do_else>
            </do_if>
            <do_else>
              <!-- Still waiting for batch or cache search - check cache results -->
              <set_value name="$cacheFound" exact="@$shipResults.$Found"/>
              <do_if value="$cacheFound">
                <set_value name="$searchState" exact="'cache'"/>
              </do_if>
              <do_else>
                <set_value name="$searchState" exact="'fresh'"/>
              </do_else>
            </do_else>
          </do_if>
          <do_else>
            <!-- No results yet - fresh search -->
            <set_value name="$searchState" exact="'fresh'"/>
          </do_else>
        </do_if>
        
        <!-- Debug state detection -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') SearchState=' + $searchState + ' (originalMaxDistance=' + $originalMaxDistance + ', maxDistance=' + $maxDistance + ')'" chance="100"/>
        </do_if>

        <!-- CRITICAL:
             If a live search is already in progress for this ship, exit immediately.
             Otherwise a second SearchTradeRoutes instance can run during the cache-miss cooldown window
             and incorrectly signal GT_No_Trade_Found while the async live-search/batch pipeline is still running
             (this is exactly what happens for EDS-278 in the log at 1669.86). -->
        <do_if value="$searchState == 'fresh' and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <!-- Check if state is stale (> 60 seconds old) - if so, clear it and release lock -->
          <set_value name="$stateStarted" exact="null"/>
          <do_if value="global.$GT_SearchLiveTrades_State.{$ship}.$Started?">
            <set_value name="$stateStarted" exact="global.$GT_SearchLiveTrades_State.{$ship}.$Started"/>
          </do_if>
          <set_value name="$stateAge" exact="-1"/>
          <do_if value="$stateStarted?">
            <set_value name="$stateAge" exact="player.age - $stateStarted"/>
          </do_if>
          
          <!-- CRITICAL FIX: Reduce stale threshold from 60s to 30s to prevent ships from waiting too long -->
          <!-- Batch processing can take time, but if it's been >30s without completion, something is likely stuck -->
          <do_if value="$stateAge gt 30 or $stateAge lt 0">
            <!-- State is stale or missing Started timestamp - clear it and release lock -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Live search state is stale (age: ' + $stateAge + 's) - clearing state and releasing lock'" chance="100"/>
            </do_if>
            <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$ship"/>
              <param name="reason" value="'stale_live_search_state'"/>
            </run_actions>
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- State is fresh - wait for continuation -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Live search already in progress - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_else>
        </do_if>
        
        <!-- Clear fallback flag at start of new search cycle -->
        <!-- This allows fallback to be attempted again if cache and live search both fail -->
        <!-- BUT: Don't clear if this is a fallback continuation -->
          <do_if value="global.$GT_FallbackAttempted.{$ship}? and $searchState != 'fallback'">
          <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Starting new search cycle - cleared fallback flag'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Clear logbook flag ONLY when starting a completely new search (not from continuation) -->
        <do_if value="global.$GT_FallbackLogbookWritten.{$ship}? and $searchState == 'fresh'">
          <remove_value name="global.$GT_FallbackLogbookWritten.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cleared logbook flag - new search request detected'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Create faction priority text for debug output -->
        <run_actions ref="md.GT_Libraries_General.GT_GetFactionPriorityText" result="$factionPriorityText">
          <param name="factionPriority" value="$factionPriority"/>
        </run_actions>
        
        <!-- Get distance penalty setting (0-100% converted to 0.0-2.0 multiplier) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetDistancePenaltyMultiplier" result="$distancePenaltyMultiplier">
          <param name="ship" value="$ship"/>
        </run_actions>

        <!-- Resolve pilot skill and apply feature gates + level-based thresholds -->
        <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$skillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>

        <!-- Feature gates by skill level -->
        <set_value name="$gt_ThreatIntel" exact="$skillLevel ge 6"/>
        <set_value name="$gt_SatelliteIntel" exact="$skillLevel ge 9"/>
        <set_value name="$gt_FleetCoord" exact="$skillLevel ge 12"/>
        <set_value name="$gt_AdvancedAnalytics" exact="$skillLevel ge 15"/>
        
        <!-- Profit threshold is now pilot level-based (set in gt_trading_queue.xml) -->
        <!-- Level 1: 0 Cr, Level 2: 100 Cr, Level 3: 500 Cr, Level 4+: Config value with skill multiplier -->
        <!-- Params already contain the correct pilot level-based threshold, so no need to apply multiplier here -->
        <!-- ROI multiplier still applies for ROI threshold (not profit threshold) -->
        <!-- Only apply ROI multiplier if NOT a fallback continuation -->
        <!-- Fallback continuation params come from SearchFallbackTrades which already relaxed the already-multiplied values -->
        <do_if value="$searchState != 'fallback'">
          <run_actions ref="md.GT_Libraries_General.GT_GetSkillMultiplier" result="$roiMultiplier">
            <param name="skillLevel" value="$skillLevel"/>
          </run_actions>
          <set_value name="$minROI" exact="$minROI * $roiMultiplier"/>
          <!-- Note: $minAbsoluteProfit is already set correctly from params (pilot level-based) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') [OK] Profit threshold unchanged (pilot level-based): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI multiplier applied: ' + $minROI + '% (multiplier: ' + $roiMultiplier + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fallback continuation - params already have relaxed thresholds -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Profit threshold from fallback continuation (already relaxed): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI: ' + $minROI + '%'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- Log search start for detailed diagnostics (debug mode only) -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$pilotInfo" exact="'No Pilot'"/>
          <do_if value="$ship.pilot">
            <set_value name="$shownSkill" exact="1"/>
            <do_if value="global.$GT_Pilots.{$ship.pilot}? and global.$GT_Pilots.{$ship.pilot}.$Level?">
              <set_value name="$shownSkill" exact="global.$GT_Pilots.{$ship.pilot}.$Level"/>
            </do_if>
            <do_elseif value="$ship.pilot.skill.management?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.management"/>
            </do_elseif>
            <do_elseif value="$ship.pilot.skill.piloting?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.piloting"/>
            </do_elseif>
            <set_value name="$pilotInfo" exact="$ship.pilot.name + ' (Skill: ' + $shownSkill + ')'"/>
          </do_if>
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') === TRADE SEARCH START ===' + 
            '\nShip: ' + $ship.knownname + 
            '\nPilot: ' + $pilotInfo + 
            '\nCurrent Sector: ' + $ship.sector.knownname + 
            '\nMax Distance: ' + $maxDistance + ' jumps' + 
            '\nMin ROI: ' + $minROI + '%' + 
            '\nMin Absolute Profit: ' + ($minAbsoluteProfit / 100) + ' Cr' + 
            '\nShip Cargo: ' + ($ship.cargo.capacity.all - $ship.cargo.free.all) + '/' + $ship.cargo.capacity.all +
            '\nFaction Priority: ' + $factionPriorityText" 
            chance="100"/>
        </do_if>
        
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$foundCachedTrade" exact="false"/>
        <!-- Note: $fallbackSearchTriggered is set earlier based on SearchState - don't reset it here! -->

        <!-- V2: Ensure these are always initialized BEFORE the cache/live branching.
             They are used by the lightweight cache picker and live-search coalescing logic. -->
        <set_value name="$homeSector" exact="null"/>
        <run_actions ref="md.GT_Libraries_General.GT_GetHomeSector" result="$homeSector">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- CRITICAL: Abort search if home sector cannot be determined (prevents drift) -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cannot determine home sector - aborting search to prevent drift'" chance="100"/>
          </do_if>
          <!-- Release lock and abort -->
          <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
            <param name="ship" value="$ship"/>
            <param name="reason" value="'no_home_sector'"/>
          </run_actions>
          <cancel_cue cue="this"/>
        </do_if>

        <set_value name="$ignoreCarrierAux" exact="false"/>
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux?">
          <set_value name="$ignoreCarrierAux" exact="global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux"/>
        </do_if>
        <set_value name="$ignoreBuildStorage" exact="false"/>
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage?">
          <set_value name="$ignoreBuildStorage" exact="global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage"/>
        </do_if>
        
        <!-- Clear logbook flag when new normal search cycle starts -->
        <!-- This allows logbook message to be written again for new fallback attempts -->
        <!-- BUT: Don't clear if this is a continuation (fallback or live search) -->
        <!-- Note: Already handled above in state detection section -->
        
        <!-- Extract live search results if continuation (already detected earlier) -->
        <!-- When SearchLiveTrades_Resume signals SearchTradeRoutes, live results are already in global.$GT_SearchResult -->
        <!-- We should use those results instead of running cache search again -->
        <!-- Extract and preserve live results IMMEDIATELY before cache search can overwrite them -->
        <!-- SearchState is already set earlier (before skill multiplier) - use it to determine continuation -->
        <set_value name="$liveTradeList" exact="[]"/>
        <set_value name="$liveBestTrade" exact="null"/>
        <set_value name="$liveBestScore" exact="0"/>
        
        <!-- Initialize fallback trigger flag - set to true if this IS a fallback continuation (prevents re-triggering) -->
        <!-- This prevents infinite loops when SearchState='fallback' -->
        <set_value name="$fallbackSearchTriggered" exact="false"/>
        <do_if value="$searchState == 'fallback'">
          <!-- This IS a fallback continuation - mark as triggered to prevent infinite loop -->
          <set_value name="$fallbackSearchTriggered" exact="true"/>
        </do_if>
        
        <!-- Extract live search results if this is a live or fallback continuation -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <set_value name="$savedTradeList" exact="[]"/>
          <set_value name="$savedTradeListTemp" exact="@global.$GT_SearchResult.{$ship}.$TradeList"/>
          <do_if value="$savedTradeListTemp?">
            <set_value name="$tempCount" exact="@$savedTradeListTemp.count"/>
            <do_if value="$tempCount?">
              <set_value name="$savedTradeList" exact="$savedTradeListTemp"/>
            </do_if>
          </do_if>
          <set_value name="$liveTradeList" exact="$savedTradeList"/>
          <!-- SAFETY: ensure list is never null (prevents .count property lookup crash) -->
          <do_if value="$liveTradeList == null">
            <set_value name="$liveTradeList" exact="[]"/>
          </do_if>
          <set_value name="$liveBestTrade" exact="@global.$GT_SearchResult.{$ship}.$BestTrade"/>
          <set_value name="$liveBestScore" exact="@global.$GT_SearchResult.{$ship}.$BestScore"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$liveTradeCount" exact="0"/>
            <do_if value="$liveTradeList != null">
              <set_value name="$liveTradeCount" exact="$liveTradeList.count"/>
            </do_if>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Using live search results (' + $liveTradeCount + ' trades, state=' + $searchState + ', fallbackTriggered=' + $fallbackSearchTriggered + ')'" chance="100"/>
          </do_if>
        </do_if>
        

        
        <!-- Check trade cache with age validation -->
        <!-- Only run cache search if NOT continuing from live search AND NOT forcing live search -->
        <set_value name="$cacheChecked" exact="false"/>
        <set_value name="$cacheCount" exact="0"/>
        <set_value name="$cacheTradeList" exact="[]"/>
        <set_value name="$cacheBestTrade" exact="null"/>
        <set_value name="$cacheBestScore" exact="0"/>
        
        <!-- Check if ForceLiveSearch flag is set (AI rejected all cached trades) -->
        <set_value name="$forceLiveSearch" exact="@$params.$ForceLiveSearch"/>

        <!-- ISOLATED POLICY:
             Isolated ships should do their own cheap 1-sector live search and must NOT rely on cached data.
             Rationale: isolated-mode relaxed profit filtering should not “poison” the global cache and the isolated search scope is tiny. -->
        <set_value name="$skipCacheBecauseIsolated" exact="false"/>
        <set_value name="$shipIsIsolatedForCachePolicy" exact="false"/>
        <set_value name="$blacklistgroupForCachePolicy" exact="null"/>
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroupForCachePolicy">
          <param name="ship" value="$ship"/>
        </run_actions>
        <do_if value="$ship.sector? and $blacklistgroupForCachePolicy?">
          <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckConnectedSectorsBlacklisted" result="$isolationCheckForCachePolicy">
            <param name="sector" value="$ship.sector"/>
            <param name="ship" value="$ship"/>
            <param name="blacklistgroup" value="$blacklistgroupForCachePolicy"/>
            <param name="returnDetails" value="false"/>
          </run_actions>
          <set_value name="$isolatedValue" exact="@$isolationCheckForCachePolicy.$IsIsolated"/>
          <do_if value="$isolatedValue? and ($isolatedValue == true or $isolatedValue == 1)">
            <set_value name="$shipIsIsolatedForCachePolicy" exact="true"/>
            
            <!-- CRITICAL: Immediately set the global flag and trigger name update -->
            <!-- We already know the ship is isolated from GT_CheckConnectedSectorsBlacklisted, so set flag directly -->
            <do_if value="not global.$GT_IsolatedTradeActive?">
              <set_value name="global.$GT_IsolatedTradeActive" exact="table[]"/>
            </do_if>
            <set_value name="global.$GT_IsolatedTradeActive.{$ship}" exact="true"/>
            
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ISOLATION DETECTED EARLY: Set global.$GT_IsolatedTradeActive.{$ship} = true'" chance="100"/>
            </do_if>
            
            <!-- Trigger ship name update immediately -->
            <set_value name="$pilot" exact="@$ship.pilot"/>
            <do_if value="$pilot? and $pilot.exists">
              <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$pilot}.$XP"/>
              <do_if value="not $pilotXP?">
                <set_value name="$pilotXP" exact="0"/>
              </do_if>
              <set_value name="$skillLevel" exact="1"/>
              <do_all exact="15" counter="$lvl">
                <do_if value="$pilotXP ge global.$GT_Config.$XP.$SkillThresholds.{$lvl}">
                  <set_value name="$skillLevel" exact="$lvl"/>
                </do_if>
              </do_all>
              <set_value name="$rankTitle" exact="'Lehrling'"/>
              <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
                <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
                <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                  <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
                </do_if>
                <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                  <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
                </do_if>
              </do_if>
              
              <!-- Signal ship name update with isolated nameType -->
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship = $ship,
                $pilot = $pilot,
                $xp = $pilotXP,
                $level = $skillLevel,
                $rank = $rankTitle,
                $nameType = 'isolated'
              ]"/>
              
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') ISOLATION DETECTED EARLY: Triggered ship name update with nameType=isolated'" chance="100"/>
              </do_if>
            </do_if>
            <do_else>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') ISOLATION DETECTED EARLY: Cannot trigger name update - pilot missing (pilot=' + (if $pilot? then 'exists' else 'null') + ', exists=' + (if $pilot.exists then 'yes' else 'no') + ')'" chance="100"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>
        <do_if value="$shipIsIsolatedForCachePolicy and $searchState == 'fresh'">
          <set_value name="$skipCacheBecauseIsolated" exact="true"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ISOLATED: bypassing cache and running own live search (1-sector scope)'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Cache continuation: scheduler CacheQuery already completed and re-signalled us -->
        <set_value name="$cacheContinuation" exact="false"/>
        <do_if value="$params.$CacheContinuation? and $params.$CacheContinuation == true">
          <set_value name="$cacheContinuation" exact="true"/>
        </do_if>
        <!-- If we intentionally bypass cache (isolated policy), treat cache phase as complete so the cue can proceed. -->
        <do_if value="$skipCacheBecauseIsolated and $searchState == 'fresh'">
          <set_value name="$cacheContinuation" exact="true"/>
        </do_if>
        
        <!-- Only check cache if this is a fresh search (not live/fallback continuation) -->
        <do_if value="$searchState == 'fresh' and not $forceLiveSearch and not $skipCacheBecauseIsolated">
          <!-- Phase 4: Use scheduler for cache query instead of direct call -->
          <!-- Check if cache result already provided (from scheduler continuation) -->
          <set_value name="$cacheResultFromScheduler" exact="@$params.$CacheResult"/>
          <do_if value="$cacheResultFromScheduler? and $cacheResultFromScheduler != null">
            <!-- Cache query completed via scheduler - extract results -->
            <set_value name="$cachePick" exact="$cacheResultFromScheduler"/>
            <set_value name="$foundCachedTrade" exact="false"/>
            <set_value name="$cacheBestTrade" exact="null"/>
            <set_value name="$cacheBestScore" exact="0"/>
            <set_value name="$cacheTradeList" exact="[]"/>
            
            <!-- CRITICAL: Check that cachePick is not null before accessing properties -->
            <do_if value="$cachePick != null and $cachePick.$Found?">
              <set_value name="$cacheBestTrade" exact="@$cachePick.$Trade"/>
              <set_value name="$cacheBestScore" exact="@$cachePick.$BestScore"/>
              <set_value name="$hasTrades" exact="false"/>
              <do_if value="$cachePick.$Trades? and $cachePick.$Trades != null and $cachePick.$Trades.count gt 0">
                <set_value name="$cacheTradeList" exact="$cachePick.$Trades"/>
                <set_value name="$hasTrades" exact="true"/>
              </do_if>
              <do_else>
                <do_if value="$cacheBestTrade != null">
                  <append_to_list name="$cacheTradeList" exact="$cacheBestTrade"/>
                  <set_value name="$hasTrades" exact="true"/>
                </do_if>
              </do_else>
              <!-- Only set foundCachedTrade to true if we actually have trades -->
              <set_value name="$foundCachedTrade" exact="$hasTrades"/>
            </do_if>
            
            <set_value name="$cacheContinuation" exact="true"/>
            <set_value name="$searchMethod" exact="'cache'"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cache check complete (scheduler): Found=' + $foundCachedTrade + ', Trades=' + $cacheTradeList.count + ', BestScore=' + $cacheBestScore" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Phase 4: Create scheduler work item for cache query -->
            <set_value name="$searchMethod" exact="'cache'"/>
            <set_value name="$cacheChecked" exact="true"/>
            
            <!-- Calculate total cache count from all home sectors -->
            <run_actions ref="md.GT_Libraries_General.GT_CalculateTotalCacheCount" result="$cacheCount"/>
            
            <!-- Log cache check start (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Enqueueing cache query via scheduler (cache size: ' + $cacheCount + ' entries)'" chance="100"/>
            </do_if>
            
            <!-- Create cache query work item -->
            <run_actions ref="md.GT_Libraries_General.GT_CreateWorkItem" result="$cacheWorkItem">
              <param name="type" value="'CacheQuery'"/>
              <param name="key" value="$ship.idcode + '_CacheQuery'"/>
              <param name="traceId" value="$traceId"/>
              <param name="payload" value="table[
                $Ship = $ship,
                $HomeSector = $homeSector,
                $MaxDistance = $maxDistance,
                $MinROI = $minROI,
                $MinAbsoluteProfit = $minAbsoluteProfit,
                $IgnoreBuildStorage = $ignoreBuildStorage,
                $IgnoreCarrierAux = $ignoreCarrierAux,
                $ResumeParams = $params
              ]"/>
            </run_actions>
            
            <!-- Enqueue work item -->
            <run_actions ref="md.GT_Libraries_General.GT_EnqueueWorkItem">
              <param name="workItem" value="$cacheWorkItem"/>
            </run_actions>
            
            <!-- Exit cue - will resume when cache query completes -->
            <cancel_cue cue="this"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- Live search continuation OR ForceLiveSearch - skip cache, use live results -->
          <set_value name="$searchMethod" exact="'live'"/>
          <do_if value="$forceLiveSearch">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ForceLiveSearch flag set - skipping cache, going straight to live search'" chance="100"/>
            </do_if>
            <!-- Clear ForceLiveSearch flag after use -->
            <!-- FIX: Clear from all storage locations (params, global AI params, and request table) to prevent persistence -->
            <!-- Initialization guarantees global.$GT_AIParameters exists -->
            <do_if value="global.$GT_AIParameters.{$ship}?">
              <remove_value name="global.$GT_AIParameters.{$ship}.$ForceLiveSearch"/>
            </do_if>
            <!-- Also clear from params to prevent it from being carried forward -->
            <set_value name="$params.$ForceLiveSearch" exact="false"/>
            <!-- Also clear from request table (used when re-enqueueing from gt_trading_execution.xml) -->
            <do_if value="global.$GT_TS? and global.$GT_TS.$Requests? and global.$GT_TS.$Requests.{$ship}?">
              <set_value name="$req" exact="global.$GT_TS.$Requests.{$ship}"/>
              <set_value name="$req.$ForceLiveSearch" exact="false"/>
              <set_value name="global.$GT_TS.$Requests.{$ship}" exact="$req"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- WAIT: Cache query is async (scheduler/batched). Don't proceed until cache results are ready. -->
        <!-- Initial fresh search enqueues a CacheQuery work item in the scheduler and then pauses this cue instance. -->
        <!-- Continuations (CacheContinuation/live/fallback) skip this gate and proceed normally. -->
        <do_if value="$cacheContinuation or $searchState != 'fresh' or $forceLiveSearch">
        
        <!-- Compare cache vs live results and use the best -->
        <!-- If we have live/fallback continuation, use live results (they're fresher) -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <!-- Using live search results -->
          <set_value name="$bestTrade" exact="$liveBestTrade"/>
          <set_value name="$bestScore" exact="$liveBestScore"/>
          <set_value name="$tradeList" exact="$liveTradeList"/>
          <set_value name="$foundCachedTrade" exact="false"/>
        </do_if>
        <do_else>
          <!-- Using cache results (or will check live search if needed) -->
          <set_value name="$bestTrade" exact="$cacheBestTrade"/>
          <set_value name="$bestScore" exact="$cacheBestScore"/>
          <set_value name="$tradeList" exact="$cacheTradeList"/>
        </do_else>
        <!-- SAFETY: ensure list is never null (prevents .count property lookup crash) -->
        <do_if value="$tradeList == null">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        
        <!-- Validate bestTrade IMMEDIATELY after setting from cache/live sources -->
        <!-- Use strict validation to catch invalid trades before execution validation -->
        <set_value name="$bestTradePreSourceCheck" exact="$bestTrade"/>
        <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeValidFromSource">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        <do_if value="not $bestTradeValidFromSource">
          <!-- Explain WHY it's invalid (debug-only, safe lookups) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$invalidReason" exact="'unknown'"/>
            <do_if value="$bestTradePreSourceCheck == null">
              <set_value name="$invalidReason" exact="'null (cache miss / no live result yet)'"/>
            </do_if>
            <do_else>
              <set_value name="$rBuyOffer" exact="@$bestTradePreSourceCheck.$BuyOffer"/>
              <set_value name="$rSellOffer" exact="@$bestTradePreSourceCheck.$SellOffer"/>
              <set_value name="$rScore" exact="@$bestTradePreSourceCheck.$Score"/>
              <do_if value="$rBuyOffer == null">
                <set_value name="$invalidReason" exact="'missing BuyOffer'"/>
              </do_if>
              <do_elseif value="$rSellOffer == null">
                <set_value name="$invalidReason" exact="'missing SellOffer'"/>
              </do_elseif>
              <do_elseif value="$rScore == null">
                <set_value name="$invalidReason" exact="'missing Score'"/>
              </do_elseif>
              <do_elseif value="$rScore le 0">
                <set_value name="$invalidReason" exact="'Score le 0'"/>
              </do_elseif>
              <do_else>
                <set_value name="$rWare" exact="@$rBuyOffer.ware"/>
                <do_if value="$rWare == null">
                  <set_value name="$invalidReason" exact="'missing BuyOffer.ware'"/>
                </do_if>
                <do_else>
                  <set_value name="$invalidReason" exact="'failed GT_IsTradeValid (unexpected field/state)'" />
                </do_else>
              </do_else>
            </do_else>
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') bestTrade invalid (source cache/live): ' + $invalidReason" chance="100"/>
          </do_if>

          <!-- bestTrade from source is invalid - clear it so fallback can fix it -->
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade from source cleared for fallback (invalid)'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Initialize rejection statistics (for both cached and live searches) -->
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedBlacklist" exact="0"/>
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$offersFound" exact="0"/>
        <set_value name="$stationsEvaluated" exact="0"/>
        <set_value name="$bestRejectedTrade" exact="null"/>
        
        <!-- If using live search continuation, retrieve rejection stats from global (includes filtering stats) -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') RETRIEVING STATS FROM CONTINUATION:' +
              '\n  TradesRejectedDocking exists: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedDocking? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist exists: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist value: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist? then global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist else 'null') +
              '\n  FilteredByBlacklist exists: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByBlacklist? then 'yes' else 'no') +
              '\n  FilteredByBlacklist value: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByBlacklist? then global.$GT_SearchResult.{$ship}.$FilteredByBlacklist else 'null') +
              '\n  FilteredByPathBlocked exists: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked? then 'yes' else 'no') +
              '\n  FilteredByPathBlocked value: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked? then global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked else 'null') +
              '\n  TotalTradesEvaluated exists: ' + (if global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated? then 'yes' else 'no') +
              '\n  TotalTradesEvaluated value: ' + (if global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated? then global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated else 'null')" 
              chance="100"/>
          </do_if>
          
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance?">
            <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$StationsEvaluated?">
            <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.{$ship}.$StationsEvaluated"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$OffersFound?">
            <set_value name="$offersFound" exact="global.$GT_SearchResult.{$ship}.$OffersFound"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$BestRejectedTrade?">
            <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.{$ship}.$BestRejectedTrade"/>
          </do_if>
          
          <!-- Store stats immediately when continuation detected (BEFORE trade execution) -->
          <!-- This ensures stats are available for logbook even if execution fails later -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: $tradesRejectedBlacklist already includes combined value from resume -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = use resume stats if available (more accurate) -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from live search continuation results -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats != null">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="((if $existingTotal != null then $existingTotal else 0) gt 0) or ((if $existingDocking != null then $existingDocking else 0) gt 0) or ((if $existingProfit != null then $existingProfit else 0) gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <do_if value="$totalEvaluated gt 0 or not $hasExistingStats">
            <!-- SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Use library function to update rejection stats -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateRejectionStats">
              <param name="ship" value="$ship"/>
              <param name="stats" value="$newShipStats"/>
            </run_actions>
          </do_if>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORED STATS ON CONTINUATION (available for logbook if execution fails):' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalBlacklistFiltered: ' + $statsBlacklist +
              '\n  RejectedDocking: ' + $statsDocking +
              '\n  RejectedProfit: ' + $statsProfit +
              '\n  RejectedAmount: ' + $statsAmount" 
              chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Check cache diversity: Count unique wares in trade list -->
        <set_value name="$cacheWareCount" exact="0"/>
        <set_value name="$cacheWares" exact="table[]"/>
        <do_if value="$tradeList != null and $tradeList.count gt 0">
          <do_all exact="$tradeList.count" counter="$i">
            <set_value name="$trade" exact="$tradeList.{$i}"/>
            <set_value name="$ware" exact="@$trade.$BuyOffer.ware"/>
            <do_if value="$ware? and not $cacheWares.{$ware}?">
              <set_value name="$cacheWares.{$ware}" exact="true"/>
              <set_value name="$cacheWareCount" exact="$cacheWareCount + 1"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Live trade search (only if no cached trades found) -->
        <!-- Skip live search entirely if we're already using live search results from continuation -->
        <!-- Low diversity check removed - use cached trades even if diversity is low -->
        <!-- Trigger live search if: 
             1. NOT continuing from live search, AND
             2. No cached trades found, AND
             3. Previous live search did NOT return 0 trades (to prevent infinite loops when all trades are blacklisted) -->
        <set_value name="$shouldDoLiveSearch" exact="false"/>
        <set_value name="$previousLiveSearchReturnedZeroTrades" exact="false"/>
        <do_if value="($searchState == 'live' or $searchState == 'fallback') and ($liveTradeList == null or $liveTradeList.count == 0)">
          <!-- Previous live search returned 0 trades -->
          <!-- Apply cooldown to prevent infinite loop when ship is stuck -->
          <!-- If ship is in blacklisted sector and all trades filtered, cooldown prevents immediate re-search -->
          <!-- Don't apply cooldown if ship needs to escape -->
          
          <!-- Check if ship is in blacklisted sector (needs escape) - using library function -->
          <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckNeedsEscape" result="$needsEscape">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Previous live search returned 0 trades - ' + if $needsEscape then 'ESCAPE NEEDED, skipping cooldown' else 'applying cooldown to prevent loop (ship may be stuck in blacklisted sector)'" chance="100"/>
          </do_if>
          
          <!-- Clear continuation state -->
          <set_value name="$liveTradeList" exact="[]"/>
          <set_value name="$liveBestTrade" exact="null"/>
          <set_value name="$liveBestScore" exact="0"/>
          
          <!-- Initialize tradeList to empty list to prevent null errors -->
          <set_value name="$tradeList" exact="[]"/>
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          
          <!-- Clear old search result state to prevent re-use -->
          <!-- Remove entire per-ship entry to prevent future requests from being treated as continuations -->
          <do_if value="global.$GT_SearchResult.{$ship}?">
            <remove_value name="global.$GT_SearchResult.{$ship}"/>
          </do_if>
          
          <!-- Apply cooldown for zero-trade live searches (prevents infinite loop) -->
          <!-- Only apply cooldown if ship doesn't need to escape -->
          <do_if value="not $needsEscape">
            <!-- Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <!-- Use same cooldown system as cache misses, but mark it as zero-trade cooldown -->
            <!-- FIX: Use configurable cooldown duration (default: 30s, was hardcoded 60s) -->
            <set_value name="$zeroTradeCooldown" exact="30s"/> <!-- Default fallback -->
            <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Fleet? and global.$GT_GlobalSettings.$Fleet.$ZeroTradeCooldown?">
              <set_value name="$zeroTradeCooldown" exact="global.$GT_GlobalSettings.$Fleet.$ZeroTradeCooldown"/>
            </do_if>
            <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
              $LastLiveSearch = player.age,
              $CooldownDuration = $zeroTradeCooldown
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ')    Applied ' + ($zeroTradeCooldown / 1) + 's cooldown after zero-trade live search - ship may be stuck, will retry later'" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship needs to escape - clear any existing cooldown so it can search again immediately -->
            <!-- Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ESCAPE NEEDED: Zero trades found but ship in blacklisted sector - clearing cooldown to allow immediate escape search'" chance="100"/>
            </do_if>
          </do_else>
        </do_if>
        
        <!-- Only trigger live search if this is a fresh search (not live/fallback continuation) -->
        <do_if value="$searchState == 'fresh'">
          <!-- Low diversity check removed - only trigger live search on cache miss -->
          <set_value name="$shouldDoLiveSearch" exact="not $foundCachedTrade"/>
        </do_if>
        <do_else>
          <!-- Using continuation results - don't trigger new live search -->
          <set_value name="$shouldDoLiveSearch" exact="false"/>
        </do_else>
        
        <!-- Track whether we started an async live search in THIS invocation -->
        <!-- If true, we must NOT run execution/no-trade-found/cleanup until SearchLiveTrades_Resume signals us again. -->
        <set_value name="$waitingForLiveSearch" exact="false"/>
        <!-- Track whether we intentionally deferred "NoTradeFound" because we kicked an async fallback/live pipeline.
             This is required because MD <cancel_cue/> does NOT stop the current actions block (control flow continues),
             and we must not signal GT_No_Trade_Found while live/batch work is still in-flight. -->
        <set_value name="$deferNoTradeFound" exact="false"/>
        <!-- FIX: Track if live search was skipped (vs actually ran) for accurate diagnostics -->
        <set_value name="$liveSearchSkipped" exact="false"/>
        
        <do_if value="$shouldDoLiveSearch">
          <!-- Prevent cache miss live search loops -->
          <!-- If cache miss triggered live search recently, enforce cooldown before allowing another -->
          <!-- Bypass cooldown if ship is in blacklisted sector and needs to escape -->
          <!-- CRITICAL: Also bypass cooldown if ForceLiveSearch is set (all cached trades rejected = stale cache) -->
          <set_value name="$canDoLiveSearch" exact="true"/>
          <set_value name="$cooldownRemaining" exact="0"/>
          
          <!-- Check if ship is in blacklisted sector (needs escape, bypass cooldown) -->
          <set_value name="$needsEscape" exact="false"/>
          <set_value name="$currentSector" exact="$ship.sector"/>
          <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
            <param name="ship" value="$ship"/>
          </run_actions>
          <do_if value="$blacklistgroup? and $currentSector?">
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$needsEscape">
              <param name="sector" value="$currentSector"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
          </do_if>
          
          <!-- Check cooldown for cache miss triggers (only if not escaping and not ForceLiveSearch) -->
          <!-- ForceLiveSearch means all cached trades were rejected = cache is stale, need fresh data -->
          <set_value name="$hasCooldown" exact="false"/>
          <do_if value="not $needsEscape and not $forceLiveSearch">
            <!-- Only check cooldown if ship doesn't need to escape -->
            <!-- Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <set_value name="$hasCooldown" exact="true"/>
              <set_value name="$cooldownData" exact="global.$GT_CacheMissCooldowns.{$ship}"/>
              <set_value name="$timeSinceLastSearch" exact="player.age - $cooldownData.$LastLiveSearch"/>
              <set_value name="$cooldownRemaining" exact="$cooldownData.$CooldownDuration - $timeSinceLastSearch"/>
              <do_if value="$cooldownRemaining gt 0">
                <!-- Still in cooldown - skip live search -->
                <set_value name="$canDoLiveSearch" exact="false"/>
                <!-- FIX: Track that live search was skipped BEFORE it runs -->
                <set_value name="$liveSearchSkipped" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss   live search cooldown active (' + ($cooldownRemaining / 1) + 's remaining of ' + ($cooldownData.$CooldownDuration / 1) + 's) - skipping live search to prevent loop'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          <do_elseif value="$forceLiveSearch">
            <!-- ForceLiveSearch flag set - all cached trades were rejected, cache is stale -->
            <!-- Bypass cooldown to get fresh data from live search -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') FORCE LIVE SEARCH: All cached trades rejected - bypassing cooldown to refresh stale cache'" chance="100"/>
            </do_if>
            <!-- Clear cooldown so ship can search immediately for fresh data -->
            <!-- Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
          </do_elseif>
          <do_else>
            <!-- Ship needs to escape - bypass cooldown and clear it -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ESCAPE NEEDED: Ship in blacklisted sector - bypassing cooldown to search for escape route'" chance="100"/>
            </do_if>
            <!-- Clear cooldown so ship can search immediately for escape -->
            <!-- Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
          </do_else>
          
          <do_if value="$canDoLiveSearch">
            <!-- Separate live-search concurrency:
                 - Let cache searches run with cache concurrency (SearchQueue)
                - Live searches are scheduled via scheduler HomeSearch work items and serialized per home sector -->
            <do_if value="$searchState == 'fresh' and not $fromLiveQueue">
              <!-- MD NOTE: cancel_cue does NOT reliably stop the current actions block immediately.
                   Always use an explicit flag to prevent fallthrough when we deny a request. -->
              <set_value name="$denyHomeRefresh" exact="false"/>

              <!-- PER-HOME-SECTOR COALESCING (leader model):
                   Goal: Prevent fleets from building up a live-search queue that stalls the whole process.
                   Rule: At most ONE live-refresh per home sector at a time.
                     - First ship that cache-misses becomes the leader (or queues as leader if global live slots are full).
                     - Other ships with the same home sector are DENIED with reason 'home_refresh' and will retry cache later.
                   NOTE: This does NOT require a special leader ship; any ship can become leader when the sector is idle. -->
              <run_actions ref="md.GT_Libraries_General.GT_GetHomeSector" result="$homeSectorForCoalescing">
                <param name="ship" value="$ship"/>
              </run_actions>
              
              <!-- CRITICAL: Abort if home sector cannot be determined (prevents drift) -->
              <do_if value="not $homeSectorForCoalescing? or not $homeSectorForCoalescing.exists">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cannot determine home sector for coalescing - aborting search to prevent drift'" chance="100"/>
                </do_if>
                <!-- Release lock and abort -->
                <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                  <param name="ship" value="$ship"/>
                  <param name="reason" value="'no_home_sector'"/>
                </run_actions>
                <cancel_cue cue="this"/>
              </do_if>
              
              <set_value name="$homeSector" exact="$homeSectorForCoalescing"/>
              <do_if value="not global.$GT_TS_LiveRefreshBySector?">
                <set_value name="global.$GT_TS_LiveRefreshBySector" exact="table[]"/>
              </do_if>
              <set_value name="$refreshEntry" exact="@global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
              <set_value name="$refreshActive" exact="false"/>
              <do_if value="$refreshEntry? and $refreshEntry != null and $refreshEntry.$Active? and $refreshEntry.$Active">
                <set_value name="$refreshActive" exact="true"/>
              </do_if>
              <!-- Clear stale/invalid active markers -->
              <!-- CRITICAL FIX: Reduce stale timeout from 300s to 60s to prevent stuck refresh markers -->
              <!-- If a refresh takes longer than 60s, it's likely stuck and should be cleared -->
              <do_if value="$refreshActive">
                <set_value name="$initiator" exact="@$refreshEntry.$Initiator"/>
                <set_value name="$started" exact="@$refreshEntry.$LastStarted"/>
                <do_if value="not $initiator? or not $initiator.exists or not $started? or (player.age - $started) gt 60s">
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] Clearing stale home refresh marker (home=' + @$homeSector.knownname + ', initiator=' + (if $initiator? then @$initiator.idcode else 'NULL') + ', age=' + (if $started? then (player.age - $started) else 'unknown') + 's)'" chance="100"/>
                  </do_if>
                  <remove_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}"/>
                  <set_value name="$refreshActive" exact="false"/>
                </do_if>
              </do_if>

              <!-- If another ship is already refreshing this home sector:
                   - DO NOT enqueue another live search for this same home sector.
                   - DO NOT signal the AI (silent waiting).
                   - Keep the request lock; the ship will be resumed automatically when the home refresh finishes.
                   EXCEPTION: isolated ships must not be blocked by home_refresh; they run their own cheap 1-sector live search. -->
              <do_if value="not $shipIsIsolatedForCachePolicy and $refreshActive and $refreshEntry? and $refreshEntry != null and $refreshEntry.$Initiator? and $refreshEntry.$Initiator != $ship">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Home-sector live refresh already active (home=' + @$homeSector.knownname + ', initiator=' + @$refreshEntry.$Initiator.idcode + ') - waiting silently for refresh to complete'" chance="100"/>
                </do_if>

                <!-- Ensure waiter structures exist -->
                <do_if value="not global.$GT_TS_LiveRefreshBySector.{$homeSector}.$Waiters? or global.$GT_TS_LiveRefreshBySector.{$homeSector}.$Waiters == null">
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$Waiters" exact="[]"/>
                </do_if>
                <do_if value="not global.$GT_TS_LiveRefreshBySector.{$homeSector}.$WaiterQueued? or global.$GT_TS_LiveRefreshBySector.{$homeSector}.$WaiterQueued == null">
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$WaiterQueued" exact="table[]"/>
                </do_if>

                <!-- O(1) dedupe: only queue once per ship -->
                <do_if value="not global.$GT_TS_LiveRefreshBySector.{$homeSector}.$WaiterQueued.{$ship}?">
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$WaiterQueued.{$ship}" exact="true"/>
                  <append_to_list name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$Waiters" exact="table[
                    $Ship = $ship,
                    $Params = $params,
                    $EnqueuedAt = player.age
                  ]"/>
                </do_if>
                
                <!-- Refresh the request timestamp while we are waiting silently.
                     Prevents "stale in-progress request" cleanup from firing while the ship is legitimately waiting for its home-sector refresh. -->
                <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}?">
                  <set_value name="global.$GT_AIParameters.{$ship}.$RequestTime" exact="player.age"/>
                  <set_value name="global.$GT_AIParameters.{$ship}.$WaitReason" exact="'home_refresh_wait'"/>
                </do_if>

                <!-- Mark that we're waiting (prevents fallthrough) -->
                <set_value name="$liveSearchSkipped" exact="true"/>
                <set_value name="$waitingForLiveSearch" exact="true"/>
                <set_value name="$deferNoTradeFound" exact="true"/>

                <!-- IMPORTANT: If this invocation used a cache-search queue slot, release it and continue the cache queue. -->
                <do_if value="$useSearchQueueCounter">
                  <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
                    <remove_value name="global.$GT_SearchQueue.$Params.{$ship}"/>
                  </do_if>
                  <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
                    <param name="clampToZero" value="true"/>
                    <param name="triggerQueueProcessor" value="true"/>
                  </run_actions>
                  <set_value name="$useSearchQueueCounter" exact="false"/>
                </do_if>

                <!-- Prevent fallthrough into "mark leader" and live enqueue -->
                <set_value name="$denyHomeRefresh" exact="true"/>
                <cancel_cue cue="this"/>
              </do_if>

              <!-- IMPORTANT:
                   cancel_cue does NOT stop the current actions block immediately.
                   After we enqueue as a silent waiter (home refresh already active) we must NOT fall through into leader marking,
                   otherwise we'd start multiple live searches for the same home sector. -->
              <!-- If denied, do nothing else in this invocation (gated; cancel_cue alone is not sufficient). -->
              <do_if value="not $denyHomeRefresh">
                <!-- CRITICAL FIX: Check if ship still has GT order before marking as refresh initiator -->
                <!-- Ships without GT orders shouldn't trigger live searches or become refresh initiators -->
                <set_value name="$hasGTOrder" exact="false"/>
                <do_if value="$ship.defaultorder? and @$ship.defaultorder.id == 'GalaxyTraderMK3'">
                  <set_value name="$hasGTOrder" exact="true"/>
                </do_if>
                <do_else>
                  <!-- Check if subordinate to GT commander -->
                  <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
                    <do_if value="$ship.commander.defaultorder? and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
                      <set_value name="$hasGTOrder" exact="true"/>
                    </do_if>
                  </do_if>
                </do_else>
                
                <!-- Only mark as refresh initiator if ship has GT order -->
                <do_if value="$hasGTOrder and not $shipIsIsolatedForCachePolicy and $homeSector? and $homeSector.exists">
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}" exact="table[
                    $Active = true,
                    $Initiator = $ship,
                    $LastStarted = player.age
                  ]"/>
                </do_if>
                <do_else>
                  <!-- Ship doesn't have GT order - release lock and signal no trade found -->
                  <do_if value="not $hasGTOrder">
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Ship no longer has GT order - releasing lock and aborting search'" chance="100"/>
                    </do_if>
                    <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                      <param name="ship" value="$ship"/>
                      <param name="reason" value="'no_gt_order'"/>
                    </run_actions>
                    <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'no_gt_order'"/>
                    <set_value name="$denyHomeRefresh" exact="true"/>
                  </do_if>
                </do_else>

                <!-- Central hub: live search scheduling is owned by scheduler HomeSearch work items. -->
                <do_if value="$shouldDoLiveSearch">
              <!-- Release cache-search queue slot immediately so other ships can run cache checks -->
              <do_if value="$useSearchQueueCounter">
                <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
                  <remove_value name="global.$GT_SearchQueue.$Params.{$ship}"/>
                </do_if>
                <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
                  <param name="clampToZero" value="true"/>
                  <param name="triggerQueueProcessor" value="true"/>
                </run_actions>
              </do_if>

              <!-- Phase 4: Use scheduler for live search instead of old queue -->
              <!-- CRITICAL: MD cancel_cue does not abort the current actions block.
                   Mark that we're now waiting for the async live-search pipeline, so we don't fall through into
                   fallback/no-trade logic in the same invocation (which would start a stampede of live searches). -->
              <set_value name="$waitingForLiveSearch" exact="true"/>
              <set_value name="$deferNoTradeFound" exact="true"/>

              <!-- Create HomeSearch work item for scheduler -->
              <run_actions ref="md.GT_Libraries_General.GT_CreateWorkItem" result="$homeSearchWorkItem">
                <param name="type" value="'HomeSearch'"/>
                <param name="key" value="$ship.idcode + '_HomeSearch'"/>
                <param name="traceId" value="$traceId"/>
                <param name="payload" value="table[
                  $Ship = $ship,
                  $MaxDistance = $maxDistance,
                  $MinROI = $minROI,
                  $MinAbsoluteProfit = $minAbsoluteProfit,
                  $FactionPriority = $factionPriority,
                  $FactionPriorityText = $factionPriorityText,
                  $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                  $SkillLevel = $skillLevel,
                  $ThreatIntel = $gt_ThreatIntel,
                  $FleetCoord = $gt_FleetCoord,
                  $AdvancedAnalytics = $gt_AdvancedAnalytics,
                  $ResumeParams = $params
                ]"/>
              </run_actions>
              
              <!-- Enqueue work item -->
              <run_actions ref="md.GT_Libraries_General.GT_EnqueueWorkItem">
                <param name="workItem" value="$homeSearchWorkItem"/>
              </run_actions>
              
                  <!-- Exit cue - will resume when live search completes -->
                  <cancel_cue cue="this"/>
                </do_if>
            </do_if>
            </do_if>

            <!-- IMPORTANT:
                 For fresh searches, we either enqueue a HomeSearch work item (normal), or intentionally skip (busy).
                 In BOTH cases we must NOT start a direct live search here. -->
            <do_if value="not ($searchState == 'fresh' and not $fromLiveQueue)">
              <!-- Log when live search starts (debug mode only) -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$cacheTradeCountForLog" exact="0"/>
                <do_if value="$cacheTradeList?">
                  <set_value name="$cacheTradeCountForLog" exact="@$cacheTradeList.count"/>
                </do_if>
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Starting LIVE market search (cache had ' + $cacheTradeCountForLog + ' trades, none suitable)'" chance="100"/>
              </do_if>
              
              <!-- Initialize cooldown tracking if not exists -->
              <!-- Defensive check for race condition (initialization might not have completed yet) -->
              <do_if value="not global.$GT_CacheMissCooldowns?">
                <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
              </do_if>
              
              <!-- Update cooldown for cache miss triggers -->
              <do_if value="not $hasCooldown">
                <!-- First live search trigger for this ship - start at 10 seconds -->
                <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                  $LastLiveSearch = player.age,
                  $CooldownDuration = 10s
                ]"/>
              </do_if>
              <do_else>
                <!-- Increase cooldown (double, max 60s) - cooldownData exists since hasCooldown is true -->
                <set_value name="$newCooldown" exact="$cooldownData.$CooldownDuration * 2"/>
                <do_if value="$newCooldown gt 60s">
                  <set_value name="$newCooldown" exact="60s"/>
                </do_if>
                <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                  $LastLiveSearch = player.age,
                  $CooldownDuration = $newCooldown
                ]"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss   live search cooldown increased to ' + ($newCooldown / 1) + 's'" chance="100"/>
                </do_if>
              </do_else>
              
              <!-- FIX: Check if a search is already in progress before starting a new one -->
              <set_value name="$searchInProgress" exact="false"/>
              <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
                <set_value name="$searchInProgress" exact="true"/>
              </do_if>
              
              <do_if value="$searchInProgress">
                <!-- Check if state is stale (> 60 seconds old) - if so, clear it and release lock -->
                <set_value name="$stateStarted" exact="null"/>
                <do_if value="global.$GT_SearchLiveTrades_State.{$ship}.$Started?">
                  <set_value name="$stateStarted" exact="global.$GT_SearchLiveTrades_State.{$ship}.$Started"/>
                </do_if>
                <set_value name="$stateAge" exact="-1"/>
                <do_if value="$stateStarted?">
                  <set_value name="$stateAge" exact="player.age - $stateStarted"/>
                </do_if>
                
                <do_if value="$stateAge gt 60 or $stateAge lt 0">
                  <!-- State is stale or missing Started timestamp - clear it and release lock -->
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Search state is stale (age: ' + $stateAge + 's) - clearing state and releasing lock'" chance="100"/>
                  </do_if>
                  <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
                  <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                    <param name="ship" value="$ship"/>
                    <param name="reason" value="'stale_search_state'"/>
                  </run_actions>
                  <cancel_cue cue="this"/>
                </do_if>
                <do_else>
                  <!-- State is fresh - wait for continuation -->
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Search already in progress - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
                  </do_if>
                  <cancel_cue cue="this"/>
                </do_else>
              </do_if>

              <!-- IMPORTANT: Do NOT apply per-home-sector coalescing here.
                   Coalescing/Initiator assignment happens ONLY in the "fresh + not fromLiveQueue" enqueue path above.
                   When we are here, we are executing the chosen initiator’s live search, so denying here would stall fleets. -->

              <!-- Phase 4: Use scheduler for live search instead of direct signal -->
              <!-- Perform live search (this invocation is the actual live-search execution for the chosen initiator) -->
              <set_value name="$waitingForLiveSearch" exact="true"/>
              
              <!-- FIX #3 + #4: Use original maxDistance for cache population (sector list), but cap results by pilot skill -->
              <!-- Order definition uses skill.max() for defaults (allows fleet coordination) -->
              <!-- For cache population: Use original maxDistance (commander's skill) so higher-level pilots benefit -->
              <!-- For result filtering: Cap by requesting ship's pilot skill so low-level pilots don't get trades they can't execute -->
              <run_actions ref="md.GT_Ship_Management.Calculate_Jump_Distance" result="$pilotSkillMaxDistance">
                <param name="skill_level" value="$skillLevel"/>
              </run_actions>
              <set_value name="$cappedMaxDistance" exact="[$maxDistance, $pilotSkillMaxDistance].min"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <do_if value="$cappedMaxDistance lt $maxDistance">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Live search: Order maxDistance=' + $maxDistance + ' jumps (for cache), Pilot skill (Lv' + $skillLevel + ') max=' + $pilotSkillMaxDistance + ' jumps (for results), Results will be capped to=' + $cappedMaxDistance + ' jumps'" chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Create HomeSearch work item for scheduler -->
              <run_actions ref="md.GT_Libraries_General.GT_CreateWorkItem" result="$homeSearchWorkItem">
                <param name="type" value="'HomeSearch'"/>
                <param name="key" value="$ship.idcode + '_HomeSearch'"/>
                <param name="traceId" value="$traceId"/>
                <param name="payload" value="table[
                  $Ship = $ship,
                  $MaxDistance = $maxDistance,
                  $OriginalMaxDistance = $maxDistance,
                  $PilotSkillMaxDistance = $cappedMaxDistance,
                  $MinROI = $minROI,
                  $MinAbsoluteProfit = $minAbsoluteProfit,
                  $FactionPriority = $factionPriority,
                  $FactionPriorityText = $factionPriorityText,
                  $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                  $SkillLevel = $skillLevel,
                  $ThreatIntel = $gt_ThreatIntel,
                  $FleetCoord = $gt_FleetCoord,
                  $AdvancedAnalytics = $gt_AdvancedAnalytics,
                  $ResumeParams = $params
                ]"/>
              </run_actions>
              
              <!-- Enqueue work item -->
              <run_actions ref="md.GT_Libraries_General.GT_EnqueueWorkItem">
                <param name="workItem" value="$homeSearchWorkItem"/>
              </run_actions>
              
              <!-- Log live search start -->
              <do_if value="$traceId != ''">
                <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                  <param name="traceId" value="$traceId"/>
                  <param name="stage" value="'LiveSearch'"/>
                  <param name="action" value="'Enqueued'"/>
                  <param name="details" value="'ship=' + $ship.idcode + ' maxDistance=' + $maxDistance + ' cappedMaxDistance=' + $cappedMaxDistance"/>
                  <param name="logLevel" value="1"/>
                </run_actions>
              </do_if>
              
              <!-- CRITICAL FIX: Check for stale lock before retaining for async continuation -->
              <set_value name="$lockTime" exact="null"/>
              <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
                <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$ship}"/>
              </do_if>
              <set_value name="$lockStale" exact="false"/>
              <do_if value="$lockTime?">
                <set_value name="$lockAge" exact="player.age - $lockTime"/>
                <do_if value="$lockAge gt 60">
                  <!-- Lock is stale - release it instead of retaining for continuation -->
                  <set_value name="$lockStale" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Lock is stale (age: ' + $lockAge + 's) - releasing instead of waiting for continuation'" chance="100"/>
                  </do_if>
                  <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
                  <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
                    <param name="ship" value="$ship"/>
                    <param name="reason" value="'stale_lock_before_continuation'"/>
                  </run_actions>
                </do_if>
              </do_if>
              
              <!-- Exit immediately after signaling SearchLiveTrades (unless lock is stale) -->
              <do_if value="not $lockStale">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ')    SearchLiveTrades signaled - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
                </do_if>
                <cancel_cue cue="this"/>
              </do_if>
              <do_else>
                <!-- Lock was stale and released - exit without cancel (cleanup will run) -->
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Stale lock released - exiting'" chance="100"/>
                </do_if>
              </do_else>
              
              <set_value name="$searchMethod" exact="'live'"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Cooldown active - skip live search -->
            <!-- CRITICAL: Don't clear results if we're using live search continuation (results already set above) -->
            <!-- CRITICAL: Preserve cache tradeList even if bestTrade was invalid (fallback can find valid trade from list) -->
            <do_if value="$searchState == 'fresh'">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Skipping live search due to cooldown - preserving cache results (bestTrade may be null, tradeList.count=' + (if $tradeList != null then @$tradeList.count else 0) + ')'" chance="100"/>
              </do_if>
              <set_value name="$searchMethod" exact="'cache'"/>
              <!-- Only clear bestTrade if it was invalid (already cleared above), but preserve tradeList from cache -->
              <!-- bestTrade will be selected from tradeList by fallback logic if needed -->
              <do_if value="$bestTrade == null or @$bestTrade.$BuyOffer == null">
                <set_value name="$bestTrade" exact="null"/>
                <set_value name="$bestScore" exact="0"/>
              </do_if>
              <!-- Preserve tradeList from cache - don't overwrite with empty list! -->
              <!-- Fallback logic will try to find valid trade from tradeList -->
            </do_if>
          </do_else>
          
          <!-- Check batch status BEFORE extracting results -->
          <!-- If batch is in progress, exit immediately - don't extract stale results -->
          <!-- SearchLiveTrades_Resume will signal this cue again when batch completes -->
          <set_value name="$batchInProgress" exact="false"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$WaitingForBatch?">
            <set_value name="$batchInProgress" exact="global.$GT_SearchResult.{$ship}.$WaitingForBatch"/>
          </do_if>
          
          <do_if value="$batchInProgress">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Batch processing in progress - skipping result extraction (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <!-- Exit - SearchLiveTrades_Resume will signal this cue again when batch completes -->
            <cancel_cue cue="this"/>
          </do_if>
          
          <!-- Redundant batch check removed - already handled at the beginning of the cue -->
          <!-- Extract live search results from global return variable (batch processing completed) -->
          <!-- Note: If this is a live/fallback continuation, live results were already extracted above -->
          <do_if value="$searchState == 'fresh'">
            <set_value name="$bestTrade" exact="@global.$GT_SearchResult.{$ship}.$BestTrade"/>
            <set_value name="$bestScore" exact="@global.$GT_SearchResult.{$ship}.$BestScore"/>
            
            <!-- Validate bestTrade IMMEDIATELY after extracting from global -->
            <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeValidFromGlobal">
              <param name="trade" value="$bestTrade"/>
              <param name="minScore" value="0"/>
            </run_actions>
            <do_if value="not $bestTradeValidFromGlobal">
              <!-- bestTrade from global is invalid - clear it so fallback can fix it -->
              <set_value name="$bestTrade" exact="null"/>
              <set_value name="$bestScore" exact="0"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade from global.$GT_SearchResult is INVALID - cleared for fallback fix'" chance="100"/>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_SearchResult.{$ship}.$StationsEvaluated?">
              <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.{$ship}.$StationsEvaluated"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$OffersFound?">
              <set_value name="$offersFound" exact="global.$GT_SearchResult.{$ship}.$OffersFound"/>
            </do_if>
            <!-- Initialize to empty list first, then extract from global if it exists -->
            <set_value name="$tradeList" exact="[]"/>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradeList?">
              <set_value name="$tradeList" exact="global.$GT_SearchResult.{$ship}.$TradeList"/>
            </do_if>
            <!-- Update rejection statistics from live search (if available) -->
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
              <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
              <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
              <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance?">
              <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
              <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$BestRejectedTrade?">
              <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.{$ship}.$BestRejectedTrade"/>
            </do_if>
            
            <!-- Failed sector filtering now happens during best trade tracking (inside evaluation loop) -->
            <!-- This ensures: 1) All trades are cached for other ships, 2) Best selection excludes failed sectors -->
          </do_if>  <!-- End of extracting live results if not continuation -->
        </do_if>  <!-- End of live trade search -->
        
        <!-- Sort trade list by score (highest first) before sending to AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <run_actions ref="md.GT_Libraries_General.GT_SortTradesByScore" result="$tradeList">
          <param name="tradeList" value="$tradeList"/>
        </run_actions>
        
        <!-- If tradeList exists but bestTrade is null, select best from list -->
        <!-- This can happen during continuation if BestTrade wasn't stored in global -->
        <!-- Use strict validation (library function) instead of weak Score-only check -->
        <set_value name="$bestTradeIsValid" exact="false"/>
        <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeIsValid">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        
        <do_if value="not $bestTradeIsValid">
          <!-- FIX: Use library function for consistent validation -->
          <do_if value="$tradeList != null and @$tradeList.count gt 0">
            <do_all exact="@$tradeList.count" counter="$i">
              <set_value name="$firstTrade" exact="@$tradeList.{$i}"/>
              <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$firstTradeValid">
                <param name="trade" value="$firstTrade"/>
                <param name="minScore" value="0"/>
              </run_actions>
              <do_if value="$firstTradeValid">
                <set_value name="$testScore" exact="@$firstTrade.$Score"/>
                <set_value name="$bestTrade" exact="$firstTrade"/>
                <set_value name="$bestScore" exact="$testScore"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade was null but tradeList has ' + @$tradeList.count + ' trades - selected valid trade[' + $i + '] as bestTrade'" chance="100"/>
                </do_if>
                <break/>
              </do_if>
            </do_all>
          </do_if>
        </do_if>
        
        <!-- If we started an async live search in this invocation, stop here and wait for resume signal -->
        <do_if value="not $waitingForLiveSearch">
        
        <!-- Execute best trade if found -->
        <!-- DEBUG: Log bestTrade status for continuation debugging -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$bestTradeExists" exact="$bestTrade != null"/>
          <set_value name="$tradeListCount" exact="0"/>
          <do_if value="$tradeList != null">
            <set_value name="$tradeListCount" exact="@$tradeList.count"/>
          </do_if>
          <set_value name="$bestTradeCheck" exact="'null'"/>
          <do_if value="$bestTrade != null">
            <set_value name="$bestTradeCheck" exact="'exists'"/>
            <do_if value="@$bestTrade.$BuyOffer != null">
              <set_value name="$bestTradeCheck" exact="'valid'"/>
            </do_if>
          </do_if>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Trade execution check: bestTrade=' + $bestTradeCheck + ', tradeList.count=' + $tradeListCount + ', searchState=' + $searchState" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Validate bestTrade before execution -->
        <!-- More robust validation - check that properties actually exist and are not null -->
        <set_value name="$bestTradeIsValidForExecution" exact="false"/>
        <do_if value="$bestTrade != null">
          <set_value name="$testBuyOffer" exact="@$bestTrade.$BuyOffer"/>
          <set_value name="$testSellOffer" exact="@$bestTrade.$SellOffer"/>
          <set_value name="$testScore" exact="@$bestTrade.$Score"/>
          <!-- Check if BuyOffer/SellOffer exist AND are not null, AND Score exists AND is > 0 -->
          <!-- In MD, null? returns true (variable exists), so we need to check Score > 0 to ensure it's a real trade -->
          <do_if value="$testBuyOffer != null and $testSellOffer != null and $testScore != null">
            <do_if value="$testScore gt 0">
              <!-- Double-check: Try accessing a property from BuyOffer to ensure it's not null -->
              <set_value name="$testWare" exact="@$testBuyOffer.ware"/>
              <do_if value="$testWare != null">
                <set_value name="$bestTradeIsValidForExecution" exact="true"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <do_if value="$bestTradeIsValidForExecution">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade is VALID - proceeding with execution'" chance="100"/>
          </do_if>
          <do_else>
            <!-- Explain WHY invalid (execution-time view) -->
            <set_value name="$execInvalidReason" exact="'unknown'"/>
            <do_if value="$bestTrade == null">
              <set_value name="$execInvalidReason" exact="'null (no best trade selected)'"/>
            </do_if>
            <do_else>
              <set_value name="$eBuyOffer" exact="@$bestTrade.$BuyOffer"/>
              <set_value name="$eSellOffer" exact="@$bestTrade.$SellOffer"/>
              <set_value name="$eScore" exact="@$bestTrade.$Score"/>
              <do_if value="$eBuyOffer == null">
                <set_value name="$execInvalidReason" exact="'missing BuyOffer'"/>
              </do_if>
              <do_elseif value="$eSellOffer == null">
                <set_value name="$execInvalidReason" exact="'missing SellOffer'"/>
              </do_elseif>
              <do_elseif value="$eScore == null">
                <set_value name="$execInvalidReason" exact="'missing Score'"/>
              </do_elseif>
              <do_elseif value="$eScore le 0">
                <set_value name="$execInvalidReason" exact="'Score le 0'"/>
              </do_elseif>
              <do_else>
                <set_value name="$eWare" exact="@$eBuyOffer.ware"/>
                <do_if value="$eWare == null">
                  <set_value name="$execInvalidReason" exact="'missing BuyOffer.ware'"/>
                </do_if>
              </do_else>
            </do_else>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade is INVALID - cannot execute (reason: ' + $execInvalidReason + ')'" chance="100"/>
            <!-- If bestTrade is invalid but tradeList has trades, select first valid trade from list -->
            <do_if value="$tradeList != null and @$tradeList.count gt 0">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Attempting to select valid trade from tradeList (' + @$tradeList.count + ' trades available)'" chance="100"/>
              <do_all exact="@$tradeList.count" counter="$i">
                <set_value name="$candidateTrade" exact="$tradeList.{$i}"/>
                <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$candidateValid">
                  <param name="trade" value="$candidateTrade"/>
                  <param name="minScore" value="0"/>
                </run_actions>
                <do_if value="$candidateValid">
                  <set_value name="$candidateScore" exact="@$candidateTrade.$Score"/>
                  <set_value name="$bestTrade" exact="$candidateTrade"/>
                  <set_value name="$bestScore" exact="$candidateScore"/>
                  <set_value name="$bestTradeIsValidForExecution" exact="true"/>
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Selected valid trade from tradeList[' + $i + '] (Score: ' + $candidateScore + ')'" chance="100"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            <!-- If still invalid after all fallbacks, check for fallback search before signaling no trade found -->
            <do_if value="not $bestTradeIsValidForExecution">
              <!-- Batch processing is complete (checked at start) - safe to proceed with "no trade found" logic -->
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') No valid trades found in tradeList (' + (if $tradeList != null then @$tradeList.count else 0) + ' entries) - all trades invalid'" chance="100"/>
              
              <!-- Check if we should trigger fallback search before signaling no trade found -->
              <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
                <!-- Check if fallback was already attempted in this search cycle -->
                <set_value name="$fallbackAlreadyAttempted" exact="false"/>
                <do_if value="global.$GT_FallbackAttempted.{$ship}?">
                  <set_value name="$fallbackAlreadyAttempted" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
                  </do_if>
                </do_if>
                
                <!-- Cache search failed, live search failed - check if ship is isolated -->
                <set_value name="$shipIsIsolated" exact="false"/>
                <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
                  <param name="ship" value="$ship"/>
                  <param name="state" value="table[]"/>
                </run_actions>
                <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
                
                <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted.
                     ALSO respect live-search availability: if we intentionally skipped live-search due to saturation/cooldown,
                     do NOT trigger fallback (it would enqueue a live/batch search anyway and recreate fleet-wide stalls). -->
                <!-- CRITICAL: Prevent fallback from starting while we're already waiting for an async live/batch pipeline,
                     and never trigger fallback for ships denied by home_refresh (cancel_cue fallthrough can reach here). -->
                <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted and $shouldDoLiveSearch and not $waitingForLiveSearch and not $denyHomeRefresh">
                  <!-- Ensure table exists before accessing -->
                  <do_if value="not global.$GT_FallbackAttempted?">
                    <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
                  </do_if>
                  
                  <!-- Check if logbook message was already written for this fallback attempt -->
                  <!-- Use a separate flag to prevent logbook spam -->
                  <!-- Ensure table exists before checking -->
                  <do_if value="not global.$GT_FallbackLogbookWritten?">
                    <set_value name="global.$GT_FallbackLogbookWritten" exact="table[]"/>
                  </do_if>
                  
                  <!-- Check if logbook already written - if so, skip writing -->
                  <set_value name="$logbookAlreadyWritten" exact="false"/>
                  <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
                    <set_value name="$logbookAlreadyWritten" exact="true"/>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Logbook message already written - skipping (flag exists, searchState=' + $searchState + ')'" chance="100"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Logbook flag NOT set - will write message (searchState=' + $searchState + ')'" chance="100"/>
                    </do_if>
                  </do_else>
                  
                  <!-- Set flag IMMEDIATELY when fallback is triggered (before any other processing) -->
                  <!-- This ensures flag persists across cue instances and prevents logbook spam -->
                  <do_if value="not $logbookAlreadyWritten">
                    <set_value name="global.$GT_FallbackLogbookWritten.{$ship}" exact="true"/>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set logbook flag - fallback triggered'" chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <!-- Calculate skill level for fallback distance calculation -->
                  <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
                    <param name="ship" value="$ship"/>
                  </run_actions>
                  <set_value name="$fallbackSkillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>
                  
                  <!-- Use originalMaxDistance for fallback calculation if available (prevents decreasing distance) -->
                  <!-- If this is already a fallback continuation, $maxDistance is already reduced, so use originalMaxDistance -->
                  <set_value name="$distanceForFallbackCalc" exact="$maxDistance"/>
                  <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                    <set_value name="$distanceForFallbackCalc" exact="$originalMaxDistance"/>
                  </do_if>
                  
                  <!-- Calculate fallback distance: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
                  <set_value name="$fallbackMaxDistance" exact="1"/>  <!-- Default fallback to 1 -->
                  <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackDistance" result="$fallbackMaxDistance">
                    <param name="maxDistance" value="$distanceForFallbackCalc"/>
                    <param name="skillLevel" value="$fallbackSkillLevel"/>
                  </run_actions>
                  
                  <!-- Write logbook message ONLY if not already written for this fallback attempt -->
                  <do_if value="not $logbookAlreadyWritten">
                    
                    <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
                    <do_if value="not $currentSectorName?">
                      <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
                    </do_if>
                    
                    <!-- Use originalMaxDistance in logbook message if available (shows original search range) -->
                    <set_value name="$originalSearchRange" exact="$maxDistance"/>
                    <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                      <set_value name="$originalSearchRange" exact="$originalMaxDistance"/>
                    </do_if>
                    
                    <!-- Construct logbook message using TextDB syntax with calculated fallback distance -->
                    <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $originalSearchRange, $fallbackMaxDistance]"/>
                    
                    <!-- Write logbook entry using centralized library -->
                    <run_actions ref="md.GT_Libraries_General.WriteLogbookMessage">
                      <param name="Message" value="$logbookMessage"/>
                      <param name="Category" value="'alerts'"/>
                      <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                      <param name="Object" value="$ship"/>
                      <param name="Interaction" value="'showonmap'"/>
                      <param name="CheckGlobalSettings" value="true"/>
                    </run_actions>
                  </do_if>
                  
                  <!-- Mark that fallback search was triggered -->
                  <set_value name="$fallbackSearchTriggered" exact="true"/>
                  
                  <!-- Mark fallback as attempted globally (persists across cue instances) -->
                  <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
                  
                  <!-- Trigger fallback search -->
                  <!-- Fallback uses lower profit thresholds, so we compensate by restricting travel distance -->
                  <!-- Formula: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
                  <!-- OriginalMaxDistance used for filtering stations from home sector -->
                  <!-- CRITICAL: Pass $originalMaxDistance (not $maxDistance) to preserve original search range -->
                  <set_value name="$fallbackParams" exact="table[
                    $Ship = $ship,
                    $MaxDistance = $fallbackMaxDistance,
                    $OriginalMaxDistance = $originalMaxDistance,
                    $MinROI = $minROI,
                    $MinAbsoluteProfit = $minAbsoluteProfit,
                    $FactionPriority = $factionPriority,
                    $FactionPriorityText = $factionPriorityText,
                    $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                    $SkillLevel = $skillLevel,
                    $ThreatIntel = $gt_ThreatIntel,
                    $FleetCoord = $gt_FleetCoord,
                    $AdvancedAnalytics = $gt_AdvancedAnalytics
                  ]"/>
                  <signal_cue_instantly cue="md.GT_Search_Methods.SearchFallbackTrades" param="$fallbackParams"/>
                  
                  <!-- IMPORTANT: We have started an async fallback/live pipeline.
                       Do NOT signal GT_No_Trade_Found or release the search lock in this invocation.
                       Let SearchLiveTrades_Resume signal SearchTradeRoutes again when results are ready. -->
                  <set_value name="$waitingForLiveSearch" exact="true"/>
                  <set_value name="$deferNoTradeFound" exact="true"/>
                  <!-- Do NOT cancel here; we must reach unified cleanup to release queue slots while retaining the lock. -->
                </do_if>
                <do_else>
                  <!-- Ship is isolated OR fallback already attempted - signal no trade found -->
                  <!-- FIX: Only track that live search was skipped if this is NOT a continuation from live search.
                       If searchState=live, then live search already ran (and found 0 trades), so don't mark it as skipped. -->
                  <do_if value="$searchState != 'live'">
                    <set_value name="$liveSearchSkipped" exact="true"/>
                  </do_if>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ') Ship is isolated or fallback already attempted - signaling no trade found'" chance="100"/>
                  </do_if>
                  
                  <!-- If the ship is isolated, set the [ISOLATED] ship-name flag even when no trade is found.
                       Naming logic in GT_XP_Training.UpdateShipName is responsible for safely replacing GT-owned prefixes
                       (e.g. [TD]/[ID] -> [IS]) without clobbering user-defined custom prefixes. -->
                  <do_if value="$shipIsIsolated and $searchState != 'fallback'">
                    <do_if value="not global.$GT_IsolatedTradeActive?">
                      <set_value name="global.$GT_IsolatedTradeActive" exact="table[]"/>
                    </do_if>
                    <set_value name="global.$GT_IsolatedTradeActive.{$ship}" exact="true"/>

                    <!-- Calculate rank title from skill level for ship name update -->
                    <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
                    <do_if value="not $pilotXP?">
                      <set_value name="$pilotXP" exact="0"/>
                    </do_if>
                    <set_value name="$rankTitle" exact="'Lehrling'"/>
                    <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
                      <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
                      <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                        <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
                      </do_if>
                      <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                        <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
                      </do_if>
                    </do_if>
                    
                    <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                      $ship = $ship,
                      $pilot = $ship.pilot,
                      $xp = $pilotXP,
                      $level = $skillLevel,
                      $rank = $rankTitle,
                      $nameType = 'isolated'
                    ]"/>
                    
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set [ISOLATED] flag - ship is isolated (no trade found)'" chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <!-- IMPORTANT: We're finalizing this attempt with GT_No_Trade_Found.
                       Ensure we do NOT leave stale live-search state behind (otherwise future requests hit the pre-gate
                       "Live search already in progress" and the ship can get stuck indefinitely; seen with EDS-278). -->
                  <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
                    <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
                    <remove_value name="global.$GT_BatchDataList.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_BatchResultsList? and global.$GT_BatchResultsList.{$ship}?">
                    <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled.{$ship}?">
                    <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Queued? and global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                    <remove_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Params? and global.$GT_LiveOfferSliceQueue.$Params.{$ship}?">
                    <remove_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>
                  </do_if>
                  <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Ships? and global.$GT_LiveOfferSliceQueue.$Ships.count gt 0">
                    <remove_from_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                  </do_if>
                  <do_if value="global.$GT_PathfindingQueue?">
                    <do_if value="global.$GT_PathfindingQueue.$ActiveShips?">
                      <remove_from_list name="global.$GT_PathfindingQueue.$ActiveShips" exact="$ship"/>
                    </do_if>
                    <do_if value="global.$GT_PathfindingQueue.$Requests? and global.$GT_PathfindingQueue.$Requests.count gt 0">
                      <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$qi" reverse="true">
                        <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$qi}"/>
                        <do_if value="$req? and $req.$Ship? and $req.$Ship == $ship">
                          <remove_from_list name="global.$GT_PathfindingQueue.$Requests" exact="$req"/>
                        </do_if>
                      </do_all>
                    </do_if>
                  </do_if>
                  <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
                </do_else>
              </do_if>
              <do_else>
                <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Search complete - signaling no trade found (fallback already triggered or cache succeeded)'" chance="100"/>
                </do_if>
                <!-- Same cleanup as above: don't leave stale in-flight live-search markers behind on a final no-trade result. -->
                <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
                  <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
                  <remove_value name="global.$GT_BatchDataList.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_BatchResultsList? and global.$GT_BatchResultsList.{$ship}?">
                  <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled.{$ship}?">
                  <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Queued? and global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
                  <remove_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Params? and global.$GT_LiveOfferSliceQueue.$Params.{$ship}?">
                  <remove_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Ships? and global.$GT_LiveOfferSliceQueue.$Ships.count gt 0">
                  <remove_from_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
                </do_if>
                <do_if value="global.$GT_PathfindingQueue?">
                  <do_if value="global.$GT_PathfindingQueue.$ActiveShips?">
                    <remove_from_list name="global.$GT_PathfindingQueue.$ActiveShips" exact="$ship"/>
                  </do_if>
                  <do_if value="global.$GT_PathfindingQueue.$Requests? and global.$GT_PathfindingQueue.$Requests.count gt 0">
                    <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$qi" reverse="true">
                      <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$qi}"/>
                      <do_if value="$req? and $req.$Ship? and $req.$Ship == $ship">
                        <remove_from_list name="global.$GT_PathfindingQueue.$Requests" exact="$req"/>
                      </do_if>
                    </do_all>
                  </do_if>
                </do_if>
                <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
              </do_else>
            </do_if>
          </do_else>
          </do_if>
        
        <do_if value="$bestTradeIsValidForExecution">
          <!-- Check if we should clear fallback or isolated flags (normal search succeeded) -->
          <do_if value="(global.$GT_FallbackTradeActive.{$ship}? or global.$GT_IsolatedTradeActive.{$ship}?) and $searchState != 'fallback'">
            <!-- Normal search succeeded - clear flags and restore normal name -->
            <do_if value="global.$GT_FallbackTradeActive.{$ship}?">
              <remove_value name="global.$GT_FallbackTradeActive.{$ship}"/>
            </do_if>
            <do_if value="global.$GT_IsolatedTradeActive.{$ship}?">
              <remove_value name="global.$GT_IsolatedTradeActive.{$ship}"/>
            </do_if>
            
            <!-- Calculate rank title from skill level for ship name update -->
            <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
            <do_if value="not $pilotXP?">
              <set_value name="$pilotXP" exact="0"/>
            </do_if>
            <set_value name="$rankTitle" exact="'Lehrling'"/>
            <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
              <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
              <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
              </do_if>
              <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
              </do_if>
            </do_if>
            
            <!-- Update ship name back to normal -->
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship = $ship,
              $pilot = $ship.pilot,
              $xp = $pilotXP,
              $level = $skillLevel,
              $rank = $rankTitle,
              $nameType = 'trader'
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Normal search succeeded - cleared [FALLBACK]/[ISOLATED] flags'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Check if ship is isolated and set [ISOLATED] flag -->
          <set_value name="$shipIsIsolated" exact="false"/>
          <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
            <param name="ship" value="$ship"/>
            <param name="state" value="table[]"/>
          </run_actions>
          <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
          
          <do_if value="$shipIsIsolated and $searchState != 'fallback'">
            <!-- Ship is isolated and found a trade - set isolated flag and update ship name -->
            <do_if value="not global.$GT_IsolatedTradeActive?">
              <set_value name="global.$GT_IsolatedTradeActive" exact="table[]"/>
            </do_if>
            <set_value name="global.$GT_IsolatedTradeActive.{$ship}" exact="true"/>
            
            <!-- Calculate rank title from skill level for ship name update -->
            <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
            <do_if value="not $pilotXP?">
              <set_value name="$pilotXP" exact="0"/>
            </do_if>
            <set_value name="$rankTitle" exact="'Lehrling'"/>
            <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
              <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
              <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
              </do_if>
              <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
              </do_if>
            </do_if>
            
            <!-- Update ship name to show [ISOLATED] flag -->
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship = $ship,
              $pilot = $ship.pilot,
              $xp = $pilotXP,
              $level = $skillLevel,
              $rank = $rankTitle,
              $nameType = 'isolated'
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set [ISOLATED] flag - trade found while ship is isolated'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Log that we're entering the bestTrade execution block -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ENTERING bestTrade execution block'" chance="100"/>
            <!-- Log if this trade came from fallback search -->
            <do_if value="$searchState == 'fallback'">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback search complete: Found ' + (if $tradeList != null then @$tradeList.count else 0) + ' trades'" chance="100"/>
              </do_if>
              
              <!-- Set fallback trade active flag and update ship name to [FALLBACK] -->
              <do_if value="not global.$GT_FallbackTradeActive?">
                <set_value name="global.$GT_FallbackTradeActive" exact="table[]"/>
              </do_if>
              <set_value name="global.$GT_FallbackTradeActive.{$ship}" exact="true"/>
              
              <!-- Calculate rank title from skill level for ship name update -->
              <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
              <do_if value="not $pilotXP?">
                <set_value name="$pilotXP" exact="0"/>
              </do_if>
              <set_value name="$rankTitle" exact="'Lehrling'"/>
              <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
                <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
                <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                  <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
                </do_if>
                <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                  <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
                </do_if>
              </do_if>
              
              <!-- Update ship name to show [FALLBACK] flag -->
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship = $ship,
                $pilot = $ship.pilot,
                $xp = $pilotXP,
                $level = $skillLevel,
                $rank = $rankTitle,
                $nameType = 'fallback'
              ]"/>
              
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set [FALLBACK] flag - trade came from fallback search'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Trade execution with full details -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$wareName" exact="@$bestTrade.$BuyOffer.ware.name"/>
            <set_value name="$buyStationName" exact="@$bestTrade.$BuyOffer.owner.knownname"/>
            <set_value name="$sellStationName" exact="@$bestTrade.$SellOffer.owner.knownname"/>
            <set_value name="$amount" exact="@$bestTrade.$Amount"/>
            <set_value name="$buyPrice" exact="@$bestTrade.$BuyPrice"/>
            <set_value name="$sellPrice" exact="@$bestTrade.$SellPrice"/>
            <set_value name="$distance" exact="@$bestTrade.$Distance"/>
            <set_value name="$profit" exact="@$bestTrade.$Profit"/>
            <set_value name="$roi" exact="@$bestTrade.$ROI"/>
            <set_value name="$score" exact="@$bestTrade.$Score"/>
            <set_value name="$risk" exact="@$bestTrade.$Risk"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') BEST TRADE SELECTED:' + '\n  Ware: ' + $wareName + ' (x' + $amount + ')' + '\n  BUY from: ' + $buyStationName + ' @ ' + ($buyPrice / 100) + ' Cr' + '\n  SELL to: ' + $sellStationName + ' @ ' + ($sellPrice / 100) + ' Cr' + '\n  Distance: ' + $distance + ' jumps' + '\n  Profit: ' + ($profit / 100) + ' Cr' + '\n  ROI: ' + $roi + '%' + '\n  Score: ' + $score + '\n   Risk: ' + $risk" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Fleet coordination: final claim check (closes race between "select best trade" and "reserve") -->
          <!-- If the chosen route is already reserved by another ship, pick the next-best non-conflicted trade. -->
          <do_if value="global.$GT_GlobalSettings.$Fleet.$EnableFleetCoordination">
            <!-- Fleet coordination is best-effort only: it must never block trade execution completely. -->
            <set_value name="$originalBestTrade" exact="$bestTrade"/>

            <!-- Initialize global.$GT_ActiveTradeReservations if it doesn't exist -->
            <do_if value="not global.$GT_ActiveTradeReservations?">
              <set_value name="global.$GT_ActiveTradeReservations" exact="table[]"/>
            </do_if>
            
            <!-- Build reserved route keys (excluding this ship) -->
            <set_value name="$reservedRoutes" exact="[]"/>
            <do_if value="global.$GT_ActiveTradeReservations?">
              <do_all exact="global.$GT_ActiveTradeReservations.keys.count" counter="$resIdx">
                <set_value name="$otherShip" exact="global.$GT_ActiveTradeReservations.keys.{$resIdx}"/>
                <do_if value="$otherShip != $ship and $otherShip.exists">
                  <set_value name="$otherRoute" exact="global.$GT_ActiveTradeReservations.{$otherShip}"/>
                  <do_if value="$otherRoute.$BuyStation? and $otherRoute.$SellStation? and $otherRoute.$Ware?">
                    <do_if value="$otherRoute.$BuyStation.idcode? and $otherRoute.$SellStation.idcode?">
                      <set_value name="$cacheKey" exact="$otherRoute.$BuyStation.idcode + '_' + $otherRoute.$SellStation.idcode + '_' + $otherRoute.$Ware"/>
                      <append_to_list name="$reservedRoutes" exact="$cacheKey"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Check current bestTrade -->
            <set_value name="$fleetBuyStation" exact="@$bestTrade.$BuyOffer.owner"/>
            <set_value name="$fleetSellStation" exact="@$bestTrade.$SellOffer.owner"/>
            <set_value name="$fleetWare" exact="@$bestTrade.$BuyOffer.ware"/>
            <set_value name="$routeConflicted" exact="false"/>
            <do_if value="$reservedRoutes.count gt 0 and $fleetBuyStation? and $fleetSellStation? and $fleetWare?">
              <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$routeConflicted">
                <param name="sellStation" value="$fleetBuyStation"/>
                <param name="buyStation" value="$fleetSellStation"/>
                <param name="ware" value="$fleetWare"/>
                <param name="reservedRoutes" value="$reservedRoutes"/>
              </run_actions>
            </do_if>
            
            <do_if value="$routeConflicted">
              <set_value name="$replacementTrade" exact="null"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$candidate" exact="$tradeList.{$i}"/>
                <set_value name="$candBuyStation" exact="@$candidate.$BuyOffer.owner"/>
                <set_value name="$candSellStation" exact="@$candidate.$SellOffer.owner"/>
                <set_value name="$candWare" exact="@$candidate.$BuyOffer.ware"/>
                <do_if value="$candBuyStation? and $candSellStation? and $candWare?">
                  <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$candConflicted">
                    <param name="sellStation" value="$candBuyStation"/>
                    <param name="buyStation" value="$candSellStation"/>
                    <param name="ware" value="$candWare"/>
                    <param name="reservedRoutes" value="$reservedRoutes"/>
                  </run_actions>
                  <do_if value="not $candConflicted">
                    <set_value name="$replacementTrade" exact="$candidate"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_all>
              
              <do_if value="$replacementTrade != null">
                <set_value name="$bestTrade" exact="$replacementTrade"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Fleet] (' + $ship.idcode + ') Best trade was already reserved - switched to next non-conflicted trade'" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- No non-conflicted trade available: proceed with the best trade anyway. -->
                <!-- Fleet coordination MUST NOT be a show-stopper. -->
                <set_value name="$bestTrade" exact="$originalBestTrade"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Fleet] (' + $ship.idcode + ') All candidates conflicted - proceeding with best trade anyway (best-effort fleet coordination)'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            
            <!-- Reserve trade route for fleet coordination (after claim check) -->
            <do_if value="$bestTrade != null">
              <set_value name="$fleetBuyStation" exact="@$bestTrade.$BuyOffer.owner"/>
              <set_value name="$fleetSellStation" exact="@$bestTrade.$SellOffer.owner"/>
              <set_value name="$fleetWare" exact="@$bestTrade.$BuyOffer.ware"/>
              <do_if value="$fleetBuyStation? and $fleetSellStation? and $fleetWare?">
                <set_value name="global.$GT_ActiveTradeReservations.{$ship}" exact="table[
                  $BuyStation = $fleetBuyStation,
                  $SellStation = $fleetSellStation,
                  $Ware = $fleetWare,
                  $Timestamp = player.age
                ]"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Execute trade (only if still valid after claim check) -->
          <do_if value="$bestTrade != null">
            <!-- Phase 3: Reserve trade before execution to prevent other ships from selecting it -->
            <!-- Extract offers -->
            <set_value name="$bestBuyOffer" exact="@$bestTrade.$BuyOffer"/>
            <set_value name="$bestSellOffer" exact="@$bestTrade.$SellOffer"/>
            <set_value name="$bestTradeKey" exact="''"/>
            
            <!-- Generate trade key for reservation.
                 Note: offer.id is not reliably available; GT_GenerateTradeKey has a fallback (method B) to keep reservations working. -->
            <run_actions ref="md.GT_Libraries_General.GT_GenerateTradeKey" result="$bestTradeKey">
              <param name="buyOffer" value="$bestBuyOffer"/>
              <param name="sellOffer" value="$bestSellOffer"/>
              <param name="traceId" value="$traceId"/>
            </run_actions>

            <do_if value="$bestTradeKey != ''">
              <!-- Final claim check: verify trade is not reserved by another ship -->
              <run_actions ref="md.GT_Libraries_General.GT_IsTradeReserved" result="$bestTradeReserved">
                <param name="tradeKey" value="$bestTradeKey"/>
                <param name="ship" value="$ship"/>
                <param name="traceId" value="$traceId"/>
              </run_actions>
              <do_if value="$bestTradeReserved">
                <!-- Trade was reserved by another ship between selection and reservation - skip it -->
                <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                  <param name="traceId" value="$traceId"/>
                  <param name="stage" value="'Reservation'"/>
                  <param name="action" value="'Conflict'"/>
                  <param name="details" value="'trade=' + $bestTradeKey + ' ship=' + $ship.idcode + ' reason=race_condition'"/>
                  <param name="logLevel" value="1"/>
                </run_actions>
                <!-- Try next trade from list if available -->
                <set_value name="$fallbackTrade" exact="null"/>
                <do_all exact="$tradeList.count" counter="$ti">
                  <set_value name="$candidateTrade" exact="$tradeList.{$ti}"/>
                  <do_if value="$candidateTrade != null and $candidateTrade != $bestTrade">
                    <set_value name="$candidateBuyOffer" exact="@$candidateTrade.$BuyOffer"/>
                    <set_value name="$candidateSellOffer" exact="@$candidateTrade.$SellOffer"/>
                    <set_value name="$candidateKey" exact="''"/>
                    <run_actions ref="md.GT_Libraries_General.GT_GenerateTradeKey" result="$candidateKey">
                      <param name="buyOffer" value="$candidateBuyOffer"/>
                      <param name="sellOffer" value="$candidateSellOffer"/>
                      <param name="traceId" value="$traceId"/>
                    </run_actions>
                    <do_if value="$candidateKey != ''">
                      <run_actions ref="md.GT_Libraries_General.GT_IsTradeReserved" result="$candidateReserved">
                        <param name="tradeKey" value="$candidateKey"/>
                        <param name="ship" value="$ship"/>
                        <param name="traceId" value="$traceId"/>
                      </run_actions>
                      <do_if value="not $candidateReserved">
                        <set_value name="$fallbackTrade" exact="$candidateTrade"/>
                        <set_value name="$bestTrade" exact="$candidateTrade"/>
                        <set_value name="$bestTradeKey" exact="$candidateKey"/>
                        <break/>
                      </do_if>
                    </do_if>
                  </do_if>
                </do_all>
                <!-- If no fallback found, signal no trade -->
                <do_if value="$fallbackTrade == null">
                  <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                    <param name="traceId" value="$traceId"/>
                    <param name="stage" value="'Reservation'"/>
                    <param name="action" value="'NoFallback'"/>
                    <param name="details" value="'trade=' + $bestTradeKey + ' ship=' + $ship.idcode + ' reason=all_reserved'"/>
                    <param name="logLevel" value="1"/>
                  </run_actions>
                  <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'reserved'"/>
                  <cancel_cue cue="this"/>
                </do_if>
              </do_if>
              
              <!-- Reserve the trade (or fallback trade) -->
              <run_actions ref="md.GT_Libraries_General.GT_ReserveTrade" result="$reservationSuccess">
                <param name="tradeKey" value="$bestTradeKey"/>
                <param name="ship" value="$ship"/>
                <param name="ttl" value="10s"/>
                <param name="traceId" value="$traceId"/>
              </run_actions>
              <do_if value="not $reservationSuccess">
                <!-- Reservation failed (conflict) - try next trade or signal no trade -->
                <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                  <param name="traceId" value="$traceId"/>
                  <param name="stage" value="'Reservation'"/>
                  <param name="action" value="'ReserveFailed'"/>
                  <param name="details" value="'trade=' + $bestTradeKey + ' ship=' + $ship.idcode"/>
                  <param name="logLevel" value="1"/>
                </run_actions>
                <!-- Try fallback trades -->
                <set_value name="$fallbackTrade" exact="null"/>
                <do_all exact="$tradeList.count" counter="$ti">
                  <set_value name="$candidateTrade" exact="$tradeList.{$ti}"/>
                  <do_if value="$candidateTrade != null and $candidateTrade != $bestTrade">
                    <set_value name="$candidateBuyOffer" exact="@$candidateTrade.$BuyOffer"/>
                    <set_value name="$candidateSellOffer" exact="@$candidateTrade.$SellOffer"/>
                    <set_value name="$candidateKey" exact="''"/>
                    <run_actions ref="md.GT_Libraries_General.GT_GenerateTradeKey" result="$candidateKey">
                      <param name="buyOffer" value="$candidateBuyOffer"/>
                      <param name="sellOffer" value="$candidateSellOffer"/>
                      <param name="traceId" value="$traceId"/>
                    </run_actions>
                    <do_if value="$candidateKey != ''">
                      <run_actions ref="md.GT_Libraries_General.GT_ReserveTrade" result="$candidateReserved">
                        <param name="tradeKey" value="$candidateKey"/>
                        <param name="ship" value="$ship"/>
                        <param name="ttl" value="10s"/>
                        <param name="traceId" value="$traceId"/>
                      </run_actions>
                      <do_if value="$candidateReserved">
                        <set_value name="$fallbackTrade" exact="$candidateTrade"/>
                        <set_value name="$bestTrade" exact="$candidateTrade"/>
                        <set_value name="$bestTradeKey" exact="$candidateKey"/>
                        <break/>
                      </do_if>
                    </do_if>
                  </do_if>
                </do_all>
                <!-- If no fallback found, signal no trade -->
                <do_if value="$fallbackTrade == null">
                  <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'reserved'"/>
                  <cancel_cue cue="this"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- DEBUG: Log exact trade list being sent to trading AI -->
            <!-- COMMENTED OUT: Reduces log spam - uncomment if needed for debugging -->
            <!-- <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$logTradeList" exact="'[GT-Search] SENDING TRADE LIST TO AI: ' + $ship.idcode + ' (' + $tradeList.count + ' trades)'"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$listTrade" exact="$tradeList.{$i}"/>
                <set_value name="$logTradeList" exact="$logTradeList + 
                  '\n  [' + $i + '] ' + @$listTrade.$BuyOffer.ware.name + 
                  ' | Buy: ' + @$listTrade.$BuyStation.knownname + ' @ ' + (@$listTrade.$BuyPrice / 100) + ' Cr' +
                  ' | Sell: ' + @$listTrade.$SellStation.knownname + ' @ ' + (@$listTrade.$SellPrice / 100) + ' Cr' +
                  ' | Score: ' + $listTrade.$Score + ' | Profit: ' + (@$listTrade.$Profit / 100) + ' Cr | ROI: ' + @$listTrade.$ROI + '% | Dist: ' + $listTrade.$Distance + ' jumps'"/>
              </do_all>
              <debug_text text="$logTradeList" chance="100"/>
            </do_if> -->
            
            <!-- Clear fallback logbook flag when trade is found (allows new message for next search cycle) -->
            <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
              <remove_value name="global.$GT_FallbackLogbookWritten.{$ship}"/>
            </do_if>
            
            <!-- Signal execution module (which will signal AI after storing trade LIST) -->
            <!-- Pass searchMethod so AI knows if trades came from cache or live search -->
            <!-- Pass trade key and trace ID for reservation cleanup -->
            <signal_cue_instantly cue="md.GT_Trading_Execution.ExecuteTrade" param="table[
              $Ship = $ship,
              $Trade = $bestTrade,
              $TradeList = $tradeList,
              $SearchMethod = $searchMethod,
              $TradeKey = $bestTradeKey,
              $TraceId = $traceId
            ]"/>
            
            <!-- GT_Trade_Found signal now sent FROM ExecuteTrade cue after storing pending trade -->
          </do_if>
          <do_else>
            <!-- No non-conflicted trade remained after fleet claim check -->
            <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
          </do_else>
        </do_if>
        
        <do_else>
          <!-- No valid trades found -->
          
          <!-- Check batch status BEFORE executing "no trade found" logic -->
          <!-- If batch is in progress, exit immediately - don't process stale data or signal failure -->
          <!-- SearchLiveTrades_Resume will signal this cue again when batch completes -->
          <set_value name="$batchStillInProgress" exact="false"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$WaitingForBatch?">
            <set_value name="$batchStillInProgress" exact="global.$GT_SearchResult.{$ship}.$WaitingForBatch"/>
          </do_if>
          
          <do_if value="$batchStillInProgress">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Batch processing still in progress - skipping no-trade-found logic (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <!-- Exit - SearchLiveTrades_Resume will signal this cue again when batch completes -->
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- Batch processing is complete - safe to proceed with "no trade found" logic -->
            
            <!-- DEBUG: No trades found (only if not waiting for batch) -->
            <do_if value="not $waitingForBatch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <!-- Show detailed analysis when no trades found (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <!-- Debug-only calculations for analysis message -->
              <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedDistance + $tradesRejectedAmount"/>
              <!-- Defensive: these are computed later for logbook storage, but this analysis debug_text uses them now. -->
              <!-- Initialize to prevent "Property lookup failed" when the analysis runs before the stats block. -->
              <set_value name="$totalBlacklistFiltered" exact="0"/>
              <set_value name="$totalEvaluated" exact="0"/>
              <!-- Get valid entries count from cache search (if available) -->
              <set_value name="$validEntries" exact="0"/>
              <set_value name="$diverseListCount" exact="0"/>
              <do_if value="global.$GT_SearchResult.{$ship}.$ValidEntries?">
                <set_value name="$validEntries" exact="global.$GT_SearchResult.{$ship}.$ValidEntries"/>
              </do_if>
              <do_if value="global.$GT_SearchResult.{$ship}.$DiverseListCount?">
                <set_value name="$diverseListCount" exact="global.$GT_SearchResult.{$ship}.$DiverseListCount"/>
              </do_if>
              
              <!-- FIX: Always log counters even if 0 or missing to avoid misleading diagnostics -->
              <set_value name="$stationsEvaluatedDisplay" exact="if $stationsEvaluated? then $stationsEvaluated else 0"/>
              <set_value name="$offersFoundDisplay" exact="if $offersFound? then $offersFound else 0"/>
              <!-- FIX: Detect if live search was skipped vs actually ran -->
              <set_value name="$liveSearchSkippedCheck" exact="if $liveSearchSkipped? then $liveSearchSkipped else false"/>
              <set_value name="$diagnosticInfo" exact="'\n\nSEARCH CONTEXT:' +
                '\n  Search method: ' + $searchMethod +
                (if $cacheChecked then '\n  Cache checked: Yes (' + $cacheCount + ' entries)' else '\n  Cache checked: No') +
                (if $searchMethod == 'live' and $liveSearchSkippedCheck then '\n  Live search SKIPPED (ship isolated or fallback already attempted)' else '') +
                (if $searchMethod == 'live' and not $liveSearchSkippedCheck then '\n  Stations evaluated: ' + $stationsEvaluatedDisplay else '') +
                (if $searchMethod == 'live' and not $liveSearchSkippedCheck then '\n  Offers found: ' + $offersFoundDisplay else '') +
                (if $searchMethod == 'cache' and $validEntries gt 0 then '\n  Valid cached trades found: ' + $validEntries + ' (diverse list: ' + $diverseListCount + ')' else '') +
                (if $totalRejected == 0 and $validEntries == 0 and $offersFoundDisplay == 0 and not $liveSearchSkippedCheck then '\n  No trades were evaluated (cache empty or no offers found)' else '') +
                (if $validEntries gt 0 and $diverseListCount == 0 then '\n  All valid trades filtered out during diverse list building (need unique station pairs)' else '')"/>
              
              <!-- Build best rejected trade info safely (extract properties first, then check) -->
              <set_value name="$bestRejectedInfo" exact="''"/>
              <do_if value="$bestRejectedTrade?">
                <!-- Extract properties safely -->
                <set_value name="$rejectedWare" exact="@$bestRejectedTrade.$ware"/>
                <set_value name="$rejectedBuyFrom" exact="@$bestRejectedTrade.$buyFrom"/>
                <set_value name="$rejectedSellTo" exact="@$bestRejectedTrade.$sellTo"/>
                <set_value name="$rejectedBuyPrice" exact="@$bestRejectedTrade.$buyPrice"/>
                <set_value name="$rejectedSellPrice" exact="@$bestRejectedTrade.$sellPrice"/>
                <set_value name="$rejectedProfit" exact="@$bestRejectedTrade.$profit"/>
                <set_value name="$rejectedROI" exact="@$bestRejectedTrade.$roi"/>
                
                <!-- Build info string with safe checks (use @ operator for property access) -->
                <set_value name="$bestRejectedInfo" exact="'\n\nBEST REJECTED TRADE (still unprofitable):' +
                  '\n  Ware: ' + (if $rejectedWare? then @$rejectedWare.name else 'Unknown') +
                  '\n  Buy from: ' + (if $rejectedBuyFrom? then @$rejectedBuyFrom.knownname else 'Unknown') + ' @ ' + (if $rejectedBuyPrice? then ($rejectedBuyPrice / 100) else '0') + ' Cr/unit' +
                  '\n  Sell to: ' + (if $rejectedSellTo? then @$rejectedSellTo.knownname else 'Unknown') + ' @ ' + (if $rejectedSellPrice? then ($rejectedSellPrice / 100) else '0') + ' Cr/unit' +
                  '\n  Best profit found: ' + (if $rejectedProfit? then ($rejectedProfit / 100) else '0') + ' Cr (needed: ' + ($minAbsoluteProfit / 100) + ' Cr)' +
                  '\n  Best ROI found: ' + (if $rejectedROI? then $rejectedROI else '0') + '% (needed: ' + $minROI + '%)'"/>
              </do_if>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') === NO TRADES FOUND ANALYSIS ===' + 
                '\nShip: ' + $ship.knownname + 
                '\nSector: ' + $ship.sector.knownname + 
                '\nSearch Method: ' + $searchMethod +
                '\nSearch params: Dist=' + $maxDistance + ', MinROI=' + $minROI + '%, MinAbsoluteProfit=' + ($minAbsoluteProfit / 100) + ' Cr' +
                $diagnosticInfo +
                '\n\nREJECTION STATISTICS:' +
                '\n  Docking not allowed: ' + $tradesRejectedDocking +
                '\n  Insufficient profit: ' + $tradesRejectedProfit +
                '\n  Distance too far: ' + $tradesRejectedDistance +
                '\n  Amount zero/negative: ' + $tradesRejectedAmount +
                '\n  Blacklisted/Path blocked: ' + $totalBlacklistFiltered +
                '\n' +
                '\n  TOTAL REJECTED: ' + $totalRejected +
                '\n  TOTAL EVALUATED: ' + $totalEvaluated +
                '\n  OFFERS FOUND: ' + $offersFoundDisplay +
                $bestRejectedInfo" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Commented out to reduce log spam -->
          <!-- <debug_text text="'[GalaxyTrader MK3] No profitable trades found for ' + $ship.knownname" chance="100"/> -->
          
          <!-- Store rejection statistics for AI script to use after 60s wait -->
          <!-- Logbook entry will be written by AI script only after max wait time (60s) -->
          <!-- Note: Get filtered counts from live search resume if available (tracks blacklist/path filtering) -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: If using continuation, $tradesRejectedBlacklist already includes combined value -->
          <!-- Otherwise, combine evaluation-phase rejections + pre-filtering rejections -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <do_if value="$searchState == 'fresh'">
            <!-- Not a continuation: combine evaluation-phase + pre-filtering rejections -->
            <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist + $filteredByBlacklistFromResume + $filteredByPathBlockedFromResume"/>
          </do_if>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = evaluation-phase rejections + valid trades found + pre-filtered trades -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <!-- If we have resume stats, use those (more accurate) -->
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <!-- Fallback: Use rejection count if we have rejections, or offers found count -->
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          <do_else>
            <!-- No stats available - default to 0 (no trades found at all) -->
            <set_value name="$totalEvaluated" exact="0"/>
          </do_else>
          
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          
          <!-- DEBUG: Log rejection stats before storing (only if debug logging enabled) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORING REJECTION STATS FOR LOGBOOK:' +
              '\n  SectorName: ' + (if $currentSectorName? then $currentSectorName else 'null') +
              '\n  MaxDistance: ' + $maxDistance +
              '\n  MinAbsoluteProfit: ' + ($minAbsoluteProfit/100) + ' Cr' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalRejected: ' + $totalRejected +
              '\n  RejectedDocking: ' + $tradesRejectedDocking +
              '\n  RejectedProfit: ' + $tradesRejectedProfit +
              '\n  RejectedAmount: ' + $tradesRejectedAmount +
              '\n  RejectedBlacklist (eval phase): ' + $tradesRejectedBlacklist +
              '\n  FilteredBlacklist (pre-filter): ' + $filteredByBlacklistFromResume +
              '\n  FilteredPathBlocked (pre-filter): ' + $filteredByPathBlockedFromResume +
              '\n  TotalBlacklistFiltered: ' + $totalBlacklistFiltered +
              '\n  OffersFound: ' + $offersFound +
              '\n  TotalTradesFromResume: ' + $totalTradesFromResume" 
              chance="100"/>
          </do_if>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from batch processor results or live search continuation -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 (stats might be in global from FilterTradeList_Resume) -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats?">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="($existingTotal? and $existingTotal gt 0) or ($existingDocking? and $existingDocking gt 0) or ($existingProfit? and $existingProfit gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Log storage decision (only if debug logging enabled) -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') LastRejectionStats STORAGE DECISION:' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  ExistingStats exists: ' + (if $existingStats != null then 'yes' else 'no') +
              '\n  ExistingTotal: ' + (if $existingTotal != null then $existingTotal else 'null') +
              '\n  ExistingDocking: ' + (if $existingDocking != null then $existingDocking else 'null') +
              '\n  ExistingProfit: ' + (if $existingProfit != null then $existingProfit else 'null') +
              '\n  HasExistingStats: ' + $hasExistingStats +
              '\n  Will store: ' + (if ($totalEvaluated gt 0 or not $hasExistingStats) then 'yes' else 'no')" 
              chance="100"/>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <!-- CRITICAL: Check $ship exists before updating stats -->
          <do_if value="$ship? and ($totalEvaluated gt 0 or not $hasExistingStats)">
            <!-- SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Use library function to update rejection stats -->
            <!-- CRITICAL: $ship is validated above, safe to pass to library -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateRejectionStats">
              <param name="ship" value="$ship"/>
              <param name="stats" value="$newShipStats"/>
            </run_actions>
            
            <!-- DEBUG: Verify storage succeeded (only if debug logging enabled) -->
            <!-- CRITICAL: Check $ship exists before using it -->
            <do_if value="$ship? and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$verifyStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
              <set_value name="$verifyTotal" exact="@$verifyStats.$Total"/>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORED LastRejectionStats - Verification:' +
                '\n  Stored Total: ' + (if $verifyTotal? then $verifyTotal else 'null') +
                '\n  Stored Docking: ' + (if $verifyStats.$Docking? then $verifyStats.$Docking else 'null') +
                '\n  Stored Profit: ' + (if $verifyStats.$Profit? then $verifyStats.$Profit else 'null') +
                '\n  Stored Amount: ' + (if $verifyStats.$Amount? then $verifyStats.$Amount else 'null') +
                '\n  Stored Blacklist: ' + (if $verifyStats.$Blacklist? then $verifyStats.$Blacklist else 'null')" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Check if we should trigger fallback search before signaling no trade found -->
          <!-- This is the "no trades found" path after live search continuation completes -->
          <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
            <!-- Check if fallback was already attempted in this search cycle -->
            <set_value name="$fallbackAlreadyAttempted" exact="false"/>
            <do_if value="global.$GT_FallbackAttempted.{$ship}?">
              <set_value name="$fallbackAlreadyAttempted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Cache search failed, live search failed - check if ship is isolated -->
            <set_value name="$shipIsIsolated" exact="false"/>
            <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
              <param name="ship" value="$ship"/>
              <param name="state" value="table[]"/>
            </run_actions>
            <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
            
            <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted -->
            <!-- CRITICAL: Prevent fallback from starting while we're already waiting for an async live/batch pipeline,
                 and never trigger fallback for ships denied by home_refresh (cancel_cue fallthrough can reach here). -->
            <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted and $shouldDoLiveSearch and not $waitingForLiveSearch and not $denyHomeRefresh">
              <!-- Ensure table exists before accessing -->
              <do_if value="not global.$GT_FallbackAttempted?">
                <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
              </do_if>
              
              <!-- Check if logbook message was already written for this fallback attempt -->
              <!-- Use a separate flag to prevent logbook spam -->
              <!-- Ensure table exists before checking -->
              <do_if value="not global.$GT_FallbackLogbookWritten?">
                <set_value name="global.$GT_FallbackLogbookWritten" exact="table[]"/>
              </do_if>
              
              <!-- Check if logbook already written - if so, skip writing -->
              <set_value name="$logbookAlreadyWritten" exact="false"/>
              <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
                <set_value name="$logbookAlreadyWritten" exact="true"/>
              </do_if>
              
              <!-- Calculate skill level for fallback distance calculation -->
              <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
                <param name="ship" value="$ship"/>
              </run_actions>
              <set_value name="$fallbackSkillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>
              
              <!-- Use originalMaxDistance for fallback calculation if available (prevents decreasing distance) -->
              <!-- If this is already a fallback continuation, $maxDistance is already reduced, so use originalMaxDistance -->
              <set_value name="$distanceForFallbackCalc" exact="$maxDistance"/>
              <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                <set_value name="$distanceForFallbackCalc" exact="$originalMaxDistance"/>
              </do_if>
              
              <!-- Calculate fallback distance: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
              <set_value name="$fallbackMaxDistance" exact="1"/>  <!-- Default fallback to 1 -->
              <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackDistance" result="$fallbackMaxDistance">
                <param name="maxDistance" value="$distanceForFallbackCalc"/>
                <param name="skillLevel" value="$fallbackSkillLevel"/>
              </run_actions>
              
              <!-- Write logbook message ONLY if not already written for this fallback attempt -->
              <do_if value="not $logbookAlreadyWritten">
                <!-- Set flag IMMEDIATELY before writing to prevent race conditions -->
                <set_value name="global.$GT_FallbackLogbookWritten.{$ship}" exact="true"/>
                
                <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
                <do_if value="not $currentSectorName?">
                  <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
                </do_if>
                
                <!-- Use originalMaxDistance in logbook message if available (shows original search range) -->
                <set_value name="$originalSearchRange" exact="$maxDistance"/>
                <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                  <set_value name="$originalSearchRange" exact="$originalMaxDistance"/>
                </do_if>
                
                <!-- Construct logbook message using TextDB syntax with calculated fallback distance -->
                <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $originalSearchRange, $fallbackMaxDistance]"/>
                
                <!-- Write logbook entry using centralized library -->
                <run_actions ref="md.GT_Libraries_General.WriteLogbookMessage">
                  <param name="Message" value="$logbookMessage"/>
                  <param name="Category" value="'alerts'"/>
                  <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                  <param name="Object" value="$ship"/>
                  <param name="Interaction" value="'showonmap'"/>
                  <param name="CheckGlobalSettings" value="true"/>
                </run_actions>
              </do_if>
              
              <!-- Mark that fallback search was triggered -->
              <set_value name="$fallbackSearchTriggered" exact="true"/>
              
              <!-- Mark fallback as attempted globally (persists across cue instances) -->
              <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
              
              <!-- Trigger fallback search -->
              <!-- Fallback uses lower profit thresholds, so we compensate by restricting travel distance -->
              <!-- Formula: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
              <!-- OriginalMaxDistance used for filtering stations from home sector -->
              <!-- CRITICAL: Pass $originalMaxDistance (not $maxDistance) to preserve original search range -->
              <set_value name="$fallbackParams" exact="table[
                $Ship = $ship,
                $MaxDistance = $fallbackMaxDistance,
                $OriginalMaxDistance = $originalMaxDistance,
                $MinROI = $minROI,
                $MinAbsoluteProfit = $minAbsoluteProfit,
                $FactionPriority = $factionPriority,
                $FactionPriorityText = $factionPriorityText,
                $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                $SkillLevel = $skillLevel,
                $ThreatIntel = $gt_ThreatIntel,
                $FleetCoord = $gt_FleetCoord,
                $AdvancedAnalytics = $gt_AdvancedAnalytics
              ]"/>
              <signal_cue_instantly cue="md.GT_Search_Methods.SearchFallbackTrades" param="$fallbackParams"/>
              
              <!-- Exit - SearchFallbackTrades will signal SearchTradeRoutes again when complete -->
              <set_value name="$waitingForLiveSearch" exact="true"/>
              <set_value name="$deferNoTradeFound" exact="true"/>
              <!-- Do NOT cancel here; we must reach unified cleanup to release queue slots while retaining the lock. -->
            </do_if>
            <do_else>
              <!-- Ship is isolated - signal no trade found (normal behavior for isolated ships) -->
              <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
            <!-- Log if fallback search completed with no trades -->
            <do_if value="$searchState == 'fallback' and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback search complete: No trades found'" chance="100"/>
            </do_if>
            
            <!-- FIX: Clear failed sector pairs if fallback search also found nothing (prevents deadlock) -->
            <!-- If both normal and fallback searches found nothing, failed sector pairs are blocking everything -->
            <!-- Clear them to allow ship to retry routes that may have become available -->
            <!-- Clear per-sector (not per-ship) so all ships in the sector benefit -->
            <do_if value="$searchState == 'fallback'">
              <set_value name="$currentSector" exact="$ship.sector"/>
              <do_if value="$currentSector? and $currentSector.exists and global.$GT_FailedSectorPairs? and global.$GT_FailedSectorPairs.{$currentSector}?">
                <set_value name="$failedTradesCount" exact="global.$GT_FailedSectorPairs.{$currentSector}.count"/>
                <remove_value name="global.$GT_FailedSectorPairs.{$currentSector}"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$sectorName" exact="@$currentSector.knownname"/>
                  <debug_text text="'[GT-Search] Cleared ' + $failedTradesCount + ' failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (Ship: ' + $ship.idcode + ', fallback search also found nothing - preventing deadlock)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Only signal NoTradeFound if we did NOT defer to an async fallback/live pipeline in this invocation. -->
            <do_if value="not $deferNoTradeFound">
              <!-- ENHANCED: Log before signaling no trade found (debug mode only) -->
              <!-- CRITICAL: Check $ship exists before using it -->
              <do_if value="$ship? and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Search complete - signaling GT_No_Trade_Found (TotalRejected=' + $totalRejected + ', TotalEvaluated=' + $totalEvaluated + ', OffersFound=' + $offersFound + ')'" chance="100"/>
              </do_if>
              <!-- Signal back to AI script: No Trade Found -->
              <!-- CRITICAL: Always send 'blacklist' param to prevent idle timeout escalation -->
              <!-- Reason: With blacklist-aware pre-filtering, we can't distinguish "filtered" from "genuinely empty" -->
              <!-- Better UX: Don't escalate to 60s timeout when ship might just need blacklist adjustment -->
              <!-- CRITICAL: Check $ship exists before signaling -->
              <do_if value="$ship?">
                <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
              </do_if>
            </do_if>
          </do_else>
          </do_else>
        </do_else>
        </do_if>
        
        <!-- Release search lock ONLY if NOT waiting for batch processing FOR THIS SHIP -->
        <!-- If waiting for batch, SearchLiveTrades_Resume will signal SearchTradeRoutes again -->
        <!-- and we'll release the lock after processing live search results -->
        <!-- If we're continuing from live search, this IS the final completion, so release the lock -->
        <!-- CRITICAL: Check $params exists before accessing $params.$Ship -->
        <set_value name="$shipForCleanup" exact="null"/>
        <do_if value="$params? and $params.$Ship?">
          <set_value name="$shipForCleanup" exact="$params.$Ship"/>
        </do_if>
        <do_if value="$shouldProceed and $ship?">
          <!-- If we proceeded, use the processed $ship (might have been modified) -->
          <set_value name="$shipForCleanup" exact="$ship"/>
        </do_if>
        
        <!-- CRITICAL FIX: Ensure we have a ship for cleanup - fallback to params.$Ship if available -->
        <!-- This prevents lock leaks when $shouldProceed is false but we still need to clean up -->
        <do_if value="not $shipForCleanup? and $params? and $params.$Ship?">
          <set_value name="$shipForCleanup" exact="$params.$Ship"/>
        </do_if>
        
        <!-- CRITICAL: Only proceed with cleanup if we have a valid ship -->
        <do_if value="$shipForCleanup?">
          <set_value name="$isWaitingForThisShipBatch" exact="false"/>
          <do_if value="$waitingForBatch and $params? and $params.$Ship? and $batchShip == $params.$Ship">
            <set_value name="$isWaitingForThisShipBatch" exact="true"/>
          </do_if>

          <!-- ALSO treat "live search started in this invocation" as an async continuation that must retain the lock.
               Otherwise we release the request registry immediately, and the next SearchTradeRoutes run (cooldown path)
               will incorrectly signal GT_No_Trade_Found while the live/batch pipeline is still running. -->
          <set_value name="$isWaitingForContinuation" exact="$isWaitingForThisShipBatch"/>
          <do_if value="$waitingForLiveSearch">
            <set_value name="$isWaitingForContinuation" exact="true"/>
          </do_if>
          
          <!-- CRITICAL FIX: Check for stale async continuations - release lock if continuation is too old -->
          <set_value name="$continuationStale" exact="false"/>
          <do_if value="$isWaitingForContinuation">
            <!-- Check lock age - if lock is older than 60 seconds, the continuation is stale -->
            <set_value name="$lockTime" exact="null"/>
            <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$shipForCleanup}?">
              <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$shipForCleanup}"/>
            </do_if>
            <do_if value="$lockTime?">
              <set_value name="$lockAge" exact="player.age - $lockTime"/>
              <do_if value="$lockAge gt 60">
                <!-- Lock is stale - release it and clear continuation flags -->
                <set_value name="$continuationStale" exact="true"/>
                <set_value name="$isWaitingForContinuation" exact="false"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $shipForCleanup.idcode + ') Async continuation is stale (lock age: ' + $lockAge + 's) - releasing lock'" chance="100"/>
                </do_if>
                <!-- Clear stale state if present -->
                <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$shipForCleanup}?">
                  <set_value name="$staleHomeSector" exact="@global.$GT_SearchLiveTrades_State.{$shipForCleanup}.$HomeSector"/>
                  <remove_value name="global.$GT_SearchLiveTrades_State.{$shipForCleanup}"/>
                  
                  <!-- CRITICAL FIX: Clear home refresh marker if this ship was the initiator -->
                  <!-- This prevents other ships from being blocked by a stuck refresh -->
                  <do_if value="$staleHomeSector? and global.$GT_TS_LiveRefreshBySector? and global.$GT_TS_LiveRefreshBySector.{$staleHomeSector}?">
                    <set_value name="$refreshEntry" exact="global.$GT_TS_LiveRefreshBySector.{$staleHomeSector}"/>
                    <do_if value="$refreshEntry? and $refreshEntry.$Initiator? and $refreshEntry.$Initiator == $shipForCleanup">
                      <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                        <debug_text text="'[GT-Search] (' + $shipForCleanup.idcode + ') Clearing stale home refresh marker (home=' + @$staleHomeSector.knownname + ')'" chance="100"/>
                      </do_if>
                      <remove_value name="global.$GT_TS_LiveRefreshBySector.{$staleHomeSector}"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
        
          <!-- Release lock and parameters using Request Registry -->
          <!-- Only release if NOT waiting for async continuation (live search + batch) FOR THIS SHIP -->
          <!-- OR if continuation is stale (timeout) -->
          <!-- If waiting for batch, we'll need these parameters when processing live search results -->
          <!-- If we're continuing from live search, this IS the final completion, so clean up parameters -->
          <do_if value="not $isWaitingForContinuation or $searchState == 'live' or $searchState == 'fallback' or $continuationStale">
            <set_value name="$releaseReason" exact="if ($searchState == 'live' or $searchState == 'fallback') then 'live search continuation complete' else 'search complete'"/>
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$shipForCleanup"/>
              <param name="reason" value="$releaseReason"/>
            </run_actions>
            
            <!-- CRITICAL: Clean up live search state when processing live/fallback continuation successfully -->
            <!-- This prevents stale state from blocking future fresh searches -->
            <do_if value="($searchState == 'live' or $searchState == 'fallback') and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$shipForCleanup}?">
              <remove_value name="global.$GT_SearchLiveTrades_State.{$shipForCleanup}"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $shipForCleanup.idcode + ') Cleaned up live search state after successful processing (SearchState=' + $searchState + ')'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Removed unused TradeRequestQueue bookkeeping (cleanup) -->
          </do_if>
          <do_else>
            <!-- Async continuation in progress FOR THIS SHIP - keep lock until live search/batch completes -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $shipForCleanup.idcode + ') Search lock retained (waiting for live search/batch to complete)'" chance="100"/>
            </do_if>
          </do_else>
          
          <!-- Mark search complete and process next ship in queue -->
          <!-- Use $shipForCleanup instead of $ship (available even if $shouldProceed was false) -->
          <set_value name="$shipForQueue" exact="$shipForCleanup"/>

          <!-- If this run used a cache-search queue slot, release it -->
          <do_if value="$useSearchQueueCounter">
            <!-- IMPORTANT:
                 When we defer to LIVE search, SearchLiveTrades_Resume needs the ORIGINAL params to signal SearchTradeRoutes again.
                 So: release the cache-search slot, but DO NOT delete $Params while live-search is in progress for this ship. -->
            <set_value name="$keepSearchQueueParams" exact="false"/>
            <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$shipForQueue}?">
              <set_value name="$keepSearchQueueParams" exact="true"/>
            </do_if>
            <do_if value="not $keepSearchQueueParams">
              <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$shipForQueue}?">
                <remove_value name="global.$GT_SearchQueue.$Params.{$shipForQueue}"/>
              </do_if>
            </do_if>
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="false"/>
            </run_actions>
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <!-- Null-safe: we no longer guarantee global.$GT_SearchQueue.$Ships exists when bypassing legacy cache queue. -->
              <set_value name="$sqActive" exact="0"/>
              <set_value name="$sqMax" exact="0"/>
              <set_value name="$sqQueued" exact="0"/>
              <do_if value="global.$GT_SearchQueue?">
                <do_if value="global.$GT_SearchQueue.$ActiveSearches?">
                  <set_value name="$sqActive" exact="global.$GT_SearchQueue.$ActiveSearches"/>
                </do_if>
                <do_if value="global.$GT_SearchQueue.$MaxConcurrent?">
                  <set_value name="$sqMax" exact="global.$GT_SearchQueue.$MaxConcurrent"/>
                </do_if>
                <do_if value="global.$GT_SearchQueue.$Ships?">
                  <set_value name="$sqQueued" exact="global.$GT_SearchQueue.$Ships.count"/>
                </do_if>
              </do_if>
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $shipForQueue.idcode + ') SEARCH COMPLETE (active: ' + $sqActive + '/' + $sqMax + ', queued: ' + $sqQueued + ')'" chance="100"/>
            </do_if>
            <!-- Continue processing cache-search queue if there are ships waiting -->
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
            </do_if>
          </do_if>

          <!-- LiveSearchQueue removed (hub finalization): live work is scheduled via HomeSearch work items only. -->
        </do_if>
        <do_else>
          <!-- No valid ship for cleanup - skip cleanup but still process queue -->
          <!-- This can happen if params were invalid and cue should have been cancelled earlier -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchTradeRoutes: Skipping cleanup - no valid ship (params invalid or cue cancelled)'" chance="100"/>
          </do_if>
          
          <!-- Still decrement cache-search queue counter (only if this run used it) -->
          <do_if value="$useSearchQueueCounter">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
          </do_if>

          <!-- Release live-search slot if we had one -->
          <do_if value="$fromLiveQueue and $params.$LiveSlotAcquired? and $params.$LiveSlotAcquired == true">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveLiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
          </do_if>
        </do_else>
        
        <!-- Close live-search wait guard -->
        </do_if>
        
        <!-- Close cache-ready gate -->
        </do_if>

        <!-- Close $hasGTOrder gate -->
        </do_if>

        <!-- Close $paramsValid gate -->
        </do_if>
      </actions>
    </cue>
    <!--  -->
    <!-- SearchLiveTrades_Resume: Process batch processor results with ship-specific filtering -->
    <!-- This cue receives completed batch processing results and applies ship-specific filters -->
    <!-- (ware basket, illegal wares, blacklists, path availability) before returning results -->
    <!--  -->
    <cue name="SearchLiveTrades_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- 1. Retrieve ship object from signal (used as table key) -->
        <set_value name="$ship" exact="event.param"/>

        <!-- De-dupe batch completion/resume processing per ship+batchId.
             Evidence (log): Some ships (e.g. CDR-476, CLB-157) can get multiple batch completions
             which triggers multiple SearchLiveTrades_Resume / FilterTradeList_Resume runs. This can race:
               - first completion releases the search lock ("live search continuation complete"),
               - later duplicate resume sees hasLock=0 and cannot signal SearchTradeRoutes, leaving ships stuck waiting.
             Fix: Only process the FIRST resume for the current batchId; ignore duplicates. -->
        <do_if value="not global.$GT_BatchResumeLastId? or global.$GT_BatchResumeLastId == null">
          <set_value name="global.$GT_BatchResumeLastId" exact="table[]"/>
        </do_if>
        <set_value name="$batchId" exact="null"/>
        <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}? and global.$GT_BatchDataList.{$ship}.$batchId?">
          <set_value name="$batchId" exact="global.$GT_BatchDataList.{$ship}.$batchId"/>
        </do_if>
        <!-- IMPORTANT: Use the ship OBJECT as key. String keys (e.g. $ship.idcode = 'AVZ-789') can fail to set in MD tables. -->
        <do_if value="$batchId? and $batchId != null and global.$GT_BatchResumeLastId.{$ship}? and global.$GT_BatchResumeLastId.{$ship} == $batchId">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Duplicate batch resume ignored (batchId=' + $batchId + ')'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        <do_if value="$batchId? and $batchId != null">
          <set_value name="global.$GT_BatchResumeLastId.{$ship}" exact="$batchId"/>
        </do_if>

        <!-- V2 LIVE COALESCING: clear per-home-sector refresh active marker (job finished / batch completed) -->
        <do_if value="global.$GT_TS_LiveRefreshBySector? and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <set_value name="$homeSector" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$HomeSector"/>
          <do_if value="$homeSector? and global.$GT_TS_LiveRefreshBySector.{$homeSector}?">
            <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$Active" exact="false"/>
            <set_value name="global.$GT_TS_LiveRefreshBySector.{$homeSector}.$LastFinished" exact="player.age"/>
            <!-- Wake any ships waiting silently for this home-sector refresh to finish -->
            <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.HomeRefreshFinished" param="$homeSector"/>
          </do_if>
        </do_if>
        
        <!-- Extract trace ID from state for logging -->
        <set_value name="$traceId" exact="''"/>
        <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}? and global.$GT_SearchLiveTrades_State.{$ship}.$TraceId?">
          <set_value name="$traceId" exact="global.$GT_SearchLiveTrades_State.{$ship}.$TraceId"/>
        </do_if>
        
        <!-- Log finalization start -->
        <do_if value="$traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'Finalization'"/>
            <param name="action" value="'Start'"/>
            <param name="details" value="'batchId=' + (if $batchId? then $batchId else 'null')"/>
            <param name="logLevel" value="1"/>
          </run_actions>
        </do_if>
        
        <!-- 2. Retrieve results from batch processor using ship object as key -->
        <set_value name="$results" exact="@global.$GT_BatchResultsList.{$ship}"/>
        
          <!-- Validate results exist -->
          <do_if value="not $results?">
            <!-- Log failure -->
            <do_if value="$traceId != ''">
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="$traceId"/>
                <param name="stage" value="'Finalization'"/>
                <param name="action" value="'Failed'"/>
                <param name="details" value="'reason=no_batch_results'"/>
                <param name="logLevel" value="0"/>
              </run_actions>
            </do_if>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Resume] Batch results not found for ship ' + $ship.idcode" chance="100"/>
            </do_if>
            
          <!-- Preserve LastRejectionStats when updating global.$GT_SearchResult -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
              <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
            </do_if>
            
            <set_value name="global.$GT_SearchResult.{$ship}" exact="table[
              $Found = false,
              $BestTrade = null,
              $BestScore = 0,
              $TradeList = [],
              $Ship = $ship
            ]"/>
            
            <!-- Restore LastRejectionStats after updating global.$GT_SearchResult -->
            <do_if value="$preservedLastRejectionStats?">
              <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
            </do_if>
            
            <cancel_cue cue="this"/>
          </do_if>
        
        <!-- Extract results -->
        <set_value name="$ship" exact="$results.$ship"/>
        <set_value name="$tradeList" exact="$results.$tradeList"/>
        <!-- Ensure $tradeList is never null - initialize to empty list if null or missing -->
        <!-- Use same pattern as FilterTradeList_Batch check (line 1939) but inverted -->
        <do_if value="not ($tradeList? and $tradeList != null)">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        <set_value name="$crossStationBestTrade" exact="$results.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="$results.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="$results.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="$results.$nonConflictedBestScore"/>
        <!-- Extract rejection statistics from batch processor -->
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <do_if value="$results.$tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="$results.$tradesRejectedProfit"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="$results.$tradesRejectedDocking"/>
        </do_if>
        <do_if value="$results.$tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="$results.$tradesRejectedAmount"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="$results.$tradesRejectedDistance"/>
        </do_if>
        <set_value name="$bestRejectedTrade" exact="null"/>
        <do_if value="$results.$bestRejectedTrade?">
          <set_value name="$bestRejectedTrade" exact="$results.$bestRejectedTrade"/>
        </do_if>
        
        <!-- Get maxDistance and originalMaxDistance from batch data (still stored for reference) -->
        <!-- FIX: Also check live search state if batch data doesn't have it -->
        <set_value name="$maxDistance" exact="null"/>
        <set_value name="$originalMaxDistance" exact="null"/>
        <set_value name="$pilotSkillMaxDistance" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData?">
          <do_if value="$batchData.$maxDistance?">
            <set_value name="$maxDistance" exact="$batchData.$maxDistance"/>
          </do_if>
          <do_if value="$batchData.$originalMaxDistance?">
            <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
          </do_if>
          <!-- FIX #3: Use pilot skill cap for result filtering if available -->
          <do_if value="$batchData.$PilotSkillMaxDistance?">
            <set_value name="$pilotSkillMaxDistance" exact="$batchData.$PilotSkillMaxDistance"/>
            <!-- Override maxDistance for filtering (sector list was built with original maxDistance for cache population) -->
            <set_value name="$maxDistance" exact="$pilotSkillMaxDistance"/>
          </do_if>
        </do_if>
        <!-- FIX: Fallback to live search state if batch data doesn't have maxDistance -->
        <do_if value="$maxDistance == null">
          <set_value name="$liveState" exact="@global.$GT_SearchLiveTrades_State.{$ship}"/>
          <do_if value="$liveState?">
            <do_if value="$liveState.$MaxDistance?">
              <set_value name="$maxDistance" exact="$liveState.$MaxDistance"/>
            </do_if>
            <do_if value="$liveState.$OriginalMaxDistance?">
              <set_value name="$originalMaxDistance" exact="$liveState.$OriginalMaxDistance"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Detect if this is a fallback search (originalMaxDistance != maxDistance) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Processing ' + $tradeList.count + ' trades from batch processor (maxDistance: ' + $maxDistance + ')'" chance="100"/>
        </do_if>
        
        <!-- 3. Apply ship-specific filtering -->
        <!-- 3a. Get ship settings -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        <set_value name="$ignoreCarrierAux" exact="@global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux"/>
        <set_value name="$ignoreBuildStorage" exact="@global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage"/>
        <!-- Get ware basket safely (using library function with null-checking pattern) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetWareBasketSafe" result="$wareBasket">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- 3b. Filter tradeList -->
        <set_value name="$filteredTradeList" exact="[]"/>
        <!-- Track filtering statistics -->
        <set_value name="$filteredByWareBasket" exact="0"/>
        <set_value name="$filteredByIllegal" exact="0"/>
        <set_value name="$filteredByBlacklist" exact="0"/>
        <set_value name="$filteredByPathBlocked" exact="0"/>
        <set_value name="$tradesByWareStats" exact="table[]"/>
        
        <!-- Initialize gatedistance cache for blacklist-aware pathfinding -->
        <!-- Reduces pathfinding calls from 200 (for 100 trades) to ~20-40 unique sector pairs -->
        <!-- (80-90% reduction in expensive gatedistance calculations) -->
        <set_value name="$gatedistanceCache" exact="table[]"/>
        <set_value name="$currentSector" exact="$ship.sector"/>
        
        <!-- Track intra-sector trade statistics -->
        <set_value name="$intraSectorTradesTotal" exact="0"/>
        <set_value name="$intraSectorTradesFiltered" exact="0"/>
        <set_value name="$intraSectorTradesValid" exact="0"/>
        
        <!-- Parallel Filtering with Cooperative Multitasking -->
        <!-- Process trades in batches to prevent blocking the game engine -->
        <!-- This prevents frame stutter when filtering large trade lists (100+ trades) -->
        <!-- Store filtering state in global table (persists across cue instances) -->
        
        <!-- Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Initialize filter state for this ship -->
        <!-- Include batch processor results variables (from SearchLiveTrades_Resume) -->
        <set_value name="$filterState" exact="table[
          $ship = $ship,
          $tradeList = $tradeList,
          $wareBasket = $wareBasket,
          $allowIllegal = $allowIllegal,
          $ignoreCarrierAux = $ignoreCarrierAux,
          $ignoreBuildStorage = $ignoreBuildStorage,
          $blacklistgroup = $blacklistgroup,
          $currentSector = $currentSector,
          $gatedistanceCache = $gatedistanceCache,
          $filteredTradeList = $filteredTradeList,
          $filteredByWareBasket = $filteredByWareBasket,
          $filteredByIllegal = $filteredByIllegal,
          $filteredByBlacklist = $filteredByBlacklist,
          $filteredByPathBlocked = $filteredByPathBlocked,
          $tradesByWareStats = $tradesByWareStats,
          $intraSectorTradesTotal = $intraSectorTradesTotal,
          $intraSectorTradesFiltered = $intraSectorTradesFiltered,
          $intraSectorTradesValid = $intraSectorTradesValid,
          $filterIndex = 0,
          $filterBatchSize = 5,
          $maxDistance = $maxDistance,
          $crossStationBestTrade = $crossStationBestTrade,
          $crossStationBestScore = $crossStationBestScore,
          $nonConflictedBestTrade = $nonConflictedBestTrade,
          $nonConflictedBestScore = $nonConflictedBestScore,
          $tradesRejectedProfit = $tradesRejectedProfit,
          $tradesRejectedDocking = $tradesRejectedDocking,
          $tradesRejectedAmount = $tradesRejectedAmount,
          $tradesRejectedDistance = $tradesRejectedDistance,
          $bestRejectedTrade = $bestRejectedTrade
        ]"/>
        <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
        
        <!-- Signal batch filtering cue to start processing -->
        <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
        
        <!-- Wait for batch filtering to complete (resume cue will signal back) -->
        <!-- Note: We'll resume in FilterTradeList_Resume cue -->
        <!-- Cancel this cue - resume cue will continue processing -->
        <cancel_cue cue="this"/>
      </actions>
    </cue>
    
    <!-- Batch Trade Filtering with Cooperative Multitasking -->
    <cue name="FilterTradeList_Batch" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Calculate delay from global Performance settings -->
        <set_value name="$batchDelay" exact="50"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay?">
          <set_value name="$batchDelay" exact="@global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay"/>
        </do_if>
        <!-- Smoothness > speed: add jitter so fleets don't wake/filter on the same frame. -->
        <set_value name="$batchDelayJitter" min="0" max="80"/>
        <!-- Convert to time value (milliseconds) -->
        <set_value name="this.$batchDelayTime" exact="($batchDelay + $batchDelayJitter) * 1ms"/>
      </actions>
      <delay exact="this.$batchDelayTime"/>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve state from global table -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- FIX: Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <!-- Filter state missing/invalid (race): recover by returning 0 trades and resuming. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] WARNING: FilterTradeList_Batch missing/invalid filterState for ship ' + $ship.idcode + ' - returning 0 trades (race/cleanup).'" chance="100"/>
          </do_if>
          <set_value name="global.$GT_FilterState.{$ship}" exact="table[
            $ship = $ship,
            $tradeList = [],
            $filteredTradeList = [],
            $filteredByWareBasket = 0,
            $filteredByIllegal = 0,
            $filteredByBlacklist = 0,
            $filteredByPathBlocked = 0,
            $tradesByWareStats = table[],
            $intraSectorTradesTotal = 0,
            $intraSectorTradesFiltered = 0,
            $intraSectorTradesValid = 0,
            $filterIndex = 0,
            $filterBatchSize = 5
          ]"/>
          <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
        <!-- Extract state variables -->
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <!-- Validate critical variables exist before use - wrap all processing in conditional -->
        <do_if value="$tradeList? and $tradeList != null">
          <set_value name="$wareBasket" exact="@$filterState.$wareBasket"/>
          <set_value name="$allowIllegal" exact="@$filterState.$allowIllegal"/>
          <set_value name="$ignoreCarrierAux" exact="@$filterState.$ignoreCarrierAux"/>
          <set_value name="$ignoreBuildStorage" exact="@$filterState.$ignoreBuildStorage"/>
          <set_value name="$blacklistgroup" exact="@$filterState.$blacklistgroup"/>
          <set_value name="$currentSector" exact="@$filterState.$currentSector"/>
          <set_value name="$gatedistanceCache" exact="@$filterState.$gatedistanceCache"/>
          <set_value name="$filterIndex" exact="@$filterState.$filterIndex"/>
          <set_value name="$filterBatchSize" exact="@$filterState.$filterBatchSize"/>
          
          <!-- Initialize filterIndex and filterBatchSize if missing -->
          <do_if value="not $filterIndex?">
            <set_value name="$filterIndex" exact="0"/>
          </do_if>
          <do_if value="not $filterBatchSize?">
            <!-- Smoothness > speed: smaller batch reduces per-frame spikes when many ships filter simultaneously. -->
            <set_value name="$filterBatchSize" exact="5"/>
          </do_if>
          
          <!-- Get mutable lists/stats from state (or initialize if first batch) -->
          <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
          <do_if value="not $filteredTradeList? or $filteredTradeList == null">
            <set_value name="$filteredTradeList" exact="[]"/>
          </do_if>
          <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
          <do_if value="not $filteredByWareBasket?">
            <set_value name="$filteredByWareBasket" exact="0"/>
          </do_if>
          <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
          <do_if value="not $filteredByIllegal?">
            <set_value name="$filteredByIllegal" exact="0"/>
          </do_if>
          <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
          <do_if value="not $filteredByBlacklist?">
            <set_value name="$filteredByBlacklist" exact="0"/>
          </do_if>
          <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
          <do_if value="not $filteredByPathBlocked?">
            <set_value name="$filteredByPathBlocked" exact="0"/>
          </do_if>
          <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
          <do_if value="not $tradesByWareStats? or $tradesByWareStats == null">
            <set_value name="$tradesByWareStats" exact="table[]"/>
          </do_if>
          <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
          <do_if value="not $intraSectorTradesTotal?">
            <set_value name="$intraSectorTradesTotal" exact="0"/>
          </do_if>
          <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
          <do_if value="not $intraSectorTradesFiltered?">
            <set_value name="$intraSectorTradesFiltered" exact="0"/>
          </do_if>
          <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
          <do_if value="not $intraSectorTradesValid?">
            <set_value name="$intraSectorTradesValid" exact="0"/>
          </do_if>
          
          <!-- Ensure $filterState is not null before setting properties -->
          <do_if value="$filterState == null">
            <set_value name="$filterState" exact="table[]"/>
          </do_if>
          
          <!-- Process one batch of trades -->
          <set_value name="$filterTotalTrades" exact="$tradeList.count"/>
          <set_value name="$batchEnd" exact="[$filterIndex + $filterBatchSize, $filterTotalTrades].min"/>
          <!-- PERF MARKER: one line per slice so timeline analyzer can attribute heavy filtering work -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-PERF] FilterSlice START ship=' + $ship.idcode + ' idx=' + $filterIndex + ' end=' + $batchEnd + ' total=' + $filterTotalTrades + ' batchSize=' + $filterBatchSize" chance="100"/>
          </do_if>
          <do_all exact="$batchEnd - $filterIndex" counter="$batchOffset">
            <set_value name="$i" exact="$filterIndex + $batchOffset"/>
            <set_value name="$trade" exact="$tradeList.{$i}"/>
            <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
            
            <!-- Initialize ware stats if needed -->
            <do_if value="not $tradesByWareStats.{$ware}?">
              <set_value name="$tradesByWareStats.{$ware}" exact="table[$total=0, $filteredByWareBasket=0, $filteredByIllegal=0, $filteredByBlacklist=0, $filteredByPathBlocked=0, $valid=0]"/>
            </do_if>
            <set_value name="$wareStats" exact="$tradesByWareStats.{$ware}"/>
            <set_value name="$wareStats.$total" exact="$wareStats.$total + 1"/>
            
            <!-- Extract sectors early for intra-sector trade detection -->
            <set_value name="$buySector" exact="@$trade.$BuyStation.sector"/>
            <set_value name="$sellSector" exact="@$trade.$SellStation.sector"/>
            
            <!-- Track if this is a TRUE intra-sector trade -->
            <run_actions ref="md.GT_Libraries_General.GT_IsIntraSectorTrade" result="$isIntraSectorTrade">
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="currentSector" value="$currentSector"/>
            </run_actions>
            <do_if value="$isIntraSectorTrade">
              <set_value name="$intraSectorTradesTotal" exact="$intraSectorTradesTotal + 1"/>
            </do_if>
            
            <!-- Filter trade for ship -->
            <run_actions ref="md.GT_Libraries_General.GT_FilterTradeForShip" result="$filterResult">
              <param name="trade" value="$trade"/>
              <param name="ship" value="$ship"/>
              <param name="ware" value="$ware"/>
              <param name="wareBasket" value="$wareBasket"/>
              <param name="allowIllegal" value="$allowIllegal"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
              <param name="currentSector" value="$currentSector"/>
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="filterStats" value="$wareStats"/>
              <param name="isIntraSectorTrade" value="$isIntraSectorTrade"/>
              <param name="ignoreCarrierAux" value="$ignoreCarrierAux"/>
              <param name="ignoreBuildStorage" value="$ignoreBuildStorage"/>
            </run_actions>
            
            <!-- Update filter statistics -->
            <set_value name="$isAllowed" exact="$filterResult.$IsAllowed"/>
            <set_value name="$filterReason" exact="$filterResult.$FilterReason"/>
            <do_if value="not $isAllowed">
              <do_if value="$filterReason == 'ware_basket'">
                <set_value name="$filteredByWareBasket" exact="$filteredByWareBasket + 1"/>
              </do_if>
              <do_elseif value="$filterReason == 'illegal'">
                <set_value name="$filteredByIllegal" exact="$filteredByIllegal + 1"/>
              </do_elseif>
              <do_elseif value="$filterReason == 'blacklist_intra' or $filterReason == 'blacklist_buy_station' or $filterReason == 'blacklist_sell_station' or $filterReason == 'blacklist_buy_sector' or $filterReason == 'blacklist_sell_sector'">
                <set_value name="$filteredByBlacklist" exact="$filteredByBlacklist + 1"/>
              </do_elseif>
              <do_elseif value="$filterReason == 'path_blocked'">
                <set_value name="$filteredByPathBlocked" exact="$filteredByPathBlocked + 1"/>
              </do_elseif>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
              </do_if>
            </do_if>
            
            <!-- Add to filtered list if valid -->
            <do_if value="$isAllowed">
              <append_to_list name="$filteredTradeList" exact="$trade"/>
              <set_value name="$wareStats.$valid" exact="$wareStats.$valid + 1"/>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesValid" exact="$intraSectorTradesValid + 1"/>
              </do_if>
            </do_if>
            <do_else>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
              </do_if>
            </do_else>
            
            <!-- Update ware stats -->
            <set_value name="$tradesByWareStats.{$ware}" exact="$wareStats"/>
          </do_all>
          
          <!-- Update state for next batch or completion -->
          <!-- Re-validate $filterState before setting properties (might have become null) -->
          <do_if value="$filterState == null">
            <debug_text text="'[GT-Batch] ERROR: $filterState became null for ship ' + $ship.idcode + ' - cannot update state'" chance="100"/>
            <cancel_cue cue="this"/>
          </do_if>
          
          <set_value name="$filterIndex" exact="$batchEnd"/>
          <set_value name="$filterState.$filterIndex" exact="$filterIndex"/>
          <set_value name="$filterState.$filteredTradeList" exact="$filteredTradeList"/>
          <set_value name="$filterState.$filteredByWareBasket" exact="$filteredByWareBasket"/>
          <set_value name="$filterState.$filteredByIllegal" exact="$filteredByIllegal"/>
          <set_value name="$filterState.$filteredByBlacklist" exact="$filteredByBlacklist"/>
          <set_value name="$filterState.$filteredByPathBlocked" exact="$filteredByPathBlocked"/>
          <set_value name="$filterState.$tradesByWareStats" exact="$tradesByWareStats"/>
          <set_value name="$filterState.$intraSectorTradesTotal" exact="$intraSectorTradesTotal"/>
          <set_value name="$filterState.$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered"/>
          <set_value name="$filterState.$intraSectorTradesValid" exact="$intraSectorTradesValid"/>
          <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
          
          <!-- Check if more batches needed -->
          <do_if value="$filterIndex lt $filterTotalTrades">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-PERF] FilterSlice END ship=' + $ship.idcode + ' nextIdx=' + $filterIndex + ' total=' + $filterTotalTrades + ' remaining=' + ($filterTotalTrades - $filterIndex) + ' filteredOut=' + ($filteredByWareBasket + $filteredByIllegal + $filteredByBlacklist + $filteredByPathBlocked)" chance="100"/>
            </do_if>
            <!-- Signal next batch -->
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
          </do_if>
          <do_else>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-PERF] FilterSlice COMPLETE ship=' + $ship.idcode + ' totalTrades=' + $filterTotalTrades + ' kept=' + $filteredTradeList.count + ' filteredOut=' + ($filteredByWareBasket + $filteredByIllegal + $filteredByBlacklist + $filteredByPathBlocked)" chance="100"/>
            </do_if>
            <!-- All batches complete - signal resume cue to continue processing -->
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- $tradeList is null:
               This can happen due to a rare race (delayed batch wakes after state was partially overwritten/cleaned).
               Treat as recoverable ONLY if the ship is still waiting (search lock held).
               If the ship is no longer locked, this is a stale delayed batch wakeup and must be cancelled silently. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] WARNING: $tradeList is null for ship ' + $ship.idcode + ' - aborting filtering and returning 0 trades (race/cleanup).'" chance="100"/>
          </do_if>
          
          <!-- Check if ship is still waiting for this pipeline (search lock held) -->
          <set_value name="$lockTime" exact="null"/>
          <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
            <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$ship}"/>
          </do_if>
          <do_if value="$lockTime == null">
            <!-- Stale delayed batch wakeup (ship already completed/cleaned); cancel without signalling continuation -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] INFO: Stale FilterTradeList_Batch wakeup for ' + $ship.idcode + ' (no search lock) - cancelling.'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- Recreate minimal state so Resume can complete safely -->
            <set_value name="global.$GT_FilterState.{$ship}" exact="table[
              $ship = $ship,
              $tradeList = [],
              $filteredTradeList = [],
              $filteredByWareBasket = 0,
              $filteredByIllegal = 0,
              $filteredByBlacklist = 0,
              $filteredByPathBlocked = 0,
              $tradesByWareStats = table[],
              $intraSectorTradesTotal = 0,
              $intraSectorTradesFiltered = 0,
              $intraSectorTradesValid = 0,
              $filterIndex = 0,
              $filterBatchSize = 5
            ]"/>
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
            <cancel_cue cue="this"/>
          </do_else>
        </do_else>
        </do_else>
      </actions>
    </cue>
    
    <!-- Resume cue: Continue processing after batch filtering completes -->
    <cue name="FilterTradeList_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <!-- Jitter resume to avoid same-frame bursts when many batch filters complete at once -->
      <delay min="10ms" max="120ms"/>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve filtered results from global state -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
        
        <!-- Extract all filtered results and statistics -->
        <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
        <do_if value="not $filteredTradeList? or $filteredTradeList == null">
          <set_value name="$filteredTradeList" exact="[]"/>
        </do_if>
        <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
        <do_if value="not $filteredByWareBasket?">
          <set_value name="$filteredByWareBasket" exact="0"/>
        </do_if>
        <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
        <do_if value="not $filteredByIllegal?">
          <set_value name="$filteredByIllegal" exact="0"/>
        </do_if>
        <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
        <do_if value="not $filteredByBlacklist?">
          <set_value name="$filteredByBlacklist" exact="0"/>
        </do_if>
        <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
        <do_if value="not $filteredByPathBlocked?">
          <set_value name="$filteredByPathBlocked" exact="0"/>
        </do_if>
        <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
        <do_if value="not $tradesByWareStats? or $tradesByWareStats == null">
          <set_value name="$tradesByWareStats" exact="table[]"/>
        </do_if>
        <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
        <do_if value="not $intraSectorTradesTotal?">
          <set_value name="$intraSectorTradesTotal" exact="0"/>
        </do_if>
        <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
        <do_if value="not $intraSectorTradesFiltered?">
          <set_value name="$intraSectorTradesFiltered" exact="0"/>
        </do_if>
        <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
        <do_if value="not $intraSectorTradesValid?">
          <set_value name="$intraSectorTradesValid" exact="0"/>
        </do_if>
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <do_if value="not $tradeList? or $tradeList == null">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        <set_value name="$maxDistance" exact="@$filterState.$maxDistance"/>
        <do_if value="not $maxDistance?">
          <set_value name="$maxDistance" exact="10"/>
        </do_if>
        
        <!-- Extract trace ID for logging -->
        <set_value name="$traceId" exact="''"/>
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$TraceId?">
          <set_value name="$traceId" exact="global.$GT_AIParameters.{$ship}.$TraceId"/>
        </do_if>
        
        <!-- Get originalMaxDistance from batch data (if available) -->
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance -->
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData? and $batchData.$originalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
        </do_if>
        
        <!-- Detect if this is a fallback search (originalMaxDistance != maxDistance) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <!-- Extract batch processor result variables -->
        <set_value name="$crossStationBestTrade" exact="@$filterState.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="@$filterState.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="@$filterState.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="@$filterState.$nonConflictedBestScore"/>
        <set_value name="$tradesRejectedProfit" exact="@$filterState.$tradesRejectedProfit"/>
        <set_value name="$tradesRejectedDocking" exact="@$filterState.$tradesRejectedDocking"/>
        <set_value name="$tradesRejectedAmount" exact="@$filterState.$tradesRejectedAmount"/>
        <set_value name="$tradesRejectedDistance" exact="@$filterState.$tradesRejectedDistance"/>
        <set_value name="$bestRejectedTrade" exact="@$filterState.$bestRejectedTrade"/>
        
        <!-- Initialize to safe defaults if not set -->
        <do_if value="not $tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="0"/>
        </do_if>
        <do_if value="not $crossStationBestScore?">
          <set_value name="$crossStationBestScore" exact="0"/>
        </do_if>
        <do_if value="not $nonConflictedBestScore?">
          <set_value name="$nonConflictedBestScore" exact="0"/>
        </do_if>
        
        <!-- Clean up filter state -->
        <remove_value name="global.$GT_FilterState.{$ship}"/>
        
        <!-- DEBUG: Log filtering statistics -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract counts safely (ternary operator evaluates both sides, so we need separate checks) -->
          <set_value name="$tradeListCountSafe" exact="0"/>
          <do_if value="$tradeList? and $tradeList != null">
            <set_value name="$tradeListCountSafe" exact="$tradeList.count"/>
          </do_if>
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <set_value name="$filteringStats" exact="'[GT-Resume] (' + $ship.idcode + ') Filtering statistics:' +
            '\n  Total trades: ' + $tradeListCountSafe +
            '\n  TRUE intra-sector trades: ' + (if $intraSectorTradesTotal? then $intraSectorTradesTotal else 0) + ' (filtered: ' + (if $intraSectorTradesFiltered? then $intraSectorTradesFiltered else 0) + ', valid: ' + (if $intraSectorTradesValid? then $intraSectorTradesValid else 0) + ')' +
            '\n  Filtered by ware basket: ' + (if $filteredByWareBasket? then $filteredByWareBasket else 0) +
            '\n  Filtered by illegal: ' + (if $filteredByIllegal? then $filteredByIllegal else 0) +
            '\n  Filtered by blacklist: ' + (if $filteredByBlacklist? then $filteredByBlacklist else 0) +
            '\n  Filtered by path blocked: ' + (if $filteredByPathBlocked? then $filteredByPathBlocked else 0) +
            '\n  Valid trades: ' + $filteredTradeListCountSafe"/>
          <debug_text text="$filteringStats" chance="100"/>
          
          <!-- Log per-ware statistics -->
          <!-- Use safe access for keys check -->
          <set_value name="$tradesByWareStatsKeysCount" exact="if $tradesByWareStats? then @$tradesByWareStats.keys.count else 0"/>
          <do_if value="$tradesByWareStatsKeysCount gt 0">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$wareStatsLog" exact="'[GT-Resume] (' + $ship.idcode + ') Per-ware filtering:'"/>
              <do_all exact="$tradesByWareStatsKeysCount" counter="$wareIdx">
                <set_value name="$ware" exact="$tradesByWareStats.keys.{$wareIdx}"/>
                <set_value name="$stats" exact="$tradesByWareStats.{$ware}"/>
                <set_value name="$wareStatsLog" exact="$wareStatsLog + 
                  '\n  - ' + @$ware.name + ': ' + $stats.$total + ' checked, ' +
                  $stats.$filteredByWareBasket + ' basket, ' +
                  $stats.$filteredByIllegal + ' illegal, ' +
                  $stats.$filteredByBlacklist + ' blacklist, ' +
                  $stats.$filteredByPathBlocked + ' path, ' +
                  $stats.$valid + ' valid'"/>
              </do_all>
              <debug_text text="$wareStatsLog" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract counts safely (ternary operator evaluates both sides) -->
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <set_value name="$tradeListCountSafe" exact="0"/>
          <do_if value="$tradeList? and $tradeList != null">
            <set_value name="$tradeListCountSafe" exact="$tradeList.count"/>
          </do_if>
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') After ship-specific filtering: ' + $filteredTradeListCountSafe + ' trades (from ' + $tradeListCountSafe + ')'" chance="100"/>
        </do_if>
        
        <!-- 4. Build diverse list: Top 5 per ware (minimum-maximum) with early exit -->
        <!-- DEBUG: Log trades before diverse list building -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract count safely (ternary operator evaluates both sides) -->
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Building diverse list from ' + $filteredTradeListCountSafe + ' filtered trades'" chance="100"/>
        </do_if>
        
        <set_value name="$tradesByWare" exact="table[]"/>
        <!-- Extract count safely before loop (ternary operator evaluates both sides) -->
        <set_value name="$filteredTradeListCountSafe" exact="0"/>
        <do_if value="$filteredTradeList? and $filteredTradeList != null">
          <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
        </do_if>
        <do_if value="$filteredTradeListCountSafe gt 0">
          <do_all exact="$filteredTradeListCountSafe" counter="$i">
            <set_value name="$trade" exact="$filteredTradeList.{$i}"/>
            <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
            <do_if value="not $tradesByWare.{$ware}?">
              <set_value name="$tradesByWare.{$ware}" exact="[]"/>
            </do_if>
            <append_to_list name="$tradesByWare.{$ware}" exact="$trade"/>
          </do_all>
        </do_if>
        
        <!-- DEBUG: Log wares found -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$wareDebug" exact="'[GT-Resume] (' + $ship.idcode + ') Found ' + $tradesByWare.keys.count + ' wares with trades:'"/>
          <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
            <set_value name="$wareCount" exact="$tradesByWare.{$ware}.count"/>
            <set_value name="$wareDebug" exact="$wareDebug + '\n  - ' + @$ware.name + ': ' + $wareCount + ' trades'"/>
          </do_all>
          <debug_text text="$wareDebug" chance="100"/>
        </do_if>
        
        <!-- Determine home sector FIRST (same logic as SearchLiveTrades) -->
        <!-- Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <!-- Ships must only trade with stations within maxDistance from HOME SECTOR, not ship position -->
        <set_value name="$homeBase" exact="null"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
              <do_if value="@$commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
          </do_if>
          <do_else>
            <!-- REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
            <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null! This should never happen.'" chance="100"/>
            <!-- Emergency fallback only - this should never happen -->
            <set_value name="$homeBase" exact="$ship.sector"/>
          </do_else>
        </do_if>
        
        <!-- Extract sector -->
        <set_value name="$homeSector" exact="null"/>
        <do_if value="@$homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
          <!-- Emergency fallback only - this should never happen -->
          <set_value name="$homeSector" exact="$ship.sector"/>
        </do_if>
        
        <!-- Log start of fallback search processing -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <set_value name="$filterMaxDistance" exact="$maxDistance"/>
          <do_if value="$originalMaxDistance?">
            <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
          </do_if>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') Fallback search processing started | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance + ' | Trades to evaluate: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <!-- Sort trades by distance from HOME SECTOR (shortest first) per ware, break when exceeding maxDistance -->
        <!-- This matches the requirement: stations must not be farther from home sector than maxDistance -->
        <set_value name="$diverseList" exact="[]"/>
        <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
          <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
          <set_value name="$wareTrades" exact="$tradesByWare.{$ware}"/>
          
          <!-- Log start of evaluation for this ware -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
            <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
            <set_value name="$filterMaxDistance" exact="$maxDistance"/>
            <do_if value="$originalMaxDistance?">
              <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
            </do_if>
            <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') Evaluating ' + $wareTrades.count + ' trades for ' + $wareName + ' | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance" chance="100"/>
          </do_if>
          
          <!-- For fallback search, filter by HOME SECTOR distance first, then use current distance for sorting -->
          <!-- Distance penalties should only affect SCORING, not FILTERING -->
          <!-- Use library function for fallback trade distance calculation -->
          <set_value name="$currentSector" exact="$ship.sector"/>
          <set_value name="$filterMaxDistance" exact="$maxDistance"/>  <!-- Default: use maxDistance -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and $originalMaxDistance?">
            <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>  <!-- Fallback: use original pilot maxDistance -->
          </do_if>
          
          <!-- Use library function to calculate distances and filter trades -->
          <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackTradeDistances" result="$distanceResult">
            <param name="wareTrades" value="$wareTrades"/>
            <param name="ship" value="$ship"/>
            <param name="homeSector" value="$homeSector"/>
            <param name="currentSector" value="$currentSector"/>
            <param name="maxDistance" value="$maxDistance"/>
            <param name="originalMaxDistance" value="$originalMaxDistance"/>
            <param name="isFallbackSearch" value="$isFallbackSearch"/>
          </run_actions>
          <set_value name="$tradesWithDistance" exact="$distanceResult.$TradesWithDistance"/>
          <set_value name="$rejectedByUnreachable" exact="$distanceResult.$RejectedByUnreachable"/>
          <set_value name="$rejectedByHomeDistance" exact="$distanceResult.$RejectedByHomeDistance"/>
          <set_value name="$evaluatedCount" exact="$distanceResult.$EvaluatedCount"/>
          
          <!-- Log summary statistics -->
          <!-- NOTE: "Evaluated" counts trades that passed the home distance filter (within maxDistance from home) -->
          <!-- Distance from current position is used only for sorting/prioritization, not filtering -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$totalTrades" exact="$wareTrades.count"/>
            <set_value name="$skippedByDistance" exact="$rejectedByUnreachable + $rejectedByHomeDistance"/>
            <set_value name="$summaryLog" exact="'[GT-Fallback] (' + $ship.idcode + ') Ware: ' + $wareName + ' | Total trades: ' + $totalTrades + ' | Evaluated (within home distance): ' + $evaluatedCount + ' | Accepted: ' + $tradesWithDistance.count + ' | Rejected: ' + ($evaluatedCount - $tradesWithDistance.count) + ' | Skipped (unreachable/home dist): ' + $skippedByDistance + ' (unreachable: ' + $rejectedByUnreachable + ', home dist: ' + $rejectedByHomeDistance + ')'"/>
            <debug_text text="$summaryLog" chance="100"/>
          </do_if>
          
          <!-- Sort by distance (shortest first) -->
          <!-- Use library function for distance-based sorting -->
          <run_actions ref="md.GT_Libraries_General.GT_SortTradesByDistance" result="$sortedTrades">
            <param name="tradesWithDistance" value="$tradesWithDistance"/>
          </run_actions>
          
          <!-- Select top 5 by Score, with early exit when distance exceeds limit -->
          <!-- For fallback search, distance from current position is used ONLY for sorting, not filtering -->
          <!-- All trades have already passed the home distance filter, so we don't need an early exit based on current distance -->
          <!-- For normal search: early exit when distance from home > maxDistance -->
          <!-- Use library function for best trade selection with diversity -->
          <run_actions ref="md.GT_Libraries_General.GT_SelectBestTradesWithDiversity" result="$bestTradesResult">
            <param name="sortedTrades" value="$sortedTrades"/>
            <param name="maxDistance" value="$maxDistance"/>
            <param name="filterMaxDistance" value="$filterMaxDistance"/>
            <param name="isFallbackSearch" value="$isFallbackSearch"/>
            <param name="ware" value="$ware"/>
            <param name="ship" value="$ship"/>
          </run_actions>
          <set_value name="$top3" exact="$bestTradesResult.$TopTrades"/>
          <set_value name="$skippedDueToDistance" exact="$bestTradesResult.$SkippedDueToDistance"/>
          
          <!-- Add up to 5 trades per ware (if less than 5, still include what we have) -->
          <do_if value="$top3.count gt 0">
            <do_all exact="$top3.count" counter="$i">
              <append_to_list name="$diverseList" exact="$top3.{$i}"/>
            </do_all>
          </do_if>
        </do_all>
        
        <!-- Log if no trades were found to evaluate -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and $tradesByWare.keys.count == 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') No trades found to evaluate | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Filtered trade list count: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Diverse list: ' + $diverseList.count + ' trades (top 5 per ware)'" chance="100"/>
        </do_if>
        
        <!-- Sort diverse list by score (highest first) before storing for AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <!-- Use library function for sorting -->
        <run_actions ref="md.GT_Libraries_General.GT_SortTradesByScore" result="$diverseList">
          <param name="tradeList" value="$diverseList"/>
        </run_actions>
        
        <!-- 5. Cache maintenance: Delete old entries (if cache was refreshed) -->
        <!-- TODO: Track if new trades were added to cache during this search -->
        <!-- For now, assume cache was refreshed if batch processor ran -->
        <set_value name="$cacheRefreshed" exact="true"/>
        <!-- Cleanup per-home-sector cache -->
        <!-- Iterate through all home sectors in cache -->
        <do_if value="$cacheRefreshed">
          <set_value name="$cacheMaxAge" exact="15min"/>
          <set_value name="$deletedCount" exact="0"/>
          <do_if value="global.$GT_TradeCache?">
            <do_all exact="global.$GT_TradeCache.keys.count" counter="$sectorIdx">
              <set_value name="$cacheHomeSector" exact="global.$GT_TradeCache.keys.{$sectorIdx}"/>
              <set_value name="$sectorCache" exact="global.$GT_TradeCache.{$cacheHomeSector}"/>
              <do_if value="(if $sectorCache != null then $sectorCache.count else 0) gt 0">
                <!-- Iterate backwards through this home sector's cache -->
                <set_value name="$sectorCacheCount" exact="$sectorCache.count"/>
                <do_all exact="$sectorCacheCount" counter="$i" reverse="true">
                  <set_value name="$entry" exact="$sectorCache.{$i}"/>
                  <do_if value="$entry? and $entry.$Timestamp?">
                    <set_value name="$entryAge" exact="player.age - $entry.$Timestamp"/>
                    <do_if value="$entryAge gt $cacheMaxAge">
                      <remove_value name="global.$GT_TradeCache.{$cacheHomeSector}.{$i}"/>
                      <set_value name="$deletedCount" operation="add"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$deletedCount gt 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Cache cleanup: Deleted ' + $deletedCount + ' entries older than 15 minutes'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- 6. Select best trade (for backward compatibility) -->
        <!-- Re-validate distance from home sector AND verify trade exists in final diverseList -->
        <!-- Prevents using stale trades that were filtered out by blacklist/path checks -->
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        
        <!-- Validate nonConflictedBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedNonConflictedTrade" exact="null"/>
        <do_if value="$nonConflictedBestTrade? and $nonConflictedBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$nonConflictedBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$nonConflictedBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $nonConflictedBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $nonConflictedBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $nonConflictedBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedNonConflictedTrade" exact="$nonConflictedBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Validate crossStationBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedCrossStationTrade" exact="null"/>
        <do_if value="$crossStationBestTrade? and $crossStationBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$crossStationBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$crossStationBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $crossStationBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $crossStationBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $crossStationBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedCrossStationTrade" exact="$crossStationBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="$validatedNonConflictedTrade? and $nonConflictedBestScore gt 0">
          <!-- Prefer non-conflicted from filtered list (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedNonConflictedTrade"/>
          <set_value name="$bestScore" exact="$nonConflictedBestScore"/>
        </do_if>
        <do_elseif value="$validatedCrossStationTrade? and $crossStationBestScore gt 0">
          <!-- Use cross-station trade (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedCrossStationTrade"/>
          <set_value name="$bestScore" exact="$crossStationBestScore"/>
        </do_elseif>
        <do_else>
          <!-- Fallback: Find best from diverse list -->
          <!-- FIX: Use library function for consistent validation -->
          <do_all exact="$diverseList.count" counter="$i">
            <set_value name="$trade" exact="$diverseList.{$i}"/>
            <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$isValid">
              <param name="trade" value="$trade"/>
              <param name="minScore" value="$bestScore"/>
            </run_actions>
            <do_if value="$isValid">
              <set_value name="$testScore" exact="@$trade.$Score"/>
              <set_value name="$bestScore" exact="$testScore"/>
              <set_value name="$bestTrade" exact="$trade"/>
            </do_if>
          </do_all>
          <!-- CRITICAL: If bestScore is still 0, all trades have Score = 0 (don't meet profit thresholds) -->
          <!-- Set bestTrade to null so "no trade found" path executes -->
          <do_if value="$bestScore le 0">
            <set_value name="$bestTrade" exact="null"/>
          </do_if>
        </do_else>
        
        <!-- 7. Extract original parameters BEFORE cleanup (so they're available when signaling) -->
        <!-- For fallback searches (maxDistance == 2), ALWAYS use batch data (has relaxed values) -->
        <!-- For normal searches, use queue params if available, otherwise fall back to batch data -->
        <set_value name="$originalParams" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <set_value name="$isFallbackFromBatch" exact="false"/>
        <!-- Proper null check for batchData and its properties -->
        <set_value name="$batchDataMaxDistance" exact="@$batchData.$maxDistance"/>
        <set_value name="$batchDataOriginalMaxDistance" exact="@$batchData.$originalMaxDistance"/>
        <!-- Detect fallback search: OriginalMaxDistance exists and differs from MaxDistance -->
        <set_value name="$isFallbackSearchFromBatch" exact="false"/>
        <do_if value="$batchData? and $batchDataMaxDistance? and $batchDataOriginalMaxDistance? and $batchDataOriginalMaxDistance != $batchDataMaxDistance">
          <set_value name="$isFallbackSearchFromBatch" exact="true"/>
        </do_if>
        <do_if value="$batchData? and $batchDataMaxDistance? and $isFallbackSearchFromBatch">
          <!-- This is a fallback search - batch data has relaxed profit thresholds, use those instead of queue -->
          <set_value name="$isFallbackFromBatch" exact="true"/>
          <set_value name="$allowIllegalDefault" exact="false"/>
          <set_value name="$originalParams" exact="table[
            $Ship = $ship,
            $MaxDistance = @$batchData.$maxDistance,
            $OriginalMaxDistance = $batchDataOriginalMaxDistance,
            $MinROI = @$batchData.$minROI,
            $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
            $FactionPriority = @$batchData.$factionPriority,
            $AllowIllegal = $allowIllegalDefault
          ]"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Using batch data params for fallback search (relaxed profit: ' + (@$batchData.$minAbsoluteProfit / 100) + ' Cr, OriginalMaxDistance: ' + $batchDataOriginalMaxDistance + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Normal search - try queue params first (cache queue), then batch data -->
          <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
            <!-- Parameters are stored in search queue when search was initiated -->
            <set_value name="$originalParams" exact="global.$GT_SearchQueue.$Params.{$ship}"/>
            <!-- Ensure OriginalMaxDistance is included if it exists in queue params -->
            <do_if value="not $originalParams.$OriginalMaxDistance? and $batchDataOriginalMaxDistance?">
              <set_value name="$originalParams.$OriginalMaxDistance" exact="$batchDataOriginalMaxDistance"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Fallback: Reconstruct parameters from batch data (before cleanup) -->
            <do_if value="$batchData?">
              <set_value name="$allowIllegalDefault" exact="false"/>
              <set_value name="$originalParams" exact="table[
                $Ship = $ship,
                $MaxDistance = @$batchData.$maxDistance,
                $OriginalMaxDistance = $batchDataOriginalMaxDistance,
                $MinROI = @$batchData.$minROI,
                $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                $FactionPriority = @$batchData.$factionPriority,
                $AllowIllegal = $allowIllegalDefault,
                $FromLiveQueue = false,
                $LiveSlotAcquired = false,
                $UseSearchQueueCounter = false
              ]"/>
            </do_if>
          </do_else>
        </do_else>
        
        <!-- 8. Return results (including rejection statistics for diagnostics) -->
        <!-- Store trade count before storing in global (for accurate logging) -->
        <set_value name="$finalTradeCount" exact="$diverseList.count"/>
        <set_value name="$waitingFlag" exact="false"/>
        <!-- Combine blacklist and path blocked (both are safety restrictions) -->
        <set_value name="$totalBlacklistAndPath" exact="$filteredByBlacklist + $filteredByPathBlocked"/>
        <!-- Calculate total trades evaluated (valid + filtered + batch processor rejections) for accurate reporting -->
        <!-- CRITICAL: Include batch processor rejection stats (tradesRejectedProfit, tradesRejectedDocking, etc.) -->
        <!-- These represent trades evaluated by the batch processor but rejected before filtering -->
        <set_value name="$batchProcessorRejections" exact="$tradesRejectedProfit + $tradesRejectedDocking + $tradesRejectedAmount + $tradesRejectedDistance"/>
        <set_value name="$totalTradesEvaluated" exact="$finalTradeCount + $totalBlacklistAndPath + $filteredByIllegal + $filteredByWareBasket + $batchProcessorRejections"/>
        
        <!-- Preserve LastRejectionStats when updating global.$GT_SearchResult -->
        <!-- FilterTradeList_Resume overwrites global.$GT_SearchResult, which would lose LastRejectionStats -->
        <set_value name="$preservedLastRejectionStats" exact="null"/>
        <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
          <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
        </do_if>
        
        <!-- Log finalization completion -->
        <do_if value="$traceId != ''">
          <set_value name="$found" exact="$finalTradeCount gt 0"/>
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'Finalization'"/>
            <param name="action" value="if $found then 'Complete' else 'Failed'"/>
            <param name="details" value="'found=' + (if $found then 'true' else 'false') + ' trades=' + $finalTradeCount + ' bestScore=' + $bestScore + ' evaluated=' + $totalTradesEvaluated + ' rejected=' + ($batchProcessorRejections + $totalBlacklistAndPath + $filteredByIllegal + $filteredByWareBasket)"/>
            <param name="logLevel" value="1"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="if $found then 'Completed' else 'Failed'"/>
            <param name="delta" value="1"/>
          </run_actions>
        </do_if>
        
        <set_value name="global.$GT_SearchResult.{$ship}" exact="table[
          $Found = ($finalTradeCount gt 0),
          $BestTrade = $bestTrade,
          $BestScore = $bestScore,
          $TradeList = $diverseList,
          $TradesRejectedProfit = $tradesRejectedProfit,
          $TradesRejectedDocking = $tradesRejectedDocking,
          $TradesRejectedAmount = $tradesRejectedAmount,
          $TradesRejectedDistance = $tradesRejectedDistance,
          $TradesRejectedBlacklist = $totalBlacklistAndPath,
          $BestRejectedTrade = $bestRejectedTrade,
          $WaitingForBatch = $waitingFlag,
          $Ship = $ship,
          $FilteredByBlacklist = $filteredByBlacklist,
          $FilteredByPathBlocked = $filteredByPathBlocked,
          $TotalTradesEvaluated = $totalTradesEvaluated
        ]"/>
        
        <!-- Restore LastRejectionStats after updating global.$GT_SearchResult -->
        <do_if value="$preservedLastRejectionStats?">
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
        </do_if>
        
        <!-- NOTE: LiveSearchQueue removed (hub finalization): ships waiting for a home-sector refresh are handled via global.$GT_TS_LiveRefreshBySector waiters. -->
        
        <!-- 9. Cleanup batch data (using ship object as key) -->
        <remove_value name="global.$GT_BatchDataList.{$ship}"/>
        <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Complete. Returning ' + $diverseList.count + ' diverse trades. Best score: ' + $bestScore" chance="100"/>
        </do_if>
        
        <!-- Phase 4: Complete scheduler work item if it exists -->
        <!-- Use ship as ActiveWork key (not string WorkItemKey) -->
        <set_value name="$workItemKey" exact="null"/>
        <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <set_value name="$workItemKey" exact="@global.$GT_SearchLiveTrades_State.{$ship}.$WorkItemKey"/>
        </do_if>
        <do_if value="$workItemKey? and $workItemKey != ''">
          <!-- Lookup ActiveWork by ship (not by string key) -->
          <do_if value="global.$GT_Scheduler? and global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.{$ship}?">
            <set_value name="$workItem" exact="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
            <set_value name="$workTraceId" exact="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
            
            <!-- Mark work item as completed -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="$workItemKey"/>
              <param name="newState" value="'completed'"/>
              <param name="traceId" value="$workTraceId"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            
            <!-- Remove from ActiveWork using ship key -->
            <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
            
            <!-- Log completion -->
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$workTraceId"/>
              <param name="stage" value="'HomeSearch'"/>
              <param name="action" value="'Complete'"/>
              <param name="details" value="'ship=' + $ship.idcode + ' trades=' + $finalTradeCount + ' duration=' + ((player.age - (if global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}? and global.$GT_SearchLiveTrades_State.{$ship}.$Started? then global.$GT_SearchLiveTrades_State.{$ship}.$Started else player.age)) / 1ms) + 'ms'"/>
              <param name="logLevel" value="1"/>
            </run_actions>
          </do_if>
        </do_if>
        
        <!-- 10. Signal SearchTradeRoutes again with original parameters so it can read the live search results -->
        <!-- IMPORTANT: In MD, $var? can be true even if $var == null. Also guard against stale continuation (no search lock). -->
        <set_value name="$canSignalContinuation" exact="false"/>
        <set_value name="$hasSearchLock" exact="false"/>
        <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
          <set_value name="$hasSearchLock" exact="true"/>
        </do_if>
        <do_if value="$hasSearchLock and $originalParams? and $originalParams != null">
          <do_if value="$originalParams.$MaxDistance? and $originalParams.$MaxDistance != null">
            <set_value name="$canSignalContinuation" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="$canSignalContinuation">
          <!-- Set explicit SearchState based on whether this is a fallback search -->
          <set_value name="$searchState" exact="'live'"/>
          <do_if value="$isFallbackSearchFromBatch">
            <set_value name="$searchState" exact="'fallback'"/>
          </do_if>
          <set_value name="$originalParams.$SearchState" exact="$searchState"/>
          <!-- Central hub: resume SearchTradeRoutes through the scheduler's paced entry (no CacheQuery; SearchState is live/fallback) -->
          <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.SearchTradeRoutes_Delayed" param="$originalParams"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Signaled SearchTradeRoutes to continue with live search results (' + $finalTradeCount + ' trades, state=' + $searchState + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Could not (or should not) signal continuation.
               Common causes:
               - stale delayed resume (no search lock anymore)
               - missing/invalid MaxDistance in params table -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Not signaling SearchTradeRoutes continuation (hasLock=' + $hasSearchLock + ', params=' + (if $originalParams? then 'exists' else 'missing') + ', maxDist=' + (if $originalParams? and $originalParams != null and $originalParams.$MaxDistance? then $originalParams.$MaxDistance else 'null') + ') - results stored in global.$GT_SearchResult'" chance="100"/>
          </do_if>
        </do_else>
        <!-- Close filterStateValid do_else guard -->
        </do_else>
      </actions>
    </cue>
    
    <!-- Search for Sell Opportunities -->
    <cue name="SearchSellOpportunities" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Receive parameters directly -->
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$minProfit" exact="$params.$MinProfit"/>
        
        <!-- DEBUG: Sell search start -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') === SELL SEARCH START ===' + '\nShip: ' + $ship.knownname + '\nCurrent Sector: ' + $ship.sector.knownname + '\nMax Distance: ' + $maxDistance + ' jumps' + '\nMin Profit: ' + $minProfit + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- Determine home sector for sell search (needed for sector list building) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetHomeSector" result="$homeSector">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- CRITICAL: Abort if home sector cannot be determined (prevents drift) -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cannot determine home sector for sell search - aborting to prevent drift'" chance="100"/>
          </do_if>
          <!-- Release lock and abort -->
          <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
            <param name="ship" value="$ship"/>
            <param name="reason" value="'no_home_sector'"/>
          </run_actions>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Determine blacklistgroup (needed for sector list building) -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Build sell sectors list (per-sector queries like vanilla) -->
        <!-- FIX: Query per-sector instead of galaxy-wide to work without initialized market data -->
        <!-- Vanilla pattern: query stations in specific sectors, not galaxy-wide -->
        <set_value name="$sellspaces" exact="[]"/>
        <run_actions ref="md.GT_Libraries_Pathfinding.GT_FindSectorsInRange" result="$sellspaces">
          <param name="refobject" value="$homeSector"/>
          <param name="mingatedistance" value="0"/>
          <param name="maxgatedistance" value="$maxDistance"/>
          <param name="applyblacklist" value="true"/>
          <param name="blacklistgroup" value="$blacklistgroup"/>
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Sell] (' + $ship.idcode + ') Found ' + $sellspaces.count + ' sell sectors within ' + $maxDistance + ' jumps from home sector'" chance="100"/>
        </do_if>
        
        <!-- Find best sell location for current cargo -->
        <set_value name="$bestOffer" exact="null"/>
        <set_value name="$bestPrice" exact="0"/>
        <set_value name="$bestAmount" exact="0"/>
        
        <!-- Get ship's current cargo -->
        <set_value name="$currentCargo" exact="$ship.cargo.list"/>
        
        <do_if value="$currentCargo.count gt 0">
          <!-- Rotate through cargo entries to avoid getting stuck on unsellable wares -->
          <!-- Track last attempted ware index to rotate through cargo list -->
          <!-- If one ware can't be sold (banned, blacklisted, mission-tied), next request tries next ware -->
          <set_value name="$selectedIndex" exact="1"/>
          <do_if value="global.$GT_ForcedSellLastWare? and global.$GT_ForcedSellLastWare.{$ship}?">
            <!-- Get last attempted ware index -->
            <set_value name="$lastWareIndex" exact="global.$GT_ForcedSellLastWare.{$ship}"/>
            <!-- Rotate to next ware (wrap around if needed) -->
            <!-- Use % operator for modulo (X4 MD syntax) -->
            <set_value name="$selectedIndex" exact="(($lastWareIndex % $currentCargo.count) + 1)"/>
          </do_if>
          
          <!-- Select ware at rotated index -->
          <set_value name="$selectedWare" exact="$currentCargo.{$selectedIndex}"/>
          <set_value name="$selectedAmount" exact="$ship.cargo.{$selectedWare}.count"/>
          
          <!-- Store attempted ware index for next rotation -->
          <do_if value="not global.$GT_ForcedSellLastWare?">
            <set_value name="global.$GT_ForcedSellLastWare" exact="table[]"/>
          </do_if>
          <set_value name="global.$GT_ForcedSellLastWare.{$ship}" exact="$selectedIndex"/>
          
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Cargo contains ' + $currentCargo.count + ' ware types, attempting to sell ware ' + $selectedIndex + '/' + $currentCargo.count + ': ' + @$selectedWare.name + ' x' + $selectedAmount + ' (rotating through cargo to avoid stuck on unsellable wares)'" chance="100"/>
          </do_if>
          
          <!-- FIX: Query per-sector instead of galaxy-wide (like vanilla) -->
          <!-- This allows ships to find trades even without initialized market data (satellites) -->
          <!-- Vanilla pattern: iterate through sectors and query stations in each sector -->
          <set_value name="$buyOffers" exact="[]"/>
          <do_all exact="$sellspaces.count" counter="$i">
            <set_value name="$sector" exact="$sellspaces.{$i}"/>
            <do_if value="not $sector? or not $sector.exists">
              <continue/>
            </do_if>
            
            <!-- Initialize per-sector offer list -->
            <set_value name="$sectorBuyOffers" exact="[]"/>
            
            <!-- Query buy offers in this sector (ship sells to stations' buy offers) -->
            <find_buy_offer tradepartner="$ship" space="$sector" result="$sectorBuyOffers" multiple="true" wares="$selectedWare">
              <match_buyer tradesknownto="$ship.owner">
                <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
              </match_buyer>
              <amount min="1"/>
              <totalvolume min="1"/>
            </find_buy_offer>
            
            <!-- Append sector's offers to main list -->
            <set_value name="$sectorBuyOffersCount" exact="0"/>
            <do_if value="$sectorBuyOffers?">
              <set_value name="$sectorBuyOffersCountTemp" exact="@$sectorBuyOffers.count"/>
              <do_if value="$sectorBuyOffersCountTemp?">
                <set_value name="$sectorBuyOffersCount" exact="$sectorBuyOffersCountTemp"/>
              </do_if>
            </do_if>
            <do_all exact="$sectorBuyOffersCount" counter="$j">
              <append_to_list name="$buyOffers" exact="$sectorBuyOffers.{$j}"/>
            </do_all>
          </do_all>
          
          <!-- Debug: Log if no offers found -->
          <do_if value="$buyOffers.count == 0">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Sell] ' + $ship.idcode + ': No buy offers found for ' + @$selectedWare.name + ' (ship cargo: ' + $selectedAmount + ' units) after querying ' + $sellspaces.count + ' sectors'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Find best price -->
          <do_all exact="$buyOffers.count" counter="$j">
            <set_value name="$offer" exact="$buyOffers.{$j}"/>
            
            <!-- Validate offer is still valid (station may have been destroyed/removed) -->
            <set_value name="$station" exact="@$offer.owner"/>
            <set_value name="$offerValid" exact="false"/>
            <do_if value="@$station.exists">
              <set_value name="$currentSector" exact="$ship.sector"/>
              <set_value name="$stationSector" exact="@$station.sector"/>
              
              <!-- Validate station sector is valid -->
              <do_if value="@$stationSector.exists">
                <set_value name="$offerValid" exact="true"/>
              </do_if>
            </do_if>
            
            <!-- Only process valid offers -->
            <do_if value="$offerValid">
              <!-- tradepartner="$ship" in find_buy_offer already filters by faction relations -->
              <!-- No explicit check needed - C++ engine handles it -->
              
              <!-- Check blacklists before considering offer -->
              <set_value name="$isBlacklisted" exact="false"/>
            
            <!-- Block intra-sector sales in blacklisted sectors (force escape) -->
            <!-- If ship is in blacklisted sector and trying to sell to station in same sector, block -->
            <do_if value="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
              <do_if value="$stationSector == $currentSector">
                <!-- Intra-sector sale in blacklisted sector - BLOCK to force escape -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (intra-sector sale in blacklisted sector - must escape)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check station blacklist (object activity) -->
            <do_if value="not $isBlacklisted and @$station.isblacklisted.{blacklisttype.objectactivity}.{$blacklistgroup}.{$ship}">
              <set_value name="$isBlacklisted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (station blacklisted)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (sector activity) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector activity blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (travel) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector travel blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check if path to station goes through blacklisted sectors -->
            <!-- Uses blacklist-aware gatedistance - returns -1 if path blocked by blacklisted sector -->
            <!-- Vanilla pattern: order.dock.xml:503 -->
            <do_if value="not $isBlacklisted">
              <set_value name="$pathDistance" exact="$ship.gatedistance.{$stationSector}.{$blacklistgroup}.{$ship}"/>
              
              <do_if value="$pathDistance lt 0">
                <!-- Path goes through blacklisted sector or no path exists -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <!-- <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (path goes through blacklisted sector)'" chance="100"/> -->
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check carrier/aux exclusion (for stations only) -->
            <do_if value="not $isBlacklisted">
              <set_value name="$ignoreCarrierAux" exact="false"/>
              <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux?">
                <set_value name="$ignoreCarrierAux" exact="global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux"/>
              </do_if>
              
              <do_if value="$ignoreCarrierAux and $station.isclass.station">
                <set_value name="$stationPrimaryPurpose" exact="@$station.primarypurpose"/>
                <do_if value="$stationPrimaryPurpose == purpose.auxiliary or $stationPrimaryPurpose == purpose.fight">
                  <set_value name="$isBlacklisted" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (carrier/aux excluded)'" chance="100"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check build storage exclusion -->
            <do_if value="not $isBlacklisted">
              <set_value name="$ignoreBuildStorage" exact="false"/>
              <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage?">
                <set_value name="$ignoreBuildStorage" exact="global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage"/>
              </do_if>
              
              <do_if value="$ignoreBuildStorage and $station.isclass.buildstorage">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (build storage excluded)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check operational status -->
            <set_value name="$isOperational" exact="$station.isoperational and not @$station.isclosingdown"/>
            <do_if value="not $isBlacklisted and not $isOperational">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (not operational)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Check technical docking capability - does station have docking bay for this ship size? -->
            <set_value name="$canDock" exact="false"/>
            <do_if value="not $isBlacklisted and $isOperational">
              <find_dockingbay name="$testDock" object="$station" checkoperational="true" multiple="false">
                <match_dock size="$ship.docksize" storage="false"/>
              </find_dockingbay>
              <do_if value="$testDock">
                <!-- Station has docking bay for this ship size - check docking permission -->
                <set_value name="$canDock" exact="$station.dockingallowed.{$ship}"/>
              </do_if>
              <do_else>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (no docking bay for ship size ' + $ship.docksize + ')'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            
            <!-- Check docking permission -->
            <do_if value="not $isBlacklisted and $isOperational and not $canDock">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (docking not allowed)'" chance="100"/>
              </do_if>
            </do_if>
            
              <!-- Only consider valid, non-blacklisted, operational, dockable offers -->
              <do_if value="not $isBlacklisted and $isOperational and $canDock and $offer.available">
                <set_value name="$tradeAmount" exact="[$selectedAmount, $offer.amount].min"/>
                
                <!-- CRITICAL: Skip if trade amount is zero or negative (ship has no cargo or offer has no amount) -->
                <do_if value="$tradeAmount gt 0">
                  <set_value name="$profit" exact="$offer.unitprice * $tradeAmount"/>
                  
                  <do_if value="$profit gt $bestPrice">
                    <set_value name="$bestOffer" exact="$offer"/>
                    <set_value name="$bestPrice" exact="$profit"/>
                    <set_value name="$bestAmount" exact="$tradeAmount"/>
                    
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer now: ' + @$station.knownname + ' - ' + $offer.ware.name + ' x' + $tradeAmount + ' @ ' + $offer.unitprice + ' Cr/unit (profit: ' + $profit + ' Cr)'" chance="100"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            <!-- End of $offerValid check -->
          </do_all>
          
          <!-- Execute best sell if found - use normal pipeline (store in GT_PendingTrades, let AI create orders) -->
          <!-- For cargo disposal, accept even zero profit (ship must clear cargo) - use ge instead of gt to allow zero -->
          <do_if value="$bestOffer and $bestPrice ge $minProfit">
            <!-- Validate offer is STILL valid before proceeding -->
            <!-- Offers can become invalid between search and order creation -->
            <set_value name="$offerStillValid" exact="$bestOffer.available and $bestOffer.amount gt 0"/>
            
            <do_if value="$offerStillValid">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3] ' + $ship.knownname + ' found sell opportunity'" chance="100"/>
              </do_if>
              
              <!-- Create trade structure compatible with normal pipeline -->
              <!-- For forced sell: ship already has cargo, so we create a sell-only trade structure -->
              <!-- BuyStation = null for sell-only trades (ship already has cargo, no buy station needed) -->
              <!-- Setting BuyStation to ship causes docking checks on ship object which fails -->
              <!-- SellStation = target station buying the cargo -->
              <set_value name="$sellStation" exact="$bestOffer.owner"/>
              
              <!-- Create trade structure matching normal pipeline format -->
              <!-- For sell-only trades, BuyOffer and BuyStation are null (ship already has cargo) -->
              <!-- ExecuteTrade will handle this via $IsSellOnly flag -->
              <set_value name="$sellTrade" exact="table[
                $BuyStation = null,
                $SellStation = $sellStation,
                $Ware = $selectedWare,
                $BuyOffer = null,
                $SellOffer = $bestOffer,
                $Amount = $bestAmount,
                $BuyPrice = 0,
                $SellPrice = $bestOffer.unitprice,
                $Profit = $bestPrice,
                $ROI = 0,
                $Score = $bestPrice,
                $Distance = 0,
                $IsSellOnly = true
              ]"/>
              
              <!-- Store in GT_PendingTrades and send to execution pipeline -->
              <!-- This ensures failure tracking, telemetry, and proper order creation by AI -->
              <signal_cue_instantly cue="md.GT_Trading_Execution.ExecuteTrade" param="table[
                $Ship = $ship,
                $Trade = $sellTrade,
                $TradeList = [$sellTrade],
                $SearchMethod = 'forced_sell'
              ]"/>
              
              <!-- Note: GT_Trade_Found signal now sent FROM ExecuteTrade after storing pending trade -->
            </do_if>
            <do_else>
              <!-- Offer became invalid - don't create order -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer became invalid before order creation - retrying'" chance="100"/>
              </do_if>
              
              <!-- Signal back to AI script: No Trade Found (will retry) -->
              <run_actions ref="md.GT_Libraries_General.GT_RequestStatus_Update">
                <param name="ship" value="$ship"/>
                <param name="stage" value="'result'"/>
                <param name="state" value="'no_trade_found'"/>
                <param name="reason" value="'forced_sell_offer_invalid'"/>
                <param name="traceId" value="if global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$TraceId? then global.$GT_AIParameters.{$ship}.$TraceId else ''"/>
              </run_actions>
              <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Signal back to AI script: No Trade Found -->
            <run_actions ref="md.GT_Libraries_General.GT_RequestStatus_Update">
              <param name="ship" value="$ship"/>
              <param name="stage" value="'result'"/>
              <param name="state" value="'no_trade_found'"/>
              <param name="reason" value="'forced_sell_no_offer'"/>
              <param name="traceId" value="if global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$TraceId? then global.$GT_AIParameters.{$ship}.$TraceId else ''"/>
            </run_actions>
            <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- Signal back to AI script: No Trade Found (no cargo) -->
          <run_actions ref="md.GT_Libraries_General.GT_RequestStatus_Update">
            <param name="ship" value="$ship"/>
            <param name="stage" value="'result'"/>
            <param name="state" value="'no_trade_found'"/>
            <param name="reason" value="'forced_sell_no_cargo'"/>
            <param name="traceId" value="if global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$TraceId? then global.$GT_AIParameters.{$ship}.$TraceId else ''"/>
          </run_actions>
          <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
        </do_else>
        
        <!-- Release lock and parameters using Request Registry -->
        <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
          <param name="ship" value="$ship"/>
          <param name="reason" value="'search_aborted'"/>
        </run_actions>
      </actions>
    </cue>

    <!-- Debug: Periodic cache snapshot (VERY heavy).
         IMPORTANT: This can cause microstutter by dumping hundreds/thousands of lines in a single frame.
         It is now opt-in via global.$GT_Config.$Debug.$CacheSnapshotEnabled. -->
    <!-- Purpose: Diagnose cache composition (missing wares, low diversity, unexpected evictions). -->
    <cue name="CacheSnapshotLogger" instantiate="true" checkinterval="2min">
      <conditions>
        <check_value value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and @global.$GT_Config.$Debug.$CacheSnapshotEnabled"/>
      </conditions>
      <actions>
        <set_value name="$total" exact="0"/>
        <run_actions ref="md.GT_Libraries_General.GT_CalculateTotalCacheCount" result="$total"/>
        <debug_text text="'[GT-Cache-Snapshot] BEGIN t=' + (player.age / 1) + 's total=' + $total" chance="100"/>

        <do_if value="not global.$GT_TradeCache?">
          <debug_text text="'[GT-Cache-Snapshot] No global.$GT_TradeCache table yet.'" chance="100"/>
        </do_if>
        <do_else>
          <!-- IMPORTANT: Some saves may still have a legacy list-shaped GT_TradeCache (no .keys property).
               Use safe reads and support both shapes so we can always dump what exists. -->
          <set_value name="$cacheObj" exact="@global.$GT_TradeCache"/>
          
          <!-- Prefer an explicit home-sector registry (populated during caching) -->
          <set_value name="$keys" exact="[]"/>
          <do_if value="global.$GT_TradeCacheHomes?">
            <set_value name="$keys" exact="@global.$GT_TradeCacheHomes"/>
          </do_if>
          <do_else>
            <set_value name="$keys" exact="@$cacheObj.keys"/>
            <do_if value="$keys == null">
              <set_value name="$keys" exact="[]"/>
            </do_if>
          </do_else>
          
          <debug_text text="'[GT-Cache-Snapshot] homeKeys=' + $keys.count + ' (homesRegistry=' + (global.$GT_TradeCacheHomes? and 'true' or 'false') + ', cacheHasKeys=' + ($cacheObj.keys? and 'true' or 'false') + ')'" chance="100"/>

          <!-- Normal shape: table keyed by home sector -->
          <!-- FIX: Handle empty keys list (valid state - just means no cached home sectors yet) -->
          <do_if value="$keys.count gt 0">
            <do_all exact="$keys.count" counter="$k">
              <set_value name="$home" exact="$keys.{$k}"/>
              <set_value name="$sectorCache" exact="@global.$GT_TradeCache.{$home}"/>
              <do_if value="$sectorCache == null">
                <continue/>
              </do_if>

              <set_value name="$homeName" exact="@$home.knownname"/>
              <do_if value="not $homeName?">
                <set_value name="$homeName" exact="'[unknown home sector]'"/>
              </do_if>

              <debug_text text="'[GT-Cache-Snapshot] HOME ' + $homeName + ' entries=' + $sectorCache.count" chance="100"/>

              <!-- Per-ware counts for this home sector (avoid table.keys; some saves/types make .keys unreliable) -->
              <set_value name="$wareSummary" exact="[]"/>

              <!-- Full dump (bounded HARD to prevent microstutter during debug sessions). -->
              <set_value name="$dumpLimit" exact="200"/>
              <set_value name="$dumpCount" exact="[$sectorCache.count, $dumpLimit].min"/>
              <do_all exact="$dumpCount" counter="$i">
                <set_value name="$e" exact="$sectorCache.{$i}"/>
                <do_if value="$e == null">
                  <continue/>
                </do_if>

                <set_value name="$wareObj" exact="@$e.$BuyOffer.ware"/>
                <set_value name="$wareName" exact="if $e.$WareName? then $e.$WareName else @$wareObj.name"/>
                <do_if value="not $wareName?">
                  <set_value name="$wareName" exact="'[unknown ware]'"/>
                </do_if>

                <!-- Update per-ware counts by name -->
                <set_value name="$wsFound" exact="false"/>
                <do_all exact="$wareSummary.count" counter="$wsi">
                  <do_if value="$wareSummary.{$wsi}.$WareName == $wareName">
                    <set_value name="$wareSummary.{$wsi}.$Count" exact="$wareSummary.{$wsi}.$Count + 1"/>
                    <set_value name="$wsFound" exact="true"/>
                    <break/>
                  </do_if>
                </do_all>
                <do_if value="not $wsFound">
                  <append_to_list name="$wareSummary" exact="table[$WareName = $wareName, $Count = 1]"/>
                </do_if>

                <set_value name="$roi" exact="@$e.$ROI"/>
                <do_if value="$roi == null">
                  <set_value name="$roi" exact="-1"/>
                </do_if>

                <set_value name="$profit" exact="@$e.$Profit"/>
                <do_if value="$profit == null">
                  <set_value name="$profit" exact="0"/>
                </do_if>

                <set_value name="$dist" exact="@$e.$Distance"/>
                <do_if value="$dist == null">
                  <set_value name="$dist" exact="-1"/>
                </do_if>

                <set_value name="$age" exact="-1"/>
                <do_if value="$e.$Timestamp? and $e.$Timestamp != null">
                  <set_value name="$age" exact="(player.age - $e.$Timestamp) / 1"/>
                </do_if>

                <set_value name="$buyName" exact="@$e.$BuyOffer.owner.knownname"/>
                <do_if value="not $buyName?">
                  <set_value name="$buyName" exact="'[unknown buy]'"/>
                </do_if>
                <set_value name="$sellName" exact="@$e.$SellOffer.owner.knownname"/>
                <do_if value="not $sellName?">
                  <set_value name="$sellName" exact="'[unknown sell]'"/>
                </do_if>

                <debug_text text="'[GT-Cache-Snapshot]  ' + $i +
                  ' ware=' + $wareName +
                  ' roi=' + ($roi / 1) + '%' +
                  ' profit=' + ($profit / 100) + 'Cr' +
                  ' dist=' + $dist +
                  ' age=' + $age + 's' +
                  ' buy=' + $buyName +
                  ' sell=' + $sellName" chance="100"/>
              </do_all>

              <do_if value="$sectorCache.count gt $dumpLimit">
                <debug_text text="'[GT-Cache-Snapshot] HOME ' + $homeName + ': dump truncated at ' + $dumpLimit + ' / ' + $sectorCache.count + ' entries.'" chance="100"/>
              </do_if>

              <!-- Per-ware summary at end of each home sector -->
              <debug_text text="'[GT-Cache-Snapshot] HOME ' + $homeName + ' distinctWares=' + $wareSummary.count" chance="100"/>
              <do_all exact="$wareSummary.count" counter="$wi">
                <set_value name="$row" exact="$wareSummary.{$wi}"/>
                <debug_text text="'[GT-Cache-Snapshot]   WARE ' + $row.$WareName + ' count=' + $row.$Count" chance="100"/>
              </do_all>
            </do_all>
          </do_if>
          <do_elseif value="$keys.count == 0">
            <!-- FIX: Empty keys list is valid - just means no cached home sectors yet -->
            <debug_text text="'[GT-Cache-Snapshot] Cache is empty (no home sectors cached yet) - this is normal for new saves or after cache clear'" chance="100"/>
          </do_elseif>
          <do_else>
            <!-- Legacy shape: GT_TradeCache is a flat list (no home-sector keys). Dump as one "home". -->
            <do_if value="$cacheObj.count? and $cacheObj.count ge 0">
              <set_value name="$sectorCache" exact="$cacheObj"/>
              <set_value name="$homeName" exact="'[GT_TradeCache legacy list]'"/>
              <debug_text text="'[GT-Cache-Snapshot] HOME ' + $homeName + ' entries=' + $sectorCache.count" chance="100"/>

              <set_value name="$wareSummary" exact="[]"/>
              <set_value name="$dumpLimit" exact="5000"/>
              <set_value name="$dumpCount" exact="[$sectorCache.count, $dumpLimit].min"/>
              <do_all exact="$dumpCount" counter="$i">
                <set_value name="$e" exact="$sectorCache.{$i}"/>
                <do_if value="$e == null">
                  <continue/>
                </do_if>

                <set_value name="$wareObj" exact="@$e.$BuyOffer.ware"/>
                <set_value name="$wareName" exact="if $e.$WareName? then $e.$WareName else @$wareObj.name"/>
                <do_if value="not $wareName?">
                  <set_value name="$wareName" exact="'[unknown ware]'"/>
                </do_if>

                <!-- Update per-ware counts by name -->
                <set_value name="$wsFound" exact="false"/>
                <do_all exact="$wareSummary.count" counter="$wsi">
                  <do_if value="$wareSummary.{$wsi}.$WareName == $wareName">
                    <set_value name="$wareSummary.{$wsi}.$Count" exact="$wareSummary.{$wsi}.$Count + 1"/>
                    <set_value name="$wsFound" exact="true"/>
                    <break/>
                  </do_if>
                </do_all>
                <do_if value="not $wsFound">
                  <append_to_list name="$wareSummary" exact="table[$WareName = $wareName, $Count = 1]"/>
                </do_if>

                <set_value name="$roi" exact="@$e.$ROI"/>
                <do_if value="$roi == null">
                  <set_value name="$roi" exact="-1"/>
                </do_if>

                <set_value name="$profit" exact="@$e.$Profit"/>
                <do_if value="$profit == null">
                  <set_value name="$profit" exact="0"/>
                </do_if>

                <set_value name="$dist" exact="@$e.$Distance"/>
                <do_if value="$dist == null">
                  <set_value name="$dist" exact="-1"/>
                </do_if>

                <set_value name="$age" exact="-1"/>
                <do_if value="$e.$Timestamp? and $e.$Timestamp != null">
                  <set_value name="$age" exact="(player.age - $e.$Timestamp) / 1"/>
                </do_if>

                <set_value name="$buyName" exact="@$e.$BuyOffer.owner.knownname"/>
                <do_if value="not $buyName?">
                  <set_value name="$buyName" exact="'[unknown buy]'"/>
                </do_if>
                <set_value name="$sellName" exact="@$e.$SellOffer.owner.knownname"/>
                <do_if value="not $sellName?">
                  <set_value name="$sellName" exact="'[unknown sell]'"/>
                </do_if>

                <debug_text text="'[GT-Cache-Snapshot]  ' + $i +
                  ' ware=' + $wareName +
                  ' roi=' + ($roi / 1) + '%' +
                  ' profit=' + ($profit / 100) + 'Cr' +
                  ' dist=' + $dist +
                  ' age=' + $age + 's' +
                  ' buy=' + $buyName +
                  ' sell=' + $sellName" chance="100"/>
              </do_all>

              <debug_text text="'[GT-Cache-Snapshot] HOME ' + $homeName + ' distinctWares=' + $wareSummary.count" chance="100"/>
              <do_all exact="$wareSummary.count" counter="$wi">
                <set_value name="$row" exact="$wareSummary.{$wi}"/>
                <debug_text text="'[GT-Cache-Snapshot]   WARE ' + $row.$WareName + ' count=' + $row.$Count" chance="100"/>
              </do_all>
            </do_if>
            <do_else>
              <debug_text text="'[GT-Cache-Snapshot] ERROR: GT_TradeCache has no keys and no count - cannot dump.'" chance="100"/>
            </do_else>
          </do_else>
        </do_else>

        <debug_text text="'[GT-Cache-Snapshot] END'" chance="100"/>
      </actions>
    </cue>
  </cues>
</mdscript>
