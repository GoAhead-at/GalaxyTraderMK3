<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Trading_Search" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ========================================
         GALAXY TRADER MK3 - SEARCH ENGINE
         Core trade route search and matching logic
         ======================================== -->
    
    <!-- Search for Trade Routes (MAIN SEARCH ENGINE) -->
    <cue name="SearchTradeRoutes" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- âœ… PERFORMANCE FIX: Receive parameters directly from event to prevent race conditions -->
        <!-- Handle case where SearchLiveTrades_Resume signals again after batch completion -->
        <set_value name="$params" exact="event.param"/>
        <do_if value="not $params?">
          <!-- Parameters not provided - try to get from search queue or batch data -->
          <set_value name="$shipFromQueue" exact="null"/>
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <do_if value="global.$GT_SearchResult.$Ship?">
            <!-- Ship stored in SearchResult from live search -->
            <set_value name="$shipFromQueue" exact="global.$GT_SearchResult.$Ship"/>
          </do_if>
          
          <do_if value="$shipFromQueue?">
            <!-- Try to get params from search queue -->
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchQueue exists -->
            <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$shipFromQueue}?">
              <set_value name="$params" exact="global.$GT_SearchQueue.$Params.{$shipFromQueue}"/>
            </do_if>
            <do_else>
              <!-- Reconstruct params from batch data (if still available) -->
              <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$shipFromQueue}"/>
              <do_if value="$batchData?">
                <set_value name="$allowIllegalDefault" exact="false"/>
                <set_value name="$params" exact="table[
                  $Ship = $shipFromQueue,
                  $MaxDistance = @$batchData.$maxDistance,
                  $MinROI = @$batchData.$minROI,
                  $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                  $FactionPriority = @$batchData.$factionPriority,
                  $AllowIllegal = $allowIllegalDefault
                ]"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>
        
        <!-- âœ… CRITICAL FIX: Validate params exist and are not null -->
        <!-- Check if $params exists AND has required $Ship property (handles null case) -->
        <set_value name="$paramsValid" exact="false"/>
        <do_if value="$params?">
          <set_value name="$testShip" exact="@$params.$Ship"/>
          <do_if value="$testShip?">
            <set_value name="$paramsValid" exact="true"/>
          </do_if>
        </do_if>
        
        <do_if value="not $paramsValid">
          <!-- âœ… DEBUG MODE: Only log when debug is enabled -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] âš ï¸ SearchTradeRoutes called without valid parameters - cannot proceed'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$minROI" exact="$params.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="$params.$FactionPriority"/>
        
        <!-- âœ… DEBUG: Log profit threshold from params -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ’° Profit threshold from params: ' + ($minAbsoluteProfit / 100) + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- âœ… CRITICAL FIX: Detect continuation EARLY (before skill multiplier) -->
        <!-- Check if we're continuing from live search completion BEFORE applying skill multiplier -->
        <!-- When SearchLiveTrades_Resume signals SearchTradeRoutes, live results are already in global.$GT_SearchResult -->
        <set_value name="$isLiveSearchContinuation" exact="false"/>
        <do_if value="global.$GT_SearchResult.$Ship? and global.$GT_SearchResult.$Ship == $ship">
          <set_value name="$savedWaitingForBatch" exact="@global.$GT_SearchResult.$WaitingForBatch"/>
          <do_if value="not $savedWaitingForBatch">
            <!-- Live search just completed for this ship - this is a continuation -->
            <set_value name="$isLiveSearchContinuation" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- âœ… CRITICAL FIX: Check if this is a fallback search continuation - if so, params already have skill multiplier applied -->
        <!-- Fallback search receives already-multiplied values, relaxes them, then SearchLiveTrades_Resume signals SearchTradeRoutes -->
        <!-- When SearchTradeRoutes runs as continuation, params already have relaxed values that shouldn't be multiplied again -->
        <set_value name="$isFallbackContinuation" exact="false"/>
        <do_if value="$isLiveSearchContinuation and $maxDistance == 2">
          <set_value name="$isFallbackContinuation" exact="true"/>
          <!-- âœ… CRITICAL FIX: For fallback continuation, params already have relaxed profit thresholds from SearchFallbackTrades -->
          <!-- These were calculated from already-multiplied values, so don't apply multiplier again -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Fallback continuation detected - skipping skill multiplier (params already relaxed)'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- âœ… FALLBACK COOLDOWN: Clear fallback flag at start of new search cycle -->
        <!-- This allows fallback to be attempted again if cache and live search both fail -->
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_FallbackAttempted exists -->
        <do_if value="global.$GT_FallbackAttempted.{$ship}?">
          <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Starting new search cycle - cleared fallback flag'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Create faction priority text for debug output -->
        <run_actions ref="md.GT_Trade_Utilities.GT_GetFactionPriorityText" result="$factionPriorityText">
          <param name="factionPriority" value="$factionPriority"/>
        </run_actions>
        
        <!-- Get distance penalty setting (0-100% converted to 0.0-2.0 multiplier) -->
        <run_actions ref="md.GT_Trade_Utilities.GT_GetDistancePenaltyMultiplier" result="$distancePenaltyMultiplier">
          <param name="ship" value="$ship"/>
        </run_actions>

        <!-- Resolve pilot skill and apply feature gates + level-based thresholds -->
        <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$skillLevel" exact="if $skillInfo? and $skillInfo.$Level? then $skillInfo.$Level else 1"/>

        <!-- Feature gates by skill level -->
        <set_value name="$gt_ThreatIntel" exact="$skillLevel ge 6"/>
        <set_value name="$gt_SatelliteIntel" exact="$skillLevel ge 9"/>
        <set_value name="$gt_FleetCoord" exact="$skillLevel ge 12"/>
        <set_value name="$gt_AdvancedAnalytics" exact="$skillLevel ge 15"/>
        
        <!-- âœ… NEW: Profit threshold is now pilot level-based (set in gt_trading_queue.xml) -->
        <!-- Level 1: 0 Cr, Level 2: 100 Cr, Level 3: 500 Cr, Level 4+: Config value with skill multiplier -->
        <!-- Params already contain the correct pilot level-based threshold, so no need to apply multiplier here -->
        <!-- ROI multiplier still applies for ROI threshold (not profit threshold) -->
        <!-- âœ… CRITICAL FIX: Only apply ROI multiplier if NOT a fallback continuation -->
        <!-- Fallback continuation params come from SearchFallbackTrades which already relaxed the already-multiplied values -->
        <do_if value="not $isFallbackContinuation">
          <run_actions ref="md.GT_Trade_Utilities.GT_GetSkillMultiplier" result="$roiMultiplier">
            <param name="skillLevel" value="$skillLevel"/>
          </run_actions>
          <set_value name="$minROI" exact="$minROI * $roiMultiplier"/>
          <!-- Note: $minAbsoluteProfit is already set correctly from params (pilot level-based) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Profit threshold unchanged (pilot level-based): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI multiplier applied: ' + $minROI + '% (multiplier: ' + $roiMultiplier + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fallback continuation - params already have relaxed thresholds -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Profit threshold from fallback continuation (already relaxed): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI: ' + $minROI + '%'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- âœ… ENHANCED: Log search start for detailed diagnostics (debug mode only) -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$pilotInfo" exact="'No Pilot'"/>
          <do_if value="$ship.pilot">
            <set_value name="$shownSkill" exact="1"/>
            <do_if value="global.$GT_Pilots.{$ship.pilot}? and global.$GT_Pilots.{$ship.pilot}.$Level?">
              <set_value name="$shownSkill" exact="global.$GT_Pilots.{$ship.pilot}.$Level"/>
            </do_if>
            <do_elseif value="$ship.pilot.skill.management?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.management"/>
            </do_elseif>
            <do_elseif value="$ship.pilot.skill.piloting?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.piloting"/>
            </do_elseif>
            <set_value name="$pilotInfo" exact="$ship.pilot.name + ' (Skill: ' + $shownSkill + ')'"/>
          </do_if>
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') === TRADE SEARCH START ===' + 
            '\nShip: ' + $ship.knownname + 
            '\nPilot: ' + $pilotInfo + 
            '\nCurrent Sector: ' + $ship.sector.knownname + 
            '\nMax Distance: ' + $maxDistance + ' jumps' + 
            '\nMin ROI: ' + $minROI + '%' + 
            '\nMin Absolute Profit: ' + ($minAbsoluteProfit / 100) + ' Cr' + 
            '\nShip Cargo: ' + ($ship.cargo.capacity.all - $ship.cargo.free.all) + '/' + $ship.cargo.capacity.all +
            '\nFaction Priority: ' + $factionPriorityText" 
            chance="100"/>
        </do_if>
        
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$foundCachedTrade" exact="false"/>
        <set_value name="$fallbackSearchTriggered" exact="false"/>  <!-- Track if fallback search was triggered -->
        
        <!-- âœ… FALLBACK COOLDOWN: Clear fallback flag when new normal search cycle starts -->
        <!-- This allows fallback to be tried again after normal search cooldown expires -->
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_FallbackAttempted exists -->
        <do_if value="global.$GT_FallbackAttempted.{$ship}?">
          <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… New search cycle started - fallback flag cleared'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- âœ… CRITICAL FIX: Extract live search results if continuation (already detected earlier) -->
        <!-- When SearchLiveTrades_Resume signals SearchTradeRoutes, live results are already in global.$GT_SearchResult -->
        <!-- We should use those results instead of running cache search again -->
        <!-- CRITICAL: Extract and preserve live results IMMEDIATELY before cache search can overwrite them -->
        <!-- Note: $isLiveSearchContinuation already set earlier (before skill multiplier) - don't reset it! -->
        <set_value name="$liveTradeList" exact="[]"/>
        <set_value name="$liveBestTrade" exact="null"/>
        <set_value name="$liveBestScore" exact="0"/>
        
        <!-- âœ… FALLBACK SEARCH: Check if we're already in a fallback search (MaxDistance == 2 from previous call) -->
        <!-- If MaxDistance is 2 and we're being signaled from SearchLiveTrades_Resume, we're in fallback search -->
        <!-- Note: $isLiveSearchContinuation already detected earlier (before skill multiplier) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$isLiveSearchContinuation">
          <!-- If MaxDistance is 2, this is a fallback search continuation -->
          <do_if value="$maxDistance == 2">
            <set_value name="$isFallbackSearch" exact="true"/>
            <set_value name="$fallbackSearchTriggered" exact="true"/>  <!-- Prevent triggering fallback again -->
          </do_if>
        </do_if>
        
        <!-- Save current global.$GT_SearchResult to local variables BEFORE cache search overwrites it -->
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
        <set_value name="$savedSearchResult" exact="null"/>
        <!-- Create a copy of the search result to preserve it -->
        <do_if value="true">
          <set_value name="$savedWaitingForBatch" exact="true"/>
          <do_if value="global.$GT_SearchResult.$WaitingForBatch?">
            <set_value name="$savedWaitingForBatch" exact="global.$GT_SearchResult.$WaitingForBatch"/>
          </do_if>
          <set_value name="$savedShip" exact="@global.$GT_SearchResult.$Ship"/>
          <!-- âœ… CRITICAL: Initialize to empty list first, then extract if global exists and is not null -->
          <!-- The ? operator checks existence, not null - so initialize to safe default first -->
          <set_value name="$savedTradeList" exact="[]"/>
          <set_value name="$savedTradeListTemp" exact="@global.$GT_SearchResult.$TradeList"/>
          <do_if value="$savedTradeListTemp?">
            <!-- Global value exists - check if it's actually a list (has .count property) -->
            <set_value name="$tempCount" exact="@$savedTradeListTemp.count"/>
            <do_if value="$tempCount?">
              <!-- Valid list with count - use it -->
              <set_value name="$savedTradeList" exact="$savedTradeListTemp"/>
            </do_if>
          </do_if>
          <!-- âœ… SAFETY: Ensure $savedTradeList is valid before accessing .count -->
          <set_value name="$savedTradeListCount" exact="0"/>
          <do_if value="$savedTradeList?">
            <set_value name="$savedTradeListCountTemp" exact="@$savedTradeList.count"/>
            <do_if value="$savedTradeListCountTemp?">
              <set_value name="$savedTradeListCount" exact="$savedTradeListCountTemp"/>
            </do_if>
          </do_if>
          <set_value name="$savedBestTrade" exact="@global.$GT_SearchResult.$BestTrade"/>
          <set_value name="$savedBestScore" exact="@global.$GT_SearchResult.$BestScore"/>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$savedShipId" exact="'null'"/>
            <do_if value="$savedShip?">
              <set_value name="$savedShipIdTemp" exact="@$savedShip.idcode"/>
              <do_if value="$savedShipIdTemp?">
                <set_value name="$savedShipId" exact="$savedShipIdTemp"/>
              </do_if>
            </do_if>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸ” Continuation check: waitingFlag=' + $savedWaitingForBatch + ', liveShip=' + $savedShipId + ', currentShip=' + $ship.idcode + ', tradeListCount=' + $savedTradeListCount" chance="100"/>
          </do_if>
          
          <!-- Check if live search just completed (WaitingForBatch = false, TradeList exists or is empty, Ship matches) -->
          <!-- âœ… FIX: Accept continuation even with 0 trades (all blacklisted) to prevent infinite loops -->
          <do_if value="not $savedWaitingForBatch and $savedShip == $ship">
            <!-- Live search just completed for this ship - use those results (even if 0 trades) -->
            <set_value name="$isLiveSearchContinuation" exact="true"/>
            <set_value name="$liveTradeList" exact="$savedTradeList"/>
            <set_value name="$liveBestTrade" exact="$savedBestTrade"/>
            <set_value name="$liveBestScore" exact="$savedBestScore"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âœ… Live search continuation detected - using live results (' + $liveTradeList.count + ' trades) instead of running cache search again'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- ===== PHASE 1: CHECK TRADE CACHE WITH AGE VALIDATION ===== -->
        <!-- Only run cache search if NOT continuing from live search AND NOT forcing live search -->
        <set_value name="$cacheChecked" exact="false"/>
        <set_value name="$cacheCount" exact="0"/>
        <set_value name="$cacheTradeList" exact="[]"/>
        <set_value name="$cacheBestTrade" exact="null"/>
        <set_value name="$cacheBestScore" exact="0"/>
        
        <!-- âœ… NEW: Check if ForceLiveSearch flag is set (AI rejected all cached trades) -->
        <set_value name="$forceLiveSearch" exact="@$params.$ForceLiveSearch"/>
        
        <do_if value="not $isLiveSearchContinuation and not $forceLiveSearch">
          <!-- Track search method for diagnostics -->
          <set_value name="$searchMethod" exact="'cache'"/>
          <set_value name="$cacheChecked" exact="true"/>
          <!-- âœ… PERFORMANCE OPTIMIZATION v5: Calculate total cache count from all home sectors -->
          <!-- global.$GT_TradeCache is now a table indexed by home sector -->
          <set_value name="$cacheCount" exact="0"/>
          <do_if value="global.$GT_TradeCache?">
            <do_all exact="global.$GT_TradeCache.keys.count" counter="$sectorIdx">
              <set_value name="$sectorCache" exact="global.$GT_TradeCache.{global.$GT_TradeCache.keys.{$sectorIdx}}"/>
              <do_if value="$sectorCache? and $sectorCache.count?">
                <set_value name="$cacheCount" exact="$cacheCount + $sectorCache.count"/>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- âœ… ENHANCED: Log cache check start (debug mode only) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ” Checking trade cache (cache size: ' + $cacheCount + ' entries)'" chance="100"/>
          </do_if>
          
          <signal_cue_instantly cue="SearchCachedTrades" param="table[
            $Ship = $ship,
            $MaxDistance = $maxDistance,
            $MinROI = $minROI,
            $MinAbsoluteProfit = $minAbsoluteProfit,
            $FactionPriority = $factionPriority,
            $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
            $SkillLevel = $skillLevel,
            $AllowIllegal = $params.$AllowIllegal
          ]"/>
          
          <!-- Extract cache results from global return variable -->
          <set_value name="$foundCachedTrade" exact="@global.$GT_SearchResult.$Found"/>
          <set_value name="$cacheBestTrade" exact="@global.$GT_SearchResult.$BestTrade"/>
          <set_value name="$cacheBestScore" exact="@global.$GT_SearchResult.$BestScore"/>
          <set_value name="$cacheBlacklistRejections" exact="@global.$GT_SearchResult.$BlacklistRejections"/>
          <set_value name="$cacheTradeList" exact="@global.$GT_SearchResult.$TradeList"/>
          
          <!-- âœ… ENHANCED: Log cache check results (debug mode only) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$cacheTradeCount" exact="0"/>
            <do_if value="$cacheTradeList?">
              <set_value name="$cacheTradeCount" exact="@$cacheTradeList.count"/>
            </do_if>
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ“‹ Cache check complete: Found=' + $foundCachedTrade + ', Trades=' + $cacheTradeCount + ', BestScore=' + $cacheBestScore" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Live search continuation OR ForceLiveSearch - skip cache, use live results -->
          <set_value name="$searchMethod" exact="'live'"/>
          <do_if value="$forceLiveSearch">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ ForceLiveSearch flag set - skipping cache, going straight to live search'" chance="100"/>
            </do_if>
            <!-- Clear ForceLiveSearch flag after use -->
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_AIParameters exists -->
            <do_if value="global.$GT_AIParameters.{$ship}?">
              <remove_value name="global.$GT_AIParameters.{$ship}.$ForceLiveSearch"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- âœ… CRITICAL FIX: Compare cache vs live results and use the best -->
        <!-- If we have both cache and live results, prefer live (they're fresher) -->
        <do_if value="$isLiveSearchContinuation">
          <!-- Using live search results -->
          <set_value name="$bestTrade" exact="$liveBestTrade"/>
          <set_value name="$bestScore" exact="$liveBestScore"/>
          <set_value name="$tradeList" exact="$liveTradeList"/>
          <set_value name="$foundCachedTrade" exact="false"/>
        </do_if>
        <do_else>
          <!-- Using cache results (or will check live search if needed) -->
          <set_value name="$bestTrade" exact="$cacheBestTrade"/>
          <set_value name="$bestScore" exact="$cacheBestScore"/>
          <set_value name="$tradeList" exact="$cacheTradeList"/>
        </do_else>
        
        <!-- âœ… FIX: Validate bestTrade IMMEDIATELY after setting from cache/live sources -->
        <!-- Use strict validation to catch invalid trades before execution validation -->
        <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$bestTradeValidFromSource">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        <do_if value="not $bestTradeValidFromSource">
          <!-- bestTrade from source is invalid - clear it so fallback can fix it -->
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš ï¸ bestTrade from source (cache/live) is INVALID - cleared for fallback fix'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Initialize rejection statistics (for both cached and live searches) -->
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedBlacklist" exact="0"/>
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$offersFound" exact="0"/>
        <set_value name="$stationsEvaluated" exact="0"/>
        <set_value name="$bestRejectedTrade" exact="null"/>
        
        <!-- âœ… CRITICAL: If using live search continuation, retrieve rejection stats from global (includes filtering stats) -->
        <do_if value="$isLiveSearchContinuation">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ” RETRIEVING STATS FROM CONTINUATION:' +
              '\n  TradesRejectedDocking exists: ' + (if global.$GT_SearchResult.$TradesRejectedDocking? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist exists: ' + (if global.$GT_SearchResult.$TradesRejectedBlacklist? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist value: ' + (if global.$GT_SearchResult.$TradesRejectedBlacklist? then global.$GT_SearchResult.$TradesRejectedBlacklist else 'null') +
              '\n  FilteredByBlacklist exists: ' + (if global.$GT_SearchResult.$FilteredByBlacklist? then 'yes' else 'no') +
              '\n  FilteredByBlacklist value: ' + (if global.$GT_SearchResult.$FilteredByBlacklist? then global.$GT_SearchResult.$FilteredByBlacklist else 'null') +
              '\n  FilteredByPathBlocked exists: ' + (if global.$GT_SearchResult.$FilteredByPathBlocked? then 'yes' else 'no') +
              '\n  FilteredByPathBlocked value: ' + (if global.$GT_SearchResult.$FilteredByPathBlocked? then global.$GT_SearchResult.$FilteredByPathBlocked else 'null') +
              '\n  TotalTradesEvaluated exists: ' + (if global.$GT_SearchResult.$TotalTradesEvaluated? then 'yes' else 'no') +
              '\n  TotalTradesEvaluated value: ' + (if global.$GT_SearchResult.$TotalTradesEvaluated? then global.$GT_SearchResult.$TotalTradesEvaluated else 'null')" 
              chance="100"/>
          </do_if>
          
          <do_if value="global.$GT_SearchResult.$TradesRejectedDocking?">
            <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TradesRejectedBlacklist?">
            <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.$TradesRejectedBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TradesRejectedProfit?">
            <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TradesRejectedDistance?">
            <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.$TradesRejectedDistance"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TradesRejectedAmount?">
            <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$StationsEvaluated?">
            <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.$StationsEvaluated"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$OffersFound?">
            <set_value name="$offersFound" exact="global.$GT_SearchResult.$OffersFound"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$BestRejectedTrade?">
            <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.$BestRejectedTrade"/>
          </do_if>
          
          <!-- âœ… CRITICAL: Store stats immediately when continuation detected (BEFORE trade execution) -->
          <!-- This ensures stats are available for logbook even if execution fails later -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: $tradesRejectedBlacklist already includes combined value from resume -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = use resume stats if available (more accurate) -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Utilities.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- âœ… FIX: Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- âœ… FIX: Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from live search continuation results -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- âœ… CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats?">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="($existingTotal? and $existingTotal gt 0) or ($existingDocking? and $existingDocking gt 0) or ($existingProfit? and $existingProfit gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <do_if value="$totalEvaluated gt 0 or not $hasExistingStats">
            <!-- âœ… SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Build new $LastRejectionStats: preserve existing entries, update/add per-ship entry -->
            <set_value name="$newLastRejectionStats" exact="table[]"/>
            <!-- Copy existing entries if valid -->
            <do_if value="$existingLastRejectionStats?">
              <set_value name="$existingStatsKeys" exact="@$existingLastRejectionStats.keys"/>
              <do_if value="$existingStatsKeys?">
                <set_value name="$existingStatsKeysCount" exact="@$existingStatsKeys.count"/>
                <do_if value="$existingStatsKeysCount? and $existingStatsKeysCount gt 0">
                  <do_all exact="$existingStatsKeysCount" counter="$k">
                    <set_value name="$key" exact="$existingStatsKeys.{$k}"/>
                    <do_if value="$key != $ship">
                      <set_value name="$newLastRejectionStats.{$key}" exact="@$existingLastRejectionStats.{$key}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>
            </do_if>
            <!-- Add/update per-ship entry -->
            <set_value name="$newLastRejectionStats.{$ship}" exact="$newShipStats"/>
            <!-- Build new $searchResultTable: preserve existing properties, set new $LastRejectionStats -->
            <set_value name="$newSearchResultTable" exact="table[$LastRejectionStats = $newLastRejectionStats]"/>
            <!-- Copy other existing properties -->
            <do_if value="$existingSearchResult?">
              <set_value name="$existingKeys" exact="@$existingSearchResult.keys"/>
              <do_if value="$existingKeys?">
                <set_value name="$existingKeysCount" exact="@$existingKeys.count"/>
                <do_if value="$existingKeysCount? and $existingKeysCount gt 0">
                  <do_all exact="$existingKeysCount" counter="$tk">
                    <set_value name="$tableKey" exact="$existingKeys.{$tk}"/>
                    <do_if value="$tableKey != 'LastRejectionStats'">
                      <set_value name="$newSearchResultTable.{$tableKey}" exact="@$existingSearchResult.{$tableKey}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>
            </do_if>
            <!-- Set atomically to global -->
            <set_value name="global.$GT_SearchResult" exact="$newSearchResultTable"/>
          </do_if>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ“ STORED STATS ON CONTINUATION (available for logbook if execution fails):' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalBlacklistFiltered: ' + $statsBlacklist +
              '\n  RejectedDocking: ' + $statsDocking +
              '\n  RejectedProfit: ' + $statsProfit +
              '\n  RejectedAmount: ' + $statsAmount" 
              chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Check cache diversity: Count unique wares in trade list -->
        <set_value name="$cacheWareCount" exact="0"/>
        <set_value name="$cacheWares" exact="table[]"/>
        <do_if value="$tradeList.count gt 0">
          <do_all exact="$tradeList.count" counter="$i">
            <set_value name="$trade" exact="$tradeList.{$i}"/>
            <set_value name="$ware" exact="@$trade.$BuyOffer.ware"/>
            <do_if value="$ware? and not $cacheWares.{$ware}?">
              <set_value name="$cacheWares.{$ware}" exact="true"/>
              <set_value name="$cacheWareCount" exact="$cacheWareCount + 1"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- ===== PHASE 2: LIVE TRADE SEARCH (only if no cached trades found) ===== -->
        <!-- Skip live search entirely if we're already using live search results from continuation -->
        <!-- âœ… REMOVED: Low diversity check - use cached trades even if diversity is low -->
        <!-- Trigger live search if: 
             1. NOT continuing from live search, AND
             2. No cached trades found, AND
             3. Previous live search did NOT return 0 trades (to prevent infinite loops when all trades are blacklisted) -->
        <set_value name="$shouldDoLiveSearch" exact="false"/>
        <set_value name="$previousLiveSearchReturnedZeroTrades" exact="false"/>
        <do_if value="$isLiveSearchContinuation and $liveTradeList.count == 0">
          <!-- Previous live search returned 0 trades -->
          <!-- âœ… CRITICAL FIX: Apply cooldown to prevent infinite loop when ship is stuck -->
          <!-- If ship is in blacklisted sector and all trades filtered, cooldown prevents immediate re-search -->
          <!-- âœ… ESCAPE EXCEPTION: Don't apply cooldown if ship needs to escape -->
          
          <!-- Check if ship is in blacklisted sector (needs escape) - using library function -->
          <run_actions ref="md.GT_Blacklist_Utilities.GT_CheckNeedsEscape" result="$needsEscape">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš ï¸ Previous live search returned 0 trades - ' + if $needsEscape then 'ESCAPE NEEDED, skipping cooldown' else 'applying cooldown to prevent loop (ship may be stuck in blacklisted sector)'" chance="100"/>
          </do_if>
          
          <!-- Clear continuation state -->
          <set_value name="$isLiveSearchContinuation" exact="false"/>
          <set_value name="$liveTradeList" exact="[]"/>
          <set_value name="$liveBestTrade" exact="null"/>
          <set_value name="$liveBestScore" exact="0"/>
          
          <!-- âœ… CRITICAL: Initialize tradeList to empty list to prevent null errors -->
          <set_value name="$tradeList" exact="[]"/>
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          
          <!-- Clear old search result state to prevent re-use -->
          <remove_value name="global.$GT_SearchResult.$WaitingForBatch"/>
          <remove_value name="global.$GT_SearchResult.$TradeList"/>
          <remove_value name="global.$GT_SearchResult.$BestTrade"/>
          <remove_value name="global.$GT_SearchResult.$BestScore"/>
          <remove_value name="global.$GT_SearchResult.$FilteredByBlacklist"/>
          <remove_value name="global.$GT_SearchResult.$FilteredByPathBlocked"/>
          <remove_value name="global.$GT_SearchResult.$TotalTradesEvaluated"/>
          
          <!-- âœ… CRITICAL: Apply cooldown for zero-trade live searches (prevents infinite loop) -->
          <!-- âœ… ESCAPE EXCEPTION: Only apply cooldown if ship doesn't need to escape -->
          <do_if value="not $needsEscape">
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <!-- Use same cooldown system as cache misses, but mark it as zero-trade cooldown -->
            <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
              $LastLiveSearch = player.age,
              $CooldownDuration = 60s
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') â¸ï¸ Applied 60s cooldown after zero-trade live search - ship may be stuck, will retry later'" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship needs to escape - clear any existing cooldown so it can search again immediately -->
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸš¨ ESCAPE NEEDED: Zero trades found but ship in blacklisted sector - clearing cooldown to allow immediate escape search'" chance="100"/>
            </do_if>
          </do_else>
        </do_if>
        
        <do_if value="not $isLiveSearchContinuation">
          <!-- âœ… REMOVED: Low diversity check - only trigger live search on cache miss -->
          <set_value name="$shouldDoLiveSearch" exact="not $foundCachedTrade"/>
        </do_if>
        <do_else>
          <!-- Using continuation results - don't trigger new live search -->
          <set_value name="$shouldDoLiveSearch" exact="false"/>
        </do_else>
        
        <do_if value="$shouldDoLiveSearch">
          <!-- âœ… COOLDOWN MECHANISM: Prevent cache miss â†’ live search loops -->
          <!-- If cache miss triggered live search recently, enforce cooldown before allowing another -->
          <!-- âœ… ESCAPE EXCEPTION: Bypass cooldown if ship is in blacklisted sector and needs to escape -->
          <set_value name="$canDoLiveSearch" exact="true"/>
          <set_value name="$cooldownRemaining" exact="0"/>
          
          <!-- âœ… ESCAPE LOGIC: Check if ship is in blacklisted sector (needs escape, bypass cooldown) -->
          <set_value name="$needsEscape" exact="false"/>
          <set_value name="$currentSector" exact="$ship.sector"/>
          <run_actions ref="md.GT_Blacklist_Utilities.GT_GetBlacklistGroup" result="$blacklistgroup">
            <param name="ship" value="$ship"/>
          </run_actions>
          <do_if value="$blacklistgroup? and $currentSector?">
            <run_actions ref="md.GT_Blacklist_Utilities.GT_IsSectorBlacklisted" result="$needsEscape">
              <param name="sector" value="$currentSector"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
          </do_if>
          
          <!-- Check cooldown for cache miss triggers (only if not escaping) -->
          <set_value name="$hasCooldown" exact="false"/>
          <do_if value="not $needsEscape">
            <!-- Only check cooldown if ship doesn't need to escape -->
            <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <set_value name="$hasCooldown" exact="true"/>
              <set_value name="$cooldownData" exact="global.$GT_CacheMissCooldowns.{$ship}"/>
              <set_value name="$timeSinceLastSearch" exact="player.age - $cooldownData.$LastLiveSearch"/>
              <set_value name="$cooldownRemaining" exact="$cooldownData.$CooldownDuration - $timeSinceLastSearch"/>
              <do_if value="$cooldownRemaining gt 0">
                <!-- Still in cooldown - skip live search -->
                <set_value name="$canDoLiveSearch" exact="false"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss â†’ live search cooldown active (' + ($cooldownRemaining / 1) + 's remaining of ' + ($cooldownData.$CooldownDuration / 1) + 's) - skipping live search to prevent loop'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship needs to escape - bypass cooldown and clear it -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸš¨ ESCAPE NEEDED: Ship in blacklisted sector - bypassing cooldown to search for escape route'" chance="100"/>
            </do_if>
            <!-- Clear cooldown so ship can search immediately for escape -->
            <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
          </do_else>
          
          <do_if value="$canDoLiveSearch">
            <!-- âœ… ENHANCED: Log when live search starts (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$cacheTradeCountForLog" exact="0"/>
              <do_if value="$cacheTradeList?">
                <set_value name="$cacheTradeCountForLog" exact="@$cacheTradeList.count"/>
              </do_if>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Starting LIVE market search (cache had ' + $cacheTradeCountForLog + ' trades, none suitable)'" chance="100"/>
            </do_if>
            
            <!-- Initialize cooldown tracking if not exists -->
            <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            
            <!-- âœ… FIX: Update cooldown for cache miss triggers -->
            <do_if value="not $hasCooldown">
              <!-- First live search trigger for this ship - start at 10 seconds -->
              <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                $LastLiveSearch = player.age,
                $CooldownDuration = 10s
              ]"/>
            </do_if>
            <do_else>
              <!-- Increase cooldown (double, max 60s) - cooldownData exists since hasCooldown is true -->
              <set_value name="$newCooldown" exact="$cooldownData.$CooldownDuration * 2"/>
              <do_if value="$newCooldown gt 60s">
                <set_value name="$newCooldown" exact="60s"/>
              </do_if>
              <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                $LastLiveSearch = player.age,
                $CooldownDuration = $newCooldown
              ]"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss â†’ live search cooldown increased to ' + ($newCooldown / 1) + 's'" chance="100"/>
              </do_if>
            </do_else>
            
            <!-- Perform live search -->
            <signal_cue_instantly cue="SearchLiveTrades" param="table[
            $Ship = $ship,
            $MaxDistance = $maxDistance,
            $MinROI = $minROI,
            $MinAbsoluteProfit = $minAbsoluteProfit,
            $FactionPriority = $factionPriority,
            $FactionPriorityText = $factionPriorityText,
            $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
            $SkillLevel = $skillLevel,
            $ThreatIntel = $gt_ThreatIntel,
            $FleetCoord = $gt_FleetCoord,
            $AdvancedAnalytics = $gt_AdvancedAnalytics
            ]"/>
            
            <!-- Track that live search was performed -->
            <set_value name="$searchMethod" exact="'live'"/>
          </do_if>
          <do_else>
            <!-- Cooldown active - skip live search -->
            <!-- CRITICAL: Don't clear results if we're using live search continuation (results already set above) -->
            <!-- CRITICAL: Preserve cache tradeList even if bestTrade was invalid (fallback can find valid trade from list) -->
            <do_if value="not $isLiveSearchContinuation">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Skipping live search due to cooldown - preserving cache results (bestTrade may be null, tradeList.count=' + (if $tradeList? and $tradeList.count? then $tradeList.count else 0) + ')'" chance="100"/>
              </do_if>
              <set_value name="$searchMethod" exact="'cache'"/>
              <!-- Only clear bestTrade if it was invalid (already cleared above), but preserve tradeList from cache -->
              <!-- bestTrade will be selected from tradeList by fallback logic if needed -->
              <do_if value="not $bestTrade? or not $bestTrade.$BuyOffer?">
                <set_value name="$bestTrade" exact="null"/>
                <set_value name="$bestScore" exact="0"/>
              </do_if>
              <!-- Preserve tradeList from cache - don't overwrite with empty list! -->
              <!-- Fallback logic will try to find valid trade from tradeList -->
            </do_if>
          </do_else>
          
          <!-- Check if batch processing is still in progress -->
          <!-- Skip this check if we're continuing from live search (results are already available) -->
          <do_if value="not $isLiveSearchContinuation">
            <set_value name="$waitingForBatch" exact="false"/>
            <do_if value="global.$GT_SearchResult.$WaitingForBatch?">
              <set_value name="$waitingForBatch" exact="global.$GT_SearchResult.$WaitingForBatch"/>
            </do_if>
            
            <!-- If batch processing is in progress, exit early - SearchLiveTrades_Resume will signal back when complete -->
            <do_if value="$waitingForBatch">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Live search batch processing in progress - waiting for completion'" chance="100"/>
              </do_if>
              <!-- Exit - SearchLiveTrades_Resume will signal this cue again when results are ready -->
              <cancel_cue cue="this"/>
            </do_if>
          </do_if>
          
          <!-- Extract live search results from global return variable (batch processing completed) -->
          <!-- Note: If $isLiveSearchContinuation is true, live results were already extracted above -->
          <do_if value="not $isLiveSearchContinuation">
            <set_value name="$bestTrade" exact="@global.$GT_SearchResult.$BestTrade"/>
            <set_value name="$bestScore" exact="@global.$GT_SearchResult.$BestScore"/>
            
            <!-- âœ… FIX: Validate bestTrade IMMEDIATELY after extracting from global -->
            <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$bestTradeValidFromGlobal">
              <param name="trade" value="$bestTrade"/>
              <param name="minScore" value="0"/>
            </run_actions>
            <do_if value="not $bestTradeValidFromGlobal">
              <!-- bestTrade from global is invalid - clear it so fallback can fix it -->
              <set_value name="$bestTrade" exact="null"/>
              <set_value name="$bestScore" exact="0"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš ï¸ bestTrade from global.$GT_SearchResult is INVALID - cleared for fallback fix'" chance="100"/>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_SearchResult.$StationsEvaluated?">
              <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.$StationsEvaluated"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$OffersFound?">
              <set_value name="$offersFound" exact="global.$GT_SearchResult.$OffersFound"/>
            </do_if>
            <!-- âœ… CRITICAL: Initialize to empty list first, then extract from global if it exists -->
            <set_value name="$tradeList" exact="[]"/>
            <do_if value="global.$GT_SearchResult.$TradeList?">
              <set_value name="$tradeList" exact="global.$GT_SearchResult.$TradeList"/>
            </do_if>
            <!-- Update rejection statistics from live search (if available) -->
            <do_if value="global.$GT_SearchResult.$TradesRejectedDocking?">
              <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.$TradesRejectedDocking"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$TradesRejectedBlacklist?">
              <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.$TradesRejectedBlacklist"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$TradesRejectedProfit?">
              <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.$TradesRejectedProfit"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$TradesRejectedDistance?">
              <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.$TradesRejectedDistance"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$TradesRejectedAmount?">
              <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.$TradesRejectedAmount"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$BestRejectedTrade?">
              <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.$BestRejectedTrade"/>
            </do_if>
            
            <!-- Failed sector filtering now happens during best trade tracking (inside evaluation loop) -->
            <!-- This ensures: 1) All trades are cached for other ships, 2) Best selection excludes failed sectors -->
          </do_if>  <!-- End of extracting live results if not continuation -->
        </do_if>  <!-- End of live trade search -->
        
        <!-- âœ… SORT TRADE LIST BY SCORE (highest first) before sending to AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <run_actions ref="md.GT_Trade_Utilities.GT_SortTradesByScore" result="$tradeList">
          <param name="tradeList" value="$tradeList"/>
        </run_actions>
        
        <!-- âœ… CRITICAL FIX: If tradeList exists but bestTrade is null, select best from list -->
        <!-- This can happen during continuation if BestTrade wasn't stored in global -->
        <!-- âœ… FIX: Use strict validation (library function) instead of weak Score-only check -->
        <set_value name="$bestTradeIsValid" exact="false"/>
        <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$bestTradeIsValid">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        
        <do_if value="not $bestTradeIsValid">
          <!-- âœ… FIX: Use library function for consistent validation -->
          <do_if value="$tradeList? and $tradeList.count? and $tradeList.count gt 0">
            <do_all exact="$tradeList.count" counter="$i">
              <set_value name="$firstTrade" exact="@$tradeList.{$i}"/>
              <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$firstTradeValid">
                <param name="trade" value="$firstTrade"/>
                <param name="minScore" value="0"/>
              </run_actions>
              <do_if value="$firstTradeValid">
                <set_value name="$testScore" exact="@$firstTrade.$Score"/>
                <set_value name="$bestTrade" exact="$firstTrade"/>
                <set_value name="$bestScore" exact="$testScore"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš ï¸ bestTrade was null but tradeList has ' + $tradeList.count + ' trades - selected valid trade[' + $i + '] as bestTrade'" chance="100"/>
                </do_if>
                <break/>
              </do_if>
            </do_all>
          </do_if>
        </do_if>
        
        <!-- Execute best trade if found -->
        <!-- DEBUG: Log bestTrade status for continuation debugging -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$bestTradeExists" exact="$bestTrade?"/>
          <set_value name="$tradeListCount" exact="0"/>
          <do_if value="$tradeList?">
            <set_value name="$tradeListCount" exact="$tradeList.count"/>
          </do_if>
          <set_value name="$bestTradeCheck" exact="'null'"/>
          <do_if value="$bestTrade?">
            <set_value name="$bestTradeCheck" exact="'exists'"/>
            <do_if value="$bestTrade.$BuyOffer?">
              <set_value name="$bestTradeCheck" exact="'valid'"/>
            </do_if>
          </do_if>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Trade execution check: bestTrade=' + $bestTradeCheck + ', tradeList.count=' + $tradeListCount + ', isContinuation=' + $isLiveSearchContinuation" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- âœ… DEBUG: Validate bestTrade before execution -->
        <!-- âœ… FIX: More robust validation - check that properties actually exist and are not null -->
        <set_value name="$bestTradeIsValidForExecution" exact="false"/>
        <do_if value="$bestTrade?">
          <set_value name="$testBuyOffer" exact="@$bestTrade.$BuyOffer"/>
          <set_value name="$testSellOffer" exact="@$bestTrade.$SellOffer"/>
          <set_value name="$testScore" exact="@$bestTrade.$Score"/>
          <!-- âœ… CRITICAL FIX: Check if BuyOffer/SellOffer exist AND are not null, AND Score exists AND is > 0 -->
          <!-- In MD, null? returns true (variable exists), so we need to check Score > 0 to ensure it's a real trade -->
          <do_if value="$testBuyOffer? and $testSellOffer? and $testScore? and $testScore gt 0">
            <!-- Double-check: Try accessing a property from BuyOffer to ensure it's not null -->
            <set_value name="$testWare" exact="@$testBuyOffer.ware"/>
            <do_if value="$testWare?">
              <set_value name="$bestTradeIsValidForExecution" exact="true"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <do_if value="$bestTradeIsValidForExecution">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âœ… bestTrade is VALID - proceeding with execution'" chance="100"/>
          </do_if>
          <do_else>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âŒ bestTrade is INVALID (null or missing properties) - cannot execute'" chance="100"/>
            <!-- âœ… FIX: If bestTrade is invalid but tradeList has trades, select first valid trade from list -->
            <do_if value="$tradeList? and $tradeList.count? and $tradeList.count gt 0">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš ï¸ Attempting to select valid trade from tradeList (' + $tradeList.count + ' trades available)'" chance="100"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$candidateTrade" exact="$tradeList.{$i}"/>
                <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$candidateValid">
                  <param name="trade" value="$candidateTrade"/>
                  <param name="minScore" value="0"/>
                </run_actions>
                <do_if value="$candidateValid">
                  <set_value name="$candidateScore" exact="@$candidateTrade.$Score"/>
                  <set_value name="$bestTrade" exact="$candidateTrade"/>
                  <set_value name="$bestScore" exact="$candidateScore"/>
                  <set_value name="$bestTradeIsValidForExecution" exact="true"/>
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âœ… Selected valid trade from tradeList[' + $i + '] (Score: ' + $candidateScore + ')'" chance="100"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            <!-- âœ… FIX: If still invalid after all fallbacks, check for fallback search before signaling no trade found -->
            <do_if value="not $bestTradeIsValidForExecution">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âŒ No valid trades found in tradeList (' + (if $tradeList? and $tradeList.count? then $tradeList.count else 0) + ' entries) - all trades invalid'" chance="100"/>
              
              <!-- âœ… FALLBACK SEARCH: Check if we should trigger fallback search before signaling no trade found -->
              <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
                <!-- âœ… FALLBACK COOLDOWN: Check if fallback was already attempted in this search cycle -->
                <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_FallbackAttempted exists -->
                <set_value name="$fallbackAlreadyAttempted" exact="false"/>
                <do_if value="global.$GT_FallbackAttempted.{$ship}?">
                  <set_value name="$fallbackAlreadyAttempted" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ') â¸ï¸ Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
                  </do_if>
                </do_if>
                
                <!-- Cache search failed, live search failed - check if ship is isolated -->
                <set_value name="$shipIsIsolated" exact="false"/>
                <run_actions ref="md.GT_Blacklist_Utilities.GT_CheckAndHandleIsolation" result="$isolationResult">
                  <param name="ship" value="$ship"/>
                  <param name="state" value="table[]"/>
                </run_actions>
                <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
                
                <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted -->
                <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted">
                  <!-- Write logbook message BEFORE triggering fallback search -->
                  <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
                  <do_if value="not $currentSectorName?">
                    <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
                  </do_if>
                  
                  <!-- Construct logbook message using TextDB syntax -->
                  <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $maxDistance, 2]"/>
                  
                  <!-- Write logbook entry using centralized library -->
                  <run_actions ref="md.GT_Logbook_Utilities.WriteLogbookMessage">
                    <param name="Message" value="$logbookMessage"/>
                    <param name="Category" value="'alerts'"/>
                    <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                    <param name="Object" value="$ship"/>
                    <param name="Interaction" value="'showonmap'"/>
                    <param name="CheckGlobalSettings" value="true"/>
                  </run_actions>
                  
                  <!-- Mark that fallback search was triggered -->
                  <set_value name="$fallbackSearchTriggered" exact="true"/>
                  
                  <!-- âœ… RACE CONDITION FIX: Ensure table exists before accessing (handles race condition) -->
                  <do_if value="not global.$GT_FallbackAttempted?">
                    <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
                  </do_if>
                  <!-- âœ… FALLBACK COOLDOWN: Mark fallback as attempted globally (persists across cue instances) -->
                  <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
                  
                  <!-- Trigger fallback search -->
                  <!-- MaxDistance forced to 2 for fallback search (search space) -->
                  <!-- OriginalMaxDistance used for filtering stations from home sector -->
                  <set_value name="$fallbackParams" exact="table[
                    $Ship = $ship,
                    $MaxDistance = 2,
                    $OriginalMaxDistance = $maxDistance,
                    $MinROI = $minROI,
                    $MinAbsoluteProfit = $minAbsoluteProfit,
                    $FactionPriority = $factionPriority,
                    $FactionPriorityText = $factionPriorityText,
                    $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                    $SkillLevel = $skillLevel,
                    $ThreatIntel = $gt_ThreatIntel,
                    $FleetCoord = $gt_FleetCoord,
                    $AdvancedAnalytics = $gt_AdvancedAnalytics
                  ]"/>
                  <signal_cue_instantly cue="SearchFallbackTrades" param="$fallbackParams"/>
                  
                  <!-- Exit - SearchFallbackTrades will signal SearchTradeRoutes again when complete -->
                  <cancel_cue cue="this"/>
                </do_if>
                <do_else>
                  <!-- Ship is isolated - signal no trade found (normal behavior for isolated ships) -->
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ') âš ï¸ Ship is isolated (no reachable sectors) - signaling no trade found'" chance="100"/>
                  </do_if>
                  <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
                </do_else>
              </do_if>
              <do_else>
                <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Search complete - signaling no trade found (fallback already triggered or cache succeeded)'" chance="100"/>
                </do_if>
                <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
              </do_else>
            </do_if>
          </do_else>
        </do_if>
        
        <!-- Check if batch processing is still in progress (for both trade found AND no trade found paths) -->
        <set_value name="$waitingForBatch" exact="false"/>
        <do_if value="global.$GT_SearchResult.$WaitingForBatch?">
          <set_value name="$waitingForBatch" exact="global.$GT_SearchResult.$WaitingForBatch"/>
        </do_if>
        
        <do_if value="$bestTradeIsValidForExecution">
          <!-- âœ… DEBUG: Log that we're entering the bestTrade execution block -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âœ… ENTERING bestTrade execution block'" chance="100"/>
            <!-- âœ… FALLBACK SEARCH: Log if this trade came from fallback search -->
            <do_if value="$isFallbackSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Fallback search complete: Found ' + (if $tradeList? and $tradeList.count? then $tradeList.count else 0) + ' trades (MaxDistance=2)'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Trade execution with full details -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$wareName" exact="@$bestTrade.$BuyOffer.ware.name"/>
            <set_value name="$buyStationName" exact="@$bestTrade.$BuyOffer.owner.knownname"/>
            <set_value name="$sellStationName" exact="@$bestTrade.$SellOffer.owner.knownname"/>
            <set_value name="$amount" exact="@$bestTrade.$Amount"/>
            <set_value name="$buyPrice" exact="@$bestTrade.$BuyPrice"/>
            <set_value name="$sellPrice" exact="@$bestTrade.$SellPrice"/>
            <set_value name="$distance" exact="@$bestTrade.$Distance"/>
            <set_value name="$profit" exact="@$bestTrade.$Profit"/>
            <set_value name="$roi" exact="@$bestTrade.$ROI"/>
            <set_value name="$score" exact="@$bestTrade.$Score"/>
            <set_value name="$risk" exact="@$bestTrade.$Risk"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸ“Š BEST TRADE SELECTED:' + '\n  ðŸ“¦ Ware: ' + $wareName + ' (x' + $amount + ')' + '\n  ðŸ“ BUY from: ' + $buyStationName + ' @ ' + ($buyPrice / 100) + ' Cr' + '\n  ðŸ“ SELL to: ' + $sellStationName + ' @ ' + ($sellPrice / 100) + ' Cr' + '\n  ðŸš€ Distance: ' + $distance + ' jumps' + '\n  ðŸ’° Profit: ' + ($profit / 100) + ' Cr' + '\n  ðŸ“ˆ ROI: ' + $roi + '%' + '\n  ðŸ“Š Score: ' + $score + '\n  âš  Risk: ' + $risk" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- âœ… OPTIMIZED: Reserve trade route for fleet coordination (inline conflict resolution done during search) -->
          <do_if value="global.$GT_GlobalSettings.$Fleet.$EnableFleetCoordination">
            <!-- âœ… FIX: Initialize global.$GT_ActiveTradeReservations if it doesn't exist -->
            <do_if value="not global.$GT_ActiveTradeReservations?">
              <set_value name="global.$GT_ActiveTradeReservations" exact="table[]"/>
            </do_if>
            
            <!-- âœ… FIX: Use safe operators to access bestTrade properties -->
            <set_value name="$fleetBuyStation" exact="@$bestTrade.$BuyOffer.owner"/>
            <set_value name="$fleetSellStation" exact="@$bestTrade.$SellOffer.owner"/>
            <set_value name="$fleetWare" exact="@$bestTrade.$BuyOffer.ware"/>
            <do_if value="$fleetBuyStation? and $fleetSellStation? and $fleetWare?">
              <set_value name="global.$GT_ActiveTradeReservations.{$ship}" exact="table[
                $BuyStation = $fleetBuyStation,
                $SellStation = $fleetSellStation,
                $Ware = $fleetWare,
                $Timestamp = player.age
              ]"/>
            </do_if>
          </do_if>
          
          <!-- Execute trade -->
          <do_if value="true">
            <!-- DEBUG: Log exact trade list being sent to trading AI -->
            <!-- COMMENTED OUT: Reduces log spam - uncomment if needed for debugging -->
            <!-- <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$logTradeList" exact="'[GT-Search] ðŸ“¤ SENDING TRADE LIST TO AI: ' + $ship.idcode + ' (' + $tradeList.count + ' trades)'"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$listTrade" exact="$tradeList.{$i}"/>
                <set_value name="$logTradeList" exact="$logTradeList + 
                  '\n  [' + $i + '] ' + @$listTrade.$BuyOffer.ware.name + 
                  ' | Buy: ' + @$listTrade.$BuyStation.knownname + ' @ ' + (@$listTrade.$BuyPrice / 100) + ' Cr' +
                  ' | Sell: ' + @$listTrade.$SellStation.knownname + ' @ ' + (@$listTrade.$SellPrice / 100) + ' Cr' +
                  ' | Score: ' + $listTrade.$Score + ' | Profit: ' + (@$listTrade.$Profit / 100) + ' Cr | ROI: ' + @$listTrade.$ROI + '% | Dist: ' + $listTrade.$Distance + ' jumps'"/>
              </do_all>
              <debug_text text="$logTradeList" chance="100"/>
            </do_if> -->
            
            <!-- Signal execution module (which will signal AI after storing trade LIST) -->
            <!-- âœ… NEW: Pass searchMethod so AI knows if trades came from cache or live search -->
            <signal_cue_instantly cue="md.GT_Trading_Execution.ExecuteTrade" param="table[
              $Ship = $ship,
              $Trade = $bestTrade,
              $TradeList = $tradeList,
              $SearchMethod = $searchMethod
            ]"/>
            
            <!-- GT_Trade_Found signal now sent FROM ExecuteTrade cue after storing pending trade -->
          </do_if>
        </do_if>
        
        <do_else>
          <!-- No valid trades found -->
          
          <!-- DEBUG: No trades found (only if not waiting for batch) -->
          <do_if value="not $waitingForBatch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedDistance + $tradesRejectedAmount"/>
            <!-- Get valid entries count from cache search (if available) -->
            <set_value name="$validEntries" exact="0"/>
            <set_value name="$diverseListCount" exact="0"/>
            <do_if value="global.$GT_SearchResult.$ValidEntries?">
              <set_value name="$validEntries" exact="global.$GT_SearchResult.$ValidEntries"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.$DiverseListCount?">
              <set_value name="$diverseListCount" exact="global.$GT_SearchResult.$DiverseListCount"/>
            </do_if>
            
            <set_value name="$diagnosticInfo" exact="'\n\nðŸ” SEARCH CONTEXT:' +
              '\n  Search method: ' + $searchMethod +
              (if $cacheChecked then '\n  Cache checked: Yes (' + $cacheCount + ' entries)' else '\n  Cache checked: No') +
              (if $searchMethod == 'live' and $stationsEvaluated? then '\n  Stations evaluated: ' + $stationsEvaluated else '') +
              (if $searchMethod == 'live' and $offersFound? then '\n  Offers found: ' + $offersFound else '') +
              (if $searchMethod == 'cache' and $validEntries gt 0 then '\n  Valid cached trades found: ' + $validEntries + ' (diverse list: ' + $diverseListCount + ')' else '') +
              (if $totalRejected == 0 and $validEntries == 0 and ($offersFound == 0 or not $offersFound?) then '\n  âš ï¸ No trades were evaluated (cache empty or no offers found)' else '') +
              (if $validEntries gt 0 and $diverseListCount == 0 then '\n  âš ï¸ All valid trades filtered out during diverse list building (need unique station pairs)' else '')"/>
            
            <!-- Build best rejected trade info safely (extract properties first, then check) -->
            <set_value name="$bestRejectedInfo" exact="''"/>
            <do_if value="$bestRejectedTrade?">
              <!-- Extract properties safely -->
              <set_value name="$rejectedWare" exact="@$bestRejectedTrade.$ware"/>
              <set_value name="$rejectedBuyFrom" exact="@$bestRejectedTrade.$buyFrom"/>
              <set_value name="$rejectedSellTo" exact="@$bestRejectedTrade.$sellTo"/>
              <set_value name="$rejectedBuyPrice" exact="@$bestRejectedTrade.$buyPrice"/>
              <set_value name="$rejectedSellPrice" exact="@$bestRejectedTrade.$sellPrice"/>
              <set_value name="$rejectedProfit" exact="@$bestRejectedTrade.$profit"/>
              <set_value name="$rejectedROI" exact="@$bestRejectedTrade.$roi"/>
              
              <!-- Build info string with safe checks (use @ operator for property access) -->
              <set_value name="$bestRejectedInfo" exact="'\n\nðŸ† BEST REJECTED TRADE (still unprofitable):' +
                '\n  Ware: ' + (if $rejectedWare? then @$rejectedWare.name else 'Unknown') +
                '\n  Buy from: ' + (if $rejectedBuyFrom? then @$rejectedBuyFrom.knownname else 'Unknown') + ' @ ' + (if $rejectedBuyPrice? then ($rejectedBuyPrice / 100) else '0') + ' Cr/unit' +
                '\n  Sell to: ' + (if $rejectedSellTo? then @$rejectedSellTo.knownname else 'Unknown') + ' @ ' + (if $rejectedSellPrice? then ($rejectedSellPrice / 100) else '0') + ' Cr/unit' +
                '\n  Best profit found: ' + (if $rejectedProfit? then ($rejectedProfit / 100) else '0') + ' Cr (needed: ' + ($minAbsoluteProfit / 100) + ' Cr)' +
                '\n  Best ROI found: ' + (if $rejectedROI? then $rejectedROI else '0') + '% (needed: ' + $minROI + '%)'"/>
            </do_if>
            
            <!-- âœ… ENHANCED: Show detailed analysis when no trades found (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') === NO TRADES FOUND ANALYSIS ===' + 
                '\nShip: ' + $ship.knownname + 
                '\nSector: ' + $ship.sector.knownname + 
                '\nSearch Method: ' + $searchMethod +
                '\nSearch params: Dist=' + $maxDistance + ', MinROI=' + $minROI + '%, MinAbsoluteProfit=' + ($minAbsoluteProfit / 100) + ' Cr' +
                $diagnosticInfo +
                '\n\nðŸ“Š REJECTION STATISTICS:' +
                '\n  â›” Docking not allowed: ' + $tradesRejectedDocking +
                '\n  ðŸ’° Insufficient profit: ' + $tradesRejectedProfit +
                '\n  ðŸ“ Distance too far: ' + $tradesRejectedDistance +
                '\n  ðŸ“¦ Amount zero/negative: ' + $tradesRejectedAmount +
                '\n  ðŸš« Blacklisted/Path blocked: ' + $totalBlacklistFiltered +
                '\n  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”' +
                '\n  TOTAL REJECTED: ' + $totalRejected +
                '\n  TOTAL EVALUATED: ' + $totalEvaluated +
                '\n  OFFERS FOUND: ' + $offersFound +
                $bestRejectedInfo" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Commented out to reduce log spam -->
          <!-- <debug_text text="'[GalaxyTrader MK3] No profitable trades found for ' + $ship.knownname" chance="100"/> -->
          
          <!-- Store rejection statistics for AI script to use after 60s wait -->
          <!-- Logbook entry will be written by AI script only after max wait time (60s) -->
          <!-- Note: Get filtered counts from live search resume if available (tracks blacklist/path filtering) -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: If using continuation, $tradesRejectedBlacklist already includes combined value -->
          <!-- Otherwise, combine evaluation-phase rejections + pre-filtering rejections -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <do_if value="not $isLiveSearchContinuation">
            <!-- Not a continuation: combine evaluation-phase + pre-filtering rejections -->
            <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist + $filteredByBlacklistFromResume + $filteredByPathBlockedFromResume"/>
          </do_if>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = evaluation-phase rejections + valid trades found + pre-filtered trades -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <!-- If we have resume stats, use those (more accurate) -->
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <!-- Fallback: Use rejection count if we have rejections, or offers found count -->
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          <do_else>
            <!-- No stats available - default to 0 (no trades found at all) -->
            <set_value name="$totalEvaluated" exact="0"/>
          </do_else>
          
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          
          <!-- âœ… DEBUG: Log rejection stats before storing (only if debug logging enabled) -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ“ STORING REJECTION STATS FOR LOGBOOK:' +
              '\n  SectorName: ' + (if $currentSectorName? then $currentSectorName else 'null') +
              '\n  MaxDistance: ' + $maxDistance +
              '\n  MinAbsoluteProfit: ' + ($minAbsoluteProfit/100) + ' Cr' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalRejected: ' + $totalRejected +
              '\n  RejectedDocking: ' + $tradesRejectedDocking +
              '\n  RejectedProfit: ' + $tradesRejectedProfit +
              '\n  RejectedAmount: ' + $tradesRejectedAmount +
              '\n  RejectedBlacklist (eval phase): ' + $tradesRejectedBlacklist +
              '\n  FilteredBlacklist (pre-filter): ' + $filteredByBlacklistFromResume +
              '\n  FilteredPathBlocked (pre-filter): ' + $filteredByPathBlockedFromResume +
              '\n  TotalBlacklistFiltered: ' + $totalBlacklistFiltered +
              '\n  OffersFound: ' + $offersFound +
              '\n  TotalTradesFromResume: ' + $totalTradesFromResume" 
              chance="100"/>
          </do_if>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Utilities.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- âœ… FIX: Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- âœ… FIX: Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from batch processor results or live search continuation -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 (stats might be in global from FilterTradeList_Resume) -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- âœ… CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats?">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="($existingTotal? and $existingTotal gt 0) or ($existingDocking? and $existingDocking gt 0) or ($existingProfit? and $existingProfit gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- âœ… DEBUG: Log storage decision (only if debug logging enabled) -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ“ LastRejectionStats STORAGE DECISION:' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  ExistingStats exists: ' + (if $existingStats? then 'yes' else 'no') +
              '\n  ExistingTotal: ' + (if $existingStats? and $existingStats.$Total? then $existingStats.$Total else 'null') +
              '\n  ExistingDocking: ' + (if $existingStats? and $existingStats.$Docking? then $existingStats.$Docking else 'null') +
              '\n  ExistingProfit: ' + (if $existingStats? and $existingStats.$Profit? then $existingStats.$Profit else 'null') +
              '\n  HasExistingStats: ' + $hasExistingStats +
              '\n  Will store: ' + (if ($totalEvaluated gt 0 or not $hasExistingStats) then 'yes' else 'no')" 
              chance="100"/>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <do_if value="$totalEvaluated gt 0 or not $hasExistingStats">
            <!-- âœ… SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Build new $LastRejectionStats: preserve existing entries, update/add per-ship entry -->
            <set_value name="$newLastRejectionStats" exact="table[]"/>
            <!-- Copy existing entries if valid -->
            <do_if value="$existingLastRejectionStats?">
              <set_value name="$existingStatsKeys" exact="@$existingLastRejectionStats.keys"/>
              <do_if value="$existingStatsKeys?">
                <set_value name="$existingStatsKeysCount" exact="@$existingStatsKeys.count"/>
                <do_if value="$existingStatsKeysCount? and $existingStatsKeysCount gt 0">
                  <do_all exact="$existingStatsKeysCount" counter="$k">
                    <set_value name="$key" exact="$existingStatsKeys.{$k}"/>
                    <do_if value="$key != $ship">
                      <set_value name="$newLastRejectionStats.{$key}" exact="@$existingLastRejectionStats.{$key}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>
            </do_if>
            <!-- Add/update per-ship entry -->
            <set_value name="$newLastRejectionStats.{$ship}" exact="$newShipStats"/>
            <!-- Build new $searchResultTable: preserve existing properties, set new $LastRejectionStats -->
            <set_value name="$newSearchResultTable" exact="table[$LastRejectionStats = $newLastRejectionStats]"/>
            <!-- Copy other existing properties -->
            <do_if value="$existingSearchResult?">
              <set_value name="$existingKeys" exact="@$existingSearchResult.keys"/>
              <do_if value="$existingKeys?">
                <set_value name="$existingKeysCount" exact="@$existingKeys.count"/>
                <do_if value="$existingKeysCount? and $existingKeysCount gt 0">
                  <do_all exact="$existingKeysCount" counter="$tk">
                    <set_value name="$tableKey" exact="$existingKeys.{$tk}"/>
                    <do_if value="$tableKey != 'LastRejectionStats'">
                      <set_value name="$newSearchResultTable.{$tableKey}" exact="@$existingSearchResult.{$tableKey}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>
            </do_if>
            <!-- Set atomically to global -->
            <set_value name="global.$GT_SearchResult" exact="$newSearchResultTable"/>
            
            <!-- âœ… DEBUG: Verify storage succeeded (only if debug logging enabled) -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$verifyStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
              <set_value name="$verifyTotal" exact="@$verifyStats.$Total"/>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… STORED LastRejectionStats - Verification:' +
                '\n  Stored Total: ' + (if $verifyTotal? then $verifyTotal else 'null') +
                '\n  Stored Docking: ' + (if $verifyStats.$Docking? then $verifyStats.$Docking else 'null') +
                '\n  Stored Profit: ' + (if $verifyStats.$Profit? then $verifyStats.$Profit else 'null') +
                '\n  Stored Amount: ' + (if $verifyStats.$Amount? then $verifyStats.$Amount else 'null') +
                '\n  Stored Blacklist: ' + (if $verifyStats.$Blacklist? then $verifyStats.$Blacklist else 'null')" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- âœ… FALLBACK SEARCH: Check if we should trigger fallback search before signaling no trade found -->
          <!-- This is the "no trades found" path after live search continuation completes -->
          <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
            <!-- âœ… FALLBACK COOLDOWN: Check if fallback was already attempted in this search cycle -->
            <set_value name="$fallbackAlreadyAttempted" exact="false"/>
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_FallbackAttempted exists -->
            <do_if value="global.$GT_FallbackAttempted.{$ship}?">
              <set_value name="$fallbackAlreadyAttempted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') â¸ï¸ Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Cache search failed, live search failed - check if ship is isolated -->
            <set_value name="$shipIsIsolated" exact="false"/>
            <run_actions ref="md.GT_Blacklist_Utilities.GT_CheckAndHandleIsolation" result="$isolationResult">
              <param name="ship" value="$ship"/>
              <param name="state" value="table[]"/>
            </run_actions>
            <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
            
            <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted -->
            <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted">
              <!-- Write logbook message BEFORE triggering fallback search -->
              <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
              <do_if value="not $currentSectorName?">
                <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
              </do_if>
              
              <!-- Construct logbook message using TextDB syntax -->
              <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $maxDistance, 2]"/>
              
              <!-- Write logbook entry using centralized library -->
              <run_actions ref="md.GT_Logbook_Utilities.WriteLogbookMessage">
                <param name="Message" value="$logbookMessage"/>
                <param name="Category" value="'alerts'"/>
                <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                <param name="Object" value="$ship"/>
                <param name="Interaction" value="'showonmap'"/>
                <param name="CheckGlobalSettings" value="true"/>
              </run_actions>
              
              <!-- Mark that fallback search was triggered -->
              <set_value name="$fallbackSearchTriggered" exact="true"/>
              
              <!-- âœ… FALLBACK COOLDOWN: Mark fallback as attempted globally (persists across cue instances) -->
              <do_if value="not global.$GT_FallbackAttempted?">
                <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
              </do_if>
              <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
              
              <!-- Trigger fallback search -->
              <!-- MaxDistance forced to 2 for fallback search (search space) -->
              <!-- OriginalMaxDistance used for filtering stations from home sector -->
              <set_value name="$fallbackParams" exact="table[
                $Ship = $ship,
                $MaxDistance = 2,
                $OriginalMaxDistance = $maxDistance,
                $MinROI = $minROI,
                $MinAbsoluteProfit = $minAbsoluteProfit,
                $FactionPriority = $factionPriority,
                $FactionPriorityText = $factionPriorityText,
                $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                $SkillLevel = $skillLevel,
                $ThreatIntel = $gt_ThreatIntel,
                $FleetCoord = $gt_FleetCoord,
                $AdvancedAnalytics = $gt_AdvancedAnalytics
              ]"/>
              <signal_cue_instantly cue="SearchFallbackTrades" param="$fallbackParams"/>
              
              <!-- Exit - SearchFallbackTrades will signal SearchTradeRoutes again when complete -->
              <cancel_cue cue="this"/>
            </do_if>
            <do_else>
              <!-- Ship is isolated - signal no trade found (normal behavior for isolated ships) -->
              <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
            <!-- âœ… FALLBACK SEARCH: Log if fallback search completed with no trades -->
            <do_if value="$isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') âŒ Fallback search complete: No trades found (MaxDistance=2)'" chance="100"/>
            </do_if>
            <!-- âœ… ENHANCED: Log before signaling no trade found (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Search complete - signaling GT_No_Trade_Found (TotalRejected=' + $totalRejected + ', TotalEvaluated=' + $totalEvaluated + ', OffersFound=' + $offersFound + ')'" chance="100"/>
            </do_if>
            <!-- Signal back to AI script: No Trade Found -->
            <!-- CRITICAL: Always send 'blacklist' param to prevent idle timeout escalation -->
            <!-- Reason: With blacklist-aware pre-filtering, we can't distinguish "filtered" from "genuinely empty" -->
            <!-- Better UX: Don't escalate to 60s timeout when ship might just need blacklist adjustment -->
            <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
          </do_else>
        </do_else>
        
        <!-- CRITICAL: Release search lock ONLY if NOT waiting for batch processing -->
        <!-- If waiting for batch, SearchLiveTrades_Resume will signal SearchTradeRoutes again -->
        <!-- and we'll release the lock after processing live search results -->
        <!-- If we're continuing from live search, this IS the final completion, so release the lock -->
        <do_if value="not $waitingForBatch or $isLiveSearchContinuation">
          <do_if value="global.$GT_SearchLocks.{$ship}?">
            <remove_value name="global.$GT_SearchLocks.{$ship}"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$lockReason" exact="if $isLiveSearchContinuation then 'live search continuation complete' else 'search complete'"/>
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Search lock released (' + $lockReason + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        <do_else>
          <!-- Batch processing in progress - keep lock until live search completes -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Search lock retained (waiting for live search batch to complete)'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- CRITICAL: Clean up AI parameters ONLY if NOT waiting for batch processing -->
        <!-- If waiting for batch, we'll need these parameters when processing live search results -->
        <!-- If we're continuing from live search, this IS the final completion, so clean up parameters -->
        <do_if value="not $waitingForBatch or $isLiveSearchContinuation">
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_AIParameters exists -->
          <do_if value="global.$GT_AIParameters.{$ship}?">
            <remove_value name="global.$GT_AIParameters.{$ship}"/>
          </do_if>
        </do_if>
        
        <!-- âœ… PERFORMANCE FIX: Mark search complete and process next ship in queue -->
        <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
          <remove_value name="global.$GT_SearchQueue.$Params.{$ship}"/>
        </do_if>
        
        <!-- Decrement active search counter -->
        <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
        
        <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸ” SEARCH COMPLETE (active: ' + global.$GT_SearchQueue.$ActiveSearches + '/' + global.$GT_SearchQueue.$MaxConcurrent + ', queued: ' + global.$GT_SearchQueue.$Ships.count + ')'" chance="100"/>
        </do_if>
        
        <!-- Continue processing search queue if there are ships waiting -->
        <do_if value="global.$GT_SearchQueue.$Ships.count gt 0">
          <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- Search Cached Trades (Sub-module) -->
    <cue name="SearchCachedTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$minAbsoluteProfit" exact="$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="$params.$FactionPriority"/>
        <set_value name="$distancePenaltyMultiplier" exact="$params.$DistancePenaltyMultiplier"/>
        <set_value name="$skillLevel" exact="$params.$SkillLevel"/>
        <set_value name="$allowIllegal" exact="@$params.$AllowIllegal"/> <!-- Default to false if not provided -->
        
        <!-- Get ware basket for filtering (using library function with safe null-checking) -->
        <run_actions ref="md.GT_Utilities.GT_GetWareBasketSafe" result="$wareBasket">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- âœ… NEW: Collect top trades instead of just best one -->
        <!-- Use global setting for max trades to return -->
        <set_value name="$tradeList" exact="[]"/>
        <set_value name="$maxTradesToReturn" exact="200"/> <!-- Default fallback -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn?">
          <set_value name="$maxTradesToReturn" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn"/>
        </do_if>
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$foundCachedTrade" exact="false"/>
        
        <!-- ===== DETERMINE HOME SECTOR (using library function) ===== -->
        <run_actions ref="md.GT_Utilities.GT_GetHomeSector" result="$homeSector">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Cache age check removed - not needed, individual entries have $Timestamp -->
        <set_value name="$cacheAge" exact="0s"/>
        
        <!-- Get failed trades for this ship -->
        <set_value name="$failedTrades" exact="[]"/>
        <do_if value="global.$GT_FailedTrades? and global.$GT_FailedTrades.{$ship}?">
          <set_value name="$failedTrades" exact="global.$GT_FailedTrades.{$ship}"/>
        </do_if>
        
        <!-- âœ… CACHE REPLENISHMENT: Force live search if cache too small -->
        <!-- âœ… DIAGNOSTIC: Check if cache is disabled first -->
        <do_if value="not global.$GT_GlobalSettings.$Fleet.$EnableTradeCache? or not global.$GT_GlobalSettings.$Fleet.$EnableTradeCache">
          <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$LogLevel ge 1">
            <debug_text text="'[GT-Cache-DIAG] âš  Cache is DISABLED (global.$GT_GlobalSettings.$Fleet.$EnableTradeCache = false) - cannot use cache'" chance="100"/>
          </do_if>
        </do_if>
        <!-- âœ… PERFORMANCE OPTIMIZATION v5: Calculate total cache count from all home sectors -->
        <!-- global.$GT_TradeCache is now a table indexed by home sector -->
        <set_value name="$totalCacheCount" exact="0"/>
        <do_if value="global.$GT_TradeCache?">
          <do_all exact="global.$GT_TradeCache.keys.count" counter="$sectorIdx">
            <set_value name="$sectorCache" exact="global.$GT_TradeCache.{global.$GT_TradeCache.keys.{$sectorIdx}}"/>
            <do_if value="$sectorCache? and $sectorCache.count?">
              <set_value name="$totalCacheCount" exact="$totalCacheCount + $sectorCache.count"/>
            </do_if>
          </do_all>
        </do_if>
        <do_if value="$totalCacheCount lt 10">
          <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$LogLevel ge 1">
            <debug_text text="'[GT-Cache] âš  Cache too small (' + $totalCacheCount + ' entries) - forcing live search to replenish'" chance="100"/>
            <!-- âœ… DIAGNOSTIC: If cache is enabled but empty, log threshold info -->
            <do_if value="global.$GT_GlobalSettings.$Fleet.$EnableTradeCache? and global.$GT_GlobalSettings.$Fleet.$EnableTradeCache and $totalCacheCount == 0">
              <set_value name="$cacheThreshold" exact="20"/>
              <do_if value="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold?">
                <set_value name="$cacheThreshold" exact="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold"/>
              </do_if>
              <debug_text text="'[GT-Cache-DIAG] Cache is empty but enabled - threshold is ' + ($cacheThreshold/1) + '% ROI (check batch processor logs for why trades are rejected)'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Return empty result via global variable to trigger live search -->
          <!-- âœ… CRITICAL FIX: Preserve LastRejectionStats when updating global.$GT_SearchResult -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
          </do_if>
          
          <set_value name="global.$GT_SearchResult" exact="table[
            $Found = false,
            $BestTrade = null,
            $BestScore = 0,
            $BlacklistRejections = 0,
            $TradeList = []
          ]"/>
          
          <!-- âœ… CRITICAL FIX: Restore LastRejectionStats after updating global.$GT_SearchResult -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- âœ… PERFORMANCE OPTIMIZATION v5: Per-home-sector cache with pre-computed distances -->
        <!-- Each home sector has its own cache list - ships only search their own home sector's cache -->
        <!-- âœ… FIX: Initialize variables BEFORE conditional block to ensure they exist even if cache is empty -->
        <set_value name="$cacheMaxAge" exact="600s"/>  <!-- 10 minutes -->
        <set_value name="$checkedEntries" exact="0"/>
        <set_value name="$validEntries" exact="0"/>
        <set_value name="$expiredEntries" exact="0"/>
        <set_value name="$tradesByWareBeforeFiltering" exact="table[]"/>
        
        <!-- Get THIS home sector's cache (only trades cached for this home sector) -->
        <set_value name="$homeSectorCache" exact="null"/>
        <do_if value="$homeSector? and $homeSector.exists and global.$GT_TradeCache? and global.$GT_TradeCache.{$homeSector}?">
          <set_value name="$homeSectorCache" exact="global.$GT_TradeCache.{$homeSector}"/>
        </do_if>
        
        <!-- âœ… FIX: Check if cache exists, is not null, and has entries -->
        <do_if value="$homeSectorCache? and $homeSectorCache != null and $homeSectorCache.count? and $homeSectorCache.count gt 0">
          
          <!-- DEBUG: Log cache status -->
          <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$LogLevel ge 2">
            <set_value name="$sectorName" exact="@$homeSector.knownname"/>
            <debug_text text="'[GT-Cache-DEBUG] Home sector cache (' + (if $sectorName? then $sectorName else 'Unknown') + ') has ' + $homeSectorCache.count + ' trade entries'" chance="100"/>
          </do_if>
          
          <!-- Iterate through THIS home sector's cache entries BACKWARDS to safely remove invalid entries -->
          <!-- When we remove entry N, entries 1 to N-1 remain at same indices (already processed) -->
          <!-- âœ… PERFORMANCE OPTIMIZATION v5: Only check entries from THIS home sector's cache -->
          <!-- This ensures ships only validate trades cached for their own home sector -->
          <set_value name="$cacheCount" exact="$homeSectorCache.count"/>
          <do_all exact="$cacheCount" counter="$i" reverse="true">
            <set_value name="$cacheEntry" exact="$homeSectorCache.{$i}"/>
            <!-- âœ… FIX: Store loop index in a variable accessible in nested scopes -->
            <set_value name="$cacheEntryIndex" exact="$i"/>
            <set_value name="$checkedEntries" exact="$checkedEntries + 1"/>
            
            <!-- Track ware in statistics (even if entry will be filtered) -->
            <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
            <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
            <do_if value="$ware? and $ware != null">
              <do_if value="not $tradesByWareBeforeFiltering.{$ware}?">
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="table[
                  $total=0, 
                  $filtered=0, 
                  $valid=0,
                  $invalidStructure=0,
                  $expired=0,
                  $offersNoLongerExist=0,
                  $offersNotAvailable=0,
                  $insufficientAmount=0,
                  $stationNotOperational=0,
                  $failedSectorPair=0,
                  $outOfRange=0,
                  $unreachable=0,
                  $incompatibleCargo=0,
                  $illegal=0,
                  $wareBasket=0,
                  $distanceConstraint=0,
                  $profitConstraint=0,
                  $efficiencyThreshold=0,
                  $stationsWaresNoLongerExist=0,
                  $freshOffersNotAvailable=0,
                  $insufficientTradeableAmount=0,
                  $roiBelowThreshold=0,
                  $profitTooLow=0,
                  $roiDropTooHigh=0
                ]"/>
              </do_if>
              <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
              <set_value name="$wareStats.$total" exact="$wareStats.$total + 1"/>
              <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
            </do_if>
            
            <!-- Validate cache entry structure -->
            <do_if value="not $cacheEntry? or not $cacheEntry.$BuyOffer? or not $cacheEntry.$SellOffer? or not $cacheEntry.$Timestamp?">
              <!-- Track as filtered (invalid structure) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$invalidStructure" exact="$wareStats.$invalidStructure + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- Check if entry is too old (TTL filter) -->
            <set_value name="$entryAge" exact="player.age - $cacheEntry.$Timestamp"/>
            <do_if value="$entryAge gt $cacheMaxAge">
              <set_value name="$expiredEntries" exact="$expiredEntries + 1"/>
              <!-- Track as filtered (expired) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$expired" exact="$wareStats.$expired + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <!-- âœ… PERFORMANCE OPTIMIZATION v5: Remove from per-home-sector cache -->
              <!-- âœ… FIX: Use $cacheEntryIndex (stored at loop start) instead of $i -->
              <!-- Since we iterate backwards, removing entry $cacheEntryIndex is safe -->
              <do_if value="$cacheEntryIndex?">
                <remove_value name="global.$GT_TradeCache.{$homeSector}.{$cacheEntryIndex}"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- Validate offers still exist and are available -->
            <do_if value="not $cacheEntry.$BuyOffer.exists or not $cacheEntry.$SellOffer.exists">
              <!-- Track as filtered (offers no longer exist) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$offersNoLongerExist" exact="$wareStats.$offersNoLongerExist + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- CRITICAL: Validate offers are still available (not out of stock) -->
            <do_if value="not $cacheEntry.$BuyOffer.available or not $cacheEntry.$SellOffer.available">
              <!-- Track as filtered (offers not available) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$offersNotAvailable" exact="$wareStats.$offersNotAvailable + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- âœ… REMOVED: Pre-query amount check - amount validation happens after querying fresh offers -->
            <!-- Rationale: Even if cached amount dropped, trade may still be valid if ROI is within dropoff tolerance -->
            <!-- Amount validation now happens at line 1067 after querying fresh offers -->
            
            <!-- Validate stations still operational -->
            <do_if value="not @$cacheEntry.$BuyOffer.owner.isoperational or not @$cacheEntry.$SellOffer.owner.isoperational">
              <!-- Track as filtered (station not operational) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$stationNotOperational" exact="$wareStats.$stationNotOperational + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- CRITICAL: Filter out sector pairs that previously failed for THIS ship -->
            <!-- One failure in a sector pair blocks ALL station combinations in that route -->
            <do_if value="$failedTrades.count gt 0">
              <set_value name="$skipThisCacheEntry" exact="false"/>
              <do_all exact="$failedTrades.count" counter="$failIdx">
                <set_value name="$failedTrade" exact="$failedTrades.{$failIdx}"/>
                
                <!-- Check if SECTOR PAIR matches (buy sector â†’ sell sector) -->
                <!-- CRITICAL: Validate failed trade has complete sector data before comparing -->
                <do_if value="$failedTrade.$BuySector? and $failedTrade.$SellSector?">
                  <do_if value="@$cacheEntry.$BuyOffer.owner.sector == @$failedTrade.$BuySector and 
                                @$cacheEntry.$SellOffer.owner.sector == @$failedTrade.$SellSector">
                    <set_value name="$skipThisCacheEntry" exact="true"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_all>
              
              <do_if value="$skipThisCacheEntry">
                <!-- Track as filtered (failed sector pair) - $total already incremented above -->
                <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                <do_if value="$ware? and $ware != null">
                  <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                  <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                  <set_value name="$wareStats.$failedSectorPair" exact="$wareStats.$failedSectorPair + 1"/>
                  <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                </do_if>
                <continue/> <!-- Skip to next cache entry -->
              </do_if>
            </do_if>
            
            <!-- 
              TWO-STAGE DISTANCE VALIDATION:
              1. Range check: Is trade within ship's operational range from home base? (NO blacklist)
              2. Reachability check: Can ship reach it from current position? (basic connectivity)
            -->
            
            <!-- STAGE 1: Range check from home base (no blacklist) -->
            <!-- âœ… PERFORMANCE OPTIMIZATION v5: Use pre-computed distances from cache entry -->
            <!-- Distances were calculated ONCE during caching - no recalculation needed! -->
            <set_value name="$rangeCheckBuy" exact="@$cacheEntry.$HomeToBuyDistance"/>
            <set_value name="$rangeCheckSell" exact="@$cacheEntry.$HomeToSellDistance"/>
            
            <!-- Fallback: Recalculate if not pre-computed (backward compatibility with old cache entries) -->
            <do_if value="not $rangeCheckBuy? or not $rangeCheckSell?">
              <set_value name="$rangeCheckBuy" exact="$homeSector.gatedistance.{$cacheEntry.$BuyOffer.owner.sector}"/>
              <set_value name="$rangeCheckSell" exact="$homeSector.gatedistance.{$cacheEntry.$SellOffer.owner.sector}"/>
            </do_if>
            
            <!-- âœ… FIX: Validate using max distance from home (both stations must be within maxDistance from home) -->
            <!-- This ensures stations are within operational range, regardless of ship's current position -->
            <set_value name="$maxStationDistanceFromHome" exact="[$rangeCheckBuy, $rangeCheckSell].max"/>
            
            <!-- Skip if outside operational range -->
            <do_if value="$rangeCheckBuy lt 0 or $rangeCheckSell lt 0 or $maxStationDistanceFromHome gt $maxDistance">
              <!-- Track as filtered (out of range) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$outOfRange" exact="$wareStats.$outOfRange + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- STAGE 2: Basic reachability check from current position -->
            <!-- Use BLACKLIST-AWARE gatedistance so blocked paths return -1 -->
            <set_value name="$buySector" exact="$cacheEntry.$BuyOffer.owner.sector"/>
            
            <!-- âœ… FIX: Determine blacklistgroup (same logic as SearchLiveTrades_Resume) -->
            <run_actions ref="md.GT_Blacklist_Utilities.GT_GetBlacklistGroup" result="$blacklistgroup">
              <param name="ship" value="$ship"/>
            </run_actions>
            
            <set_value name="$currentSector" exact="$ship.sector"/>
            
            <!-- âœ… FIX: Block intra-sector trades in blacklisted sectors (force escape) -->
            <!-- If ship is in blacklisted sector and both buy/sell are same sector, block trade -->
            <set_value name="$skipIntraSectorTrade" exact="false"/>
            <do_if value="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
              <do_if value="$buySector == $currentSector and $cacheEntry.$BuyOffer.owner.sector == $cacheEntry.$SellOffer.owner.sector">
                <!-- Intra-sector trade in blacklisted sector - BLOCK to force escape -->
                <set_value name="$skipIntraSectorTrade" exact="true"/>
                <!-- Track as filtered (intra-sector in blacklisted sector) -->
                <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                  <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                  <do_if value="$ware? and $ware != null">
                    <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                    <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                    <set_value name="$wareStats.$outOfRange" exact="$wareStats.$outOfRange + 1"/>
                    <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                  </do_if>
              </do_if>
            </do_if>
            
            <do_if value="$skipIntraSectorTrade">
              <continue/> <!-- Skip to next cache entry -->
            </do_if>
            
            <!-- âœ… PERFORMANCE: Removed buy/sell sector blacklist checks during cache iteration -->
            <!-- Blacklist validation now happens only for best trade(s) before returning (CPU-efficient) -->
            
            <!-- âœ… ESCAPE LOGIC: Use non-blacklist-aware gatedistance for escape trades -->
            <!-- If ship is in blacklisted sector and buying from different sector, use non-blacklist-aware pathfinding -->
            <set_value name="$currentSectorIsBlacklistedForEscape" exact="false"/>
            <do_if value="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
              <set_value name="$currentSectorIsBlacklistedForEscape" exact="true"/>
            </do_if>
            <do_if value="$currentSectorIsBlacklistedForEscape and $buySector != $currentSector">
              <!-- Ship escaping from blacklisted sector - use non-blacklist-aware gatedistance to find ANY path -->
              <set_value name="$buyDistance" exact="$ship.gatedistance.{$buySector}"/>
            </do_if>
            <do_else>
              <!-- Normal case: Use blacklist-aware gatedistance -->
              <set_value name="$buyDistance" exact="$ship.gatedistance.{$buySector}.{$blacklistgroup}.{$ship}"/>
            </do_else>
            
            <!-- Sell distance: BuyOffer station to SellOffer station -->
            <do_if value="$cacheEntry.$BuyOffer.owner.sector == $cacheEntry.$SellOffer.owner.sector">
              <set_value name="$sellDistance" exact="0"/>
              <set_value name="$sellSector" exact="$cacheEntry.$SellOffer.owner.sector"/>
            </do_if>
            <do_else>
              <set_value name="$sellSector" exact="$cacheEntry.$SellOffer.owner.sector"/>
              <set_value name="$sellDistance" exact="$buySector.gatedistance.{$sellSector}.{$blacklistgroup}.{$ship}"/>
            </do_else>
            
            <!-- âœ… PERFORMANCE: Removed sell sector blacklist check during cache iteration -->
            <!-- Blacklist validation now happens only for best trade(s) before returning (CPU-efficient) -->
            
            <!-- If trade route is unreachable (disconnected sectors), skip this trade -->
            <!-- NOTE: This is an early check for efficiency, but we also check later at line 749 -->
            <!-- Track here to ensure all unreachable entries are counted -->
            <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
              <!-- Track as filtered (unreachable) - $total already incremented above -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$unreachable" exact="$wareStats.$unreachable + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <!-- Commented out to reduce log spam - uncomment if needed for debugging -->
              <!-- <debug_text text="'[GT-Cache] âš  PATH BLOCKED: Trade route unreachable (disconnected sectors)' +
                '\n  Ship: ' + $ship.idcode +
                '\n  Ware: ' + @$cacheEntry.$BuyOffer.ware.name +
                '\n  Buy: ' + @$cacheEntry.$BuyOffer.owner.knownname + ' (distance: ' + $buyDistance + ')' +
                '\n  Sell: ' + @$cacheEntry.$SellOffer.owner.knownname + ' (distance: ' + $sellDistance + ')'"
                chance="100"/> -->
              <continue/>
            </do_if>
            
            <!-- Safe defaults for null values (should be rare - only if sectors are completely disconnected) -->
            <do_if value="not $buyDistance? or typeof $buyDistance != datatype.integer">
              <set_value name="$buyDistance" exact="-1"/>
            </do_if>
            <do_if value="not $sellDistance? or typeof $sellDistance != datatype.integer">
              <set_value name="$sellDistance" exact="-1"/>
            </do_if>
            
            <!-- NOTE: Unreachable check already handled at line 714 (early exit for efficiency) -->
            <!-- No need to check again here - unreachable entries already filtered and tracked -->
            
            <!-- âœ… PERFORMANCE: Sector blacklist checks are now performed ONLY for best trade(s) before returning -->
            <!-- This avoids checking hundreds of cache entries (CPU-efficient) -->
            <!-- If best trade is blacklisted, we try the next trade in list before giving up -->
            <!-- Station blacklist checks are still handled by vanilla during trade execution -->
            
            <!-- Calculate total distance (ship â†’ buy â†’ sell) for filtering/validation -->
            <set_value name="$currentDistance" exact="$buyDistance + $sellDistance"/>
            
            <!-- âœ… CARGO TYPE COMPATIBILITY FILTER: Skip wares ship cannot carry -->
            <!-- Some wares (like Methane/gas, Feststoffe/solids) require special cargo bays -->
            <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
            <set_value name="$canCarryWareType" exact="false"/>
            <do_if value="$ware? and $ware != null">
              <!-- Check if ship has cargo bay capacity for this specific ware type -->
              <set_value name="$canCarryWareType" exact="$ship.cargo.{$ware}.max gt 0"/>
            </do_if>
            <do_if value="not $canCarryWareType">
              <!-- Track ware for statistics -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <!-- Initialize incompatibleCargo field if it doesn't exist -->
                <do_if value="not $wareStats.$incompatibleCargo?">
                  <set_value name="$wareStats.$incompatibleCargo" exact="0"/>
                </do_if>
                <set_value name="$wareStats.$incompatibleCargo" exact="$wareStats.$incompatibleCargo + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- âœ… ILLEGAL WARE FILTER: Skip illegal wares if ship doesn't allow illegal trades -->
            <do_if value="not $allowIllegal and $cacheEntry.$BuyOffer.ware.illegal">
              <!-- Track ware for statistics -->
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$illegal" exact="$wareStats.$illegal + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- âœ… WARE BASKET FILTER: Only consider manually selected wares (using library function) -->
            <run_actions ref="md.GT_Utilities.GT_GetWareBasketSafe" result="$wareBasket">
              <param name="ship" value="$ship"/>
            </run_actions>
            <do_if value="$wareBasket.count gt 0">
              <!-- Check if ware is in basket (using library function) -->
              <run_actions ref="md.GT_Utilities.GT_IsWareInBasket" result="$wareInBasket">
                <param name="ware" value="$cacheEntry.$BuyOffer.ware"/>
                <param name="basket" value="$wareBasket"/>
              </run_actions>
              <do_if value="not $wareInBasket">
                <!-- Track ware for statistics -->
                <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                <do_if value="$ware? and $ware != null">
                  <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                  <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                  <set_value name="$wareStats.$wareBasket" exact="$wareStats.$wareBasket + 1"/>
                  <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                </do_if>
                <continue/>
              </do_if>
            </do_if>
            
            <!-- CRITICAL: Validate prices haven't changed unfavorably (allow 10% variance) -->
            <!-- âŒ REMOVED: Stale price check was filtering out valid entries before querying fresh offers!
                 The old logic read prices from cached tradeoffer objects which are stale.
                 We should only validate against fresh prices AFTER querying fresh offers. -->
            
            <!-- âœ… REMOVED: Redundant distance constraint check -->
            <!-- Distance validation already done at line 1310 using home-based distance -->
            <!-- Actual travel distance ($currentDistance) is used for penalty scoring only (line 1513) -->
            
            <!-- Check profit constraint -->
            <do_if value="$cacheEntry.$Profit? and $cacheEntry.$Profit lt $minAbsoluteProfit">
              <!-- Track ware for statistics -->
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$profitConstraint" exact="$wareStats.$profitConstraint + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <continue/>
            </do_if>
            
            <!-- âœ… CRITICAL: Calculate current score with ship's distance penalty setting -->
            <!-- This ensures trades are scored based on THIS ship's preferences, not the cache population settings -->
            <!-- Cache stores universal trade data (profit, distance, etc.) but Score is recalculated per-ship -->
            <!-- âœ… NEW: Multi-factor distance penalty system (shipâ†’buy, buyâ†’sell, home distance) -->
            <run_actions ref="md.GT_Trade_Utilities.GT_CalculateTradeEfficiency" result="$efficiency">
              <param name="profit" value="$cacheEntry.$Profit"/>
              <param name="distance" value="$currentDistance"/>
              <param name="distancePenaltyMultiplier" value="$distancePenaltyMultiplier"/>
              <param name="factionPriority" value="$factionPriority"/>
              <param name="buyStationOwner" value="$cacheEntry.$BuyOffer.owner.owner"/>
              <param name="sellStationOwner" value="$cacheEntry.$SellOffer.owner.owner"/>
              <param name="homeSector" value="$homeSector"/>
              <param name="shipSector" value="$currentSector"/>
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="shipToBuyDistance" value="$buyDistance"/>
              <param name="buyToSellDistance" value="$sellDistance"/>
              <param name="homeToBuyDistance" value="$rangeCheckBuy"/>
              <param name="homeToSellDistance" value="$rangeCheckSell"/>
            </run_actions>
            
            <!-- âœ… DEBUG: Log efficiency calculation with distance penalty (if enabled) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$cacheEntryWare" exact="@$cacheEntry.$BuyOffer.ware"/>
              <do_if value="$cacheEntryWare?">
                <debug_text text="'[GT-Cache] (' + $ship.idcode + ') Trade score recalculation: Ware=' + @$cacheEntryWare.name + ', Profit=' + ($cacheEntry.$Profit / 100) + 'Cr, Shipâ†’Buy=' + $buyDistance + ', Buyâ†’Sell=' + $sellDistance + ', Homeâ†’Buy=' + $rangeCheckBuy + ', Homeâ†’Sell=' + $rangeCheckSell + ', Efficiency=' + $efficiency" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- âœ… CACHE AS HINT: Re-query FRESH trade offers from the cached stations -->
            <!-- Query entries that are either:
                1. Better than current best (might improve our best trade), OR
                2. We haven't reached max trades yet (need to build diverse list)
                3. CRITICAL: Efficiency comparison only makes sense WITHIN same ware, NOT across wares
                4. For diversity: If we don't have trades for this ware yet, query based on profit/ROI only
            -->
            <!-- Get cache threshold early (needed for diversity check) -->
            <set_value name="$cacheThreshold" exact="20"/>
            <do_if value="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold?">
              <set_value name="$cacheThreshold" exact="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold"/>
            </do_if>
            
            <set_value name="$shouldQuery" exact="false"/>
            <do_if value="$efficiency gt $bestScore">
              <!-- Always query if better than current best -->
              <set_value name="$shouldQuery" exact="true"/>
            </do_if>
            <do_elseif value="$tradeList.count lt $maxTradesToReturn">
              <!-- Check if we already have trades for this ware -->
              <set_value name="$hasTradesForThisWare" exact="false"/>
              <set_value name="$currentWare" exact="@$cacheEntry.$BuyOffer.ware"/>
              <do_if value="$currentWare?">
                <do_all exact="$tradeList.count" counter="$i">
                  <do_if value="$tradeList.{$i}.$BuyOffer.ware == $currentWare">
                    <set_value name="$hasTradesForThisWare" exact="true"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_if>
              
              <!-- Calculate whether to query based on ware diversity -->
              <do_if value="$hasTradesForThisWare">
                <!-- We already have trades for this ware - use efficiency threshold (compare within same ware) -->
                <!-- Use 50% of best score as threshold (only meaningful for same ware) -->
                <set_value name="$efficiencyThreshold" exact="$bestScore / 2"/>
                <do_if value="$bestScore == 0 or $efficiency ge $efficiencyThreshold">
                  <set_value name="$shouldQuery" exact="true"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- We don't have trades for this ware yet - query based on profitability only (not efficiency vs other wares) -->
                <!-- Efficiency can't be compared across different wares, so just check if trade is profitable -->
                <do_if value="$cacheEntry.$Profit? and $cacheEntry.$Profit ge $minAbsoluteProfit">
                  <do_if value="$cacheEntry.$ROI? and $cacheEntry.$ROI ge $cacheThreshold">
                    <set_value name="$shouldQuery" exact="true"/>
                  </do_if>
                </do_if>
              </do_else>
            </do_elseif>
            
            <!-- Track entries that are skipped due to efficiency threshold -->
            <do_if value="not $shouldQuery">
              <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
              <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
              <do_if value="$ware? and $ware != null">
                <do_if value="not $tradesByWareBeforeFiltering.{$ware}?">
                  <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="table[
                    $total=0, 
                    $filtered=0, 
                    $valid=0,
                    $invalidStructure=0,
                    $expired=0,
                    $offersNoLongerExist=0,
                    $offersNotAvailable=0,
                    $insufficientAmount=0,
                    $stationNotOperational=0,
                    $failedSectorPair=0,
                    $outOfRange=0,
                    $unreachable=0,
                    $illegal=0,
                    $wareBasket=0,
                    $distanceConstraint=0,
                    $profitConstraint=0,
                    $efficiencyThreshold=0,
                    $stationsWaresNoLongerExist=0,
                    $freshOffersNotAvailable=0,
                    $insufficientTradeableAmount=0,
                    $roiBelowThreshold=0,
                    $profitTooLow=0,
                    $roiDropTooHigh=0
                  ]"/>
                </do_if>
                <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                <set_value name="$wareStats.$efficiencyThreshold" exact="$wareStats.$efficiencyThreshold + 1"/>
                <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
              </do_if>
              <!-- Skip to next entry (efficiency too low to query) -->
              <continue/>
            </do_if>
            
            <do_if value="$shouldQuery">
              <!-- âœ… CRITICAL FIX: Get ware and station objects from cached IDs, not stale tradeoffer references! -->
              <!-- Ware objects don't go stale, so we can use the cached ware object directly -->
              <set_value name="$ware" exact="$cacheEntry.$BuyOffer.ware"/>
              
              <!-- Stations: Try using cached station references first (faster) -->
              <set_value name="$buyStation" exact="$cacheEntry.$BuyOffer.owner"/>
              <set_value name="$sellStation" exact="$cacheEntry.$SellOffer.owner"/>
              
              <!-- Validate stations still exist and are operational -->
              <do_if value="$buyStation.exists and $buyStation.isoperational and $sellStation.exists and $sellStation.isoperational and $ware">
                <!-- Query FRESH sell offer from buy station (ship buys from their sell offer) -->
                <find_sell_offer seller="$buyStation" wares="$ware" result="$freshBuyOffer">
                  <match_seller tradesknownto="$ship.owner"/>
                </find_sell_offer>
                
                <!-- Query FRESH buy offer from sell station (ship sells to their buy offer) -->
                <find_buy_offer buyer="$sellStation" wares="$ware" result="$freshSellOffer">
                  <match_buyer tradesknownto="$ship.owner"/>
                </find_buy_offer>
              </do_if>
              <do_else>
                <!-- Stations or ware no longer exist/operational - skip this entry -->
                <set_value name="$freshBuyOffer" exact="null"/>
                <set_value name="$freshSellOffer" exact="null"/>
                
                <!-- Track as filtered (stations/wares no longer exist) -->
                <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                <do_if value="$ware? and $ware != null">
                  <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                  <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                  <set_value name="$wareStats.$stationsWaresNoLongerExist" exact="$wareStats.$stationsWaresNoLongerExist + 1"/>
                  <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                </do_if>
                
                <continue/>
              </do_else>
              
              <!-- Validate fresh offers exist and are available -->
              <do_if value="$freshBuyOffer and $freshBuyOffer.available and $freshSellOffer and $freshSellOffer.available">
                <!-- Calculate fresh prices and profit -->
                <set_value name="$freshBuyPrice" exact="$freshBuyOffer.unitprice"/>
                <set_value name="$freshSellPrice" exact="$freshSellOffer.unitprice"/>
                
                <!-- Calculate max tradeable amount (using library function) -->
                <run_actions ref="md.GT_Trade_Utilities.GT_CalculateMaxTradeableAmount" result="$freshMaxAmount">
                  <param name="ship" value="$ship"/>
                  <param name="ware" value="$freshBuyOffer.ware"/>
                  <param name="buyOfferAmount" value="$freshBuyOffer.amount"/>
                  <param name="sellOfferAmount" value="$freshSellOffer.amount"/>
                </run_actions>
                
                <!-- Skip if no tradeable amount -->
                <do_if value="$freshMaxAmount le 0">
                  <!-- Track as filtered (insufficient tradeable amount) -->
                  <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                  <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                  <do_if value="$ware? and $ware != null">
                    <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                    <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                    <set_value name="$wareStats.$insufficientTradeableAmount" exact="$wareStats.$insufficientTradeableAmount + 1"/>
                    <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                  </do_if>
                  <continue/>
                </do_if>
                <do_if value="$freshMaxAmount gt 0">
                  <set_value name="$freshProfit" exact="($freshSellPrice - $freshBuyPrice) * $freshMaxAmount"/>
                  
                  <!-- âœ… CORRECT LOGIC: Calculate fresh ROI and check relative percentage drop -->
                  <do_if value="$freshProfit gt 0">
                    <!-- Calculate fresh ROI as percentage (using library function) -->
                    <run_actions ref="md.GT_Trade_Utilities.GT_CalculateROIFromPrices" result="$freshROI">
                      <param name="buyPrice" value="$freshBuyPrice"/>
                      <param name="sellPrice" value="$freshSellPrice"/>
                    </run_actions>
                    
                    <!-- Get cache threshold from global settings (default 20%) -->
                    <set_value name="$cacheThreshold" exact="20"/>
                    <do_if value="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold?">
                      <set_value name="$cacheThreshold" exact="global.$GT_GlobalSettings.$Fleet.$CacheProfitThreshold"/>
                    </do_if>
                    
                    <!-- Get cached original ROI -->
                    <set_value name="$cachedROI" exact="@$cacheEntry.$ROI"/>
                    <do_if value="not $cachedROI? or $cachedROI le 0">
                      <set_value name="$cachedROI" exact="$cacheThreshold"/>  <!-- Fallback for old cache entries -->
                    </do_if>
                    
                    <!-- Get dropoff tolerance from global settings (default 15%) -->
                    <set_value name="$dropoffTolerance" exact="@global.$GT_GlobalSettings.$Fleet.$CacheDropoffTolerance"/>
                    <do_if value="not $dropoffTolerance?">
                      <set_value name="$dropoffTolerance" exact="15"/>  <!-- Default 15% -->
                    </do_if>
                    
                    <!-- Calculate relative percentage drop: ((original - current) / original) * 100 -->
                    <set_value name="$roiDrop" exact="0"/>
                    <do_if value="$cachedROI gt 0">
                      <set_value name="$roiDrop" exact="(($cachedROI - $freshROI) * 100) / $cachedROI"/>
                    </do_if>
                    
                    <!-- Check if fresh ROI meets minimum threshold AND relative drop is within tolerance -->
                    <do_if value="$freshROI ge $cacheThreshold and $freshProfit ge $minAbsoluteProfit and $roiDrop le $dropoffTolerance">
                      <!-- âœ… CACHE HIT: Fresh trade meets threshold and within dropoff tolerance! -->
                      <!-- âœ… CRITICAL: Recalculate efficiency with FRESH profit and ship's distance penalty setting -->
                      <!-- This ensures each ship's distance preference affects trade selection, not the cache population settings -->
                      <!-- Previous efficiency calculation used cached profit - now recalculate with actual fresh profit -->
                      <!-- âœ… NEW: Multi-factor distance penalty system (shipâ†’buy, buyâ†’sell, home distance) -->
                      <run_actions ref="md.GT_Trade_Utilities.GT_CalculateTradeEfficiency" result="$freshEfficiency">
                        <param name="profit" value="$freshProfit"/>
                        <param name="distance" value="$currentDistance"/>
                        <param name="distancePenaltyMultiplier" value="$distancePenaltyMultiplier"/>
                        <param name="factionPriority" value="$factionPriority"/>
                        <param name="buyStationOwner" value="$cacheEntry.$BuyOffer.owner.owner"/>
                        <param name="sellStationOwner" value="$cacheEntry.$SellOffer.owner.owner"/>
                        <param name="homeSector" value="$homeSector"/>
                        <param name="shipSector" value="$currentSector"/>
                        <param name="buySector" value="$buySector"/>
                        <param name="sellSector" value="$sellSector"/>
                        <param name="shipToBuyDistance" value="$buyDistance"/>
                        <param name="buyToSellDistance" value="$sellDistance"/>
                        <param name="homeToBuyDistance" value="$rangeCheckBuy"/>
                        <param name="homeToSellDistance" value="$rangeCheckSell"/>
                      </run_actions>
                      
                      <set_value name="$trade" exact="table[
                        $BuyOffer = $freshBuyOffer,
                        $SellOffer = $freshSellOffer,
                        $BuyStation = $freshBuyOffer.owner,
                        $SellStation = $freshSellOffer.owner,
                        $Amount = $freshMaxAmount,
                        $Profit = $freshProfit,
                        $ROI = $freshROI,
                        $BuyPrice = $freshBuyPrice,
                        $SellPrice = $freshSellPrice,
                        $Distance = $currentDistance,
                        $Score = $freshEfficiency,
                        $Risk = 0
                      ]"/>
                      
                      <!-- âœ… NEW: Add to trade list (up to max) with STATION PAIR DEDUPLICATION -->
                      <!-- Prevent duplicate station pairs in the same retrieval (even if cache has duplicates) -->
                      <set_value name="$stationPairExists" exact="false"/>
                      <set_value name="$currentBuyStation" exact="$trade.$BuyStation"/>
                      <set_value name="$currentSellStation" exact="$trade.$SellStation"/>
                      <do_all exact="$tradeList.count" counter="$j">
                        <set_value name="$existingBuyStation" exact="$tradeList.{$j}.$BuyStation"/>
                        <set_value name="$existingSellStation" exact="$tradeList.{$j}.$SellStation"/>
                        <do_if value="$existingBuyStation == $currentBuyStation and $existingSellStation == $currentSellStation">
                          <set_value name="$stationPairExists" exact="true"/>
                          <break/>
                        </do_if>
                      </do_all>
                      
                      <!-- Only add if station pair is unique and we haven't reached max -->
                      <do_if value="not $stationPairExists and $tradeList.count lt $maxTradesToReturn">
                        <append_to_list name="$tradeList" exact="$trade"/>
                        
                        <!-- Track valid trade per ware -->
                        <set_value name="$tradeWare" exact="@$trade.$BuyOffer.ware"/>
                        <do_if value="$tradeWare?">
                          <do_if value="not $tradesByWareBeforeFiltering.{$tradeWare}?">
                            <set_value name="$tradesByWareBeforeFiltering.{$tradeWare}" exact="table[$total=0, $filtered=0, $valid=0]"/>
                          </do_if>
                          <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$tradeWare}"/>
                          <set_value name="$wareStats.$valid" exact="$wareStats.$valid + 1"/>
                          <set_value name="$tradesByWareBeforeFiltering.{$tradeWare}" exact="$wareStats"/>
                        </do_if>
                      </do_if>
                      
                      <!-- Also track best trade for backward compatibility -->
                      <!-- âœ… FIX: Validate trade before setting bestTrade for consistency -->
                      <!-- âœ… CRITICAL: Use freshEfficiency (calculated with fresh profit and ship's distance penalty) -->
                      <do_if value="$freshEfficiency gt $bestScore">
                        <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$isValid">
                          <param name="trade" value="$trade"/>
                          <param name="minScore" value="0"/>
                        </run_actions>
                        <do_if value="$isValid">
                          <set_value name="$bestScore" exact="$freshEfficiency"/>
                          <set_value name="$bestTrade" exact="$trade"/>
                        </do_if>
                      </do_if>
                      
                      <set_value name="$foundCachedTrade" exact="true"/>
                      <set_value name="$validEntries" exact="$validEntries + 1"/>
                      
                    </do_if>
                    <do_else>
                      <!-- âœ… CACHE MAINTENANCE: ROI dropped below threshold - DELETE stale cache entry -->
                      <!-- Track why entry was rejected for statistics -->
                      <set_value name="$rejectionReason" exact="''"/>
                      <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                      <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                      <do_if value="$ware? and $ware != null">
                        <do_if value="not $tradesByWareBeforeFiltering.{$ware}?">
                          <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="table[
                            $total=0, 
                            $filtered=0, 
                            $valid=0,
                            $invalidStructure=0,
                            $expired=0,
                            $offersNoLongerExist=0,
                            $offersNotAvailable=0,
                            $insufficientAmount=0,
                            $stationNotOperational=0,
                            $failedSectorPair=0,
                            $outOfRange=0,
                            $unreachable=0,
                            $illegal=0,
                            $wareBasket=0,
                            $distanceConstraint=0,
                            $profitConstraint=0,
                            $efficiencyThreshold=0,
                            $stationsWaresNoLongerExist=0,
                            $freshOffersNotAvailable=0,
                            $insufficientTradeableAmount=0,
                            $roiBelowThreshold=0,
                            $profitTooLow=0,
                            $roiDropTooHigh=0
                          ]"/>
                        </do_if>
                        <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                        <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                        
                        <!-- Track specific rejection reasons -->
                        <do_if value="$freshROI lt $cacheThreshold">
                          <set_value name="$wareStats.$roiBelowThreshold" exact="$wareStats.$roiBelowThreshold + 1"/>
                          <set_value name="$rejectionReason" exact="$rejectionReason + 'ROI below threshold (' + $freshROI + '% lt ' + $cacheThreshold + '%)'"/>
                        </do_if>
                        <do_if value="$freshProfit lt $minAbsoluteProfit">
                          <set_value name="$wareStats.$profitTooLow" exact="$wareStats.$profitTooLow + 1"/>
                          <do_if value="$rejectionReason != ''">
                            <set_value name="$rejectionReason" exact="$rejectionReason + ', '"/>
                          </do_if>
                          <set_value name="$rejectionReason" exact="$rejectionReason + 'Profit too low (' + ($freshProfit/100) + ' Cr lt ' + ($minAbsoluteProfit/100) + ' Cr)'"/>
                        </do_if>
                        <do_if value="$roiDrop gt $dropoffTolerance">
                          <set_value name="$wareStats.$roiDropTooHigh" exact="$wareStats.$roiDropTooHigh + 1"/>
                          <do_if value="$rejectionReason != ''">
                            <set_value name="$rejectionReason" exact="$rejectionReason + ', '"/>
                          </do_if>
                          <set_value name="$rejectionReason" exact="$rejectionReason + 'ROI drop too high (' + $roiDrop + '% gt ' + $dropoffTolerance + '%)'"/>
                        </do_if>
                        
                        <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                      </do_if>
                      
                      <!-- âœ… PERFORMANCE OPTIMIZATION v5: Remove from per-home-sector cache -->
                      <!-- Note: $cacheEntry is from $homeSectorCache, so it's already from the correct home sector -->
                      <!-- âœ… FIX: Use $cacheEntryIndex (stored at loop start) to remove from the correct home sector's cache -->
                      <!-- Since we iterate backwards, removing entry $cacheEntryIndex is safe (already processed entries remain at same indices) -->
                      <do_if value="$cacheEntryIndex?">
                        <remove_value name="global.$GT_TradeCache.{$homeSector}.{$cacheEntryIndex}"/>
                      </do_if>
                      <!-- Skip to next entry -->
                      <continue/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!-- Track filtered trade per ware (rejected due to zero/negative profit) -->
                    <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                    <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                    <do_if value="$ware? and $ware != null">
                      <do_if value="not $tradesByWareBeforeFiltering.{$ware}?">
                        <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="table[
                          $total=0, 
                          $filtered=0, 
                          $valid=0,
                          $invalidStructure=0,
                          $expired=0,
                          $offersNoLongerExist=0,
                          $offersNotAvailable=0,
                          $insufficientAmount=0,
                          $stationNotOperational=0,
                          $failedSectorPair=0,
                          $outOfRange=0,
                          $unreachable=0,
                          $illegal=0,
                          $wareBasket=0,
                          $distanceConstraint=0,
                          $profitConstraint=0,
                          $efficiencyThreshold=0,
                          $stationsWaresNoLongerExist=0,
                          $freshOffersNotAvailable=0,
                          $insufficientTradeableAmount=0,
                          $roiBelowThreshold=0,
                          $profitTooLow=0,
                          $roiDropTooHigh=0
                        ]"/>
                      </do_if>
                      <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                      <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                      <set_value name="$wareStats.$profitTooLow" exact="$wareStats.$profitTooLow + 1"/>
                      <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                    </do_if>
                  </do_else>
                </do_if>
              </do_if>
              <do_else>
                <!-- Track as filtered (fresh offers not available) -->
                <set_value name="$ware" exact="@$cacheEntry.$BuyOffer.ware"/>
                <!-- âœ… FIX: Check both existence AND non-null (ware? only checks existence, not null) -->
                <do_if value="$ware? and $ware != null">
                  <set_value name="$wareStats" exact="$tradesByWareBeforeFiltering.{$ware}"/>
                  <set_value name="$wareStats.$filtered" exact="$wareStats.$filtered + 1"/>
                  <set_value name="$wareStats.$freshOffersNotAvailable" exact="$wareStats.$freshOffersNotAvailable + 1"/>
                  <set_value name="$tradesByWareBeforeFiltering.{$ware}" exact="$wareStats"/>
                </do_if>
              </do_else>
            </do_if>
          </do_all>
          
          <!-- âœ… BUILD DIVERSE LIST: Top 5 per ware (same logic as SearchLiveTrades_Resume) -->
          <do_if value="$tradeList.count gt 0">
            
            <!-- Group trades by ware -->
            <set_value name="$tradesByWare" exact="table[]"/>
            <do_all exact="$tradeList.count" counter="$i">
              <set_value name="$trade" exact="$tradeList.{$i}"/>
              <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
              <do_if value="not $tradesByWare.{$ware}?">
                <set_value name="$tradesByWare.{$ware}" exact="[]"/>
              </do_if>
              <append_to_list name="$tradesByWare.{$ware}" exact="$trade"/>
            </do_all>
            
            <!-- DEBUG: Log wares found -->
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$LogLevel ge 2 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$wareDebug" exact="'[GT-Cache] Found ' + $tradesByWare.keys.count + ' wares with trades:'"/>
              <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
                <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
                <set_value name="$wareCount" exact="$tradesByWare.{$ware}.count"/>
                <set_value name="$wareDebug" exact="$wareDebug + '\n  - ' + @$ware.name + ': ' + $wareCount + ' trades'"/>
              </do_all>
              <debug_text text="$wareDebug" chance="100"/>
            </do_if>
            
            <!-- Select top 5 per ware by Score -->
            <set_value name="$diverseList" exact="[]"/>
            <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
              <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
              <set_value name="$wareTrades" exact="$tradesByWare.{$ware}"/>
              
              <!-- Simple selection sort to get top 5 by Score with STATION PAIR DIVERSITY -->
              <set_value name="$top3" exact="[]"/>
              <set_value name="$maxCount" exact="[$wareTrades.count, 5].min"/>
              <do_all exact="$maxCount" counter="$rank">
                <set_value name="$maxScore" exact="-999999999"/>
                <set_value name="$maxIdx" exact="-1"/>
                <do_all exact="$wareTrades.count" counter="$i">
                  <set_value name="$trade" exact="$wareTrades.{$i}"/>
                  <set_value name="$buyStation" exact="$trade.$BuyStation"/>
                  <set_value name="$sellStation" exact="$trade.$SellStation"/>
                  
                  <!-- âœ… STATION PAIR DIVERSITY: Check if this station pair already exists in top3 -->
                  <set_value name="$stationPairExists" exact="false"/>
                  <do_all exact="$top3.count" counter="$j">
                    <set_value name="$existingBuyStation" exact="$top3.{$j}.$BuyStation"/>
                    <set_value name="$existingSellStation" exact="$top3.{$j}.$SellStation"/>
                    <do_if value="$existingBuyStation == $buyStation and $existingSellStation == $sellStation">
                      <set_value name="$stationPairExists" exact="true"/>
                      <break/>
                    </do_if>
                  </do_all>
                  
                  <!-- Only consider if station pair is unique and Score is better -->
                  <do_if value="not $stationPairExists and $trade.$Score gt $maxScore">
                    <set_value name="$maxScore" exact="$trade.$Score"/>
                    <set_value name="$maxIdx" exact="$i"/>
                  </do_if>
                </do_all>
                <do_if value="$maxIdx ge 0">
                  <append_to_list name="$top3" exact="$wareTrades.{$maxIdx}"/>
                </do_if>
                <!-- If we couldn't find a unique station pair, break early (we have all unique pairs already) -->
                <do_if value="$maxIdx lt 0">
                  <break/>
                </do_if>
              </do_all>
              
              <!-- Add up to 5 trades per ware (if less than 5, still include what we have) -->
              <do_if value="$top3.count gt 0">
                <do_all exact="$top3.count" counter="$i">
                  <append_to_list name="$diverseList" exact="$top3.{$i}"/>
                </do_all>
              </do_if>
            </do_all>
            
            <!-- DEBUG: Log diverse list result -->
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$LogLevel ge 2">
              <debug_text text="'[GT-Cache] Diverse list built: ' + $diverseList.count + ' trades from ' + $tradesByWare.keys.count + ' wares'" chance="100"/>
            </do_if>
            
            <!-- Update tradeList to be the diverse list -->
            <set_value name="$tradeList" exact="$diverseList"/>
            
            <!-- âœ… SORT TRADE LIST BY SCORE (highest first) before using it -->
            <!-- This ensures AI validates the best trades first -->
            <!-- âœ… OPTIMIZATION #5: Optimize sort for small lists (â‰¤10 items: O(n) vs O(nÂ²)) -->
            <do_if value="$tradeList.count gt 10">
              <!-- Large list: Full selection sort (necessary for proper ordering) -->
              <set_value name="$sortedTradeList" exact="[]"/>
              <set_value name="$remainingTrades" exact="$tradeList"/>
              <do_all exact="$tradeList.count" counter="$sortIdx">
                <set_value name="$maxScore" exact="-999999999"/>
                <set_value name="$maxIdx" exact="-1"/>
                <do_all exact="$remainingTrades.count" counter="$i">
                  <set_value name="$trade" exact="$remainingTrades.{$i}"/>
                  <set_value name="$tradeScore" exact="$trade.$Score"/>
                  <do_if value="$tradeScore gt $maxScore">
                    <set_value name="$maxScore" exact="$tradeScore"/>
                    <set_value name="$maxIdx" exact="$i"/>
                  </do_if>
                </do_all>
                <do_if value="$maxIdx ge 0">
                  <append_to_list name="$sortedTradeList" exact="$remainingTrades.{$maxIdx}"/>
                  <remove_value name="$remainingTrades.{$maxIdx}"/>
                </do_if>
              </do_all>
              <set_value name="$tradeList" exact="$sortedTradeList"/>
            </do_if>
            <do_elseif value="$tradeList.count gt 1">
              <!-- Small list (2-10): Single pass bubble-like sort (O(nÂ²) but n is small) -->
              <set_value name="$sortedTradeList" exact="$tradeList"/>
              <!-- Single pass: swap adjacent elements if wrong order (n-1 comparisons) -->
              <do_all exact="$tradeList.count - 1" counter="$pass">
                <set_value name="$swapped" exact="false"/>
                <do_all exact="$tradeList.count - 1 - $pass" counter="$i">
                  <set_value name="$currentScore" exact="$sortedTradeList.{$i}.$Score"/>
                  <set_value name="$nextScore" exact="$sortedTradeList.{$i + 1}.$Score"/>
                  <do_if value="$currentScore lt $nextScore">
                    <!-- Swap -->
                    <set_value name="$temp" exact="$sortedTradeList.{$i}"/>
                    <set_value name="$sortedTradeList.{$i}" exact="$sortedTradeList.{$i + 1}"/>
                    <set_value name="$sortedTradeList.{$i + 1}" exact="$temp"/>
                    <set_value name="$swapped" exact="true"/>
                  </do_if>
                </do_all>
                <!-- Early exit if no swaps (already sorted) -->
                <do_if value="not $swapped">
                  <break/>
                </do_if>
              </do_all>
              <set_value name="$tradeList" exact="$sortedTradeList"/>
            </do_elseif>
            <!-- Single item or empty: no sort needed -->
            
            <!-- Update bestTrade and bestScore from diverse list for backward compatibility -->
            <!-- âœ… FIX: Use library function for consistent validation -->
            <set_value name="$bestTrade" exact="null"/>
            <set_value name="$bestScore" exact="0"/>
            <do_all exact="$tradeList.count" counter="$i">
              <set_value name="$trade" exact="$tradeList.{$i}"/>
              <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$isValid">
                <param name="trade" value="$trade"/>
                <param name="minScore" value="$bestScore"/>
              </run_actions>
              <do_if value="$isValid">
                <set_value name="$testScore" exact="@$trade.$Score"/>
                <set_value name="$bestScore" exact="$testScore"/>
                <set_value name="$bestTrade" exact="$trade"/>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- âœ… RESET COOLDOWN: If cache hit, reset cooldown for this ship -->
          <do_if value="$foundCachedTrade">
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <!-- Cache worked - reset cooldown to allow immediate live search if needed in future -->
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
            <!-- âœ… FALLBACK COOLDOWN: Clear fallback flag when cache search succeeds (new successful cycle) -->
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_FallbackAttempted exists -->
            <do_if value="global.$GT_FallbackAttempted.{$ship}?">
              <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Log cache retrieval results -->
          <do_if value="@global.$GT_Config.$Debug.$Enabled">
            <do_if value="@global.$GT_Config.$Debug.$LogLevel ge 2">
              <do_if value="$foundCachedTrade">
                <debug_text text="'[GT-Cache] âœ… Cache HIT for ' + $ship.idcode + ': Found cached trade (Score: ' + $bestScore + ', checked: ' + $checkedEntries + ', valid: ' + $validEntries + ', expired: ' + $expiredEntries + ', diverse list: ' + $tradeList.count + ' trades)'" chance="100"/>
              </do_if>
              <do_else>
                <!-- Log why cache miss occurred -->
                <set_value name="$missReason" exact="''"/>
                <do_if value="$checkedEntries == 0">
                  <set_value name="$missReason" exact="'Cache empty'"/>
                </do_if>
                <do_else>
                  <!-- Count filtered entries from statistics -->
                  <set_value name="$totalFiltered" exact="0"/>
                  <set_value name="$filterBreakdown" exact="''"/>
                  <do_all exact="$tradesByWareBeforeFiltering.keys.count" counter="$wIdx">
                    <set_value name="$w" exact="$tradesByWareBeforeFiltering.keys.{$wIdx}"/>
                    <set_value name="$wStats" exact="$tradesByWareBeforeFiltering.{$w}"/>
                    <set_value name="$totalFiltered" exact="$totalFiltered + $wStats.$filtered"/>
                    <!-- Build breakdown for top filter reasons -->
                    <set_value name="$topFilters" exact="''"/>
                    <do_if value="$wStats.$outOfRange gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$outOfRange + ' outOfRange'"/>
                    </do_if>
                    <do_if value="$wStats.$distanceConstraint gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$distanceConstraint + ' tooFar'"/>
                    </do_if>
                    <do_if value="$wStats.$unreachable gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$unreachable + ' unreachable'"/>
                    </do_if>
                    <do_if value="$wStats.$efficiencyThreshold gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$efficiencyThreshold + ' lowEfficiency'"/>
                    </do_if>
                    <do_if value="$wStats.$roiBelowThreshold gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$roiBelowThreshold + ' roiLow'"/>
                    </do_if>
                    <do_if value="$wStats.$profitTooLow gt 0">
                      <set_value name="$topFilters" exact="$topFilters + (if $topFilters != '' then ', ' else '') + $wStats.$profitTooLow + ' profitLow'"/>
                    </do_if>
                    <do_if value="$topFilters != ''">
                      <set_value name="$filterBreakdown" exact="$filterBreakdown + (if $filterBreakdown != '' then ' | ' else '') + @$w.name + ': [' + $topFilters + ']'"/>
                    </do_if>
                  </do_all>
                  <set_value name="$missReason" exact="$totalFiltered + ' filtered (' + (if $filterBreakdown != '' then $filterBreakdown else 'no details') + ')'"/>
                </do_else>
                <debug_text text="'[GT-Cache] âŒ Cache MISS for ' + $ship.idcode + ': No valid cached trades (checked: ' + $checkedEntries + ', expired: ' + $expiredEntries + ', ' + $missReason + ', maxDistance: ' + $maxDistance + ')'" chance="100"/>
              </do_else>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- âœ… PERFORMANCE: Blacklist validation removed from cache search -->
        <!-- Blacklist checks now happen ONLY in ExecuteTrade (catches mid-search updates) -->
        <!-- ExecuteTrade will try next trade from TradeList if current trade is blacklisted -->
        
        <!-- Return results via global variable (include valid entries count for diagnostics) -->
        <!-- âœ… CRITICAL FIX: Preserve LastRejectionStats when updating global.$GT_SearchResult -->
        <set_value name="$preservedLastRejectionStats" exact="null"/>
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
        <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
          <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
        </do_if>
        
        <set_value name="global.$GT_SearchResult" exact="table[
          $Found = ($foundCachedTrade and $tradeList.count gt 0 and $bestTrade?),
          $BestTrade = $bestTrade,
          $BestScore = $bestScore,
          $TradeList = $tradeList,
          $ValidEntries = $validEntries,
          $DiverseListCount = $tradeList.count
        ]"/>
        
        <!-- âœ… CRITICAL FIX: Restore LastRejectionStats after updating global.$GT_SearchResult -->
        <do_if value="$preservedLastRejectionStats?">
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- Search Live Trades (Sub-module) -->
    <cue name="SearchLiveTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <!-- Extract all parameters -->
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance for normal searches -->
        <do_if value="$params.$OriginalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$params.$OriginalMaxDistance"/>  <!-- Fallback search: use original pilot maxDistance -->
        </do_if>
        <set_value name="$minROI" exact="$params.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="$params.$FactionPriority"/>
        <set_value name="$factionPriorityText" exact="$params.$FactionPriorityText"/>
        <set_value name="$distancePenaltyMultiplier" exact="$params.$DistancePenaltyMultiplier"/>
        <set_value name="$skillLevel" exact="$params.$SkillLevel"/>
        <set_value name="$gt_ThreatIntel" exact="$params.$ThreatIntel"/>
        <set_value name="$gt_FleetCoord" exact="$params.$FleetCoord"/>
        <set_value name="$gt_AdvancedAnalytics" exact="$params.$AdvancedAnalytics"/>
        
        <!-- NOTE: Do NOT clear failed trades here - we need to check them AFTER finding best trade -->
        <!-- Failed trades are only cleared on success (in gt_trading_signals.xml) -->
        
        <!-- VERSION LOG - COMMENTED OUT (reduces log spam) -->
        <!-- <debug_text text="'[GT-Search] ðŸš€ CODE VERSION: 2025-10-25-v5 (Score Bug Fixed) | Ship: ' + $ship.idcode" chance="100"/> -->
        
        <!-- Get failed trades for this ship (needed for filtering during best trade selection) -->
        <set_value name="$failedTrades" exact="[]"/>
        <do_if value="global.$GT_FailedTrades? and global.$GT_FailedTrades.{$ship}?">
          <set_value name="$failedTrades" exact="global.$GT_FailedTrades.{$ship}"/>
        </do_if>
        
        <!-- âœ… NEW: Collect top trades instead of just best one -->
        <!-- Use global setting for max trades to return -->
        <set_value name="$tradeList" exact="[]"/>
        <set_value name="$maxTradesToReturn" exact="200"/> <!-- Default fallback -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn?">
          <set_value name="$maxTradesToReturn" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn"/>
        </do_if>
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$stationsEvaluated" exact="0"/>
        <set_value name="$offersFound" exact="0"/>
        
        <!-- ===== DETERMINE HOME SECTOR ===== -->
        <!-- âœ… CRITICAL: Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <set_value name="$homeBase" exact="null"/>
        <set_value name="$homeBaseSource" exact="'unknown'"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
            <do_if value="$commanderHome? and $commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
              <set_value name="$homeBaseSource" exact="'commander (subordinate)'"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- âœ… For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
          <set_value name="$homeBaseSource" exact="'defaultorder'"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
            <set_value name="$homeBaseSource" exact="'GT_AIParameters (fallback)'"/>
          </do_if>
          <do_else>
            <!-- âŒ REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
            <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null! This should never happen.'" chance="100"/>
            <!-- Emergency fallback only - this should never happen -->
            <set_value name="$homeBase" exact="$ship.sector"/>
            <set_value name="$homeBaseSource" exact="'ship.sector (EMERGENCY - WILL CAUSE DRIFT!)'"/>
          </do_else>
        </do_if>
        
        <!-- Extract sector -->
        <set_value name="$homeSector" exact="null"/>
        <set_value name="$homeSectorAnchor" exact="null"/>
        <do_if value="$homeBase? and $homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
            <set_value name="$homeSectorAnchor" exact="$homeBase"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
            <set_value name="$homeSectorAnchor" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
          <!-- Emergency fallback only - this should never happen -->
          <set_value name="$homeSector" exact="$ship.sector"/>
          <set_value name="$homeSectorAnchor" exact="$ship.sector"/>
        </do_if>
        
        <!-- âœ… PERFORMANCE OPTIMIZATION: Ensure homeSectorAnchor is set (for match_gate_distance) -->
        <do_if value="not $homeSectorAnchor? or not $homeSectorAnchor.exists">
          <set_value name="$homeSectorAnchor" exact="$homeSector"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸ  Home base: ' + @$homeBase.knownname + ' (sector: ' + $homeSector.knownname + ') [source: ' + $homeBaseSource + ']'" chance="100"/>
        </do_if>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- âœ… NATIVE ACTION REFACTORING: Use C++ trade offer search instead of MD loops  -->
        <!-- Replaces 2000+ station iterations with single galaxy-wide native C++ queries  -->
        <!-- Performance: 10-100Ã— faster, ZERO stutter (C++ code executes in one frame)   -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        
        <!-- Get AI parameters for filtering -->
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        
        <!-- âœ… CRITICAL: Initialize $wareBasket safely (memory:10529400 - ? checks existence, not null) -->
        <!-- Step 1: Initialize to safe default FIRST -->
        <set_value name="$wareBasket" exact="[]"/>
        <!-- Step 2: Check if source exists -->
        <do_if value="global.$GT_AIParameters.{$ship}.$WareBasket?">
          <!-- Step 3: Get value with @ (returns null if missing) -->
          <set_value name="$tempBasket" exact="@global.$GT_AIParameters.{$ship}.$WareBasket"/>
          <!-- Step 4: Check if tempBasket is not null before accessing properties -->
          <do_if value="$tempBasket? and $tempBasket != null">
            <!-- Step 5: Extract count property with @ to check if result is valid list -->
            <set_value name="$tempCount" exact="@$tempBasket.count"/>
            <!-- Step 6: Check if COUNT result exists and is valid (>= 0 means it's a list, not null) -->
            <do_if value="$tempCount? and $tempCount != null and $tempCount ge 0">
              <!-- Step 7: Now safe to use the original temp value -->
              <set_value name="$wareBasket" exact="$tempBasket"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Determine ship's blacklistgroup -->
        <run_actions ref="md.GT_Blacklist_Utilities.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- âœ… ISOLATION CHECK: For isolated ships, collect offers from current sector ONLY -->
        <!-- Check isolation status before collecting offers to optimize collection -->
        <set_value name="$currentSector" exact="$ship.sector"/>
        <set_value name="$shipIsIsolated" exact="false"/>
        <set_value name="$searchSpace" exact="player.galaxy"/>
        <!-- Price range: Load from global config with defaults -->
        <!-- âœ… DIVERSITY FOR SCORING: Include both best and worse offers for diverse trade selection -->
        <!-- Scoring system evaluates multiple wares and combines offers, so we need a wide range -->
        <!-- Includes very cheap offers (best) AND moderately expensive ones (worse) for diversity -->
        <!-- âœ… FALLBACK SEARCH: Check if this is a fallback search (MaxDistance == 2) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$maxDistance == 2">
          <set_value name="$isFallbackSearch" exact="true"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Fallback search: Will search galaxy-wide and filter by distance from current position (max 2 jumps)'" chance="100"/>
          </do_if>
        </do_if>
        
        <set_value name="$sellPriceMax" exact="0.5"/>  <!-- Default fallback -->
        <set_value name="$buyPriceMin" exact="-0.5"/>  <!-- Default fallback -->
        <do_if value="global.$GT_Config? and global.$GT_Config.$Trading?">
          <!-- Use fallback price ranges if this is a fallback search -->
          <do_if value="$isFallbackSearch">
            <do_if value="global.$GT_Config.$Trading.$FallbackSellPriceMax?">
              <set_value name="$sellPriceMax" exact="@global.$GT_Config.$Trading.$FallbackSellPriceMax"/>
            </do_if>
            <do_if value="global.$GT_Config.$Trading.$FallbackBuyPriceMin?">
              <set_value name="$buyPriceMin" exact="@global.$GT_Config.$Trading.$FallbackBuyPriceMin"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Normal search - use normal price ranges -->
            <do_if value="global.$GT_Config.$Trading.$SellPriceMax?">
              <set_value name="$sellPriceMax" exact="@global.$GT_Config.$Trading.$SellPriceMax"/>
            </do_if>
            <do_if value="global.$GT_Config.$Trading.$BuyPriceMin?">
              <set_value name="$buyPriceMin" exact="@global.$GT_Config.$Trading.$BuyPriceMin"/>
            </do_if>
          </do_else>
        </do_if>
        <do_if value="$currentSector?">
          <!-- Quick isolation check: Check if all connected sectors are blacklisted -->
          <run_actions ref="md.GT_Blacklist_Utilities.GT_CheckConnectedSectorsBlacklisted" result="$isolationCheck">
            <param name="sector" value="$currentSector"/>
            <param name="ship" value="$ship"/>
            <param name="returnDetails" value="false"/>
          </run_actions>
          <set_value name="$isolatedValue" exact="@$isolationCheck.$IsIsolated"/>
          <set_value name="$shipIsIsolated" exact="if $isolatedValue? and ($isolatedValue == true or $isolatedValue == 1) then true else false"/>
          <do_if value="$shipIsIsolated">
            <!-- Ship is isolated - search only in current sector with expanded price range -->
            <set_value name="$searchSpace" exact="$currentSector"/>
            <!-- âœ… ISOLATION PRICE RELAXATION: Use isolated-specific price ranges from config -->
            <do_if value="global.$GT_Config? and global.$GT_Config.$Trading?">
              <do_if value="global.$GT_Config.$Trading.$IsolatedSellPriceMax?">
                <set_value name="$sellPriceMax" exact="@global.$GT_Config.$Trading.$IsolatedSellPriceMax"/>
              </do_if>
              <do_if value="global.$GT_Config.$Trading.$IsolatedBuyPriceMin?">
                <set_value name="$buyPriceMin" exact="@global.$GT_Config.$Trading.$IsolatedBuyPriceMin"/>
              </do_if>
            </do_if>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$sectorName" exact="@$currentSector.knownname"/>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”’ ISOLATED: Collecting offers from current sector only: ' + (if $sectorName? then $sectorName else 'NULL') + ' (price range expanded: sell max=' + $sellPriceMax + ', buy min=' + $buyPriceMin + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- âœ… NATIVE C++ ACTION: Find all sell offers (ship buys FROM these stations) -->
        <!-- This single call replaces ~2000 station iterations! -->
        <!-- âœ… FIX: Check for null before accessing .count (memory:10529400) -->
        <!-- NOTE: match_gate_distance is NOT supported in find_sell_offer/find_buy_offer (X4 limitation) -->
        <!-- Distance filtering happens at MD level after native query returns results -->
        <do_if value="$wareBasket? and $wareBasket != null and $wareBasket.count gt 0">
          <!-- Manual ware selection: query specific wares -->
          <find_sell_offer 
            tradepartner="$ship" 
            space="$searchSpace" 
            result="$allSellOffers" 
            wares="$wareBasket" 
            multiple="true">
            <match_seller tradesknownto="$ship.owner">
              <match_relation_to object="$ship" relation="dock" comparison="ge"/>
              <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
            </match_seller>
            <relativeprice max="$sellPriceMax"/>
            <amount min="10"/>
            <totalvolume min="100"/>
          </find_sell_offer>
        </do_if>
        <do_else>
          <!-- Auto wares: query all compatible wares -->
          <find_sell_offer 
            tradepartner="$ship" 
            space="$searchSpace" 
            result="$allSellOffers" 
            multiple="true">
            <match_seller tradesknownto="$ship.owner">
              <match_relation_to object="$ship" relation="dock" comparison="ge"/>
              <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
            </match_seller>
            <relativeprice max="$sellPriceMax"/>
            <amount min="10"/>
            <totalvolume min="100"/>
          </find_sell_offer>
        </do_else>
        
        <!-- âœ… NATIVE C++ ACTION: Find all buy offers (ship sells TO these stations) -->
        <!-- Note: $wareBasket already initialized above as empty list if null -->
        <!-- âœ… FIX: Check for null before accessing .count (memory:10529400) -->
        <!-- NOTE: match_gate_distance is NOT supported in find_sell_offer/find_buy_offer (X4 limitation) -->
        <!-- Distance filtering happens at MD level after native query returns results -->
        <do_if value="$wareBasket? and $wareBasket != null and $wareBasket.count gt 0">
          <find_buy_offer 
            tradepartner="$ship" 
            space="$searchSpace" 
            result="$allBuyOffers" 
            wares="$wareBasket" 
            multiple="true">
            <match_buyer tradesknownto="$ship.owner">
              <match_relation_to object="$ship" relation="dock" comparison="ge"/>
              <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
            </match_buyer>
            <relativeprice min="$buyPriceMin"/>
            <amount min="10"/>
            <totalvolume min="100"/>
          </find_buy_offer>
        </do_if>
        <do_else>
          <find_buy_offer 
            tradepartner="$ship" 
            space="$searchSpace" 
            result="$allBuyOffers" 
            multiple="true">
            <match_buyer tradesknownto="$ship.owner">
              <match_relation_to object="$ship" relation="dock" comparison="ge"/>
              <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
            </match_buyer>
            <relativeprice min="$buyPriceMin"/>
            <amount min="10"/>
            <totalvolume min="100"/>
          </find_buy_offer>
        </do_else>
        
        <!-- âœ… FALLBACK SEARCH: Filter offers by distance from CURRENT POSITION (max 2 jumps) -->
        <!-- For fallback search, we filter by distance from ship's current position, not home sector -->
        <!-- tradepartner already filters by distance, but we need to enforce max 2 jumps -->
        <do_if value="$isFallbackSearch and ($allSellOffers.count gt 0 or $allBuyOffers.count gt 0)">
          <set_value name="$currentSectorForFilter" exact="$ship.sector"/>
          <set_value name="$sellOffersFiltered" exact="0"/>
          <set_value name="$buyOffersFiltered" exact="0"/>
          
          <!-- Filter sell offers by distance from current position (max 2 jumps) -->
          <do_if value="$allSellOffers.count gt 0">
            <set_value name="$filteredSellOffers" exact="[]"/>
            <do_all exact="$allSellOffers.count" counter="$i">
              <set_value name="$offer" exact="$allSellOffers.{$i}"/>
              <set_value name="$station" exact="@$offer.owner"/>
              <set_value name="$stationSector" exact="@$station.sector"/>
              <set_value name="$distance" exact="-1"/>
              <do_if value="$stationSector == $currentSectorForFilter">
                <set_value name="$distance" exact="0"/>
              </do_if>
              <do_else>
                <set_value name="$distance" exact="$currentSectorForFilter.gatedistance.{$stationSector}"/>
              </do_else>
              <!-- Only keep offers from stations within 2 jumps -->
              <do_if value="$distance ge 0 and $distance le 2">
                <append_to_list name="$filteredSellOffers" exact="$offer"/>
              </do_if>
              <do_else>
                <set_value name="$sellOffersFiltered" exact="$sellOffersFiltered + 1"/>
              </do_else>
            </do_all>
            <set_value name="$allSellOffers" exact="$filteredSellOffers"/>
          </do_if>
          
          <!-- Filter buy offers by distance from current position (max 2 jumps) -->
          <do_if value="$allBuyOffers.count gt 0">
            <set_value name="$filteredBuyOffers" exact="[]"/>
            <do_all exact="$allBuyOffers.count" counter="$i">
              <set_value name="$offer" exact="$allBuyOffers.{$i}"/>
              <set_value name="$station" exact="@$offer.owner"/>
              <set_value name="$stationSector" exact="@$station.sector"/>
              <set_value name="$distance" exact="-1"/>
              <do_if value="$stationSector == $currentSectorForFilter">
                <set_value name="$distance" exact="0"/>
              </do_if>
              <do_else>
                <set_value name="$distance" exact="$currentSectorForFilter.gatedistance.{$stationSector}"/>
              </do_else>
              <!-- Only keep offers from stations within 2 jumps -->
              <do_if value="$distance ge 0 and $distance le 2">
                <append_to_list name="$filteredBuyOffers" exact="$offer"/>
              </do_if>
              <do_else>
                <set_value name="$buyOffersFiltered" exact="$buyOffersFiltered + 1"/>
              </do_else>
            </do_all>
            <set_value name="$allBuyOffers" exact="$filteredBuyOffers"/>
          </do_if>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <do_if value="$sellOffersFiltered gt 0 or $buyOffersFiltered gt 0">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Fallback: Filtered ' + $sellOffersFiltered + ' sell, ' + $buyOffersFiltered + ' buy offers (beyond 2 jumps from current position)'" chance="100"/>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') âœ… Fallback: Remaining offers within 2 jumps: ' + $allSellOffers.count + ' sell, ' + $allBuyOffers.count + ' buy'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Initialize counters -->
        <set_value name="$totalFilteredIllegal" exact="0"/>
        <set_value name="$stationsSkipped" exact="0"/>
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <!-- âœ… OPTIMIZATION 1: $tradesRejectedBlacklist removed (safety net eliminated) -->
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$offersFound" exact="$allSellOffers.count + $allBuyOffers.count"/>
        <set_value name="$stationsEvaluated" exact="0"/>  <!-- Not applicable with native actions -->
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš¡ NATIVE ACTIONS: Collected ' + $allSellOffers.count + ' sell + ' + $allBuyOffers.count + ' buy offers (instant C++ query)'" chance="100"/>
          <!-- âœ… DIAGNOSTIC: If native query returns 0 offers, test with minimal filters to find blocker -->
          <!-- âœ… PERFORMANCE OPTIMIZATION: Guard diagnostic queries behind dedicated flag (4 galaxy-wide scans are expensive!) -->
          <do_if value="$offersFound == 0 and global.$GT_Config.$Debug.$DiagnosticQueries">
            <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') âš ï¸ Native query returned 0 offers with filters: dockable=true, enemy=false, amountâ‰¥100, totalvolumeâ‰¥100, sellPriceâ‰¤average, buyPriceâ‰¥average'" chance="100"/>
            <!-- Test query with ONLY tradesknownto (no other filters) to see if offers exist -->
            <set_value name="$testSellOffers" exact="[]"/>
            <set_value name="$testBuyOffers" exact="[]"/>
            <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$testSellOffers" multiple="true">
              <match_seller tradesknownto="$ship.owner"/>
              <!-- NO other filters - just test if offers exist -->
            </find_sell_offer>
            <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$testBuyOffers" multiple="true">
              <match_buyer tradesknownto="$ship.owner"/>
              <!-- NO other filters - just test if offers exist -->
            </find_buy_offer>
            <set_value name="$testOffersFound" exact="$testSellOffers.count + $testBuyOffers.count"/>
            <do_if value="$testOffersFound gt 0">
              <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') âœ… Found ' + $testOffersFound + ' offers with MINIMAL filters (tradesknownto only) - testing individual filters...'" chance="100"/>
              
              <!-- Test 1: tradesknownto + dock (no enemy, no relativeprice) -->
              <set_value name="$test1Sell" exact="[]"/>
              <set_value name="$test1Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test1Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                </match_seller>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test1Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                </match_buyer>
              </find_buy_offer>
              <set_value name="$test1Found" exact="$test1Sell.count + $test1Buy.count"/>
              <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 1 (tradesknownto+dock): ' + $test1Found + ' offers'" chance="100"/>
              
              <!-- Test 2: tradesknownto + dock + enemy (no relativeprice) -->
              <set_value name="$test2Sell" exact="[]"/>
              <set_value name="$test2Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test2Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_seller>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test2Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_buyer>
              </find_buy_offer>
              <set_value name="$test2Found" exact="$test2Sell.count + $test2Buy.count"/>
              <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 2 (+enemy filter): ' + $test2Found + ' offers'" chance="100"/>
              
              <!-- Test 3: tradesknownto + dock + enemy + relativeprice -->
              <set_value name="$test3Sell" exact="[]"/>
              <set_value name="$test3Buy" exact="[]"/>
              <find_sell_offer tradepartner="$ship" space="player.galaxy" result="$test3Sell" multiple="true">
                <match_seller tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_seller>
                <relativeprice max="0.0"/>
              </find_sell_offer>
              <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$test3Buy" multiple="true">
                <match_buyer tradesknownto="$ship.owner">
                  <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                  <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
                </match_buyer>
                <relativeprice min="0.0"/>
              </find_buy_offer>
              <set_value name="$test3Found" exact="$test3Sell.count + $test3Buy.count"/>
              <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') Test 3 (+relativeprice): ' + $test3Found + ' offers (BLOCKING FILTER IDENTIFIED!)'" chance="100"/>
              
            </do_if>
            <do_else>
              <debug_text text="'[GT-Cache-DIAG] (' + $ship.idcode + ') âŒ Even MINIMAL query (tradesknownto only) returns 0 offers - ship may not know about any stations'" chance="100"/>
            </do_else>
          </do_if>
          <!-- âœ… PERFORMANCE OPTIMIZATION: End of diagnostic queries block (guarded by DiagnosticQueries flag) -->
          <do_elseif value="$offersFound == 0">
            <!-- Silent skip when diagnostic queries disabled (normal play) -->
          </do_elseif>
        </do_if>
        
        <!-- âœ… UNIVERSAL CACHE: Native actions filtered by:
             - known stations (tradesknownto)
             - docking relation (match_relation_to dock) - only dockable stations
             - faction relations (match_relation_to enemy not) - exclude enemy factions
             - sell price (relativeprice max=0.0) - average price or below (was 0.5 - too lenient)
             - buy price (relativeprice min=0.0) - at least average selling price (was 1.0 - too strict!)
             - amount (min=100) - minimum 100 items
             - total volume (min=100) - minimum total trade volume
             âŒ NO blacklist filtering (ship-specific, applied at retrieval)
             âŒ NO illegal ware filtering (ship-specific, applied at retrieval)
             âœ… Distance range filtering only (universal validation)
        -->
        
        <!-- ===== PRE-FILTER DISTANCE (RANGE-ONLY) ===== -->
        <!-- âœ… UNIVERSAL CACHE: Filter by distance range only (from home sector) -->
        <!-- âœ… FALLBACK SEARCH: For fallback search, use originalMaxDistance (pilot's maxDistance) instead of maxDistance (2) -->
        <!-- Path validation is ship-specific and happens during cache retrieval -->
        <do_if value="($allSellOffers.count gt 0 or $allBuyOffers.count gt 0) and $maxDistance? and $maxDistance gt 0">
          <set_value name="$sellOffersDistanceFiltered" exact="0"/>
          <set_value name="$buyOffersDistanceFiltered" exact="0"/>
          
          <!-- âœ… FALLBACK SEARCH: Use originalMaxDistance for filtering from home sector if available -->
          <set_value name="$homeSectorMaxDistance" exact="$maxDistance"/>
          <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
            <set_value name="$homeSectorMaxDistance" exact="$originalMaxDistance"/>
          </do_if>
          
          <!-- Filter sell offers by distance range (using library function) -->
          <do_if value="$allSellOffers.count gt 0">
            <run_actions ref="md.GT_Trade_Utilities.GT_FilterOffersByDistance" result="$sellFilterResult">
              <param name="offersList" value="$allSellOffers"/>
              <param name="homeSector" value="$homeSector"/>
              <param name="maxDistance" value="$homeSectorMaxDistance"/>
            </run_actions>
            <set_value name="$allSellOffers" exact="$sellFilterResult.$FilteredOffers"/>
            <set_value name="$sellOffersDistanceFiltered" exact="$sellFilterResult.$FilteredCount"/>
          </do_if>
          
          <!-- Filter buy offers by distance range (using library function) -->
          <do_if value="$allBuyOffers.count gt 0">
            <run_actions ref="md.GT_Trade_Utilities.GT_FilterOffersByDistance" result="$buyFilterResult">
              <param name="offersList" value="$allBuyOffers"/>
              <param name="homeSector" value="$homeSector"/>
              <param name="maxDistance" value="$homeSectorMaxDistance"/>
            </run_actions>
            <set_value name="$allBuyOffers" exact="$buyFilterResult.$FilteredOffers"/>
            <set_value name="$buyOffersDistanceFiltered" exact="$buyFilterResult.$FilteredCount"/>
          </do_if>
          
          <!-- Debug logging -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <do_if value="$sellOffersDistanceFiltered gt 0 or $buyOffersDistanceFiltered gt 0">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ðŸ“ PRE-FILTERED distance (range-only): ' + $sellOffersDistanceFiltered + ' sell, ' + $buyOffersDistanceFiltered + ' buy (max: ' + $homeSectorMaxDistance + ' jumps from home)'" chance="100"/>
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âœ… Offers within range: ' + $allSellOffers.count + ' sell, ' + $allBuyOffers.count + ' buy'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- ===== CROSS-STATION TRADE MATCHING ===== -->
        <do_if value="$allSellOffers.count gt 0 and $allBuyOffers.count gt 0">
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Total offers before indexing: ' + $allSellOffers.count + ' sell, ' + $allBuyOffers.count + ' buy'" chance="100"/>
          </do_if>
          
          <!-- âœ… OPTIMIZATION: Calculate available money ONCE (before loops, not inside) -->
          <set_value name="$availableMoney" exact="player.money"/>
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
          <do_if value="$homeBase? and $homeBase.exists and $homeBase.isclass.station">
            <set_value name="$availableMoney" exact="$homeBase.money"/>
          </do_if>
          
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          <!-- âœ… CRITICAL OPTIMIZATION: Index & Limit BEFORE Distance Calculation -->
          <!-- OLD: Calculate gatedistance for 3,859 stations, THEN limit to top 5 per ware -->
          <!-- NEW: Limit to top 5 per ware FIRST, THEN calculate gatedistance for ~250 stations -->
          <!-- Impact: 3,859 â†’ 250 pathfinding calls = 93.5% reduction = ELIMINATES STUTTER! -->
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          
          <!-- STEP 1: Index offers by ware (using library function) -->
          <run_actions ref="md.GT_Trade_Utilities.GT_IndexOffersByWare" result="$sellOffersByWare">
            <param name="offersList" value="$allSellOffers"/>
          </run_actions>
          <run_actions ref="md.GT_Trade_Utilities.GT_IndexOffersByWare" result="$buyOffersByWare">
            <param name="offersList" value="$allBuyOffers"/>
          </run_actions>
          
          <!-- STEP 2: Per-ware sort & limit (reduces to ~5 per ware Ã— 50 wares = ~250 stations) -->
          <!-- Use global setting for max offers per ware -->
          <set_value name="$maxOffersPerWare" exact="200"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare?">
            <set_value name="$maxOffersPerWare" exact="global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare"/>
          </do_if>
          <set_value name="$limitedSellOffers" exact="[]"/>
          <set_value name="$limitedBuyOffers" exact="[]"/>
          
          <!-- Process each ware's sell offers (using library function) -->
          <do_all exact="$sellOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$sellOffersByWare.keys.{$wareIdx}"/>
            <set_value name="$offersForWare" exact="$sellOffersByWare.{$ware}"/>
            
            <!-- Sort and limit (ascending = lowest price for buy offers) -->
            <run_actions ref="md.GT_Trade_Utilities.GT_SortAndLimitOffers" result="$limitedForWare">
              <param name="offersList" value="$offersForWare"/>
              <param name="maxCount" value="$maxOffersPerWare"/>
              <param name="sortAscending" value="true"/>
            </run_actions>
            <do_all exact="$limitedForWare.count" counter="$idx">
              <append_to_list name="$limitedSellOffers" exact="$limitedForWare.{$idx}"/>
            </do_all>
          </do_all>
          
          <!-- Process each ware's buy offers (using library function) -->
          <do_all exact="$buyOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$buyOffersByWare.keys.{$wareIdx}"/>
            <set_value name="$offersForWare" exact="$buyOffersByWare.{$ware}"/>
            
            <!-- Sort and limit (descending = highest price for sell offers) -->
            <run_actions ref="md.GT_Trade_Utilities.GT_SortAndLimitOffers" result="$limitedForWare">
              <param name="offersList" value="$offersForWare"/>
              <param name="maxCount" value="$maxOffersPerWare"/>
              <param name="sortAscending" value="false"/>
            </run_actions>
            <do_all exact="$limitedForWare.count" counter="$idx">
              <append_to_list name="$limitedBuyOffers" exact="$limitedForWare.{$idx}"/>
            </do_all>
          </do_all>
          
          <!-- Replace original lists with limited lists -->
          <set_value name="$allSellOffers" exact="$limitedSellOffers"/>
          <set_value name="$allBuyOffers" exact="$limitedBuyOffers"/>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') âš¡ OPTIMIZED: Limited to ' + $allSellOffers.count + ' sell + ' + $allBuyOffers.count + ' buy offers (top ' + $maxOffersPerWare + ' per ware)'" chance="100"/>
          </do_if>
          
          <!-- STEP 3: NOW calculate distances for LIMITED set only (93.5% fewer calls!) -->
          <!-- Re-index limited offers by ware for matching (using library function) -->
          <run_actions ref="md.GT_Trade_Utilities.GT_IndexOffersByWare" result="$sellOffersByWare">
            <param name="offersList" value="$allSellOffers"/>
          </run_actions>
          <run_actions ref="md.GT_Trade_Utilities.GT_IndexOffersByWare" result="$buyOffersByWare">
            <param name="offersList" value="$allBuyOffers"/>
          </run_actions>
          
          <!-- STEP 4: Calculate distances for LIMITED offers only (using library function) -->
          <run_actions ref="md.GT_Pathfinding_Utilities.GT_BuildStationDistanceCache" result="$stationDistanceCache">
            <param name="sellOffers" value="$allSellOffers"/>
            <param name="buyOffers" value="$allBuyOffers"/>
            <param name="homeSector" value="$homeSector"/>
          </run_actions>
          
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          <!-- âœ… BATCH PROCESSOR PREPARATION: Build data structures for per-ware processing -->
          <!-- Trade matching will be done by batch processor (one ware per batch, 10ms delay) -->
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          
          <!-- Get failed trades and reserved routes -->
          <set_value name="$failedTrades" exact="[]"/>
          <do_if value="global.$GT_FailedTrades? and global.$GT_FailedTrades.{$ship}?">
            <set_value name="$failedTrades" exact="global.$GT_FailedTrades.{$ship}"/>
          </do_if>
          
          <set_value name="$reservedRoutes" exact="[]"/>
          <do_if value="global.$GT_ActiveTradeReservations? and global.$GT_GlobalSettings.$Fleet.$EnableFleetCoordination">
            <do_all exact="global.$GT_ActiveTradeReservations.keys.count" counter="$resIdx">
              <set_value name="$otherShip" exact="global.$GT_ActiveTradeReservations.keys.{$resIdx}"/>
              <do_if value="$otherShip != $ship and $otherShip.exists">
                <set_value name="$otherRoute" exact="global.$GT_ActiveTradeReservations.{$otherShip}"/>
                <do_if value="$otherRoute.$BuyStation? and $otherRoute.$SellStation? and $otherRoute.$Ware?">
                  <do_if value="$otherRoute.$BuyStation.idcode? and $otherRoute.$SellStation.idcode?">
                    <set_value name="$cacheKey" exact="$otherRoute.$BuyStation.idcode + '_' + $otherRoute.$SellStation.idcode + '_' + $otherRoute.$Ware"/>
                    <append_to_list name="$reservedRoutes" exact="$cacheKey"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- Build list of wares that have BOTH sell and buy offers -->
          <set_value name="$wareKeysList" exact="[]"/>
          <do_all exact="$sellOffersByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$sellOffersByWare.keys.{$wareIdx}"/>
            <do_if value="$buyOffersByWare.{$ware}?">
              <append_to_list name="$wareKeysList" exact="$ware"/>
            </do_if>
          </do_all>
          
          <!-- Build sell offers list (one entry per ware) -->
          <set_value name="$sellOffersList" exact="[]"/>
          <do_all exact="$wareKeysList.count" counter="$i">
            <set_value name="$ware" exact="$wareKeysList.{$i}"/>
            <append_to_list name="$sellOffersList" exact="table[
              $ware = $ware,
              $offers = $sellOffersByWare.{$ware}
            ]"/>
          </do_all>
          
          <!-- Build buy offers list (one entry per ware) -->
          <set_value name="$buyOffersList" exact="[]"/>
          <do_all exact="$wareKeysList.count" counter="$i">
            <set_value name="$ware" exact="$wareKeysList.{$i}"/>
            <append_to_list name="$buyOffersList" exact="table[
              $ware = $ware,
              $offers = $buyOffersByWare.{$ware}
            ]"/>
          </do_all>
          
          <!-- Generate unique batch index (use ship object as key - X4 supports object keys) -->
          <set_value name="$batchIndex" exact="'' + player.age + $ship.idcode"/>
          
          <!-- âœ… CRITICAL: Ensure global.$GT_BatchDataList is initialized as TABLE (not list) -->
          <!-- Previous versions initialized this as a list - must always ensure it's a table -->
          <!-- Strategy: Check migration flag, if not migrated yet, clear and convert -->
          <!-- After migration, it's safe to assume it's a table (SystemInit ensures it) -->
          <do_if value="not global.$GT_BatchDataListMigrated?">
            <!-- First time in this session - clear if exists (might be list from old save) -->
            <do_if value="global.$GT_BatchDataList?">
              <remove_value name="global.$GT_BatchDataList"/>
            </do_if>
            <!-- Initialize as table -->
            <set_value name="global.$GT_BatchDataList" exact="table[]"/>
            <!-- Also ensure results list is a table -->
            <do_if value="global.$GT_BatchResultsList?">
              <remove_value name="global.$GT_BatchResultsList"/>
            </do_if>
            <set_value name="global.$GT_BatchResultsList" exact="table[]"/>
            <!-- Mark as migrated -->
            <set_value name="global.$GT_BatchDataListMigrated" exact="true"/>
          </do_if>
          
          <!-- Store state for batch processor - build state table first, then assign -->
          <!-- âœ… CRITICAL: Use ship object as key (not string) - X4 supports object keys in tables -->
          <!-- âœ… Use global settings for batch processing limits -->
          <set_value name="$maxTradesPerWare" exact="20"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare?">
            <set_value name="$maxTradesPerWare" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare"/>
          </do_if>
          <set_value name="$earlyExitThreshold" exact="500"/> <!-- Default fallback -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold?">
            <set_value name="$earlyExitThreshold" exact="global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold"/>
          </do_if>
          <set_value name="$stateData" exact="table[
            $batchId = $batchIndex,
            $waitingCue = null,
            $ship = $ship,
            $wareKeysList = $wareKeysList,
            $sellOffersList = $sellOffersList,
            $buyOffersList = $buyOffersList,
            $stationDistanceCache = $stationDistanceCache,
            $tradeList = [],
            $crossStationBestScore = 0,
            $crossStationBestTrade = null,
            $nonConflictedBestScore = 0,
            $nonConflictedBestTrade = null,
            $reservedRoutes = $reservedRoutes,
            $failedTrades = $failedTrades,
            $currentWareIndex = 0,
            $tradesPerWare = table[],
            $maxTradesPerWare = $maxTradesPerWare,
            $batchSize = 1,
            $earlyExitThreshold = $earlyExitThreshold,
            $maxDistance = $maxDistance,
            $originalMaxDistance = $originalMaxDistance,
            $distancePenaltyMultiplier = $distancePenaltyMultiplier,
            $factionPriority = $factionPriority,
            $minROI = $minROI,
            $minAbsoluteProfit = $minAbsoluteProfit,
            $gt_AdvancedAnalytics = $gt_AdvancedAnalytics,
            $availableMoney = $availableMoney,
            $tradesRejectedProfit = 0,
            $tradesRejectedDocking = 0,
            $tradesRejectedAmount = 0,
            $tradesRejectedDistance = 0,
            $bestRejectedProfit = null,
            $bestRejectedTrade = null,
            $homeSector = $homeSector
          ]"/>
          
          <!-- âœ… CRITICAL FIX: Use ship object as table key (X4 supports object keys, not variable string keys) -->
          <set_value name="global.$GT_BatchDataList.{$ship}" exact="$stateData"/>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Batch] (' + $ship.idcode + ') Prepared batch data: ' + $wareKeysList.count + ' wares, batchIndex=' + $batchIndex" chance="100"/>
          </do_if>
          
          <!-- Signal batch processor to start first batch (pass ship object as key) -->
          <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessTradeMatchingBatch" param="$ship"/>
          
          <!-- Exit - SearchLiveTrades_Resume will handle results -->
          <!-- Include offer counts for diagnostics (even though batch processing hasn't completed yet) -->
          <set_value name="$totalSellOffers" exact="0"/>
          <set_value name="$totalBuyOffers" exact="0"/>
          <do_all exact="$sellOffersList.count" counter="$i">
            <set_value name="$wareOffers" exact="$sellOffersList.{$i}.$offers"/>
            <set_value name="$totalSellOffers" exact="$totalSellOffers + $wareOffers.count"/>
          </do_all>
          <do_all exact="$buyOffersList.count" counter="$i">
            <set_value name="$wareOffers" exact="$buyOffersList.{$i}.$offers"/>
            <set_value name="$totalBuyOffers" exact="$totalBuyOffers + $wareOffers.count"/>
          </do_all>
          
          <!-- Note: StationsEvaluated not calculated during preparation, will be updated by batch processor -->
          <!-- âœ… CRITICAL FIX: Preserve LastRejectionStats when updating global.$GT_SearchResult -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
          </do_if>
          
          <set_value name="global.$GT_SearchResult" exact="table[
            $Found = false,
            $BestTrade = null,
            $BestScore = 0,
            $TradeList = [],
            $WaitingForBatch = true,
            $Ship = $ship,
            $OffersFound = $totalSellOffers + $totalBuyOffers,
            $StationsEvaluated = 0
          ]"/>
          
          <!-- âœ… CRITICAL FIX: Restore LastRejectionStats after updating global.$GT_SearchResult -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
        </do_if>
      </actions>
    </cue>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- SearchLiveTrades_Resume: Process batch processor results with ship-specific filtering -->
    <!-- This cue receives completed batch processing results and applies ship-specific filters -->
    <!-- (ware basket, illegal wares, blacklists, path availability) before returning results -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <cue name="SearchLiveTrades_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- 1. Retrieve ship object from signal (used as table key) -->
        <set_value name="$ship" exact="event.param"/>
        
        <!-- 2. Retrieve results from batch processor using ship object as key -->
        <set_value name="$results" exact="@global.$GT_BatchResultsList.{$ship}"/>
        
          <!-- Validate results exist -->
          <do_if value="not $results?">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Resume] âš ï¸ Batch results not found for ship ' + $ship.idcode" chance="100"/>
            </do_if>
            
            <!-- âœ… CRITICAL FIX: Preserve LastRejectionStats when updating global.$GT_SearchResult -->
            <set_value name="$preservedLastRejectionStats" exact="null"/>
            <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
              <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
            </do_if>
            
            <set_value name="global.$GT_SearchResult" exact="table[
              $Found = false,
              $BestTrade = null,
              $BestScore = 0,
              $TradeList = []
            ]"/>
            
            <!-- âœ… CRITICAL FIX: Restore LastRejectionStats after updating global.$GT_SearchResult -->
            <do_if value="$preservedLastRejectionStats?">
              <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
            </do_if>
            
            <cancel_cue cue="this"/>
          </do_if>
        
        <!-- Extract results -->
        <set_value name="$ship" exact="$results.$ship"/>
        <set_value name="$tradeList" exact="$results.$tradeList"/>
        <set_value name="$crossStationBestTrade" exact="$results.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="$results.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="$results.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="$results.$nonConflictedBestScore"/>
        <!-- Extract rejection statistics from batch processor -->
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <do_if value="$results.$tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="$results.$tradesRejectedProfit"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="$results.$tradesRejectedDocking"/>
        </do_if>
        <do_if value="$results.$tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="$results.$tradesRejectedAmount"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="$results.$tradesRejectedDistance"/>
        </do_if>
        <set_value name="$bestRejectedTrade" exact="null"/>
        <do_if value="$results.$bestRejectedTrade?">
          <set_value name="$bestRejectedTrade" exact="$results.$bestRejectedTrade"/>
        </do_if>
        
        <!-- Get maxDistance and originalMaxDistance from batch data (still stored for reference) -->
        <set_value name="$maxDistance" exact="null"/>
        <set_value name="$originalMaxDistance" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData?">
          <do_if value="$batchData.$maxDistance?">
            <set_value name="$maxDistance" exact="$batchData.$maxDistance"/>
          </do_if>
          <do_if value="$batchData.$originalMaxDistance?">
            <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
          </do_if>
        </do_if>
        
        <!-- âœ… FALLBACK SEARCH: Detect if this is a fallback search (MaxDistance == 2) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$maxDistance == 2">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Processing ' + $tradeList.count + ' trades from batch processor (maxDistance: ' + $maxDistance + ')'" chance="100"/>
        </do_if>
        
        <!-- 3. Apply ship-specific filtering -->
        <!-- 3a. Get ship settings -->
        <run_actions ref="md.GT_Blacklist_Utilities.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        <!-- âœ… CRITICAL: Get ware basket safely (using library function with null-checking pattern) -->
        <run_actions ref="md.GT_Utilities.GT_GetWareBasketSafe" result="$wareBasket">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- 3b. Filter tradeList -->
        <set_value name="$filteredTradeList" exact="[]"/>
        <!-- âœ… Track filtering statistics -->
        <set_value name="$filteredByWareBasket" exact="0"/>
        <set_value name="$filteredByIllegal" exact="0"/>
        <set_value name="$filteredByBlacklist" exact="0"/>
        <set_value name="$filteredByPathBlocked" exact="0"/>
        <set_value name="$tradesByWareStats" exact="table[]"/>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- âœ… OPTIMIZATION #4: Initialize gatedistance cache for blacklist-aware pathfinding -->
        <!-- Reduces pathfinding calls from 200 (for 100 trades) to ~20-40 unique sector pairs -->
        <!-- (80-90% reduction in expensive gatedistance calculations) -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <set_value name="$gatedistanceCache" exact="table[]"/>
        <set_value name="$currentSector" exact="$ship.sector"/>
        
        <!-- âœ… Track intra-sector trade statistics -->
        <set_value name="$intraSectorTradesTotal" exact="0"/>
        <set_value name="$intraSectorTradesFiltered" exact="0"/>
        <set_value name="$intraSectorTradesValid" exact="0"/>
        
        <!-- âœ… OPTIMIZATION #11: Parallel Filtering with Cooperative Multitasking -->
        <!-- Process trades in batches to prevent blocking the game engine -->
        <!-- This prevents frame stutter when filtering large trade lists (100+ trades) -->
        <!-- Store filtering state in global table (persists across cue instances) -->
        
        <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Initialize filter state for this ship -->
        <!-- Include batch processor results variables (from SearchLiveTrades_Resume) -->
        <set_value name="$filterState" exact="table[
          $ship = $ship,
          $tradeList = $tradeList,
          $wareBasket = $wareBasket,
          $allowIllegal = $allowIllegal,
          $blacklistgroup = $blacklistgroup,
          $currentSector = $currentSector,
          $gatedistanceCache = $gatedistanceCache,
          $filteredTradeList = $filteredTradeList,
          $filteredByWareBasket = $filteredByWareBasket,
          $filteredByIllegal = $filteredByIllegal,
          $filteredByBlacklist = $filteredByBlacklist,
          $filteredByPathBlocked = $filteredByPathBlocked,
          $tradesByWareStats = $tradesByWareStats,
          $intraSectorTradesTotal = $intraSectorTradesTotal,
          $intraSectorTradesFiltered = $intraSectorTradesFiltered,
          $intraSectorTradesValid = $intraSectorTradesValid,
          $filterIndex = 0,
          $filterBatchSize = 15,
          $maxDistance = $maxDistance,
          $crossStationBestTrade = $crossStationBestTrade,
          $crossStationBestScore = $crossStationBestScore,
          $nonConflictedBestTrade = $nonConflictedBestTrade,
          $nonConflictedBestScore = $nonConflictedBestScore,
          $tradesRejectedProfit = $tradesRejectedProfit,
          $tradesRejectedDocking = $tradesRejectedDocking,
          $tradesRejectedAmount = $tradesRejectedAmount,
          $tradesRejectedDistance = $tradesRejectedDistance,
          $bestRejectedTrade = $bestRejectedTrade
        ]"/>
        <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
        
        <!-- Signal batch filtering cue to start processing -->
        <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
        
        <!-- Wait for batch filtering to complete (resume cue will signal back) -->
        <!-- Note: We'll resume in FilterTradeList_Resume cue -->
        <!-- Cancel this cue - resume cue will continue processing -->
        <cancel_cue cue="this"/>
      </actions>
    </cue>
    
    <!-- âœ… OPTIMIZATION #11: Batch Trade Filtering with Cooperative Multitasking -->
    <cue name="FilterTradeList_Batch" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Calculate delay from global Performance settings -->
        <set_value name="$batchDelay" exact="50"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay?">
          <set_value name="$batchDelay" exact="@global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay"/>
        </do_if>
        <!-- Convert to time value (milliseconds) -->
        <set_value name="this.$batchDelayTime" exact="$batchDelay * 1ms"/>
      </actions>
      <delay exact="this.$batchDelayTime"/>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve state from global table -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- âœ… FIX: Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Extract state variables -->
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <set_value name="$wareBasket" exact="@$filterState.$wareBasket"/>
        <set_value name="$allowIllegal" exact="@$filterState.$allowIllegal"/>
        <set_value name="$blacklistgroup" exact="@$filterState.$blacklistgroup"/>
        <set_value name="$currentSector" exact="@$filterState.$currentSector"/>
        <set_value name="$gatedistanceCache" exact="@$filterState.$gatedistanceCache"/>
        <set_value name="$filterIndex" exact="@$filterState.$filterIndex"/>
        <set_value name="$filterBatchSize" exact="@$filterState.$filterBatchSize"/>
        
        <!-- Get mutable lists/stats from state (or initialize if first batch) -->
        <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
        <do_if value="not $filteredTradeList?">
          <set_value name="$filteredTradeList" exact="[]"/>
        </do_if>
        <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
        <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
        <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
        <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
        <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
        <do_if value="not $tradesByWareStats?">
          <set_value name="$tradesByWareStats" exact="table[]"/>
        </do_if>
        <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
        <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
        <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
        
        <!-- Process one batch of trades -->
        <set_value name="$filterTotalTrades" exact="$tradeList.count"/>
        <set_value name="$batchEnd" exact="[$filterIndex + $filterBatchSize, $filterTotalTrades].min"/>
        <do_all exact="$batchEnd - $filterIndex" counter="$batchOffset">
          <set_value name="$i" exact="$filterIndex + $batchOffset"/>
          <set_value name="$trade" exact="$tradeList.{$i}"/>
          <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
          
          <!-- Initialize ware stats if needed -->
          <do_if value="not $tradesByWareStats.{$ware}?">
            <set_value name="$tradesByWareStats.{$ware}" exact="table[$total=0, $filteredByWareBasket=0, $filteredByIllegal=0, $filteredByBlacklist=0, $filteredByPathBlocked=0, $valid=0]"/>
          </do_if>
          <set_value name="$wareStats" exact="$tradesByWareStats.{$ware}"/>
          <set_value name="$wareStats.$total" exact="$wareStats.$total + 1"/>
          
          <!-- Extract sectors early for intra-sector trade detection -->
          <set_value name="$buySector" exact="@$trade.$BuyStation.sector"/>
          <set_value name="$sellSector" exact="@$trade.$SellStation.sector"/>
          
          <!-- Track if this is a TRUE intra-sector trade -->
          <run_actions ref="md.GT_Trade_Utilities.GT_IsIntraSectorTrade" result="$isIntraSectorTrade">
            <param name="buySector" value="$buySector"/>
            <param name="sellSector" value="$sellSector"/>
            <param name="currentSector" value="$currentSector"/>
          </run_actions>
          <do_if value="$isIntraSectorTrade">
            <set_value name="$intraSectorTradesTotal" exact="$intraSectorTradesTotal + 1"/>
          </do_if>
          
          <!-- Filter trade for ship -->
          <run_actions ref="md.GT_Trade_Utilities.GT_FilterTradeForShip" result="$filterResult">
            <param name="trade" value="$trade"/>
            <param name="ship" value="$ship"/>
            <param name="ware" value="$ware"/>
            <param name="wareBasket" value="$wareBasket"/>
            <param name="allowIllegal" value="$allowIllegal"/>
            <param name="blacklistgroup" value="$blacklistgroup"/>
            <param name="currentSector" value="$currentSector"/>
            <param name="buySector" value="$buySector"/>
            <param name="sellSector" value="$sellSector"/>
            <param name="filterStats" value="$wareStats"/>
            <param name="isIntraSectorTrade" value="$isIntraSectorTrade"/>
          </run_actions>
          
          <!-- Update filter statistics -->
          <set_value name="$isAllowed" exact="$filterResult.$IsAllowed"/>
          <set_value name="$filterReason" exact="$filterResult.$FilterReason"/>
          <do_if value="not $isAllowed">
            <do_if value="$filterReason == 'ware_basket'">
              <set_value name="$filteredByWareBasket" exact="$filteredByWareBasket + 1"/>
            </do_if>
            <do_elseif value="$filterReason == 'illegal'">
              <set_value name="$filteredByIllegal" exact="$filteredByIllegal + 1"/>
            </do_elseif>
            <do_elseif value="$filterReason == 'blacklist_intra' or $filterReason == 'blacklist_buy_station' or $filterReason == 'blacklist_sell_station' or $filterReason == 'blacklist_buy_sector' or $filterReason == 'blacklist_sell_sector'">
              <set_value name="$filteredByBlacklist" exact="$filteredByBlacklist + 1"/>
            </do_elseif>
            <do_elseif value="$filterReason == 'path_blocked'">
              <set_value name="$filteredByPathBlocked" exact="$filteredByPathBlocked + 1"/>
            </do_elseif>
            <do_if value="$isIntraSectorTrade">
              <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
            </do_if>
          </do_if>
          
          <!-- Add to filtered list if valid -->
          <do_if value="$isAllowed">
            <append_to_list name="$filteredTradeList" exact="$trade"/>
            <set_value name="$wareStats.$valid" exact="$wareStats.$valid + 1"/>
            <do_if value="$isIntraSectorTrade">
              <set_value name="$intraSectorTradesValid" exact="$intraSectorTradesValid + 1"/>
            </do_if>
          </do_if>
          <do_else>
            <do_if value="$isIntraSectorTrade">
              <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
            </do_if>
          </do_else>
          
          <!-- Update ware stats -->
          <set_value name="$tradesByWareStats.{$ware}" exact="$wareStats"/>
        </do_all>
        
        <!-- Update state for next batch or completion -->
        <set_value name="$filterIndex" exact="$batchEnd"/>
        <set_value name="$filterState.$filterIndex" exact="$filterIndex"/>
        <set_value name="$filterState.$filteredTradeList" exact="$filteredTradeList"/>
        <set_value name="$filterState.$filteredByWareBasket" exact="$filteredByWareBasket"/>
        <set_value name="$filterState.$filteredByIllegal" exact="$filteredByIllegal"/>
        <set_value name="$filterState.$filteredByBlacklist" exact="$filteredByBlacklist"/>
        <set_value name="$filterState.$filteredByPathBlocked" exact="$filteredByPathBlocked"/>
        <set_value name="$filterState.$tradesByWareStats" exact="$tradesByWareStats"/>
        <set_value name="$filterState.$intraSectorTradesTotal" exact="$intraSectorTradesTotal"/>
        <set_value name="$filterState.$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered"/>
        <set_value name="$filterState.$intraSectorTradesValid" exact="$intraSectorTradesValid"/>
        <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
        
        <!-- Check if more batches needed -->
        <do_if value="$filterIndex lt $filterTotalTrades">
          <!-- Signal next batch -->
          <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
        </do_if>
        <do_else>
          <!-- All batches complete - signal resume cue to continue processing -->
          <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
        </do_else>
      </actions>
    </cue>
    
    <!-- Resume cue: Continue processing after batch filtering completes -->
    <cue name="FilterTradeList_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- âœ… FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve filtered results from global state -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- âœ… FIX: Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Extract all filtered results and statistics -->
        <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
        <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
        <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
        <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
        <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
        <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
        <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
        <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
        <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <set_value name="$maxDistance" exact="@$filterState.$maxDistance"/>
        
        <!-- âœ… FALLBACK SEARCH: Get originalMaxDistance from batch data (if available) -->
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance -->
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData? and $batchData.$originalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
        </do_if>
        
        <!-- âœ… FALLBACK SEARCH: Detect if this is a fallback search (MaxDistance == 2) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$maxDistance == 2">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <!-- Extract batch processor result variables -->
        <set_value name="$crossStationBestTrade" exact="@$filterState.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="@$filterState.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="@$filterState.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="@$filterState.$nonConflictedBestScore"/>
        <set_value name="$tradesRejectedProfit" exact="@$filterState.$tradesRejectedProfit"/>
        <set_value name="$tradesRejectedDocking" exact="@$filterState.$tradesRejectedDocking"/>
        <set_value name="$tradesRejectedAmount" exact="@$filterState.$tradesRejectedAmount"/>
        <set_value name="$tradesRejectedDistance" exact="@$filterState.$tradesRejectedDistance"/>
        <set_value name="$bestRejectedTrade" exact="@$filterState.$bestRejectedTrade"/>
        
        <!-- Initialize to safe defaults if not set -->
        <do_if value="not $tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="0"/>
        </do_if>
        <do_if value="not $crossStationBestScore?">
          <set_value name="$crossStationBestScore" exact="0"/>
        </do_if>
        <do_if value="not $nonConflictedBestScore?">
          <set_value name="$nonConflictedBestScore" exact="0"/>
        </do_if>
        
        <!-- Clean up filter state -->
        <remove_value name="global.$GT_FilterState.{$ship}"/>
        
        <!-- DEBUG: Log filtering statistics -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$filteringStats" exact="'[GT-Resume] (' + $ship.idcode + ') Filtering statistics:' +
            '\n  Total trades: ' + $tradeList.count +
            '\n  ðŸ  TRUE intra-sector trades: ' + $intraSectorTradesTotal + ' (filtered: ' + $intraSectorTradesFiltered + ', valid: ' + $intraSectorTradesValid + ')' +
            '\n  Filtered by ware basket: ' + $filteredByWareBasket +
            '\n  Filtered by illegal: ' + $filteredByIllegal +
            '\n  Filtered by blacklist: ' + $filteredByBlacklist +
            '\n  Filtered by path blocked: ' + $filteredByPathBlocked +
            '\n  Valid trades: ' + $filteredTradeList.count"/>
          <debug_text text="$filteringStats" chance="100"/>
          
          <!-- Log per-ware statistics -->
          <do_if value="$tradesByWareStats.keys.count gt 0">
            <set_value name="$wareStatsLog" exact="'[GT-Resume] (' + $ship.idcode + ') Per-ware filtering:'"/>
            <do_all exact="$tradesByWareStats.keys.count" counter="$wareIdx">
              <set_value name="$ware" exact="$tradesByWareStats.keys.{$wareIdx}"/>
              <set_value name="$stats" exact="$tradesByWareStats.{$ware}"/>
              <set_value name="$wareStatsLog" exact="$wareStatsLog + 
                '\n  - ' + @$ware.name + ': ' + $stats.$total + ' checked, ' +
                $stats.$filteredByWareBasket + ' basket, ' +
                $stats.$filteredByIllegal + ' illegal, ' +
                $stats.$filteredByBlacklist + ' blacklist, ' +
                $stats.$filteredByPathBlocked + ' path, ' +
                $stats.$valid + ' valid'"/>
            </do_all>
            <debug_text text="$wareStatsLog" chance="100"/>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') After ship-specific filtering: ' + $filteredTradeList.count + ' trades (from ' + $tradeList.count + ')'" chance="100"/>
        </do_if>
        
        <!-- 4. Build diverse list: Top 5 per ware (minimum-maximum) with early exit -->
        <!-- DEBUG: Log trades before diverse list building -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Building diverse list from ' + $filteredTradeList.count + ' filtered trades'" chance="100"/>
        </do_if>
        
        <set_value name="$tradesByWare" exact="table[]"/>
        <do_all exact="$filteredTradeList.count" counter="$i">
          <set_value name="$trade" exact="$filteredTradeList.{$i}"/>
          <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
          <do_if value="not $tradesByWare.{$ware}?">
            <set_value name="$tradesByWare.{$ware}" exact="[]"/>
          </do_if>
          <append_to_list name="$tradesByWare.{$ware}" exact="$trade"/>
        </do_all>
        
        <!-- DEBUG: Log wares found -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$wareDebug" exact="'[GT-Resume] (' + $ship.idcode + ') Found ' + $tradesByWare.keys.count + ' wares with trades:'"/>
          <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
            <set_value name="$wareCount" exact="$tradesByWare.{$ware}.count"/>
            <set_value name="$wareDebug" exact="$wareDebug + '\n  - ' + @$ware.name + ': ' + $wareCount + ' trades'"/>
          </do_all>
          <debug_text text="$wareDebug" chance="100"/>
        </do_if>
        
        <!-- âœ… FIX: Determine home sector FIRST (same logic as SearchLiveTrades) -->
        <!-- âœ… CRITICAL: Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <!-- Ships must only trade with stations within maxDistance from HOME SECTOR, not ship position -->
        <set_value name="$homeBase" exact="null"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
            <do_if value="$commanderHome? and $commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- âœ… For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
          </do_if>
          <do_else>
            <!-- âŒ REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
            <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null! This should never happen.'" chance="100"/>
            <!-- Emergency fallback only - this should never happen -->
            <set_value name="$homeBase" exact="$ship.sector"/>
          </do_else>
        </do_if>
        
        <!-- Extract sector -->
        <set_value name="$homeSector" exact="null"/>
        <do_if value="$homeBase? and $homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
          <!-- Emergency fallback only - this should never happen -->
          <set_value name="$homeSector" exact="$ship.sector"/>
        </do_if>
        
        <!-- âœ… FALLBACK SEARCH: Log start of fallback search processing -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <set_value name="$filterMaxDistance" exact="$maxDistance"/>
          <do_if value="$originalMaxDistance?">
            <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
          </do_if>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') ðŸ” Fallback search processing started | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance + ' | Trades to evaluate: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <!-- âœ… EARLY EXIT: Sort trades by distance from HOME SECTOR (shortest first) per ware, break when exceeding maxDistance -->
        <!-- This matches the requirement: stations must not be farther from home sector than maxDistance -->
        <set_value name="$diverseList" exact="[]"/>
        <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
          <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
          <set_value name="$wareTrades" exact="$tradesByWare.{$ware}"/>
          
          <!-- âœ… FALLBACK SEARCH: Log start of evaluation for this ware -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
            <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
            <set_value name="$filterMaxDistance" exact="$maxDistance"/>
            <do_if value="$originalMaxDistance?">
              <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
            </do_if>
            <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') ðŸ” Evaluating ' + $wareTrades.count + ' trades for ' + $wareName + ' | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance" chance="100"/>
          </do_if>
          
          <!-- âœ… STEP 1: For fallback search, calculate distance from CURRENT POSITION first, then filter by home distance -->
          <!-- FALLBACK SEARCH LOGIC:
               1. Search: Native search collects ALL trades galaxy-wide (can't avoid this)
               2. Filter: Calculate distance from CURRENT POSITION for each trade
               3. Early Exit: Skip trades > 2 jumps from current position immediately (no further evaluation)
               4. Filter: For remaining trades (<= 2 jumps), check distance from HOME SECTOR
               5. Reject: If home distance > pilot's maxJumps (capped by pilot level), reject
               6. Sort: Sort remaining trades by distance from current position
               7. Early Exit: After sorting, skip trades > 2 jumps (redundant but safe)
               
               Result: Only trades within 2 jumps from current AND within maxJumps from home are evaluated -->
          <set_value name="$currentSector" exact="$ship.sector"/>
          <set_value name="$tradesWithDistance" exact="[]"/>
          
          <!-- âœ… DEBUG: Verify current sector is correct for fallback search -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$currentSectorName" exact="if $currentSector? then @$currentSector.knownname else 'Unknown'"/>
            <set_value name="$shipSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
            <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') ðŸ” Distance calculation: currentSector=' + $currentSectorName + ', ship.sector=' + $shipSectorName + ' (should match!)'" chance="100"/>
          </do_if>
          
          <!-- âœ… FALLBACK SEARCH: Initialize rejection counters for logging -->
          <set_value name="$rejectedByCurrentDistance" exact="0"/>
          <set_value name="$rejectedByHomeDistance" exact="0"/>
          <set_value name="$rejectedByUnreachable" exact="0"/>
          <set_value name="$evaluatedCount" exact="0"/>
          
          <do_all exact="$wareTrades.count" counter="$i">
            <set_value name="$trade" exact="$wareTrades.{$i}"/>
            <set_value name="$buySector" exact="@$trade.$BuyStation.sector"/>
            <set_value name="$sellSector" exact="@$trade.$SellStation.sector"/>
            <set_value name="$buyStation" exact="@$trade.$BuyStation"/>
            <set_value name="$sellStation" exact="@$trade.$SellStation"/>
            <set_value name="$ware" exact="@$trade.$BuyOffer.ware"/>
            
            <!-- âœ… FALLBACK SEARCH: Calculate distance from CURRENT POSITION FIRST (before counting as evaluated) -->
            <!-- CRITICAL: This check happens FIRST - trades > 2 jumps are skipped immediately -->
            <set_value name="$currentToBuyDistance" exact="-1"/>
            <set_value name="$currentToSellDistance" exact="-1"/>
            <set_value name="$maxDistanceFromCurrent" exact="-1"/>  <!-- Initialize for non-fallback searches -->
            <do_if value="$isFallbackSearch? and $isFallbackSearch">
              <do_if value="$buySector == $currentSector">
                <set_value name="$currentToBuyDistance" exact="0"/>
              </do_if>
              <do_else>
                <set_value name="$currentToBuyDistance" exact="$currentSector.gatedistance.{$buySector}"/>
              </do_else>
              <do_if value="$sellSector == $currentSector">
                <set_value name="$currentToSellDistance" exact="0"/>
              </do_if>
              <do_else>
                <set_value name="$currentToSellDistance" exact="$currentSector.gatedistance.{$sellSector}"/>
              </do_else>
              
              <!-- âœ… FALLBACK SEARCH: Early exit if distance from current position > 2 -->
              <!-- CRITICAL: Trades > 2 jumps from current position are skipped IMMEDIATELY -->
              <!-- No further evaluation (home distance, profit, etc.) happens for these trades -->
              <!-- These trades are NOT counted as "evaluated" - they're skipped before evaluation -->
              <set_value name="$maxDistanceFromCurrent" exact="[$currentToBuyDistance, $currentToSellDistance].max"/>
              <do_if value="$maxDistanceFromCurrent lt 0">
                <!-- Unreachable from current position - skip silently (early exit) -->
                <set_value name="$rejectedByUnreachable" exact="$rejectedByUnreachable + 1"/>
                <!-- âœ… DEBUG: Log first few skipped trades to verify distance calculation -->
                <do_if value="$rejectedByUnreachable le 3 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$buySectorName" exact="if $buySector? then @$buySector.knownname else 'Unknown'"/>
                  <set_value name="$sellSectorName" exact="if $sellSector? then @$sellSector.knownname else 'Unknown'"/>
                  <set_value name="$currentSectorName" exact="if $currentSector? then @$currentSector.knownname else 'Unknown'"/>
                  <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âš ï¸ SKIP (unreachable): Buy=' + $buySectorName + ' (dist: ' + $currentToBuyDistance + '), Sell=' + $sellSectorName + ' (dist: ' + $currentToSellDistance + ') from current=' + $currentSectorName" chance="100"/>
                </do_if>
                <continue/>  <!-- Skip all further checks for this trade -->
              </do_if>
              <do_if value="$maxDistanceFromCurrent gt 2">
                <!-- Too far from current position (> 2 jumps) - skip silently (early exit) -->
                <!-- REQUIREMENT: No stations farther than 2 jumps from current position should be evaluated -->
                <set_value name="$rejectedByCurrentDistance" exact="$rejectedByCurrentDistance + 1"/>
                <!-- âœ… DEBUG: Log first few skipped trades to verify distance calculation -->
                <do_if value="$rejectedByCurrentDistance le 3 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$buySectorName" exact="if $buySector? then @$buySector.knownname else 'Unknown'"/>
                  <set_value name="$sellSectorName" exact="if $sellSector? then @$sellSector.knownname else 'Unknown'"/>
                  <set_value name="$currentSectorName" exact="if $currentSector? then @$currentSector.knownname else 'Unknown'"/>
                  <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âš ï¸ SKIP (too far): Buy=' + $buySectorName + ' (dist: ' + $currentToBuyDistance + '), Sell=' + $sellSectorName + ' (dist: ' + $currentToSellDistance + ') from current=' + $currentSectorName + ' | Max distance from current: ' + $maxDistanceFromCurrent + ' jumps'"/>
                </do_if>
                <continue/>  <!-- Skip all further checks for this trade -->
              </do_if>
            </do_if>
            
            <!-- âœ… FALLBACK SEARCH: Only count trades that passed the distance check as "evaluated" -->
            <!-- Trades that were skipped due to distance > 2 are NOT counted here -->
            <set_value name="$evaluatedCount" exact="$evaluatedCount + 1"/>
            <set_value name="$rejectionReason" exact="''"/>
            <set_value name="$tradeAccepted" exact="false"/>
            
            <!-- Calculate distance from HOME SECTOR to stations (for final filtering) -->
            <set_value name="$buyDistance" exact="-1"/>
            <set_value name="$sellDistance" exact="-1"/>
            
            <do_if value="$buySector == $homeSector">
              <set_value name="$buyDistance" exact="0"/>
            </do_if>
            <do_else>
              <!-- Range-only distance from home sector to buy station (universal validation) -->
              <set_value name="$buyDistance" exact="$homeSector.gatedistance.{$buySector}"/>
            </do_else>
            
            <do_if value="$sellSector == $homeSector">
              <set_value name="$sellDistance" exact="0"/>
            </do_if>
            <do_else>
              <!-- Range-only distance from home sector to sell station (universal validation) -->
              <set_value name="$sellDistance" exact="$homeSector.gatedistance.{$sellSector}"/>
            </do_else>
            
            <!-- Use max distance (farthest station from home) for sorting -->
            <set_value name="$maxStationDistance" exact="[$buyDistance, $sellDistance].max"/>
            
            <!-- âœ… FALLBACK SEARCH: For fallback search, filter by originalMaxDistance from home sector -->
            <!-- REQUIREMENT: Resulting stations must not be farther from HOME SECTOR than pilot's maxJumps (capped by pilot level) -->
            <!-- This is the SECOND filter - only trades that passed the "<= 2 jumps from current" check reach here -->
            <!-- Fallback search searches 2 jumps from current position, but stations must be within pilot's maxDistance from home -->
            <set_value name="$filterMaxDistance" exact="$maxDistance"/>  <!-- Default: use maxDistance -->
            <do_if value="$isFallbackSearch? and $isFallbackSearch and $originalMaxDistance?">
              <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>  <!-- Fallback: use original pilot maxDistance -->
            </do_if>
            
            <!-- Only include trades where BOTH stations are within filterMaxDistance from home AND paths exist -->
            <!-- REQUIREMENT: Trade is within 2 jumps from current AND within maxJumps from home = PASS -->
            <!-- REQUIREMENT: Trade is within 2 jumps from current BUT exceeds maxJumps from home = REJECT -->
            <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
              <set_value name="$rejectedByUnreachable" exact="$rejectedByUnreachable + 1"/>
              <set_value name="$rejectionReason" exact="'Unreachable from home sector (buy: ' + $buyDistance + ', sell: ' + $sellDistance + ')'"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$buyStationName" exact="if $buyStation? then @$buyStation.knownname else 'Unknown'"/>
                <set_value name="$sellStationName" exact="if $sellStation? then @$sellStation.knownname else 'Unknown'"/>
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
                <set_value name="$buySectorName" exact="if $buySector? then @$buySector.knownname else 'Unknown'"/>
                <set_value name="$sellSectorName" exact="if $sellSector? then @$sellSector.knownname else 'Unknown'"/>
                <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âŒ Trade #' + $evaluatedCount + ' REJECTED: ' + $wareName + ' | Buy: ' + $buyStationName + ' (' + $buySectorName + ') | Sell: ' + $sellStationName + ' (' + $sellSectorName + ') | Reason: ' + $rejectionReason" chance="100"/>
              </do_if>
            </do_if>
            <do_elseif value="$maxStationDistance gt $filterMaxDistance">
              <set_value name="$rejectedByHomeDistance" exact="$rejectedByHomeDistance + 1"/>
              <set_value name="$rejectionReason" exact="'Too far from home sector (' + $maxStationDistance + ' jumps, max: ' + $filterMaxDistance + ')'"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$buyStationName" exact="if $buyStation? then @$buyStation.knownname else 'Unknown'"/>
                <set_value name="$sellStationName" exact="if $sellStation? then @$sellStation.knownname else 'Unknown'"/>
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
                <set_value name="$buySectorName" exact="if $buySector? then @$buySector.knownname else 'Unknown'"/>
                <set_value name="$sellSectorName" exact="if $sellSector? then @$sellSector.knownname else 'Unknown'"/>
                <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
                <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âŒ Trade #' + $evaluatedCount + ' REJECTED: ' + $wareName + ' | Buy: ' + $buyStationName + ' (' + $buySectorName + ', home dist: ' + $buyDistance + ') | Sell: ' + $sellStationName + ' (' + $sellSectorName + ', home dist: ' + $sellDistance + ') | Home: ' + $homeSectorName + ' | Reason: ' + $rejectionReason" chance="100"/>
              </do_if>
            </do_elseif>
            <do_else>
              <!-- Trade passed all filters -->
              <set_value name="$tradeAccepted" exact="true"/>
              <!-- For fallback search, sort by distance from current position; otherwise sort by distance from home -->
              <set_value name="$sortDistance" exact="$maxStationDistance"/>  <!-- Default: sort by home distance -->
              <do_if value="$isFallbackSearch? and $isFallbackSearch">
                <set_value name="$sortDistance" exact="$maxDistanceFromCurrent"/>  <!-- Fallback: sort by current position distance -->
              </do_if>
              <append_to_list name="$tradesWithDistance" exact="table[
                $Trade = $trade,
                $Distance = $sortDistance,
                $HomeDistance = $maxStationDistance
              ]"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$buyStationName" exact="if $buyStation? then @$buyStation.knownname else 'Unknown'"/>
                <set_value name="$sellStationName" exact="if $sellStation? then @$sellStation.knownname else 'Unknown'"/>
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
                <set_value name="$buySectorName" exact="if $buySector? then @$buySector.knownname else 'Unknown'"/>
                <set_value name="$sellSectorName" exact="if $sellSector? then @$sellSector.knownname else 'Unknown'"/>
                <set_value name="$currentSectorName" exact="if $currentSector? then @$currentSector.knownname else 'Unknown'"/>
                <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
                <set_value name="$distanceInfo" exact="if $isFallbackSearch? and $isFallbackSearch then 'current: ' + $maxDistanceFromCurrent + ', home: ' + $maxStationDistance else 'home: ' + $maxStationDistance"/>
                <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âœ… Trade #' + $evaluatedCount + ' ACCEPTED: ' + $wareName + ' | Buy: ' + $buyStationName + ' (' + $buySectorName + ') | Sell: ' + $sellStationName + ' (' + $sellSectorName + ') | Distances: ' + $distanceInfo" chance="100"/>
              </do_if>
            </do_else>
          </do_all>
          
          <!-- âœ… FALLBACK SEARCH: Log summary statistics -->
          <!-- NOTE: "Evaluated" only counts trades that passed the distance check (<= 2 jumps from current) -->
          <!-- Trades skipped due to distance > 2 are NOT counted as "evaluated" -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$totalTrades" exact="$wareTrades.count"/>
            <set_value name="$skippedByDistance" exact="$rejectedByCurrentDistance + $rejectedByUnreachable"/>
            <set_value name="$summaryLog" exact="'[GT-Fallback] (' + $ship.idcode + ') ðŸ“Š Ware: ' + $wareName + ' | Total trades: ' + $totalTrades + ' | Evaluated (within 2 jumps): ' + $evaluatedCount + ' | Accepted: ' + $tradesWithDistance.count + ' | Rejected: ' + ($evaluatedCount - $tradesWithDistance.count) + ' | Skipped (beyond 2 jumps): ' + $skippedByDistance + ' (current dist: ' + $rejectedByCurrentDistance + ', unreachable: ' + $rejectedByUnreachable + ', home dist: ' + $rejectedByHomeDistance + ')'"/>
            <debug_text text="$summaryLog" chance="100"/>
          </do_if>
          
          <!-- âœ… STEP 2: Sort by distance (simple selection sort - shortest first) -->
          <set_value name="$sortedTrades" exact="[]"/>
          <do_all exact="$tradesWithDistance.count" counter="$sortIdx">
            <set_value name="$minDistance" exact="999999999"/>
            <set_value name="$minIdx" exact="-1"/>
            <do_all exact="$tradesWithDistance.count" counter="$i">
              <set_value name="$alreadySorted" exact="false"/>
              <do_all exact="$sortedTrades.count" counter="$j">
                <do_if value="$sortedTrades.{$j}.$Trade == $tradesWithDistance.{$i}.$Trade">
                  <set_value name="$alreadySorted" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="not $alreadySorted and $tradesWithDistance.{$i}.$Distance lt $minDistance">
                <set_value name="$minDistance" exact="$tradesWithDistance.{$i}.$Distance"/>
                <set_value name="$minIdx" exact="$i"/>
              </do_if>
            </do_all>
            <do_if value="$minIdx ge 0">
              <append_to_list name="$sortedTrades" exact="$tradesWithDistance.{$minIdx}"/>
            </do_if>
          </do_all>
          
          <!-- âœ… STEP 3: Select top 5 by Score, with early exit when distance exceeds limit -->
          <!-- For fallback search: early exit when distance from current position > 2 -->
          <!-- For normal search: early exit when distance from home > maxDistance -->
          <set_value name="$top3" exact="[]"/>
          <set_value name="$skippedDueToDistance" exact="0"/>
          <set_value name="$distanceLimit" exact="$maxDistance"/>  <!-- Default: use maxDistance -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch">
            <set_value name="$distanceLimit" exact="2"/>  <!-- Fallback: use 2 jumps from current position -->
          </do_if>
          <do_all exact="$sortedTrades.count" counter="$i">
            <!-- Early exit: If this trade exceeds distance limit, all subsequent trades are also too far (sorted by distance) -->
            <do_if value="$sortedTrades.{$i}.$Distance gt $distanceLimit">
              <set_value name="$skippedDueToDistance" exact="$sortedTrades.count - $i"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <set_value name="$distanceType" exact="if $isFallbackSearch? and $isFallbackSearch then 'current position' else 'home sector'"/>
                <debug_text text="'[GT-Resume] (' + $ship.idcode + ') âš¡ EARLY EXIT for ware ' + @$ware.name + ': Reached distance limit (' + $distanceLimit + ' jumps from ' + $distanceType + ') at trade ' + $i + '/' + $sortedTrades.count + ' (skipped ' + $skippedDueToDistance + ' trades)'" chance="100"/>
              </do_if>
              <break/>
            </do_if>
            
            <!-- Trade is within distance - select top 5 by Score with STATION PAIR DIVERSITY -->
            <set_value name="$trade" exact="$sortedTrades.{$i}.$Trade"/>
            <set_value name="$buyStation" exact="$trade.$BuyStation"/>
            <set_value name="$sellStation" exact="$trade.$SellStation"/>
            
            <!-- âœ… STATION PAIR DIVERSITY: Check if this station pair already exists in top3 -->
            <set_value name="$stationPairExists" exact="false"/>
            <do_all exact="$top3.count" counter="$j">
              <set_value name="$existingBuyStation" exact="$top3.{$j}.$BuyStation"/>
              <set_value name="$existingSellStation" exact="$top3.{$j}.$SellStation"/>
              <do_if value="$existingBuyStation == $buyStation and $existingSellStation == $sellStation">
                <set_value name="$stationPairExists" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Skip if station pair already exists (ensure diversity) -->
            <do_if value="not $stationPairExists">
              <set_value name="$shouldAdd" exact="false"/>
              <do_if value="$top3.count lt 5">
                <!-- Still building initial top 5 - add unique station pair -->
                <set_value name="$shouldAdd" exact="true"/>
              </do_if>
              <do_else>
                <!-- Top 5 full - check if this trade's Score is better than worst -->
                <set_value name="$worstScore" exact="999999999"/>
                <set_value name="$worstIdx" exact="-1"/>
                <do_all exact="5" counter="$j">
                  <do_if value="$top3.{$j}.$Score lt $worstScore">
                    <set_value name="$worstScore" exact="$top3.{$j}.$Score"/>
                    <set_value name="$worstIdx" exact="$j"/>
                  </do_if>
                </do_all>
                <do_if value="$trade.$Score gt $worstScore">
                  <!-- Replace worst with this trade (unique station pair) -->
                  <set_value name="$shouldAdd" exact="true"/>
                </do_if>
              </do_else>
              <do_if value="$shouldAdd">
                <do_if value="$top3.count lt 5">
                  <append_to_list name="$top3" exact="$trade"/>
                </do_if>
                <do_else>
                  <!-- Replace worst trade in top5 -->
                  <set_value name="$worstScore" exact="999999999"/>
                  <set_value name="$worstIdx" exact="-1"/>
                  <do_all exact="5" counter="$j">
                    <do_if value="$top3.{$j}.$Score lt $worstScore">
                      <set_value name="$worstScore" exact="$top3.{$j}.$Score"/>
                      <set_value name="$worstIdx" exact="$j"/>
                    </do_if>
                  </do_all>
                  <do_if value="$worstIdx ge 0">
                    <set_value name="$top3.{$worstIdx}" exact="$trade"/>
                  </do_if>
                </do_else>
              </do_if>
            </do_if>
          </do_all>
          
          <!-- Add up to 5 trades per ware (if less than 5, still include what we have) -->
          <do_if value="$top3.count gt 0">
            <do_all exact="$top3.count" counter="$i">
              <append_to_list name="$diverseList" exact="$top3.{$i}"/>
            </do_all>
          </do_if>
        </do_all>
        
        <!-- âœ… FALLBACK SEARCH: Log if no trades were found to evaluate -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and $tradesByWare.keys.count == 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') âš ï¸ No trades found to evaluate | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Filtered trade list count: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Diverse list: ' + $diverseList.count + ' trades (top 5 per ware)'" chance="100"/>
        </do_if>
        
        <!-- âœ… SORT DIVERSE LIST BY SCORE (highest first) before storing for AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <!-- âœ… OPTIMIZATION #5: Optimize sort for small lists (â‰¤10 items: O(n) vs O(nÂ²)) -->
        <do_if value="$diverseList.count gt 10">
          <!-- Large list: Full selection sort (necessary for proper ordering) -->
          <set_value name="$sortedDiverseList" exact="[]"/>
          <set_value name="$remainingTrades" exact="$diverseList"/>
          <do_all exact="$diverseList.count" counter="$sortIdx">
            <set_value name="$maxScore" exact="-999999999"/>
            <set_value name="$maxIdx" exact="-1"/>
            <do_all exact="$remainingTrades.count" counter="$i">
              <set_value name="$trade" exact="$remainingTrades.{$i}"/>
              <set_value name="$tradeScore" exact="$trade.$Score"/>
              <do_if value="$tradeScore gt $maxScore">
                <set_value name="$maxScore" exact="$tradeScore"/>
                <set_value name="$maxIdx" exact="$i"/>
              </do_if>
            </do_all>
            <do_if value="$maxIdx ge 0">
              <append_to_list name="$sortedDiverseList" exact="$remainingTrades.{$maxIdx}"/>
              <remove_value name="$remainingTrades.{$maxIdx}"/>
            </do_if>
          </do_all>
          <set_value name="$diverseList" exact="$sortedDiverseList"/>
        </do_if>
        <do_elseif value="$diverseList.count gt 1">
          <!-- Small list (2-10): Single pass bubble-like sort (O(nÂ²) but n is small) -->
          <set_value name="$sortedDiverseList" exact="$diverseList"/>
          <!-- Single pass: swap adjacent elements if wrong order (n-1 comparisons) -->
          <do_all exact="$diverseList.count - 1" counter="$pass">
            <set_value name="$swapped" exact="false"/>
            <do_all exact="$diverseList.count - 1 - $pass" counter="$i">
              <set_value name="$currentScore" exact="$sortedDiverseList.{$i}.$Score"/>
              <set_value name="$nextScore" exact="$sortedDiverseList.{$i + 1}.$Score"/>
              <do_if value="$currentScore lt $nextScore">
                <!-- Swap -->
                <set_value name="$temp" exact="$sortedDiverseList.{$i}"/>
                <set_value name="$sortedDiverseList.{$i}" exact="$sortedDiverseList.{$i + 1}"/>
                <set_value name="$sortedDiverseList.{$i + 1}" exact="$temp"/>
                <set_value name="$swapped" exact="true"/>
              </do_if>
            </do_all>
            <!-- Early exit if no swaps (already sorted) -->
            <do_if value="not $swapped">
              <break/>
            </do_if>
          </do_all>
          <set_value name="$diverseList" exact="$sortedDiverseList"/>
        </do_elseif>
        <!-- Single item or empty: no sort needed -->
        
        <!-- 5. Cache maintenance: Delete old entries (if cache was refreshed) -->
        <!-- TODO: Track if new trades were added to cache during this search -->
        <!-- For now, assume cache was refreshed if batch processor ran -->
        <set_value name="$cacheRefreshed" exact="true"/>
        <!-- âœ… PERFORMANCE OPTIMIZATION v5: Cleanup per-home-sector cache -->
        <!-- Iterate through all home sectors in cache -->
        <do_if value="$cacheRefreshed">
          <set_value name="$cacheMaxAge" exact="15min"/>
          <set_value name="$deletedCount" exact="0"/>
          <do_if value="global.$GT_TradeCache?">
            <do_all exact="global.$GT_TradeCache.keys.count" counter="$sectorIdx">
              <set_value name="$cacheHomeSector" exact="global.$GT_TradeCache.keys.{$sectorIdx}"/>
              <set_value name="$sectorCache" exact="global.$GT_TradeCache.{$cacheHomeSector}"/>
              <do_if value="$sectorCache? and $sectorCache.count gt 0">
                <!-- Iterate backwards through this home sector's cache -->
                <set_value name="$sectorCacheCount" exact="$sectorCache.count"/>
                <do_all exact="$sectorCacheCount" counter="$i" reverse="true">
                  <set_value name="$entry" exact="$sectorCache.{$i}"/>
                  <do_if value="$entry? and $entry.$Timestamp?">
                    <set_value name="$entryAge" exact="player.age - $entry.$Timestamp"/>
                    <do_if value="$entryAge gt $cacheMaxAge">
                      <remove_value name="global.$GT_TradeCache.{$cacheHomeSector}.{$i}"/>
                      <set_value name="$deletedCount" operation="add"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$deletedCount gt 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Cache cleanup: Deleted ' + $deletedCount + ' entries older than 15 minutes'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- 6. Select best trade (for backward compatibility) -->
        <!-- âœ… CRITICAL FIX: Re-validate distance from home sector AND verify trade exists in final diverseList -->
        <!-- Prevents using stale trades that were filtered out by blacklist/path checks -->
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        
        <!-- Validate nonConflictedBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedNonConflictedTrade" exact="null"/>
        <do_if value="$nonConflictedBestTrade? and $nonConflictedBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$nonConflictedBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$nonConflictedBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- âœ… CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $nonConflictedBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $nonConflictedBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $nonConflictedBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedNonConflictedTrade" exact="$nonConflictedBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Validate crossStationBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedCrossStationTrade" exact="null"/>
        <do_if value="$crossStationBestTrade? and $crossStationBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$crossStationBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$crossStationBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- âœ… CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $crossStationBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $crossStationBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $crossStationBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedCrossStationTrade" exact="$crossStationBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="$validatedNonConflictedTrade? and $nonConflictedBestScore gt 0">
          <!-- Prefer non-conflicted from filtered list (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedNonConflictedTrade"/>
          <set_value name="$bestScore" exact="$nonConflictedBestScore"/>
        </do_if>
        <do_elseif value="$validatedCrossStationTrade? and $crossStationBestScore gt 0">
          <!-- Use cross-station trade (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedCrossStationTrade"/>
          <set_value name="$bestScore" exact="$crossStationBestScore"/>
        </do_elseif>
        <do_else>
          <!-- Fallback: Find best from diverse list -->
          <!-- âœ… FIX: Use library function for consistent validation -->
          <do_all exact="$diverseList.count" counter="$i">
            <set_value name="$trade" exact="$diverseList.{$i}"/>
            <run_actions ref="md.GT_Trade_Utilities.GT_IsTradeValid" result="$isValid">
              <param name="trade" value="$trade"/>
              <param name="minScore" value="$bestScore"/>
            </run_actions>
            <do_if value="$isValid">
              <set_value name="$testScore" exact="@$trade.$Score"/>
              <set_value name="$bestScore" exact="$testScore"/>
              <set_value name="$bestTrade" exact="$trade"/>
            </do_if>
          </do_all>
          <!-- CRITICAL: If bestScore is still 0, all trades have Score = 0 (don't meet profit thresholds) -->
          <!-- Set bestTrade to null so "no trade found" path executes -->
          <do_if value="$bestScore le 0">
            <set_value name="$bestTrade" exact="null"/>
          </do_if>
        </do_else>
        
        <!-- 7. Extract original parameters BEFORE cleanup (so they're available when signaling) -->
        <!-- âœ… CRITICAL FIX: For fallback searches (maxDistance == 2), ALWAYS use batch data (has relaxed values) -->
        <!-- For normal searches, use queue params if available, otherwise fall back to batch data -->
        <set_value name="$originalParams" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <set_value name="$isFallbackFromBatch" exact="false"/>
        <do_if value="$batchData? and $batchData.$maxDistance == 2">
          <!-- This is a fallback search - batch data has relaxed profit thresholds, use those instead of queue -->
          <set_value name="$isFallbackFromBatch" exact="true"/>
          <set_value name="$allowIllegalDefault" exact="false"/>
          <set_value name="$originalParams" exact="table[
            $Ship = $ship,
            $MaxDistance = @$batchData.$maxDistance,
            $MinROI = @$batchData.$minROI,
            $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
            $FactionPriority = @$batchData.$factionPriority,
            $AllowIllegal = $allowIllegalDefault
          ]"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') âœ… Using batch data params for fallback search (relaxed profit: ' + (@$batchData.$minAbsoluteProfit / 100) + ' Cr)'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Normal search - try queue first, then batch data -->
          <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
            <!-- Parameters are stored in search queue when search was initiated -->
            <set_value name="$originalParams" exact="global.$GT_SearchQueue.$Params.{$ship}"/>
          </do_if>
          <do_else>
            <!-- Fallback: Reconstruct parameters from batch data (before cleanup) -->
            <do_if value="$batchData?">
              <set_value name="$allowIllegalDefault" exact="false"/>
              <set_value name="$originalParams" exact="table[
                $Ship = $ship,
                $MaxDistance = @$batchData.$maxDistance,
                $MinROI = @$batchData.$minROI,
                $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                $FactionPriority = @$batchData.$factionPriority,
                $AllowIllegal = $allowIllegalDefault
              ]"/>
            </do_if>
          </do_else>
        </do_else>
        
        <!-- 8. Return results (including rejection statistics for diagnostics) -->
        <!-- Store trade count before storing in global (for accurate logging) -->
        <set_value name="$finalTradeCount" exact="$diverseList.count"/>
        <set_value name="$waitingFlag" exact="false"/>
        <!-- Combine blacklist and path blocked (both are safety restrictions) -->
        <set_value name="$totalBlacklistAndPath" exact="$filteredByBlacklist + $filteredByPathBlocked"/>
        <!-- Calculate total trades evaluated (valid + filtered) for accurate reporting -->
        <set_value name="$totalTradesEvaluated" exact="$finalTradeCount + $totalBlacklistAndPath + $filteredByIllegal + $filteredByWareBasket"/>
        
        <!-- âœ… CRITICAL FIX: Preserve LastRejectionStats when updating global.$GT_SearchResult -->
        <!-- FilterTradeList_Resume overwrites global.$GT_SearchResult, which would lose LastRejectionStats -->
        <set_value name="$preservedLastRejectionStats" exact="null"/>
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
        <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
          <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
        </do_if>
        
        <set_value name="global.$GT_SearchResult" exact="table[
          $Found = ($finalTradeCount gt 0),
          $BestTrade = $bestTrade,
          $BestScore = $bestScore,
          $TradeList = $diverseList,
          $TradesRejectedProfit = $tradesRejectedProfit,
          $TradesRejectedDocking = $tradesRejectedDocking,
          $TradesRejectedAmount = $tradesRejectedAmount,
          $TradesRejectedDistance = $tradesRejectedDistance,
          $TradesRejectedBlacklist = $totalBlacklistAndPath,
          $BestRejectedTrade = $bestRejectedTrade,
          $WaitingForBatch = $waitingFlag,
          $Ship = $ship,
          $FilteredByBlacklist = $filteredByBlacklist,
          $FilteredByPathBlocked = $filteredByPathBlocked,
          $TotalTradesEvaluated = $totalTradesEvaluated
        ]"/>
        
        <!-- âœ… CRITICAL FIX: Restore LastRejectionStats after updating global.$GT_SearchResult -->
        <do_if value="$preservedLastRejectionStats?">
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
        </do_if>
        
        <!-- 9. Cleanup batch data (using ship object as key) -->
        <remove_value name="global.$GT_BatchDataList.{$ship}"/>
        <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Complete. Returning ' + $diverseList.count + ' diverse trades. Best score: ' + $bestScore" chance="100"/>
        </do_if>
        
        <!-- 10. Signal SearchTradeRoutes again with original parameters so it can read the live search results -->
        <do_if value="$originalParams?">
          <signal_cue_instantly cue="md.GT_Trading_Search.SearchTradeRoutes" param="$originalParams"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Signaled SearchTradeRoutes to continue with live search results (' + $finalTradeCount + ' trades)'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fallback: Could not find original parameters, but results are already in global.$GT_SearchResult -->
          <!-- SearchTradeRoutes will be signaled by another mechanism or will read results on next check -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') âš ï¸ Could not find original parameters to signal SearchTradeRoutes - results stored in global.$GT_SearchResult'" chance="100"/>
          </do_if>
        </do_else>
      </actions>
    </cue>
    
    <!-- Search for Sell Opportunities -->
    <cue name="SearchSellOpportunities" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Receive parameters directly -->
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$minProfit" exact="$params.$MinProfit"/>
        
        <!-- DEBUG: Sell search start -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') === SELL SEARCH START ===' + '\nShip: ' + $ship.knownname + '\nCurrent Sector: ' + $ship.sector.knownname + '\nMax Distance: ' + $maxDistance + ' jumps' + '\nMin Profit: ' + $minProfit + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- Find best sell location for current cargo -->
        <set_value name="$bestOffer" exact="null"/>
        <set_value name="$bestPrice" exact="0"/>
        <set_value name="$bestAmount" exact="0"/>
        
        <!-- Get ship's current cargo -->
        <set_value name="$currentCargo" exact="$ship.cargo.list"/>
        
        <do_if value="$currentCargo.count gt 0">
          <!-- âœ… CRITICAL FIX: Sell ONE ware at a time (first ware in list) -->
          <!-- After this trade completes, ship will loop back and sell next ware -->
          <!-- This prevents multiple concurrent trade orders for the same ship -->
          
          <set_value name="$selectedWare" exact="$currentCargo.{1}"/>
          <set_value name="$selectedAmount" exact="$ship.cargo.{$selectedWare}.count"/>
          
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Cargo contains ' + $currentCargo.count + ' ware types, selling first: ' + @$selectedWare.name + ' x' + $selectedAmount + ' (after sale, will retry for remaining wares)'" chance="100"/>
          </do_if>
          
          <!-- Find buy offers for the selected ware -->
          <!-- âœ… CRITICAL: tradepartner="$ship" ensures only executable offers (relations, permissions, F6 limitations) -->
          <find_buy_offer tradepartner="$ship" space="player.galaxy" result="$buyOffers" multiple="true" wares="$selectedWare">
            <match_buyer tradesknownto="$ship.owner">
              <match_gate_distance object="$ship" max="$maxDistance"/>
            </match_buyer>
          </find_buy_offer>
          
          <!-- âœ… FIX: Determine blacklistgroup (same logic as SearchLiveTrades_Resume) -->
          <run_actions ref="md.GT_Blacklist_Utilities.GT_GetBlacklistGroup" result="$blacklistgroup">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Find best price -->
          <do_all exact="$buyOffers.count" counter="$j">
            <set_value name="$offer" exact="$buyOffers.{$j}"/>
            <set_value name="$station" exact="$offer.owner"/>
            <set_value name="$currentSector" exact="$ship.sector"/>
            <set_value name="$stationSector" exact="$station.sector"/>
            
            <!-- âœ… NOTE: tradepartner="$ship" in find_buy_offer already filters by faction relations -->
            <!-- No explicit check needed - C++ engine handles it -->
            
            <!-- âœ… VALIDATION: Check blacklists before considering offer -->
            <set_value name="$isBlacklisted" exact="false"/>
            
            <!-- âœ… FIX: Block intra-sector sales in blacklisted sectors (force escape) -->
            <!-- If ship is in blacklisted sector and trying to sell to station in same sector, block -->
            <do_if value="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
              <do_if value="$stationSector == $currentSector">
                <!-- Intra-sector sale in blacklisted sector - BLOCK to force escape -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (intra-sector sale in blacklisted sector - must escape)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check station blacklist (object activity) -->
            <do_if value="not $isBlacklisted and @$station.isblacklisted.{blacklisttype.objectactivity}.{$blacklistgroup}.{$ship}">
              <set_value name="$isBlacklisted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (station blacklisted)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (sector activity) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector activity blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (travel) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector travel blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- âœ… VALIDATION: Check if path to station goes through blacklisted sectors -->
            <!-- Uses blacklist-aware gatedistance - returns -1 if path blocked by blacklisted sector -->
            <!-- Vanilla pattern: order.dock.xml:503 -->
            <do_if value="not $isBlacklisted">
              <set_value name="$pathDistance" exact="$ship.gatedistance.{$stationSector}.{$blacklistgroup}.{$ship}"/>
              
              <do_if value="$pathDistance lt 0">
                <!-- Path goes through blacklisted sector or no path exists -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <!-- <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (path goes through blacklisted sector)'" chance="100"/> -->
                </do_if>
              </do_if>
            </do_if>
            
            <!-- âœ… VALIDATION: Check operational status -->
            <set_value name="$isOperational" exact="$station.isoperational and not @$station.isclosingdown"/>
            <do_if value="not $isBlacklisted and not $isOperational">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (not operational)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- âœ… VALIDATION: Check technical docking capability - does station have docking bay for this ship size? -->
            <set_value name="$canDock" exact="false"/>
            <do_if value="not $isBlacklisted and $isOperational">
              <find_dockingbay name="$testDock" object="$station" checkoperational="true" multiple="false">
                <match_dock size="$ship.docksize" storage="false"/>
              </find_dockingbay>
              <do_if value="$testDock">
                <!-- Station has docking bay for this ship size - check docking permission -->
                <set_value name="$canDock" exact="$station.dockingallowed.{$ship}"/>
              </do_if>
              <do_else>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (no docking bay for ship size ' + $ship.docksize + ')'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            
            <!-- âœ… VALIDATION: Check docking permission -->
            <do_if value="not $isBlacklisted and $isOperational and not $canDock">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (docking not allowed)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Only consider valid, non-blacklisted, operational, dockable offers -->
            <do_if value="not $isBlacklisted and $isOperational and $canDock and $offer.available">
              <set_value name="$tradeAmount" exact="[$selectedAmount, $offer.amount].min"/>
              <set_value name="$profit" exact="$offer.unitprice * $tradeAmount"/>
              
              <do_if value="$profit gt $bestPrice">
                <set_value name="$bestOffer" exact="$offer"/>
                <set_value name="$bestPrice" exact="$profit"/>
                <set_value name="$bestAmount" exact="$tradeAmount"/>
                
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer now: ' + @$station.knownname + ' - ' + $offer.ware.name + ' x' + $tradeAmount + ' @ ' + $offer.unitprice + ' Cr/unit (profit: ' + $profit + ' Cr)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_all>
          
          <!-- Execute best sell if found -->
          <do_if value="$bestOffer and $bestPrice gt $minProfit">
            <!-- âœ… CRITICAL: Validate offer is STILL valid before creating order -->
            <!-- Offers can become invalid between search and order creation -->
            <set_value name="$offerStillValid" exact="$bestOffer.available and $bestOffer.amount gt 0"/>
            
            <do_if value="$offerStillValid">
              <debug_text text="'[GalaxyTrader MK3] ' + $ship.knownname + ' found sell opportunity'" chance="100"/>
              
              <!-- Create trade order with blacklist routing enabled -->
              <!-- internal="true" ensures pathfinding routes around blacklisted sectors -->
              <create_trade_order object="$ship" tradeoffer="$bestOffer" amount="$bestAmount" immediate="false" internal="true"/>
              
              <!-- Signal back to AI script: Trade Found -->
              <signal_objects object="$ship" param="'GT_Trade_Found'"/>
            </do_if>
            <do_else>
              <!-- Offer became invalid - don't create order -->
              <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer became invalid before order creation - retrying'" chance="100"/>
              
              <!-- Signal back to AI script: No Trade Found (will retry) -->
              <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Signal back to AI script: No Trade Found -->
            <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- Signal back to AI script: No Trade Found (no cargo) -->
          <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
        </do_else>
        
        <!-- CRITICAL: Clean up AI parameters -->
        <!-- âœ… SIMPLIFIED: Initialization guarantees global.$GT_AIParameters exists -->
        <do_if value="global.$GT_AIParameters.{$ship}?">
          <remove_value name="global.$GT_AIParameters.{$ship}"/>
        </do_if>
      </actions>
    </cue>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- SearchFallbackTrades: Fallback search with MaxDistance=2 for nearby trades -->
    <!-- Only triggers when cache + normal live search both fail AND ship is not isolated -->
    <!-- Reuses SearchLiveTrades infrastructure with MaxDistance forced to 2 -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <cue name="SearchFallbackTrades" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        
        <!-- âœ… DEBUG: Log fallback search trigger -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ”„ Fallback search triggered: MaxDistance=2, Ship not isolated'" chance="100"/>
        </do_if>
        
        <!-- âœ… FALLBACK PROFIT RELAXATION: Reduce profit thresholds to allow lower-profit trades -->
        <!-- Fallback is last resort, so accept lower profits to find ANY trade -->
        <!-- âœ… FIX: Fallback uses fixed 100 Cr threshold regardless of pilot level -->
        <set_value name="$fallbackMinROI" exact="[$params.$MinROI / 2, 0].max"/>  <!-- Half of normal ROI, minimum 0% -->
        <set_value name="$fallbackMinAbsoluteProfit" exact="10000"/>  <!-- Fixed 100 Cr for all levels -->
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') ðŸ’° Fallback profit thresholds relaxed: ROI ' + $params.$MinROI + '% â†’ ' + $fallbackMinROI + '%, Profit fixed at 100 Cr (all levels)'" chance="100"/>
        </do_if>
        
        <!-- Call SearchLiveTrades with MaxDistance forced to 2 and relaxed profit thresholds -->
        <!-- MaxDistance=2 is used for search space (sectors within 2 jumps from current position) -->
        <!-- OriginalMaxDistance is used for filtering (stations must be within pilot's maxDistance from home sector) -->
        <!-- All other parameters are inherited from original search request -->
        <set_value name="$liveSearchParams" exact="table[
          $Ship = $ship,
          $MaxDistance = 2,
          $OriginalMaxDistance = $params.$OriginalMaxDistance,
          $MinROI = $fallbackMinROI,
          $MinAbsoluteProfit = $fallbackMinAbsoluteProfit,
          $FactionPriority = $params.$FactionPriority,
          $FactionPriorityText = $params.$FactionPriorityText,
          $DistancePenaltyMultiplier = $params.$DistancePenaltyMultiplier,
          $SkillLevel = $params.$SkillLevel,
          $ThreatIntel = $params.$ThreatIntel,
          $FleetCoord = $params.$FleetCoord,
          $AdvancedAnalytics = $params.$AdvancedAnalytics
        ]"/>
        <signal_cue_instantly cue="SearchLiveTrades" param="$liveSearchParams"/>
        
        <!-- SearchLiveTrades will handle the rest (signals SearchLiveTrades_Resume, which signals SearchTradeRoutes) -->
        <!-- Results will be processed the same way as normal live search -->
      </actions>
    </cue>
    
  </cues>
</mdscript>
