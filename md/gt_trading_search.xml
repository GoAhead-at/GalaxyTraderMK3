<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Trading_Search" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ========================================
         GALAXY TRADER MK3 - SEARCH ENGINE
         Core trade route search and matching logic
         ======================================== -->
    
    <!-- Search for Trade Routes (MAIN SEARCH ENGINE) -->
    <cue name="SearchTradeRoutes" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Receive parameters directly from event to prevent race conditions -->
        <!-- Handle case where SearchLiveTrades_Resume signals again after batch completion -->
        <set_value name="$params" exact="event.param"/>
        <do_if value="not $params?">
          <!-- Parameters not provided - try to get from search queue or batch data -->
          <!-- Note: With per-ship storage, we can't reconstruct ship from global.$GT_SearchResult -->
          <!-- Must rely on search queue params or batch data -->
          <set_value name="$shipFromQueue" exact="null"/>
          
          <do_if value="$shipFromQueue?">
            <!-- Try to get params from search queue -->
            <!-- Initialization guarantees global.$GT_SearchQueue exists -->
            <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$shipFromQueue}?">
              <set_value name="$params" exact="global.$GT_SearchQueue.$Params.{$shipFromQueue}"/>
            </do_if>
            <do_else>
              <!-- Reconstruct params from batch data (if still available) -->
              <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$shipFromQueue}"/>
              <do_if value="$batchData?">
                <set_value name="$allowIllegalDefault" exact="false"/>
                <set_value name="$params" exact="table[
                  $Ship = $shipFromQueue,
                  $MaxDistance = @$batchData.$maxDistance,
                  $MinROI = @$batchData.$minROI,
                  $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                  $FactionPriority = @$batchData.$factionPriority,
                  $AllowIllegal = $allowIllegalDefault
                ]"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>
        
        <!-- Validate params exist and are not null -->
        <!-- Check if $params exists AND has required $Ship property (handles null case) -->
        <set_value name="$paramsValid" exact="false"/>
        <do_if value="$params?">
          <set_value name="$testShip" exact="@$params.$Ship"/>
          <do_if value="$testShip?">
            <set_value name="$paramsValid" exact="true"/>
          </do_if>
        </do_if>
        
        <do_if value="not $paramsValid">
          <!-- Only log when debug is enabled -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchTradeRoutes called without valid parameters - cannot proceed'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Check batch status FIRST, before ANY other processing -->
        <!-- If batch is in progress FOR THIS SHIP, exit IMMEDIATELY - don't do ANY processing -->
        <!-- This prevents race conditions where SearchTradeRoutes continues executing after SearchLiveTrades starts batch processing -->
        <!-- Use library function for batch status checking -->
        <run_actions ref="md.GT_Libraries_General.GT_CheckBatchStatus" result="$batchStatus">
          <param name="ship" value="$params.$Ship"/>
        </run_actions>
        <set_value name="$waitingForBatch" exact="$batchStatus.$IsBatchActive"/>
        <set_value name="$batchShip" exact="$batchStatus.$BatchShip"/>
        <set_value name="$shouldProceed" exact="$batchStatus.$ShouldProceed"/>

        <!-- Concurrency flags MUST be available even if we early-exit before the main $shouldProceed block.
             Otherwise, pre-gate exits (e.g. "live search already in progress") can leak cache-search queue slots
             because $useSearchQueueCounter is never set and the cleanup block won't decrement ActiveSearches. -->
        <set_value name="$useSearchQueueCounter" exact="false"/>
        <do_if value="$params.$UseSearchQueueCounter?">
          <set_value name="$useSearchQueueCounter" exact="$params.$UseSearchQueueCounter"/>
        </do_if>
        <set_value name="$fromLiveQueue" exact="false"/>
        <do_if value="$params.$FromLiveQueue? and $params.$FromLiveQueue == true">
          <set_value name="$fromLiveQueue" exact="true"/>
        </do_if>
        <!-- Always have a valid ship reference for early-exit cleanup paths -->
        <set_value name="$shipForCleanup" exact="$params.$Ship"/>

        <!-- CRITICAL:
             If a live search is already in progress for this ship, do NOT proceed with a fresh SearchTradeRoutes run.
             Reason: In MD, cancel_cue does not abort the current actions block immediately; the cue can still fall through
             and incorrectly signal GT_No_Trade_Found during the cache-miss cooldown window (seen for EDS-278).
             Live completion runs with explicit SearchState='live'/'fallback' and will not have live-state present. -->
        <set_value name="$searchStateParam" exact="@$params.$SearchState"/>
        <do_if value="$shouldProceed and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$params.$Ship}? and not ($searchStateParam == 'live' or $searchStateParam == 'fallback')">
          <!-- Distinguish real in-progress live search from stale leftover state.
               Real in-progress searches can be in multiple phases:
               - pathfinding queued/running (before batch markers exist),
               - batch work queued/running,
               - waiting for batch completion marker.
               Only clear state if it's OLD and there are no progress markers. -->
          <set_value name="$hasWaitingForBatchMarker" exact="false"/>
          <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.{$params.$Ship}? and global.$GT_SearchResult.{$params.$Ship}.$WaitingForBatch? and global.$GT_SearchResult.{$params.$Ship}.$WaitingForBatch == true">
            <set_value name="$hasWaitingForBatchMarker" exact="true"/>
          </do_if>
          <set_value name="$hasBatchData" exact="false"/>
          <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$params.$Ship}?">
            <set_value name="$hasBatchData" exact="true"/>
          </do_if>
          <set_value name="$hasPathfinding" exact="false"/>
          <do_if value="global.$GT_PathfindingQueue? and global.$GT_PathfindingQueue.$ActiveShips?">
            <do_all exact="global.$GT_PathfindingQueue.$ActiveShips.count" counter="$i">
              <do_if value="global.$GT_PathfindingQueue.$ActiveShips.{$i} == $params.$Ship">
                <set_value name="$hasPathfinding" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="not $hasPathfinding and global.$GT_PathfindingQueue? and global.$GT_PathfindingQueue.$Requests?">
            <do_all exact="global.$GT_PathfindingQueue.$Requests.count" counter="$i">
              <set_value name="$req" exact="global.$GT_PathfindingQueue.$Requests.{$i}"/>
              <do_if value="$req? and $req.$Ship? and $req.$Ship == $params.$Ship">
                <set_value name="$hasPathfinding" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>

          <set_value name="$stateStarted" exact="null"/>
          <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$params.$Ship}? and global.$GT_SearchLiveTrades_State.{$params.$Ship}.$Started?">
            <set_value name="$stateStarted" exact="global.$GT_SearchLiveTrades_State.{$params.$Ship}.$Started"/>
          </do_if>
          <set_value name="$stateAge" exact="-1"/>
          <do_if value="$stateStarted?">
            <set_value name="$stateAge" exact="player.age - $stateStarted"/>
          </do_if>

          <!-- HARD STALE GUARD:
               Even if progress markers exist, a live-search state can get stuck (e.g. lost completion signal).
               If it's too old, clear it so fresh requests don't stall indefinitely. -->
          <do_if value="$stateAge gt 300s">
            <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Clearing STALE live-search state (pre-gate HARD) - stateAge=' + $stateAge + ' (was blocking new requests)'" chance="100"/>
            </do_if>
          </do_if>

          <!-- If no markers: only clear if state is old enough to be genuinely stale. -->
          <do_if value="not $hasWaitingForBatchMarker and not $hasBatchData and not $hasPathfinding and ($stateAge lt 0 or $stateAge gt 120s)">
            <!-- Stale: clear and continue normally -->
            <remove_value name="global.$GT_SearchLiveTrades_State.{$params.$Ship}"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Clearing STALE live-search state (pre-gate) - no progress markers (pathfinding/batch) and stateAge=' + $stateAge" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Real in-progress: skip this fresh SearchTradeRoutes run -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Live search already in progress (pre-gate) - skipping SearchTradeRoutes execution (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>

            <!-- IMPORTANT: If this invocation consumed a cache-search queue slot, release it immediately.
                 We must NOT delete per-ship params here because live search/batch needs them for continuation. -->
            <do_if value="$useSearchQueueCounter">
              <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
                <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
              </do_if>
              <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
                <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
              </do_if>
              <!-- Prevent any later cleanup block (if reached) from double-decrementing -->
              <set_value name="$useSearchQueueCounter" exact="false"/>
            </do_if>

            <!-- IMPORTANT:
                 Do NOT stall the AI while another live-search is in progress for this ship.
                 Fail fast so the AI can retry later (and avoid indefinite "waiting for resume" if the live-search state is stuck). -->
            <do_if value="$params? and $params.$Ship? and $params.$Ship.exists">
              <signal_objects object="$params.$Ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
            </do_if>

            <set_value name="$shouldProceed" exact="false"/>
            <cancel_cue cue="this"/>
          </do_else>
        </do_if>
        
        <!-- Only exit if batch is in progress FOR THIS SHIP -->
        <!-- If batch is for a different ship, proceed normally -->
        <do_if value="$waitingForBatch and $batchStatus.$IsForThisShip">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ')    Batch processing in progress FOR THIS SHIP - waiting for completion (will resume when batch completes)'" chance="100"/>
          </do_if>

          <!-- IMPORTANT: If this invocation consumed a cache-search queue slot, release it immediately.
               This branch can be hit by duplicate signals while the batch processor is working, and without releasing
               the cache-search slot we can leak ActiveSearches → ProcessSearchQueue pins at max (active: 5) and stalls. -->
          <do_if value="$useSearchQueueCounter">
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
              <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
            </do_if>
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
            </do_if>
            <!-- Prevent any later cleanup (if reached) from double-decrementing -->
            <set_value name="$useSearchQueueCounter" exact="false"/>
          </do_if>

          <!-- Exit - SearchLiveTrades_Resume will signal this cue again when results are ready -->
          <cancel_cue cue="this"/>
        </do_if>
        <do_elseif value="$waitingForBatch and not $batchStatus.$IsForThisShip">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] (' + $params.$Ship.idcode + ') Batch processing in progress FOR DIFFERENT SHIP (' + (if $batchShip != null then @$batchShip.idcode else 'UNKNOWN') + ') - proceeding normally'" chance="100"/>
          </do_if>
        </do_elseif>
        
        <do_if value="$shouldProceed">
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="@$params.$MaxDistance"/>
        <set_value name="$minROI" exact="@$params.$MinROI"/>
        <set_value name="$minAbsoluteProfit" exact="@$params.$MinAbsoluteProfit"/>
        <set_value name="$factionPriority" exact="@$params.$FactionPriority"/>

        <!-- Concurrency flags -->
        <!-- Cache concurrency is managed by GT_SearchQueue; live concurrency is managed by GT_LiveSearchQueue -->
        <set_value name="$useSearchQueueCounter" exact="false"/>
        <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
          <set_value name="$useSearchQueueCounter" exact="true"/>
        </do_if>
        <do_if value="$params.$UseSearchQueueCounter?">
          <set_value name="$useSearchQueueCounter" exact="$params.$UseSearchQueueCounter"/>
        </do_if>
        <set_value name="$fromLiveQueue" exact="false"/>
        <do_if value="$params.$FromLiveQueue? and $params.$FromLiveQueue == true">
          <set_value name="$fromLiveQueue" exact="true"/>
        </do_if>
        
        <!-- Validate maxDistance - must not be null (fail loudly, no fallback) -->
        <do_if value="$maxDistance == null">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] ERROR: (' + $ship.idcode + ') MaxDistance is null or invalid (' + $maxDistance + ') - cannot proceed without valid distance parameter!'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        <do_elseif value="$maxDistance lt 0">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Search] ERROR: (' + $ship.idcode + ') MaxDistance is null or invalid (' + $maxDistance + ') - cannot proceed without valid distance parameter!'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_elseif>
        
        <!-- Log profit threshold from params -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') Profit threshold from params: ' + ($minAbsoluteProfit / 100) + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- EXPLICIT STATE ENUM: Determine search state from params or infer from context -->
        <!-- SearchState values: 'fresh' (new search), 'cache' (cache results), 'live' (live search continuation), 'fallback' (fallback continuation) -->
        <set_value name="$searchState" exact="@$params.$SearchState"/>
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance -->
        <do_if value="$params.$OriginalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$params.$OriginalMaxDistance"/>
        </do_if>
        
        <!-- If SearchState not provided, infer from context (backward compatibility) -->
        <do_if value="not $searchState?">
          <!-- Check if we're continuing from live search completion -->
          <set_value name="$savedWaitingForBatch" exact="true"/>
          <do_if value="global.$GT_SearchResult.{$ship}?">
            <set_value name="$shipResults" exact="global.$GT_SearchResult.{$ship}"/>
            <set_value name="$savedWaitingForBatch" exact="@$shipResults.$WaitingForBatch"/>
            <do_if value="not $savedWaitingForBatch">
              <!-- Live search just completed - check if fallback -->
              <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                <set_value name="$searchState" exact="'fallback'"/>
              </do_if>
              <do_else>
                <set_value name="$searchState" exact="'live'"/>
              </do_else>
            </do_if>
            <do_else>
              <!-- Still waiting for batch or cache search - check cache results -->
              <set_value name="$cacheFound" exact="@$shipResults.$Found"/>
              <do_if value="$cacheFound">
                <set_value name="$searchState" exact="'cache'"/>
              </do_if>
              <do_else>
                <set_value name="$searchState" exact="'fresh'"/>
              </do_else>
            </do_else>
          </do_if>
          <do_else>
            <!-- No results yet - fresh search -->
            <set_value name="$searchState" exact="'fresh'"/>
          </do_else>
        </do_if>
        
        <!-- Debug state detection -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') SearchState=' + $searchState + ' (originalMaxDistance=' + $originalMaxDistance + ', maxDistance=' + $maxDistance + ')'" chance="100"/>
        </do_if>

        <!-- CRITICAL:
             If a live search is already in progress for this ship, exit immediately.
             Otherwise a second SearchTradeRoutes instance can run during the cache-miss cooldown window
             and incorrectly signal GT_No_Trade_Found while the async live-search/batch pipeline is still running
             (this is exactly what happens for EDS-278 in the log at 1669.86). -->
        <do_if value="$searchState == 'fresh' and global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Live search already in progress - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
          </do_if>
          <cancel_cue cue="this"/>
        </do_if>
        
        <!-- Clear fallback flag at start of new search cycle -->
        <!-- This allows fallback to be attempted again if cache and live search both fail -->
        <!-- BUT: Don't clear if this is a fallback continuation -->
        <do_if value="global.$GT_FallbackAttempted.{$ship}? and $searchState != 'fallback'">
          <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Starting new search cycle - cleared fallback flag'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Clear logbook flag ONLY when starting a completely new search (not from continuation) -->
        <do_if value="global.$GT_FallbackLogbookWritten.{$ship}? and $searchState == 'fresh'">
          <remove_value name="global.$GT_FallbackLogbookWritten.{$ship}"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cleared logbook flag - new search request detected'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Create faction priority text for debug output -->
        <run_actions ref="md.GT_Libraries_General.GT_GetFactionPriorityText" result="$factionPriorityText">
          <param name="factionPriority" value="$factionPriority"/>
        </run_actions>
        
        <!-- Get distance penalty setting (0-100% converted to 0.0-2.0 multiplier) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetDistancePenaltyMultiplier" result="$distancePenaltyMultiplier">
          <param name="ship" value="$ship"/>
        </run_actions>

        <!-- Resolve pilot skill and apply feature gates + level-based thresholds -->
        <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$skillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>

        <!-- Feature gates by skill level -->
        <set_value name="$gt_ThreatIntel" exact="$skillLevel ge 6"/>
        <set_value name="$gt_SatelliteIntel" exact="$skillLevel ge 9"/>
        <set_value name="$gt_FleetCoord" exact="$skillLevel ge 12"/>
        <set_value name="$gt_AdvancedAnalytics" exact="$skillLevel ge 15"/>
        
        <!-- Profit threshold is now pilot level-based (set in gt_trading_queue.xml) -->
        <!-- Level 1: 0 Cr, Level 2: 100 Cr, Level 3: 500 Cr, Level 4+: Config value with skill multiplier -->
        <!-- Params already contain the correct pilot level-based threshold, so no need to apply multiplier here -->
        <!-- ROI multiplier still applies for ROI threshold (not profit threshold) -->
        <!-- Only apply ROI multiplier if NOT a fallback continuation -->
        <!-- Fallback continuation params come from SearchFallbackTrades which already relaxed the already-multiplied values -->
        <do_if value="$searchState != 'fallback'">
          <run_actions ref="md.GT_Libraries_General.GT_GetSkillMultiplier" result="$roiMultiplier">
            <param name="skillLevel" value="$skillLevel"/>
          </run_actions>
          <set_value name="$minROI" exact="$minROI * $roiMultiplier"/>
          <!-- Note: $minAbsoluteProfit is already set correctly from params (pilot level-based) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') [OK] Profit threshold unchanged (pilot level-based): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI multiplier applied: ' + $minROI + '% (multiplier: ' + $roiMultiplier + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fallback continuation - params already have relaxed thresholds -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Profit threshold from fallback continuation (already relaxed): ' + ($minAbsoluteProfit / 100) + ' Cr | ROI: ' + $minROI + '%'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- Log search start for detailed diagnostics (debug mode only) -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$pilotInfo" exact="'No Pilot'"/>
          <do_if value="$ship.pilot">
            <set_value name="$shownSkill" exact="1"/>
            <do_if value="global.$GT_Pilots.{$ship.pilot}? and global.$GT_Pilots.{$ship.pilot}.$Level?">
              <set_value name="$shownSkill" exact="global.$GT_Pilots.{$ship.pilot}.$Level"/>
            </do_if>
            <do_elseif value="$ship.pilot.skill.management?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.management"/>
            </do_elseif>
            <do_elseif value="$ship.pilot.skill.piloting?">
              <set_value name="$shownSkill" exact="$ship.pilot.skill.piloting"/>
            </do_elseif>
            <set_value name="$pilotInfo" exact="$ship.pilot.name + ' (Skill: ' + $shownSkill + ')'"/>
          </do_if>
          <debug_text text="'[GT-Search] (' + $ship.idcode + ') === TRADE SEARCH START ===' + 
            '\nShip: ' + $ship.knownname + 
            '\nPilot: ' + $pilotInfo + 
            '\nCurrent Sector: ' + $ship.sector.knownname + 
            '\nMax Distance: ' + $maxDistance + ' jumps' + 
            '\nMin ROI: ' + $minROI + '%' + 
            '\nMin Absolute Profit: ' + ($minAbsoluteProfit / 100) + ' Cr' + 
            '\nShip Cargo: ' + ($ship.cargo.capacity.all - $ship.cargo.free.all) + '/' + $ship.cargo.capacity.all +
            '\nFaction Priority: ' + $factionPriorityText" 
            chance="100"/>
        </do_if>
        
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        <set_value name="$foundCachedTrade" exact="false"/>
        <!-- Note: $fallbackSearchTriggered is set earlier based on SearchState - don't reset it here! -->
        
        <!-- Clear logbook flag when new normal search cycle starts -->
        <!-- This allows logbook message to be written again for new fallback attempts -->
        <!-- BUT: Don't clear if this is a continuation (fallback or live search) -->
        <!-- Note: Already handled above in state detection section -->
        
        <!-- Extract live search results if continuation (already detected earlier) -->
        <!-- When SearchLiveTrades_Resume signals SearchTradeRoutes, live results are already in global.$GT_SearchResult -->
        <!-- We should use those results instead of running cache search again -->
        <!-- Extract and preserve live results IMMEDIATELY before cache search can overwrite them -->
        <!-- SearchState is already set earlier (before skill multiplier) - use it to determine continuation -->
        <set_value name="$liveTradeList" exact="[]"/>
        <set_value name="$liveBestTrade" exact="null"/>
        <set_value name="$liveBestScore" exact="0"/>
        
        <!-- Initialize fallback trigger flag - set to true if this IS a fallback continuation (prevents re-triggering) -->
        <!-- This prevents infinite loops when SearchState='fallback' -->
        <set_value name="$fallbackSearchTriggered" exact="false"/>
        <do_if value="$searchState == 'fallback'">
          <!-- This IS a fallback continuation - mark as triggered to prevent infinite loop -->
          <set_value name="$fallbackSearchTriggered" exact="true"/>
        </do_if>
        
        <!-- Extract live search results if this is a live or fallback continuation -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <set_value name="$savedTradeList" exact="[]"/>
          <set_value name="$savedTradeListTemp" exact="@global.$GT_SearchResult.{$ship}.$TradeList"/>
          <do_if value="$savedTradeListTemp?">
            <set_value name="$tempCount" exact="@$savedTradeListTemp.count"/>
            <do_if value="$tempCount?">
              <set_value name="$savedTradeList" exact="$savedTradeListTemp"/>
            </do_if>
          </do_if>
          <set_value name="$liveTradeList" exact="$savedTradeList"/>
          <!-- SAFETY: ensure list is never null (prevents .count property lookup crash) -->
          <do_if value="$liveTradeList == null">
            <set_value name="$liveTradeList" exact="[]"/>
          </do_if>
          <set_value name="$liveBestTrade" exact="@global.$GT_SearchResult.{$ship}.$BestTrade"/>
          <set_value name="$liveBestScore" exact="@global.$GT_SearchResult.{$ship}.$BestScore"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$liveTradeCount" exact="0"/>
            <do_if value="$liveTradeList != null">
              <set_value name="$liveTradeCount" exact="$liveTradeList.count"/>
            </do_if>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Using live search results (' + $liveTradeCount + ' trades, state=' + $searchState + ', fallbackTriggered=' + $fallbackSearchTriggered + ')'" chance="100"/>
          </do_if>
        </do_if>
        

        
        <!-- Check trade cache with age validation -->
        <!-- Only run cache search if NOT continuing from live search AND NOT forcing live search -->
        <set_value name="$cacheChecked" exact="false"/>
        <set_value name="$cacheCount" exact="0"/>
        <set_value name="$cacheTradeList" exact="[]"/>
        <set_value name="$cacheBestTrade" exact="null"/>
        <set_value name="$cacheBestScore" exact="0"/>
        
        <!-- Check if ForceLiveSearch flag is set (AI rejected all cached trades) -->
        <set_value name="$forceLiveSearch" exact="@$params.$ForceLiveSearch"/>
        
        <!-- Cache continuation: SearchCachedTrades already completed and signalled us -->
        <set_value name="$cacheContinuation" exact="false"/>
        <do_if value="$params.$CacheContinuation? and $params.$CacheContinuation == true">
          <set_value name="$cacheContinuation" exact="true"/>
        </do_if>
        
        <!-- Only check cache if this is a fresh search (not live/fallback continuation) -->
        <do_if value="$searchState == 'fresh' and not $forceLiveSearch">
          <!-- Track search method for diagnostics -->
          <set_value name="$searchMethod" exact="'cache'"/>
          <set_value name="$cacheChecked" exact="true"/>
          <!-- Calculate total cache count from all home sectors -->
          <!-- Use library function for cache count calculation -->
          <run_actions ref="md.GT_Libraries_General.GT_CalculateTotalCacheCount" result="$cacheCount"/>
          
          <!-- Log cache check start (debug mode only) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') Checking trade cache (cache size: ' + $cacheCount + ' entries)'" chance="100"/>
          </do_if>
          
          <!-- Start batched cache validation if we haven't already resumed from it -->
          <do_if value="not $cacheContinuation">
            <signal_cue_instantly cue="md.GT_Search_Methods.SearchCachedTrades" param="table[
              $Ship = $ship,
              $MaxDistance = $maxDistance,
              $MinROI = $minROI,
              $MinAbsoluteProfit = $minAbsoluteProfit,
              $FactionPriority = $factionPriority,
              $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
              $SkillLevel = $skillLevel,
              $AllowIllegal = $params.$AllowIllegal
            ]"/>
            
            <!-- Exit: SearchCachedTrades will signal SearchTradeRoutes again when cache results are ready -->
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
          
            <!-- CacheContinuation: Extract cache results from per-ship storage -->
            <set_value name="$foundCachedTrade" exact="false"/>
            <set_value name="$cacheBestTrade" exact="null"/>
            <set_value name="$cacheBestScore" exact="0"/>
            <set_value name="$cacheBlacklistRejections" exact="0"/>
            <set_value name="$cacheTradeList" exact="[]"/>
            <do_if value="global.$GT_SearchResult.{$ship}?">
              <set_value name="$shipResults" exact="global.$GT_SearchResult.{$ship}"/>
              <set_value name="$foundCachedTrade" exact="@$shipResults.$Found"/>
              <set_value name="$cacheBestTrade" exact="@$shipResults.$BestTrade"/>
              <set_value name="$cacheBestScore" exact="@$shipResults.$BestScore"/>
              <set_value name="$cacheBlacklistRejections" exact="@$shipResults.$BlacklistRejections"/>
              <set_value name="$cacheTradeList" exact="@$shipResults.$TradeList"/>
            </do_if>
            
            <!-- Log cache check results (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$cacheTradeCount" exact="0"/>
              <do_if value="$cacheTradeList?">
                <set_value name="$cacheTradeCount" exact="@$cacheTradeList.count"/>
              </do_if>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Cache check complete: Found=' + $foundCachedTrade + ', Trades=' + $cacheTradeCount + ', BestScore=' + $cacheBestScore" chance="100"/>
            </do_if>
          </do_else>
        </do_if>
        <do_else>
          <!-- Live search continuation OR ForceLiveSearch - skip cache, use live results -->
          <set_value name="$searchMethod" exact="'live'"/>
          <do_if value="$forceLiveSearch">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') ForceLiveSearch flag set - skipping cache, going straight to live search'" chance="100"/>
            </do_if>
            <!-- Clear ForceLiveSearch flag after use -->
            <!-- Initialization guarantees global.$GT_AIParameters exists -->
            <do_if value="global.$GT_AIParameters.{$ship}?">
              <remove_value name="global.$GT_AIParameters.{$ship}.$ForceLiveSearch"/>
            </do_if>
          </do_if>
        </do_else>
        
        <!-- WAIT: Cache search is async (batched). Don't proceed until cache results are ready. -->
        <!-- Initial fresh search starts SearchCachedTrades and then pauses this cue instance. -->
        <!-- Continuations (CacheContinuation/live/fallback) skip this gate and proceed normally. -->
        <do_if value="$cacheContinuation or $searchState != 'fresh' or $forceLiveSearch">
        
        <!-- Compare cache vs live results and use the best -->
        <!-- If we have live/fallback continuation, use live results (they're fresher) -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <!-- Using live search results -->
          <set_value name="$bestTrade" exact="$liveBestTrade"/>
          <set_value name="$bestScore" exact="$liveBestScore"/>
          <set_value name="$tradeList" exact="$liveTradeList"/>
          <set_value name="$foundCachedTrade" exact="false"/>
        </do_if>
        <do_else>
          <!-- Using cache results (or will check live search if needed) -->
          <set_value name="$bestTrade" exact="$cacheBestTrade"/>
          <set_value name="$bestScore" exact="$cacheBestScore"/>
          <set_value name="$tradeList" exact="$cacheTradeList"/>
        </do_else>
        <!-- SAFETY: ensure list is never null (prevents .count property lookup crash) -->
        <do_if value="$tradeList == null">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        
        <!-- Validate bestTrade IMMEDIATELY after setting from cache/live sources -->
        <!-- Use strict validation to catch invalid trades before execution validation -->
        <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeValidFromSource">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        <do_if value="not $bestTradeValidFromSource">
          <!-- bestTrade from source is invalid - clear it so fallback can fix it -->
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade from source (cache/live) is INVALID - cleared for fallback fix'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Initialize rejection statistics (for both cached and live searches) -->
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedBlacklist" exact="0"/>
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$offersFound" exact="0"/>
        <set_value name="$stationsEvaluated" exact="0"/>
        <set_value name="$bestRejectedTrade" exact="null"/>
        
        <!-- If using live search continuation, retrieve rejection stats from global (includes filtering stats) -->
        <do_if value="$searchState == 'live' or $searchState == 'fallback'">
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') RETRIEVING STATS FROM CONTINUATION:' +
              '\n  TradesRejectedDocking exists: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedDocking? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist exists: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist? then 'yes' else 'no') +
              '\n  TradesRejectedBlacklist value: ' + (if global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist? then global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist else 'null') +
              '\n  FilteredByBlacklist exists: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByBlacklist? then 'yes' else 'no') +
              '\n  FilteredByBlacklist value: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByBlacklist? then global.$GT_SearchResult.{$ship}.$FilteredByBlacklist else 'null') +
              '\n  FilteredByPathBlocked exists: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked? then 'yes' else 'no') +
              '\n  FilteredByPathBlocked value: ' + (if global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked? then global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked else 'null') +
              '\n  TotalTradesEvaluated exists: ' + (if global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated? then 'yes' else 'no') +
              '\n  TotalTradesEvaluated value: ' + (if global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated? then global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated else 'null')" 
              chance="100"/>
          </do_if>
          
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance?">
            <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$StationsEvaluated?">
            <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.{$ship}.$StationsEvaluated"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$OffersFound?">
            <set_value name="$offersFound" exact="global.$GT_SearchResult.{$ship}.$OffersFound"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$BestRejectedTrade?">
            <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.{$ship}.$BestRejectedTrade"/>
          </do_if>
          
          <!-- Store stats immediately when continuation detected (BEFORE trade execution) -->
          <!-- This ensures stats are available for logbook even if execution fails later -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: $tradesRejectedBlacklist already includes combined value from resume -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = use resume stats if available (more accurate) -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from live search continuation results -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats != null">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="((if $existingTotal != null then $existingTotal else 0) gt 0) or ((if $existingDocking != null then $existingDocking else 0) gt 0) or ((if $existingProfit != null then $existingProfit else 0) gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <do_if value="$totalEvaluated gt 0 or not $hasExistingStats">
            <!-- SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Use library function to update rejection stats -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateRejectionStats">
              <param name="ship" value="$ship"/>
              <param name="stats" value="$newShipStats"/>
            </run_actions>
          </do_if>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORED STATS ON CONTINUATION (available for logbook if execution fails):' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalBlacklistFiltered: ' + $statsBlacklist +
              '\n  RejectedDocking: ' + $statsDocking +
              '\n  RejectedProfit: ' + $statsProfit +
              '\n  RejectedAmount: ' + $statsAmount" 
              chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Check cache diversity: Count unique wares in trade list -->
        <set_value name="$cacheWareCount" exact="0"/>
        <set_value name="$cacheWares" exact="table[]"/>
        <do_if value="$tradeList != null and $tradeList.count gt 0">
          <do_all exact="$tradeList.count" counter="$i">
            <set_value name="$trade" exact="$tradeList.{$i}"/>
            <set_value name="$ware" exact="@$trade.$BuyOffer.ware"/>
            <do_if value="$ware? and not $cacheWares.{$ware}?">
              <set_value name="$cacheWares.{$ware}" exact="true"/>
              <set_value name="$cacheWareCount" exact="$cacheWareCount + 1"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Live trade search (only if no cached trades found) -->
        <!-- Skip live search entirely if we're already using live search results from continuation -->
        <!-- Low diversity check removed - use cached trades even if diversity is low -->
        <!-- Trigger live search if: 
             1. NOT continuing from live search, AND
             2. No cached trades found, AND
             3. Previous live search did NOT return 0 trades (to prevent infinite loops when all trades are blacklisted) -->
        <set_value name="$shouldDoLiveSearch" exact="false"/>
        <set_value name="$previousLiveSearchReturnedZeroTrades" exact="false"/>
        <do_if value="($searchState == 'live' or $searchState == 'fallback') and ($liveTradeList == null or $liveTradeList.count == 0)">
          <!-- Previous live search returned 0 trades -->
          <!-- Apply cooldown to prevent infinite loop when ship is stuck -->
          <!-- If ship is in blacklisted sector and all trades filtered, cooldown prevents immediate re-search -->
          <!-- Don't apply cooldown if ship needs to escape -->
          
          <!-- Check if ship is in blacklisted sector (needs escape) - using library function -->
          <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckNeedsEscape" result="$needsEscape">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Previous live search returned 0 trades - ' + if $needsEscape then 'ESCAPE NEEDED, skipping cooldown' else 'applying cooldown to prevent loop (ship may be stuck in blacklisted sector)'" chance="100"/>
          </do_if>
          
          <!-- Clear continuation state -->
          <set_value name="$liveTradeList" exact="[]"/>
          <set_value name="$liveBestTrade" exact="null"/>
          <set_value name="$liveBestScore" exact="0"/>
          
          <!-- Initialize tradeList to empty list to prevent null errors -->
          <set_value name="$tradeList" exact="[]"/>
          <set_value name="$bestTrade" exact="null"/>
          <set_value name="$bestScore" exact="0"/>
          
          <!-- Clear old search result state to prevent re-use -->
          <!-- Remove entire per-ship entry to prevent future requests from being treated as continuations -->
          <do_if value="global.$GT_SearchResult.{$ship}?">
            <remove_value name="global.$GT_SearchResult.{$ship}"/>
          </do_if>
          
          <!-- Apply cooldown for zero-trade live searches (prevents infinite loop) -->
          <!-- Only apply cooldown if ship doesn't need to escape -->
          <do_if value="not $needsEscape">
            <!-- Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <!-- Use same cooldown system as cache misses, but mark it as zero-trade cooldown -->
            <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
              $LastLiveSearch = player.age,
              $CooldownDuration = 60s
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ')    Applied 60s cooldown after zero-trade live search - ship may be stuck, will retry later'" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship needs to escape - clear any existing cooldown so it can search again immediately -->
            <!-- Initialization guarantees global.$GT_CacheMissCooldowns exists -->
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ESCAPE NEEDED: Zero trades found but ship in blacklisted sector - clearing cooldown to allow immediate escape search'" chance="100"/>
            </do_if>
          </do_else>
        </do_if>
        
        <!-- Only trigger live search if this is a fresh search (not live/fallback continuation) -->
        <do_if value="$searchState == 'fresh'">
          <!-- Low diversity check removed - only trigger live search on cache miss -->
          <set_value name="$shouldDoLiveSearch" exact="not $foundCachedTrade"/>
        </do_if>
        <do_else>
          <!-- Using continuation results - don't trigger new live search -->
          <set_value name="$shouldDoLiveSearch" exact="false"/>
        </do_else>
        
        <!-- Track whether we started an async live search in THIS invocation -->
        <!-- If true, we must NOT run execution/no-trade-found/cleanup until SearchLiveTrades_Resume signals us again. -->
        <set_value name="$waitingForLiveSearch" exact="false"/>
        
        <do_if value="$shouldDoLiveSearch">
          <!-- Prevent cache miss live search loops -->
          <!-- If cache miss triggered live search recently, enforce cooldown before allowing another -->
          <!-- Bypass cooldown if ship is in blacklisted sector and needs to escape -->
          <set_value name="$canDoLiveSearch" exact="true"/>
          <set_value name="$cooldownRemaining" exact="0"/>
          
          <!-- Check if ship is in blacklisted sector (needs escape, bypass cooldown) -->
          <set_value name="$needsEscape" exact="false"/>
          <set_value name="$currentSector" exact="$ship.sector"/>
          <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
            <param name="ship" value="$ship"/>
          </run_actions>
          <do_if value="$blacklistgroup? and $currentSector?">
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$needsEscape">
              <param name="sector" value="$currentSector"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
          </do_if>
          
          <!-- Check cooldown for cache miss triggers (only if not escaping) -->
          <set_value name="$hasCooldown" exact="false"/>
          <do_if value="not $needsEscape">
            <!-- Only check cooldown if ship doesn't need to escape -->
            <!-- Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <set_value name="$hasCooldown" exact="true"/>
              <set_value name="$cooldownData" exact="global.$GT_CacheMissCooldowns.{$ship}"/>
              <set_value name="$timeSinceLastSearch" exact="player.age - $cooldownData.$LastLiveSearch"/>
              <set_value name="$cooldownRemaining" exact="$cooldownData.$CooldownDuration - $timeSinceLastSearch"/>
              <do_if value="$cooldownRemaining gt 0">
                <!-- Still in cooldown - skip live search -->
                <set_value name="$canDoLiveSearch" exact="false"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss   live search cooldown active (' + ($cooldownRemaining / 1) + 's remaining of ' + ($cooldownData.$CooldownDuration / 1) + 's) - skipping live search to prevent loop'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          <do_else>
            <!-- Ship needs to escape - bypass cooldown and clear it -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ESCAPE NEEDED: Ship in blacklisted sector - bypassing cooldown to search for escape route'" chance="100"/>
            </do_if>
            <!-- Clear cooldown so ship can search immediately for escape -->
            <!-- Defensive check for race condition (initialization might not have completed yet) -->
            <do_if value="not global.$GT_CacheMissCooldowns?">
              <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
            </do_if>
            <do_if value="global.$GT_CacheMissCooldowns.{$ship}?">
              <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
            </do_if>
          </do_else>
          
          <do_if value="$canDoLiveSearch">
            <!-- Separate live-search concurrency:
                 - Let cache searches run with cache concurrency (SearchQueue)
                 - Queue LIVE searches into GT_LiveSearchQueue so only MaxConcurrentLiveSearches run at once -->
            <do_if value="$searchState == 'fresh' and not $fromLiveQueue">
              <!-- OPTIMIZATION: If live-search concurrency is saturated, do NOT enqueue more ships to wait in line.
                   Instead, fail fast so the AI retries soon and will likely hit the cache warmed by the live search already running.
                   This avoids “burst → stall → one-by-one” under large fleets when MaxConcurrentLiveSearches is low (often 1). -->
              <set_value name="$liveQueueSaturated" exact="false"/>
              <set_value name="$maxConcurrentLiveNow" exact="1"/>
              <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches?">
                <set_value name="$maxConcurrentLiveNow" exact="@global.$GT_GlobalSettings.$Performance.$MaxConcurrentLiveSearches"/>
              </do_if>
              <do_if value="$maxConcurrentLiveNow lt 1">
                <set_value name="$maxConcurrentLiveNow" exact="1"/>
              </do_if>
              <do_if value="not global.$GT_LiveSearchQueue?">
                <set_value name="global.$GT_LiveSearchQueue" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveSearchQueue.$ActiveLiveSearches?">
                <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" exact="0"/>
              </do_if>
              <do_if value="global.$GT_LiveSearchQueue.$ActiveLiveSearches ge $maxConcurrentLiveNow">
                <set_value name="$liveQueueSaturated" exact="true"/>
              </do_if>

              <do_if value="$liveQueueSaturated">
                <!-- Apply a short cooldown so we don't spam retries every tick while live is busy -->
                <do_if value="not global.$GT_CacheMissCooldowns?">
                  <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
                </do_if>
                <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                  $LastLiveSearch = player.age,
                  $CooldownDuration = 5s
                ]"/>

                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Live search busy (active: ' + global.$GT_LiveSearchQueue.$ActiveLiveSearches + '/' + $maxConcurrentLiveNow + ') - skipping enqueue and returning no-trade-found so ship retries against warmed cache'" chance="100"/>
                </do_if>

                <!-- Skip live search; fall through to normal completion logic (will signal GT_No_Trade_Found for cache miss). -->
                <set_value name="$shouldDoLiveSearch" exact="false"/>
                <set_value name="$waitingForLiveSearch" exact="false"/>
              </do_if>

              <do_if value="$shouldDoLiveSearch">
              <!-- Initialize live search queue -->
              <do_if value="not global.$GT_LiveSearchQueue?">
                <set_value name="global.$GT_LiveSearchQueue" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveSearchQueue.$Ships?">
                <set_value name="global.$GT_LiveSearchQueue.$Ships" exact="[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveSearchQueue.$Params?">
                <set_value name="global.$GT_LiveSearchQueue.$Params" exact="table[]"/>
              </do_if>
              <do_if value="not global.$GT_LiveSearchQueue.$ActiveLiveSearches?">
                <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" exact="0"/>
              </do_if>

              <!-- Store params for resume + ensure cache is skipped when live slot starts -->
              <set_value name="$params.$ForceLiveSearch" exact="true"/>
              <set_value name="$params.$UseSearchQueueCounter" exact="false"/>
              <set_value name="global.$GT_LiveSearchQueue.$Params.{$ship}" exact="$params"/>

              <!-- Add ship to live queue if not already present -->
              <set_value name="$alreadyQueuedForLive" exact="false"/>
              <do_all exact="global.$GT_LiveSearchQueue.$Ships.count" counter="$q">
                <do_if value="global.$GT_LiveSearchQueue.$Ships.{$q} == $ship">
                  <set_value name="$alreadyQueuedForLive" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="not $alreadyQueuedForLive">
                <append_to_list name="global.$GT_LiveSearchQueue.$Ships" exact="$ship"/>
              </do_if>

              <!-- Release cache-search queue slot immediately so other ships can run cache checks -->
              <do_if value="$useSearchQueueCounter">
                <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
                  <remove_value name="global.$GT_SearchQueue.$Params.{$ship}"/>
                </do_if>
                <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
                  <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
                </do_if>
                <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
                  <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
                </do_if>
              </do_if>

              <!-- Kick live queue and exit; live queue will signal SearchTradeRoutes when slot available -->
              <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessLiveSearchQueue"/>
              <cancel_cue cue="this"/>
              </do_if>
            </do_if>

            <!-- IMPORTANT:
                 For fresh searches, we either enqueue to GT_LiveSearchQueue (normal), or intentionally skip (busy).
                 In BOTH cases we must NOT start a direct live search here.
                 Direct live search is only allowed when this cue is running from the live queue ($fromLiveQueue) or in non-fresh continuations. -->
            <do_if value="not ($searchState == 'fresh' and not $fromLiveQueue)">
              <!-- Log when live search starts (debug mode only) -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$cacheTradeCountForLog" exact="0"/>
                <do_if value="$cacheTradeList?">
                  <set_value name="$cacheTradeCountForLog" exact="@$cacheTradeList.count"/>
                </do_if>
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Starting LIVE market search (cache had ' + $cacheTradeCountForLog + ' trades, none suitable)'" chance="100"/>
              </do_if>
              
              <!-- Initialize cooldown tracking if not exists -->
              <!-- Defensive check for race condition (initialization might not have completed yet) -->
              <do_if value="not global.$GT_CacheMissCooldowns?">
                <set_value name="global.$GT_CacheMissCooldowns" exact="table[]"/>
              </do_if>
              
              <!-- Update cooldown for cache miss triggers -->
              <do_if value="not $hasCooldown">
                <!-- First live search trigger for this ship - start at 10 seconds -->
                <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                  $LastLiveSearch = player.age,
                  $CooldownDuration = 10s
                ]"/>
              </do_if>
              <do_else>
                <!-- Increase cooldown (double, max 60s) - cooldownData exists since hasCooldown is true -->
                <set_value name="$newCooldown" exact="$cooldownData.$CooldownDuration * 2"/>
                <do_if value="$newCooldown gt 60s">
                  <set_value name="$newCooldown" exact="60s"/>
                </do_if>
                <set_value name="global.$GT_CacheMissCooldowns.{$ship}" exact="table[
                  $LastLiveSearch = player.age,
                  $CooldownDuration = $newCooldown
                ]"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Cache miss   live search cooldown increased to ' + ($newCooldown / 1) + 's'" chance="100"/>
                </do_if>
              </do_else>
              
              <!-- FIX: Check if a search is already in progress before starting a new one -->
              <set_value name="$searchInProgress" exact="false"/>
              <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
                <set_value name="$searchInProgress" exact="true"/>
              </do_if>
              
              <do_if value="$searchInProgress">
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Search already in progress - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
                </do_if>
                <cancel_cue cue="this"/>
              </do_if>
              
              <!-- Perform live search -->
              <set_value name="$waitingForLiveSearch" exact="true"/>
              <signal_cue_instantly cue="md.GT_Search_Methods.SearchLiveTrades" param="table[
              $Ship = $ship,
              $MaxDistance = $maxDistance,
              $MinROI = $minROI,
              $MinAbsoluteProfit = $minAbsoluteProfit,
              $FactionPriority = $factionPriority,
              $FactionPriorityText = $factionPriorityText,
              $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
              $SkillLevel = $skillLevel,
              $ThreatIntel = $gt_ThreatIntel,
              $FleetCoord = $gt_FleetCoord,
              $AdvancedAnalytics = $gt_AdvancedAnalytics
              ]"/>
              
              <!-- Exit immediately after signaling SearchLiveTrades -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ')    SearchLiveTrades signaled - exiting (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
              </do_if>
              <cancel_cue cue="this"/>
              
              <set_value name="$searchMethod" exact="'live'"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Cooldown active - skip live search -->
            <!-- CRITICAL: Don't clear results if we're using live search continuation (results already set above) -->
            <!-- CRITICAL: Preserve cache tradeList even if bestTrade was invalid (fallback can find valid trade from list) -->
            <do_if value="$searchState == 'fresh'">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Skipping live search due to cooldown - preserving cache results (bestTrade may be null, tradeList.count=' + (if $tradeList != null then @$tradeList.count else 0) + ')'" chance="100"/>
              </do_if>
              <set_value name="$searchMethod" exact="'cache'"/>
              <!-- Only clear bestTrade if it was invalid (already cleared above), but preserve tradeList from cache -->
              <!-- bestTrade will be selected from tradeList by fallback logic if needed -->
              <do_if value="$bestTrade == null or @$bestTrade.$BuyOffer == null">
                <set_value name="$bestTrade" exact="null"/>
                <set_value name="$bestScore" exact="0"/>
              </do_if>
              <!-- Preserve tradeList from cache - don't overwrite with empty list! -->
              <!-- Fallback logic will try to find valid trade from tradeList -->
            </do_if>
          </do_else>
          
          <!-- Check batch status BEFORE extracting results -->
          <!-- If batch is in progress, exit immediately - don't extract stale results -->
          <!-- SearchLiveTrades_Resume will signal this cue again when batch completes -->
          <set_value name="$batchInProgress" exact="false"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$WaitingForBatch?">
            <set_value name="$batchInProgress" exact="global.$GT_SearchResult.{$ship}.$WaitingForBatch"/>
          </do_if>
          
          <do_if value="$batchInProgress">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Batch processing in progress - skipping result extraction (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <!-- Exit - SearchLiveTrades_Resume will signal this cue again when batch completes -->
            <cancel_cue cue="this"/>
          </do_if>
          
          <!-- Redundant batch check removed - already handled at the beginning of the cue -->
          <!-- Extract live search results from global return variable (batch processing completed) -->
          <!-- Note: If this is a live/fallback continuation, live results were already extracted above -->
          <do_if value="$searchState == 'fresh'">
            <set_value name="$bestTrade" exact="@global.$GT_SearchResult.{$ship}.$BestTrade"/>
            <set_value name="$bestScore" exact="@global.$GT_SearchResult.{$ship}.$BestScore"/>
            
            <!-- Validate bestTrade IMMEDIATELY after extracting from global -->
            <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeValidFromGlobal">
              <param name="trade" value="$bestTrade"/>
              <param name="minScore" value="0"/>
            </run_actions>
            <do_if value="not $bestTradeValidFromGlobal">
              <!-- bestTrade from global is invalid - clear it so fallback can fix it -->
              <set_value name="$bestTrade" exact="null"/>
              <set_value name="$bestScore" exact="0"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade from global.$GT_SearchResult is INVALID - cleared for fallback fix'" chance="100"/>
              </do_if>
            </do_if>
            
            <do_if value="global.$GT_SearchResult.{$ship}.$StationsEvaluated?">
              <set_value name="$stationsEvaluated" exact="global.$GT_SearchResult.{$ship}.$StationsEvaluated"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$OffersFound?">
              <set_value name="$offersFound" exact="global.$GT_SearchResult.{$ship}.$OffersFound"/>
            </do_if>
            <!-- Initialize to empty list first, then extract from global if it exists -->
            <set_value name="$tradeList" exact="[]"/>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradeList?">
              <set_value name="$tradeList" exact="global.$GT_SearchResult.{$ship}.$TradeList"/>
            </do_if>
            <!-- Update rejection statistics from live search (if available) -->
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
              <set_value name="$tradesRejectedDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
              <set_value name="$tradesRejectedBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
              <set_value name="$tradesRejectedProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance?">
              <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDistance"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
              <set_value name="$tradesRejectedAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
            </do_if>
            <do_if value="global.$GT_SearchResult.{$ship}.$BestRejectedTrade?">
              <set_value name="$bestRejectedTrade" exact="global.$GT_SearchResult.{$ship}.$BestRejectedTrade"/>
            </do_if>
            
            <!-- Failed sector filtering now happens during best trade tracking (inside evaluation loop) -->
            <!-- This ensures: 1) All trades are cached for other ships, 2) Best selection excludes failed sectors -->
          </do_if>  <!-- End of extracting live results if not continuation -->
        </do_if>  <!-- End of live trade search -->
        
        <!-- Sort trade list by score (highest first) before sending to AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <run_actions ref="md.GT_Libraries_General.GT_SortTradesByScore" result="$tradeList">
          <param name="tradeList" value="$tradeList"/>
        </run_actions>
        
        <!-- If tradeList exists but bestTrade is null, select best from list -->
        <!-- This can happen during continuation if BestTrade wasn't stored in global -->
        <!-- Use strict validation (library function) instead of weak Score-only check -->
        <set_value name="$bestTradeIsValid" exact="false"/>
        <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$bestTradeIsValid">
          <param name="trade" value="$bestTrade"/>
          <param name="minScore" value="0"/>
        </run_actions>
        
        <do_if value="not $bestTradeIsValid">
          <!-- FIX: Use library function for consistent validation -->
          <do_if value="$tradeList != null and @$tradeList.count gt 0">
            <do_all exact="@$tradeList.count" counter="$i">
              <set_value name="$firstTrade" exact="@$tradeList.{$i}"/>
              <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$firstTradeValid">
                <param name="trade" value="$firstTrade"/>
                <param name="minScore" value="0"/>
              </run_actions>
              <do_if value="$firstTradeValid">
                <set_value name="$testScore" exact="@$firstTrade.$Score"/>
                <set_value name="$bestTrade" exact="$firstTrade"/>
                <set_value name="$bestScore" exact="$testScore"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade was null but tradeList has ' + @$tradeList.count + ' trades - selected valid trade[' + $i + '] as bestTrade'" chance="100"/>
                </do_if>
                <break/>
              </do_if>
            </do_all>
          </do_if>
        </do_if>
        
        <!-- If we started an async live search in this invocation, stop here and wait for resume signal -->
        <do_if value="not $waitingForLiveSearch">
        
        <!-- Execute best trade if found -->
        <!-- DEBUG: Log bestTrade status for continuation debugging -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
          <set_value name="$bestTradeExists" exact="$bestTrade != null"/>
          <set_value name="$tradeListCount" exact="0"/>
          <do_if value="$tradeList != null">
            <set_value name="$tradeListCount" exact="@$tradeList.count"/>
          </do_if>
          <set_value name="$bestTradeCheck" exact="'null'"/>
          <do_if value="$bestTrade != null">
            <set_value name="$bestTradeCheck" exact="'exists'"/>
            <do_if value="@$bestTrade.$BuyOffer != null">
              <set_value name="$bestTradeCheck" exact="'valid'"/>
            </do_if>
          </do_if>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Trade execution check: bestTrade=' + $bestTradeCheck + ', tradeList.count=' + $tradeListCount + ', searchState=' + $searchState" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Validate bestTrade before execution -->
        <!-- More robust validation - check that properties actually exist and are not null -->
        <set_value name="$bestTradeIsValidForExecution" exact="false"/>
        <do_if value="$bestTrade != null">
          <set_value name="$testBuyOffer" exact="@$bestTrade.$BuyOffer"/>
          <set_value name="$testSellOffer" exact="@$bestTrade.$SellOffer"/>
          <set_value name="$testScore" exact="@$bestTrade.$Score"/>
          <!-- Check if BuyOffer/SellOffer exist AND are not null, AND Score exists AND is > 0 -->
          <!-- In MD, null? returns true (variable exists), so we need to check Score > 0 to ensure it's a real trade -->
          <do_if value="$testBuyOffer != null and $testSellOffer != null and $testScore != null">
            <do_if value="$testScore gt 0">
              <!-- Double-check: Try accessing a property from BuyOffer to ensure it's not null -->
              <set_value name="$testWare" exact="@$testBuyOffer.ware"/>
              <do_if value="$testWare != null">
                <set_value name="$bestTradeIsValidForExecution" exact="true"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <do_if value="$bestTradeIsValidForExecution">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade is VALID - proceeding with execution'" chance="100"/>
          </do_if>
          <do_else>
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') bestTrade is INVALID (null or missing properties) - cannot execute'" chance="100"/>
            <!-- If bestTrade is invalid but tradeList has trades, select first valid trade from list -->
            <do_if value="$tradeList != null and @$tradeList.count gt 0">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Attempting to select valid trade from tradeList (' + @$tradeList.count + ' trades available)'" chance="100"/>
              <do_all exact="@$tradeList.count" counter="$i">
                <set_value name="$candidateTrade" exact="$tradeList.{$i}"/>
                <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$candidateValid">
                  <param name="trade" value="$candidateTrade"/>
                  <param name="minScore" value="0"/>
                </run_actions>
                <do_if value="$candidateValid">
                  <set_value name="$candidateScore" exact="@$candidateTrade.$Score"/>
                  <set_value name="$bestTrade" exact="$candidateTrade"/>
                  <set_value name="$bestScore" exact="$candidateScore"/>
                  <set_value name="$bestTradeIsValidForExecution" exact="true"/>
                  <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') Selected valid trade from tradeList[' + $i + '] (Score: ' + $candidateScore + ')'" chance="100"/>
                  <break/>
                </do_if>
              </do_all>
            </do_if>
            <!-- If still invalid after all fallbacks, check for fallback search before signaling no trade found -->
            <do_if value="not $bestTradeIsValidForExecution">
              <!-- Batch processing is complete (checked at start) - safe to proceed with "no trade found" logic -->
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') No valid trades found in tradeList (' + (if $tradeList != null then @$tradeList.count else 0) + ' entries) - all trades invalid'" chance="100"/>
              
              <!-- Check if we should trigger fallback search before signaling no trade found -->
              <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
                <!-- Check if fallback was already attempted in this search cycle -->
                <set_value name="$fallbackAlreadyAttempted" exact="false"/>
                <do_if value="global.$GT_FallbackAttempted.{$ship}?">
                  <set_value name="$fallbackAlreadyAttempted" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
                  </do_if>
                </do_if>
                
                <!-- Cache search failed, live search failed - check if ship is isolated -->
                <set_value name="$shipIsIsolated" exact="false"/>
                <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
                  <param name="ship" value="$ship"/>
                  <param name="state" value="table[]"/>
                </run_actions>
                <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
                
                <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted.
                     ALSO respect live-search availability: if we intentionally skipped live-search due to saturation/cooldown,
                     do NOT trigger fallback (it would enqueue a live/batch search anyway and recreate fleet-wide stalls). -->
                <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted and $shouldDoLiveSearch">
                  <!-- Ensure table exists before accessing -->
                  <do_if value="not global.$GT_FallbackAttempted?">
                    <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
                  </do_if>
                  
                  <!-- Check if logbook message was already written for this fallback attempt -->
                  <!-- Use a separate flag to prevent logbook spam -->
                  <!-- Ensure table exists before checking -->
                  <do_if value="not global.$GT_FallbackLogbookWritten?">
                    <set_value name="global.$GT_FallbackLogbookWritten" exact="table[]"/>
                  </do_if>
                  
                  <!-- Check if logbook already written - if so, skip writing -->
                  <set_value name="$logbookAlreadyWritten" exact="false"/>
                  <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
                    <set_value name="$logbookAlreadyWritten" exact="true"/>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Logbook message already written - skipping (flag exists, searchState=' + $searchState + ')'" chance="100"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Logbook flag NOT set - will write message (searchState=' + $searchState + ')'" chance="100"/>
                    </do_if>
                  </do_else>
                  
                  <!-- Set flag IMMEDIATELY when fallback is triggered (before any other processing) -->
                  <!-- This ensures flag persists across cue instances and prevents logbook spam -->
                  <do_if value="not $logbookAlreadyWritten">
                    <set_value name="global.$GT_FallbackLogbookWritten.{$ship}" exact="true"/>
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                      <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set logbook flag - fallback triggered'" chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <!-- Calculate skill level for fallback distance calculation -->
                  <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
                    <param name="ship" value="$ship"/>
                  </run_actions>
                  <set_value name="$fallbackSkillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>
                  
                  <!-- Use originalMaxDistance for fallback calculation if available (prevents decreasing distance) -->
                  <!-- If this is already a fallback continuation, $maxDistance is already reduced, so use originalMaxDistance -->
                  <set_value name="$distanceForFallbackCalc" exact="$maxDistance"/>
                  <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                    <set_value name="$distanceForFallbackCalc" exact="$originalMaxDistance"/>
                  </do_if>
                  
                  <!-- Calculate fallback distance: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
                  <set_value name="$fallbackMaxDistance" exact="1"/>  <!-- Default fallback to 1 -->
                  <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackDistance" result="$fallbackMaxDistance">
                    <param name="maxDistance" value="$distanceForFallbackCalc"/>
                    <param name="skillLevel" value="$fallbackSkillLevel"/>
                  </run_actions>
                  
                  <!-- Write logbook message ONLY if not already written for this fallback attempt -->
                  <do_if value="not $logbookAlreadyWritten">
                    
                    <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
                    <do_if value="not $currentSectorName?">
                      <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
                    </do_if>
                    
                    <!-- Use originalMaxDistance in logbook message if available (shows original search range) -->
                    <set_value name="$originalSearchRange" exact="$maxDistance"/>
                    <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                      <set_value name="$originalSearchRange" exact="$originalMaxDistance"/>
                    </do_if>
                    
                    <!-- Construct logbook message using TextDB syntax with calculated fallback distance -->
                    <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $originalSearchRange, $fallbackMaxDistance]"/>
                    
                    <!-- Write logbook entry using centralized library -->
                    <run_actions ref="md.GT_Libraries_General.WriteLogbookMessage">
                      <param name="Message" value="$logbookMessage"/>
                      <param name="Category" value="'alerts'"/>
                      <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                      <param name="Object" value="$ship"/>
                      <param name="Interaction" value="'showonmap'"/>
                      <param name="CheckGlobalSettings" value="true"/>
                    </run_actions>
                  </do_if>
                  
                  <!-- Mark that fallback search was triggered -->
                  <set_value name="$fallbackSearchTriggered" exact="true"/>
                  
                  <!-- Mark fallback as attempted globally (persists across cue instances) -->
                  <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
                  
                  <!-- Trigger fallback search -->
                  <!-- Fallback uses lower profit thresholds, so we compensate by restricting travel distance -->
                  <!-- Formula: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
                  <!-- OriginalMaxDistance used for filtering stations from home sector -->
                  <!-- CRITICAL: Pass $originalMaxDistance (not $maxDistance) to preserve original search range -->
                  <set_value name="$fallbackParams" exact="table[
                    $Ship = $ship,
                    $MaxDistance = $fallbackMaxDistance,
                    $OriginalMaxDistance = $originalMaxDistance,
                    $MinROI = $minROI,
                    $MinAbsoluteProfit = $minAbsoluteProfit,
                    $FactionPriority = $factionPriority,
                    $FactionPriorityText = $factionPriorityText,
                    $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                    $SkillLevel = $skillLevel,
                    $ThreatIntel = $gt_ThreatIntel,
                    $FleetCoord = $gt_FleetCoord,
                    $AdvancedAnalytics = $gt_AdvancedAnalytics
                  ]"/>
                  <signal_cue_instantly cue="md.GT_Search_Methods.SearchFallbackTrades" param="$fallbackParams"/>
                  
                  <!-- Exit - SearchFallbackTrades will signal SearchTradeRoutes again when complete -->
                  <cancel_cue cue="this"/>
                </do_if>
                <do_else>
                  <!-- Ship is isolated OR fallback already attempted - signal no trade found -->
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                    <debug_text text="'[GT-Search] (' + $ship.idcode + ') Ship is isolated or fallback already attempted - signaling no trade found'" chance="100"/>
                  </do_if>
                  <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
                </do_else>
              </do_if>
              <do_else>
                <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <debug_text text="'[GT-Search] (' + $ship.idcode + ') Search complete - signaling no trade found (fallback already triggered or cache succeeded)'" chance="100"/>
                </do_if>
                <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
              </do_else>
            </do_if>
          </do_else>
          </do_if>
        
        <do_if value="$bestTradeIsValidForExecution">
          <!-- Check if we should clear fallback or isolated flags (normal search succeeded) -->
          <do_if value="(global.$GT_FallbackTradeActive.{$ship}? or global.$GT_IsolatedTradeActive.{$ship}?) and $searchState != 'fallback'">
            <!-- Normal search succeeded - clear flags and restore normal name -->
            <do_if value="global.$GT_FallbackTradeActive.{$ship}?">
              <remove_value name="global.$GT_FallbackTradeActive.{$ship}"/>
            </do_if>
            <do_if value="global.$GT_IsolatedTradeActive.{$ship}?">
              <remove_value name="global.$GT_IsolatedTradeActive.{$ship}"/>
            </do_if>
            
            <!-- Calculate rank title from skill level for ship name update -->
            <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
            <do_if value="not $pilotXP?">
              <set_value name="$pilotXP" exact="0"/>
            </do_if>
            <set_value name="$rankTitle" exact="'Lehrling'"/>
            <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
              <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
              <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
              </do_if>
              <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
              </do_if>
            </do_if>
            
            <!-- Update ship name back to normal -->
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship = $ship,
              $pilot = $ship.pilot,
              $xp = $pilotXP,
              $level = $skillLevel,
              $rank = $rankTitle,
              $nameType = 'trader'
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Normal search succeeded - cleared [FALLBACK]/[ISOLATED] flags'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Check if ship is isolated and set [ISOLATED] flag -->
          <set_value name="$shipIsIsolated" exact="false"/>
          <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
            <param name="ship" value="$ship"/>
            <param name="state" value="table[]"/>
          </run_actions>
          <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
          
          <do_if value="$shipIsIsolated and $searchState != 'fallback'">
            <!-- Ship is isolated and found a trade - set isolated flag and update ship name -->
            <do_if value="not global.$GT_IsolatedTradeActive?">
              <set_value name="global.$GT_IsolatedTradeActive" exact="table[]"/>
            </do_if>
            <set_value name="global.$GT_IsolatedTradeActive.{$ship}" exact="true"/>
            
            <!-- Calculate rank title from skill level for ship name update -->
            <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
            <do_if value="not $pilotXP?">
              <set_value name="$pilotXP" exact="0"/>
            </do_if>
            <set_value name="$rankTitle" exact="'Lehrling'"/>
            <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
              <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
              <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
              </do_if>
              <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
              </do_if>
            </do_if>
            
            <!-- Update ship name to show [ISOLATED] flag -->
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship = $ship,
              $pilot = $ship.pilot,
              $xp = $pilotXP,
              $level = $skillLevel,
              $rank = $rankTitle,
              $nameType = 'isolated'
            ]"/>
            
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set [ISOLATED] flag - trade found while ship is isolated'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Log that we're entering the bestTrade execution block -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') ENTERING bestTrade execution block'" chance="100"/>
            <!-- Log if this trade came from fallback search -->
            <do_if value="$searchState == 'fallback'">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback search complete: Found ' + (if $tradeList != null then @$tradeList.count else 0) + ' trades'" chance="100"/>
              </do_if>
              
              <!-- Set fallback trade active flag and update ship name to [FALLBACK] -->
              <do_if value="not global.$GT_FallbackTradeActive?">
                <set_value name="global.$GT_FallbackTradeActive" exact="table[]"/>
              </do_if>
              <set_value name="global.$GT_FallbackTradeActive.{$ship}" exact="true"/>
              
              <!-- Calculate rank title from skill level for ship name update -->
              <set_value name="$pilotXP" exact="@global.$GT_Pilots.{$ship.pilot}.$XP"/>
              <do_if value="not $pilotXP?">
                <set_value name="$pilotXP" exact="0"/>
              </do_if>
              <set_value name="$rankTitle" exact="'Lehrling'"/>
              <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
                <set_value name="$rankIndex" exact="($skillLevel / 3)i + 1"/>
                <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
                  <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
                </do_if>
                <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
                  <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
                </do_if>
              </do_if>
              
              <!-- Update ship name to show [FALLBACK] flag -->
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship = $ship,
                $pilot = $ship.pilot,
                $xp = $pilotXP,
                $level = $skillLevel,
                $rank = $rankTitle,
                $nameType = 'fallback'
              ]"/>
              
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ') Set [FALLBACK] flag - trade came from fallback search'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Trade execution with full details -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <set_value name="$wareName" exact="@$bestTrade.$BuyOffer.ware.name"/>
            <set_value name="$buyStationName" exact="@$bestTrade.$BuyOffer.owner.knownname"/>
            <set_value name="$sellStationName" exact="@$bestTrade.$SellOffer.owner.knownname"/>
            <set_value name="$amount" exact="@$bestTrade.$Amount"/>
            <set_value name="$buyPrice" exact="@$bestTrade.$BuyPrice"/>
            <set_value name="$sellPrice" exact="@$bestTrade.$SellPrice"/>
            <set_value name="$distance" exact="@$bestTrade.$Distance"/>
            <set_value name="$profit" exact="@$bestTrade.$Profit"/>
            <set_value name="$roi" exact="@$bestTrade.$ROI"/>
            <set_value name="$score" exact="@$bestTrade.$Score"/>
            <set_value name="$risk" exact="@$bestTrade.$Risk"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') BEST TRADE SELECTED:' + '\n  Ware: ' + $wareName + ' (x' + $amount + ')' + '\n  BUY from: ' + $buyStationName + ' @ ' + ($buyPrice / 100) + ' Cr' + '\n  SELL to: ' + $sellStationName + ' @ ' + ($sellPrice / 100) + ' Cr' + '\n  Distance: ' + $distance + ' jumps' + '\n  Profit: ' + ($profit / 100) + ' Cr' + '\n  ROI: ' + $roi + '%' + '\n  Score: ' + $score + '\n   Risk: ' + $risk" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Fleet coordination: final claim check (closes race between "select best trade" and "reserve") -->
          <!-- If the chosen route is already reserved by another ship, pick the next-best non-conflicted trade. -->
          <do_if value="global.$GT_GlobalSettings.$Fleet.$EnableFleetCoordination">
            <!-- Initialize global.$GT_ActiveTradeReservations if it doesn't exist -->
            <do_if value="not global.$GT_ActiveTradeReservations?">
              <set_value name="global.$GT_ActiveTradeReservations" exact="table[]"/>
            </do_if>
            
            <!-- Build reserved route keys (excluding this ship) -->
            <set_value name="$reservedRoutes" exact="[]"/>
            <do_if value="global.$GT_ActiveTradeReservations?">
              <do_all exact="global.$GT_ActiveTradeReservations.keys.count" counter="$resIdx">
                <set_value name="$otherShip" exact="global.$GT_ActiveTradeReservations.keys.{$resIdx}"/>
                <do_if value="$otherShip != $ship and $otherShip.exists">
                  <set_value name="$otherRoute" exact="global.$GT_ActiveTradeReservations.{$otherShip}"/>
                  <do_if value="$otherRoute.$BuyStation? and $otherRoute.$SellStation? and $otherRoute.$Ware?">
                    <do_if value="$otherRoute.$BuyStation.idcode? and $otherRoute.$SellStation.idcode?">
                      <set_value name="$cacheKey" exact="$otherRoute.$BuyStation.idcode + '_' + $otherRoute.$SellStation.idcode + '_' + $otherRoute.$Ware"/>
                      <append_to_list name="$reservedRoutes" exact="$cacheKey"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Check current bestTrade -->
            <set_value name="$fleetBuyStation" exact="@$bestTrade.$BuyOffer.owner"/>
            <set_value name="$fleetSellStation" exact="@$bestTrade.$SellOffer.owner"/>
            <set_value name="$fleetWare" exact="@$bestTrade.$BuyOffer.ware"/>
            <set_value name="$routeConflicted" exact="false"/>
            <do_if value="$reservedRoutes.count gt 0 and $fleetBuyStation? and $fleetSellStation? and $fleetWare?">
              <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$routeConflicted">
                <param name="sellStation" value="$fleetBuyStation"/>
                <param name="buyStation" value="$fleetSellStation"/>
                <param name="ware" value="$fleetWare"/>
                <param name="reservedRoutes" value="$reservedRoutes"/>
              </run_actions>
            </do_if>
            
            <do_if value="$routeConflicted">
              <set_value name="$replacementTrade" exact="null"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$candidate" exact="$tradeList.{$i}"/>
                <set_value name="$candBuyStation" exact="@$candidate.$BuyOffer.owner"/>
                <set_value name="$candSellStation" exact="@$candidate.$SellOffer.owner"/>
                <set_value name="$candWare" exact="@$candidate.$BuyOffer.ware"/>
                <do_if value="$candBuyStation? and $candSellStation? and $candWare?">
                  <run_actions ref="md.GT_Libraries_General.GT_CheckRouteConflict" result="$candConflicted">
                    <param name="sellStation" value="$candBuyStation"/>
                    <param name="buyStation" value="$candSellStation"/>
                    <param name="ware" value="$candWare"/>
                    <param name="reservedRoutes" value="$reservedRoutes"/>
                  </run_actions>
                  <do_if value="not $candConflicted">
                    <set_value name="$replacementTrade" exact="$candidate"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_all>
              
              <do_if value="$replacementTrade != null">
                <set_value name="$bestTrade" exact="$replacementTrade"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Fleet] (' + $ship.idcode + ') Best trade was already reserved - switched to next non-conflicted trade'" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- No non-conflicted trade available -->
                <set_value name="$bestTrade" exact="null"/>
              </do_else>
            </do_if>
            
            <!-- Reserve trade route for fleet coordination (after claim check) -->
            <do_if value="$bestTrade != null">
              <set_value name="$fleetBuyStation" exact="@$bestTrade.$BuyOffer.owner"/>
              <set_value name="$fleetSellStation" exact="@$bestTrade.$SellOffer.owner"/>
              <set_value name="$fleetWare" exact="@$bestTrade.$BuyOffer.ware"/>
              <do_if value="$fleetBuyStation? and $fleetSellStation? and $fleetWare?">
                <set_value name="global.$GT_ActiveTradeReservations.{$ship}" exact="table[
                  $BuyStation = $fleetBuyStation,
                  $SellStation = $fleetSellStation,
                  $Ware = $fleetWare,
                  $Timestamp = player.age
                ]"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Execute trade (only if still valid after claim check) -->
          <do_if value="$bestTrade != null">
            <!-- DEBUG: Log exact trade list being sent to trading AI -->
            <!-- COMMENTED OUT: Reduces log spam - uncomment if needed for debugging -->
            <!-- <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$logTradeList" exact="'[GT-Search] SENDING TRADE LIST TO AI: ' + $ship.idcode + ' (' + $tradeList.count + ' trades)'"/>
              <do_all exact="$tradeList.count" counter="$i">
                <set_value name="$listTrade" exact="$tradeList.{$i}"/>
                <set_value name="$logTradeList" exact="$logTradeList + 
                  '\n  [' + $i + '] ' + @$listTrade.$BuyOffer.ware.name + 
                  ' | Buy: ' + @$listTrade.$BuyStation.knownname + ' @ ' + (@$listTrade.$BuyPrice / 100) + ' Cr' +
                  ' | Sell: ' + @$listTrade.$SellStation.knownname + ' @ ' + (@$listTrade.$SellPrice / 100) + ' Cr' +
                  ' | Score: ' + $listTrade.$Score + ' | Profit: ' + (@$listTrade.$Profit / 100) + ' Cr | ROI: ' + @$listTrade.$ROI + '% | Dist: ' + $listTrade.$Distance + ' jumps'"/>
              </do_all>
              <debug_text text="$logTradeList" chance="100"/>
            </do_if> -->
            
            <!-- Clear fallback logbook flag when trade is found (allows new message for next search cycle) -->
            <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
              <remove_value name="global.$GT_FallbackLogbookWritten.{$ship}"/>
            </do_if>
            
            <!-- Signal execution module (which will signal AI after storing trade LIST) -->
            <!-- Pass searchMethod so AI knows if trades came from cache or live search -->
            <signal_cue_instantly cue="md.GT_Trading_Execution.ExecuteTrade" param="table[
              $Ship = $ship,
              $Trade = $bestTrade,
              $TradeList = $tradeList,
              $SearchMethod = $searchMethod
            ]"/>
            
            <!-- GT_Trade_Found signal now sent FROM ExecuteTrade cue after storing pending trade -->
          </do_if>
          <do_else>
            <!-- No non-conflicted trade remained after fleet claim check -->
            <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
          </do_else>
        </do_if>
        
        <do_else>
          <!-- No valid trades found -->
          
          <!-- Check batch status BEFORE executing "no trade found" logic -->
          <!-- If batch is in progress, exit immediately - don't process stale data or signal failure -->
          <!-- SearchLiveTrades_Resume will signal this cue again when batch completes -->
          <set_value name="$batchStillInProgress" exact="false"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$WaitingForBatch?">
            <set_value name="$batchStillInProgress" exact="global.$GT_SearchResult.{$ship}.$WaitingForBatch"/>
          </do_if>
          
          <do_if value="$batchStillInProgress">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Batch processing still in progress - skipping no-trade-found logic (SearchLiveTrades_Resume will signal when complete)'" chance="100"/>
            </do_if>
            <!-- Exit - SearchLiveTrades_Resume will signal this cue again when batch completes -->
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- Batch processing is complete - safe to proceed with "no trade found" logic -->
            
            <!-- DEBUG: No trades found (only if not waiting for batch) -->
            <do_if value="not $waitingForBatch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <!-- Show detailed analysis when no trades found (debug mode only) -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <!-- Debug-only calculations for analysis message -->
              <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedDistance + $tradesRejectedAmount"/>
              <!-- Get valid entries count from cache search (if available) -->
              <set_value name="$validEntries" exact="0"/>
              <set_value name="$diverseListCount" exact="0"/>
              <do_if value="global.$GT_SearchResult.{$ship}.$ValidEntries?">
                <set_value name="$validEntries" exact="global.$GT_SearchResult.{$ship}.$ValidEntries"/>
              </do_if>
              <do_if value="global.$GT_SearchResult.{$ship}.$DiverseListCount?">
                <set_value name="$diverseListCount" exact="global.$GT_SearchResult.{$ship}.$DiverseListCount"/>
              </do_if>
              
              <set_value name="$diagnosticInfo" exact="'\n\nSEARCH CONTEXT:' +
                '\n  Search method: ' + $searchMethod +
                (if $cacheChecked then '\n  Cache checked: Yes (' + $cacheCount + ' entries)' else '\n  Cache checked: No') +
                (if $searchMethod == 'live' and $stationsEvaluated? then '\n  Stations evaluated: ' + $stationsEvaluated else '') +
                (if $searchMethod == 'live' and $offersFound? then '\n  Offers found: ' + $offersFound else '') +
                (if $searchMethod == 'cache' and $validEntries gt 0 then '\n  Valid cached trades found: ' + $validEntries + ' (diverse list: ' + $diverseListCount + ')' else '') +
                (if $totalRejected == 0 and $validEntries == 0 and ($offersFound == 0 or not $offersFound?) then '\n  No trades were evaluated (cache empty or no offers found)' else '') +
                (if $validEntries gt 0 and $diverseListCount == 0 then '\n  All valid trades filtered out during diverse list building (need unique station pairs)' else '')"/>
              
              <!-- Build best rejected trade info safely (extract properties first, then check) -->
              <set_value name="$bestRejectedInfo" exact="''"/>
              <do_if value="$bestRejectedTrade?">
                <!-- Extract properties safely -->
                <set_value name="$rejectedWare" exact="@$bestRejectedTrade.$ware"/>
                <set_value name="$rejectedBuyFrom" exact="@$bestRejectedTrade.$buyFrom"/>
                <set_value name="$rejectedSellTo" exact="@$bestRejectedTrade.$sellTo"/>
                <set_value name="$rejectedBuyPrice" exact="@$bestRejectedTrade.$buyPrice"/>
                <set_value name="$rejectedSellPrice" exact="@$bestRejectedTrade.$sellPrice"/>
                <set_value name="$rejectedProfit" exact="@$bestRejectedTrade.$profit"/>
                <set_value name="$rejectedROI" exact="@$bestRejectedTrade.$roi"/>
                
                <!-- Build info string with safe checks (use @ operator for property access) -->
                <set_value name="$bestRejectedInfo" exact="'\n\nBEST REJECTED TRADE (still unprofitable):' +
                  '\n  Ware: ' + (if $rejectedWare? then @$rejectedWare.name else 'Unknown') +
                  '\n  Buy from: ' + (if $rejectedBuyFrom? then @$rejectedBuyFrom.knownname else 'Unknown') + ' @ ' + (if $rejectedBuyPrice? then ($rejectedBuyPrice / 100) else '0') + ' Cr/unit' +
                  '\n  Sell to: ' + (if $rejectedSellTo? then @$rejectedSellTo.knownname else 'Unknown') + ' @ ' + (if $rejectedSellPrice? then ($rejectedSellPrice / 100) else '0') + ' Cr/unit' +
                  '\n  Best profit found: ' + (if $rejectedProfit? then ($rejectedProfit / 100) else '0') + ' Cr (needed: ' + ($minAbsoluteProfit / 100) + ' Cr)' +
                  '\n  Best ROI found: ' + (if $rejectedROI? then $rejectedROI else '0') + '% (needed: ' + $minROI + '%)'"/>
              </do_if>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') === NO TRADES FOUND ANALYSIS ===' + 
                '\nShip: ' + $ship.knownname + 
                '\nSector: ' + $ship.sector.knownname + 
                '\nSearch Method: ' + $searchMethod +
                '\nSearch params: Dist=' + $maxDistance + ', MinROI=' + $minROI + '%, MinAbsoluteProfit=' + ($minAbsoluteProfit / 100) + ' Cr' +
                $diagnosticInfo +
                '\n\nREJECTION STATISTICS:' +
                '\n  Docking not allowed: ' + $tradesRejectedDocking +
                '\n  Insufficient profit: ' + $tradesRejectedProfit +
                '\n  Distance too far: ' + $tradesRejectedDistance +
                '\n  Amount zero/negative: ' + $tradesRejectedAmount +
                '\n  Blacklisted/Path blocked: ' + $totalBlacklistFiltered +
                '\n' +
                '\n  TOTAL REJECTED: ' + $totalRejected +
                '\n  TOTAL EVALUATED: ' + $totalEvaluated +
                '\n  OFFERS FOUND: ' + $offersFound +
                $bestRejectedInfo" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Commented out to reduce log spam -->
          <!-- <debug_text text="'[GalaxyTrader MK3] No profitable trades found for ' + $ship.knownname" chance="100"/> -->
          
          <!-- Store rejection statistics for AI script to use after 60s wait -->
          <!-- Logbook entry will be written by AI script only after max wait time (60s) -->
          <!-- Note: Get filtered counts from live search resume if available (tracks blacklist/path filtering) -->
          <set_value name="$filteredByBlacklistFromResume" exact="0"/>
          <set_value name="$filteredByPathBlockedFromResume" exact="0"/>
          <set_value name="$totalTradesFromResume" exact="0"/>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist?">
            <set_value name="$filteredByBlacklistFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByBlacklist"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked?">
            <set_value name="$filteredByPathBlockedFromResume" exact="global.$GT_SearchResult.{$ship}.$FilteredByPathBlocked"/>
          </do_if>
          <do_if value="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated?">
            <set_value name="$totalTradesFromResume" exact="global.$GT_SearchResult.{$ship}.$TotalTradesEvaluated"/>
          </do_if>
          
          <!-- Combine blacklist stats: If using continuation, $tradesRejectedBlacklist already includes combined value -->
          <!-- Otherwise, combine evaluation-phase rejections + pre-filtering rejections -->
          <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist"/>
          <do_if value="$searchState == 'fresh'">
            <!-- Not a continuation: combine evaluation-phase + pre-filtering rejections -->
            <set_value name="$totalBlacklistFiltered" exact="$tradesRejectedBlacklist + $filteredByBlacklistFromResume + $filteredByPathBlockedFromResume"/>
          </do_if>
          <set_value name="$totalRejected" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $totalBlacklistFiltered"/>
          
          <!-- Total evaluated = evaluation-phase rejections + valid trades found + pre-filtered trades -->
          <set_value name="$totalEvaluated" exact="$totalRejected"/>
          <do_if value="$totalTradesFromResume gt 0">
            <!-- If we have resume stats, use those (more accurate) -->
            <set_value name="$totalEvaluated" exact="$totalTradesFromResume"/>
          </do_if>
          <do_elseif value="$totalRejected gt 0 or $offersFound gt 0">
            <!-- Fallback: Use rejection count if we have rejections, or offers found count -->
            <set_value name="$totalEvaluated" exact="$totalRejected"/>
          </do_elseif>
          <do_else>
            <!-- No stats available - default to 0 (no trades found at all) -->
            <set_value name="$totalEvaluated" exact="0"/>
          </do_else>
          
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          
          <!-- DEBUG: Log rejection stats before storing (only if debug logging enabled) -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORING REJECTION STATS FOR LOGBOOK:' +
              '\n  SectorName: ' + (if $currentSectorName? then $currentSectorName else 'null') +
              '\n  MaxDistance: ' + $maxDistance +
              '\n  MinAbsoluteProfit: ' + ($minAbsoluteProfit/100) + ' Cr' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  TotalRejected: ' + $totalRejected +
              '\n  RejectedDocking: ' + $tradesRejectedDocking +
              '\n  RejectedProfit: ' + $tradesRejectedProfit +
              '\n  RejectedAmount: ' + $tradesRejectedAmount +
              '\n  RejectedBlacklist (eval phase): ' + $tradesRejectedBlacklist +
              '\n  FilteredBlacklist (pre-filter): ' + $filteredByBlacklistFromResume +
              '\n  FilteredPathBlocked (pre-filter): ' + $filteredByPathBlockedFromResume +
              '\n  TotalBlacklistFiltered: ' + $totalBlacklistFiltered +
              '\n  OffersFound: ' + $offersFound +
              '\n  TotalTradesFromResume: ' + $totalTradesFromResume" 
              chance="100"/>
          </do_if>
          
          <!-- Extract sector name safely (using library function) -->
          <run_actions ref="md.GT_Libraries_General.GT_GetSectorNameSafe" result="$sectorNameForStorage">
            <param name="ship" value="$ship"/>
          </run_actions>
          
          <!-- Store per-ship to prevent overwrites by other ships' searches -->
          <!-- Ensure LastRejectionStats is initialized as a table (not null) -->
          <!-- First ensure global.$GT_SearchResult exists -->
          <!-- Initialization guarantees global.$GT_SearchResult exists -->
          <!-- Then ensure LastRejectionStats is a valid table (not null) -->
          <!-- Preserve existing data if it's already a valid table -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
            <!-- Try to access .keys.count - if it returns a valid number (>= 0), it's a valid table -->
            <set_value name="$tempKeysCount" exact="@global.$GT_SearchResult.$LastRejectionStats.keys.count"/>
            <do_if value="$tempKeysCount? and $tempKeysCount ge 0">
              <!-- Valid table - preserve it using safe operator to avoid crash if it's null -->
              <set_value name="$tempTable" exact="@global.$GT_SearchResult.$LastRejectionStats"/>
              <do_if value="$tempTable?">
                <set_value name="$preservedLastRejectionStats" exact="$tempTable"/>
              </do_if>
            </do_if>
          </do_if>
          <!-- Always initialize as a fresh table (will overwrite null, but preserve valid tables) -->
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="table[]"/>
          <!-- Restore preserved data if we had a valid table -->
          <do_if value="$preservedLastRejectionStats?">
            <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
          </do_if>
          
          <!-- Use local variables (calculated in this code path) with fallback to global -->
          <!-- Local variables are calculated from batch processor results or live search continuation -->
          <!-- Fallback to global.$GT_SearchResult if local variables are 0 (stats might be in global from FilterTradeList_Resume) -->
          <set_value name="$statsDocking" exact="$tradesRejectedDocking"/>
          <set_value name="$statsProfit" exact="$tradesRejectedProfit"/>
          <set_value name="$statsAmount" exact="$tradesRejectedAmount"/>
          <set_value name="$statsBlacklist" exact="$totalBlacklistFiltered"/>
          
          <!-- Fallback to global if local is 0 and global has values -->
          <do_if value="$statsDocking == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedDocking?">
            <set_value name="$statsDocking" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedDocking"/>
          </do_if>
          <do_if value="$statsProfit == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedProfit?">
            <set_value name="$statsProfit" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedProfit"/>
          </do_if>
          <do_if value="$statsAmount == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedAmount?">
            <set_value name="$statsAmount" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedAmount"/>
          </do_if>
          <do_if value="$statsBlacklist == 0 and global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist?">
            <set_value name="$statsBlacklist" exact="global.$GT_SearchResult.{$ship}.$TradesRejectedBlacklist"/>
          </do_if>
          
          <!-- CRITICAL FIX: Only store LastRejectionStats if we have meaningful stats -->
          <!-- Prevents overwriting real stats with zeros from cache-only searches with no offers -->
          <!-- Check if we have existing stats that are non-zero, or if new stats are non-zero -->
          <set_value name="$hasExistingStats" exact="false"/>
          <set_value name="$existingStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
          <do_if value="$existingStats?">
            <!-- Check if existing stats have meaningful data - check multiple fields to be safe -->
            <set_value name="$existingTotal" exact="@$existingStats.$Total"/>
            <set_value name="$existingDocking" exact="@$existingStats.$Docking"/>
            <set_value name="$existingProfit" exact="@$existingStats.$Profit"/>
            <!-- If any field exists and is > 0, we have meaningful stats -->
            <do_if value="($existingTotal? and $existingTotal gt 0) or ($existingDocking? and $existingDocking gt 0) or ($existingProfit? and $existingProfit gt 0)">
              <set_value name="$hasExistingStats" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- DEBUG: Log storage decision (only if debug logging enabled) -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] (' + $ship.idcode + ') LastRejectionStats STORAGE DECISION:' +
              '\n  TotalEvaluated: ' + $totalEvaluated +
              '\n  ExistingStats exists: ' + (if $existingStats != null then 'yes' else 'no') +
              '\n  ExistingTotal: ' + (if $existingTotal != null then $existingTotal else 'null') +
              '\n  ExistingDocking: ' + (if $existingDocking != null then $existingDocking else 'null') +
              '\n  ExistingProfit: ' + (if $existingProfit != null then $existingProfit else 'null') +
              '\n  HasExistingStats: ' + $hasExistingStats +
              '\n  Will store: ' + (if ($totalEvaluated gt 0 or not $hasExistingStats) then 'yes' else 'no')" 
              chance="100"/>
          </do_if>
          
          <!-- Only store if: new stats are meaningful (TotalEvaluated > 0) OR no existing meaningful stats -->
          <!-- This prevents overwriting real stats with zeros, but allows storing zeros if no stats exist yet -->
          <!-- CRITICAL: Check $ship exists before updating stats -->
          <do_if value="$ship? and ($totalEvaluated gt 0 or not $hasExistingStats)">
            <!-- SIMPLIFIED: Extract, build new structure atomically, set back (initialization guarantees base structure) -->
            <!-- Extract existing data (preserve other properties and other ships' stats) -->
            <set_value name="$existingSearchResult" exact="@global.$GT_SearchResult"/>
            <set_value name="$existingLastRejectionStats" exact="@$existingSearchResult.$LastRejectionStats"/>
            <!-- Build new per-ship stats -->
            <set_value name="$newShipStats" exact="table[
              $Total = $totalEvaluated,
              $Docking = $statsDocking,
              $Profit = $statsProfit,
              $Amount = $statsAmount,
              $Blacklist = $statsBlacklist,
              $SectorName = $sectorNameForStorage,
              $MaxDistance = $maxDistance,
              $MinAbsoluteProfit = $minAbsoluteProfit
            ]"/>
            <!-- Use library function to update rejection stats -->
            <!-- CRITICAL: $ship is validated above, safe to pass to library -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateRejectionStats">
              <param name="ship" value="$ship"/>
              <param name="stats" value="$newShipStats"/>
            </run_actions>
            
            <!-- DEBUG: Verify storage succeeded (only if debug logging enabled) -->
            <!-- CRITICAL: Check $ship exists before using it -->
            <do_if value="$ship? and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$verifyStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{$ship}"/>
              <set_value name="$verifyTotal" exact="@$verifyStats.$Total"/>
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') STORED LastRejectionStats - Verification:' +
                '\n  Stored Total: ' + (if $verifyTotal? then $verifyTotal else 'null') +
                '\n  Stored Docking: ' + (if $verifyStats.$Docking? then $verifyStats.$Docking else 'null') +
                '\n  Stored Profit: ' + (if $verifyStats.$Profit? then $verifyStats.$Profit else 'null') +
                '\n  Stored Amount: ' + (if $verifyStats.$Amount? then $verifyStats.$Amount else 'null') +
                '\n  Stored Blacklist: ' + (if $verifyStats.$Blacklist? then $verifyStats.$Blacklist else 'null')" 
                chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Check if we should trigger fallback search before signaling no trade found -->
          <!-- This is the "no trades found" path after live search continuation completes -->
          <do_if value="not $fallbackSearchTriggered and not $foundCachedTrade">
            <!-- Check if fallback was already attempted in this search cycle -->
            <set_value name="$fallbackAlreadyAttempted" exact="false"/>
            <do_if value="global.$GT_FallbackAttempted.{$ship}?">
              <set_value name="$fallbackAlreadyAttempted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Search] (' + $ship.idcode + ')    Fallback search already attempted in this cycle - skipping (will retry after normal search cooldown)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Cache search failed, live search failed - check if ship is isolated -->
            <set_value name="$shipIsIsolated" exact="false"/>
            <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckAndHandleIsolation" result="$isolationResult">
              <param name="ship" value="$ship"/>
              <param name="state" value="table[]"/>
            </run_actions>
            <set_value name="$shipIsIsolated" exact="$isolationResult.$IsIsolated"/>
            
            <!-- Only trigger fallback search if ship is NOT isolated AND fallback not already attempted -->
            <do_if value="not $shipIsIsolated and not $fallbackAlreadyAttempted and $shouldDoLiveSearch">
              <!-- Ensure table exists before accessing -->
              <do_if value="not global.$GT_FallbackAttempted?">
                <set_value name="global.$GT_FallbackAttempted" exact="table[]"/>
              </do_if>
              
              <!-- Check if logbook message was already written for this fallback attempt -->
              <!-- Use a separate flag to prevent logbook spam -->
              <!-- Ensure table exists before checking -->
              <do_if value="not global.$GT_FallbackLogbookWritten?">
                <set_value name="global.$GT_FallbackLogbookWritten" exact="table[]"/>
              </do_if>
              
              <!-- Check if logbook already written - if so, skip writing -->
              <set_value name="$logbookAlreadyWritten" exact="false"/>
              <do_if value="global.$GT_FallbackLogbookWritten.{$ship}?">
                <set_value name="$logbookAlreadyWritten" exact="true"/>
              </do_if>
              
              <!-- Calculate skill level for fallback distance calculation -->
              <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
                <param name="ship" value="$ship"/>
              </run_actions>
              <set_value name="$fallbackSkillLevel" exact="if @$skillInfo.$Level != null then @$skillInfo.$Level else 1"/>
              
              <!-- Use originalMaxDistance for fallback calculation if available (prevents decreasing distance) -->
              <!-- If this is already a fallback continuation, $maxDistance is already reduced, so use originalMaxDistance -->
              <set_value name="$distanceForFallbackCalc" exact="$maxDistance"/>
              <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                <set_value name="$distanceForFallbackCalc" exact="$originalMaxDistance"/>
              </do_if>
              
              <!-- Calculate fallback distance: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
              <set_value name="$fallbackMaxDistance" exact="1"/>  <!-- Default fallback to 1 -->
              <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackDistance" result="$fallbackMaxDistance">
                <param name="maxDistance" value="$distanceForFallbackCalc"/>
                <param name="skillLevel" value="$fallbackSkillLevel"/>
              </run_actions>
              
              <!-- Write logbook message ONLY if not already written for this fallback attempt -->
              <do_if value="not $logbookAlreadyWritten">
                <!-- Set flag IMMEDIATELY before writing to prevent race conditions -->
                <set_value name="global.$GT_FallbackLogbookWritten.{$ship}" exact="true"/>
                
                <set_value name="$currentSectorName" exact="@$ship.sector.knownname"/>
                <do_if value="not $currentSectorName?">
                  <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
                </do_if>
                
                <!-- Use originalMaxDistance in logbook message if available (shows original search range) -->
                <set_value name="$originalSearchRange" exact="$maxDistance"/>
                <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
                  <set_value name="$originalSearchRange" exact="$originalMaxDistance"/>
                </do_if>
                
                <!-- Construct logbook message using TextDB syntax with calculated fallback distance -->
                <set_value name="$logbookMessage" exact="{77000,3221}.[$ship.knownname, $currentSectorName, $originalSearchRange, $fallbackMaxDistance]"/>
                
                <!-- Write logbook entry using centralized library -->
                <run_actions ref="md.GT_Libraries_General.WriteLogbookMessage">
                  <param name="Message" value="$logbookMessage"/>
                  <param name="Category" value="'alerts'"/>
                  <param name="Title" value="'Fallback Search: ' + $ship.knownname"/>
                  <param name="Object" value="$ship"/>
                  <param name="Interaction" value="'showonmap'"/>
                  <param name="CheckGlobalSettings" value="true"/>
                </run_actions>
              </do_if>
              
              <!-- Mark that fallback search was triggered -->
              <set_value name="$fallbackSearchTriggered" exact="true"/>
              
              <!-- Mark fallback as attempted globally (persists across cue instances) -->
              <set_value name="global.$GT_FallbackAttempted.{$ship}" exact="true"/>
              
              <!-- Trigger fallback search -->
              <!-- Fallback uses lower profit thresholds, so we compensate by restricting travel distance -->
              <!-- Formula: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
              <!-- OriginalMaxDistance used for filtering stations from home sector -->
              <!-- CRITICAL: Pass $originalMaxDistance (not $maxDistance) to preserve original search range -->
              <set_value name="$fallbackParams" exact="table[
                $Ship = $ship,
                $MaxDistance = $fallbackMaxDistance,
                $OriginalMaxDistance = $originalMaxDistance,
                $MinROI = $minROI,
                $MinAbsoluteProfit = $minAbsoluteProfit,
                $FactionPriority = $factionPriority,
                $FactionPriorityText = $factionPriorityText,
                $DistancePenaltyMultiplier = $distancePenaltyMultiplier,
                $SkillLevel = $skillLevel,
                $ThreatIntel = $gt_ThreatIntel,
                $FleetCoord = $gt_FleetCoord,
                $AdvancedAnalytics = $gt_AdvancedAnalytics
              ]"/>
              <signal_cue_instantly cue="md.GT_Search_Methods.SearchFallbackTrades" param="$fallbackParams"/>
              
              <!-- Exit - SearchFallbackTrades will signal SearchTradeRoutes again when complete -->
              <cancel_cue cue="this"/>
            </do_if>
            <do_else>
              <!-- Ship is isolated - signal no trade found (normal behavior for isolated ships) -->
              <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Fallback search already triggered or cache search succeeded - signal no trade found -->
            <!-- Log if fallback search completed with no trades -->
            <do_if value="$searchState == 'fallback' and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Fallback search complete: No trades found'" chance="100"/>
            </do_if>
            
            <!-- FIX: Clear failed trades if fallback search also found nothing (prevents deadlock) -->
            <!-- If both normal and fallback searches found nothing, failed trades are blocking everything -->
            <!-- Clear them to allow ship to retry routes that may have become available -->
            <do_if value="$searchState == 'fallback'">
              <do_if value="global.$GT_FailedTrades? and global.$GT_FailedTrades.{$ship}?">
                <set_value name="$failedTradesCount" exact="global.$GT_FailedTrades.{$ship}.count"/>
                <remove_value name="global.$GT_FailedTrades.{$ship}"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Search] Cleared ' + $failedTradesCount + ' failed trade entries for ' + $ship.idcode + ' (fallback search also found nothing - preventing deadlock)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- ENHANCED: Log before signaling no trade found (debug mode only) -->
            <!-- CRITICAL: Check $ship exists before using it -->
            <do_if value="$ship? and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Search] (' + $ship.idcode + ') Search complete - signaling GT_No_Trade_Found (TotalRejected=' + $totalRejected + ', TotalEvaluated=' + $totalEvaluated + ', OffersFound=' + $offersFound + ')'" chance="100"/>
            </do_if>
            <!-- Signal back to AI script: No Trade Found -->
            <!-- CRITICAL: Always send 'blacklist' param to prevent idle timeout escalation -->
            <!-- Reason: With blacklist-aware pre-filtering, we can't distinguish "filtered" from "genuinely empty" -->
            <!-- Better UX: Don't escalate to 60s timeout when ship might just need blacklist adjustment -->
            <!-- CRITICAL: Check $ship exists before signaling -->
            <do_if value="$ship?">
              <signal_objects object="$ship" param="'GT_No_Trade_Found'" param2="'blacklist'"/>
            </do_if>
          </do_else>
          </do_else>
        </do_else>
        </do_if>
        
        <!-- Release search lock ONLY if NOT waiting for batch processing FOR THIS SHIP -->
        <!-- If waiting for batch, SearchLiveTrades_Resume will signal SearchTradeRoutes again -->
        <!-- and we'll release the lock after processing live search results -->
        <!-- If we're continuing from live search, this IS the final completion, so release the lock -->
        <!-- CRITICAL: Check $params exists before accessing $params.$Ship -->
        <set_value name="$shipForCleanup" exact="null"/>
        <do_if value="$params? and $params.$Ship?">
          <set_value name="$shipForCleanup" exact="$params.$Ship"/>
        </do_if>
        <do_if value="$shouldProceed and $ship?">
          <!-- If we proceeded, use the processed $ship (might have been modified) -->
          <set_value name="$shipForCleanup" exact="$ship"/>
        </do_if>
        
        <!-- CRITICAL: Only proceed with cleanup if we have a valid ship -->
        <do_if value="$shipForCleanup?">
          <set_value name="$isWaitingForThisShipBatch" exact="false"/>
          <do_if value="$waitingForBatch and $params? and $params.$Ship? and $batchShip == $params.$Ship">
            <set_value name="$isWaitingForThisShipBatch" exact="true"/>
          </do_if>

          <!-- ALSO treat "live search started in this invocation" as an async continuation that must retain the lock.
               Otherwise we release the request registry immediately, and the next SearchTradeRoutes run (cooldown path)
               will incorrectly signal GT_No_Trade_Found while the live/batch pipeline is still running. -->
          <set_value name="$isWaitingForContinuation" exact="$isWaitingForThisShipBatch"/>
          <do_if value="$waitingForLiveSearch">
            <set_value name="$isWaitingForContinuation" exact="true"/>
          </do_if>
        
          <!-- Release lock and parameters using Request Registry -->
          <!-- Only release if NOT waiting for async continuation (live search + batch) FOR THIS SHIP -->
          <!-- If waiting for batch, we'll need these parameters when processing live search results -->
          <!-- If we're continuing from live search, this IS the final completion, so clean up parameters -->
          <do_if value="not $isWaitingForContinuation or $searchState == 'live' or $searchState == 'fallback'">
            <set_value name="$releaseReason" exact="if ($searchState == 'live' or $searchState == 'fallback') then 'live search continuation complete' else 'search complete'"/>
            <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
              <param name="ship" value="$shipForCleanup"/>
              <param name="reason" value="$releaseReason"/>
            </run_actions>
            
            <!-- Decrement trade request queue active instances counter -->
            <!-- This allows ProcessTradeRequestQueue to process next queued request -->
            <do_if value="global.$GT_TradeRequestQueue? and global.$GT_TradeRequestQueue.$ActiveInstances? and global.$GT_TradeRequestQueue.$ActiveInstances gt 0">
              <set_value name="global.$GT_TradeRequestQueue.$ActiveInstances" operation="subtract"/>
              <signal_cue_instantly cue="md.GT_TradingAI.ProcessTradeRequestQueue"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Async continuation in progress FOR THIS SHIP - keep lock until live search/batch completes -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $shipForCleanup.idcode + ') Search lock retained (waiting for live search/batch to complete)'" chance="100"/>
            </do_if>
          </do_else>
          
          <!-- Mark search complete and process next ship in queue -->
          <!-- Use $shipForCleanup instead of $ship (available even if $shouldProceed was false) -->
          <set_value name="$shipForQueue" exact="$shipForCleanup"/>

          <!-- If this run used a cache-search queue slot, release it -->
          <do_if value="$useSearchQueueCounter">
            <!-- IMPORTANT:
                 When we defer to LIVE search, SearchLiveTrades_Resume needs the ORIGINAL params to signal SearchTradeRoutes again.
                 So: release the cache-search slot, but DO NOT delete $Params while live-search is in progress for this ship. -->
            <set_value name="$keepSearchQueueParams" exact="false"/>
            <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$shipForQueue}?">
              <set_value name="$keepSearchQueueParams" exact="true"/>
            </do_if>
            <do_if value="not $keepSearchQueueParams">
              <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$shipForQueue}?">
                <remove_value name="global.$GT_SearchQueue.$Params.{$shipForQueue}"/>
              </do_if>
            </do_if>
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
              <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
            </do_if>
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $shipForQueue.idcode + ') SEARCH COMPLETE (active: ' + global.$GT_SearchQueue.$ActiveSearches + '/' + global.$GT_SearchQueue.$MaxConcurrent + ', queued: ' + global.$GT_SearchQueue.$Ships.count + ')'" chance="100"/>
            </do_if>
            <!-- Continue processing cache-search queue if there are ships waiting -->
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
            </do_if>
          </do_if>

          <!-- If this run acquired a live-search slot, release it and continue live queue -->
          <do_if value="$fromLiveQueue and $params.$LiveSlotAcquired? and $params.$LiveSlotAcquired == true">
            <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$ActiveLiveSearches? and global.$GT_LiveSearchQueue.$ActiveLiveSearches gt 0">
              <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" operation="subtract"/>
            </do_if>
            <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$Params? and global.$GT_LiveSearchQueue.$Params.{$shipForQueue}?">
              <remove_value name="global.$GT_LiveSearchQueue.$Params.{$shipForQueue}"/>
            </do_if>
            <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessLiveSearchQueue"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- No valid ship for cleanup - skip cleanup but still process queue -->
          <!-- This can happen if params were invalid and cue should have been cancelled earlier -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Search] SearchTradeRoutes: Skipping cleanup - no valid ship (params invalid or cue cancelled)'" chance="100"/>
          </do_if>
          
          <!-- Still decrement cache-search queue counter (only if this run used it) -->
          <do_if value="$useSearchQueueCounter">
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
              <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
            </do_if>
            <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
              <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
            </do_if>
          </do_if>

          <!-- Release live-search slot if we had one -->
          <do_if value="$fromLiveQueue and $params.$LiveSlotAcquired? and $params.$LiveSlotAcquired == true">
            <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$ActiveLiveSearches? and global.$GT_LiveSearchQueue.$ActiveLiveSearches gt 0">
              <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" operation="subtract"/>
            </do_if>
            <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessLiveSearchQueue"/>
          </do_if>
        </do_else>
        
        <!-- Close live-search wait guard -->
        </do_if>
        
        <!-- Close cache-ready gate -->
        </do_if>
      </actions>
    </cue>
    <!--  -->
    <!-- SearchLiveTrades_Resume: Process batch processor results with ship-specific filtering -->
    <!-- This cue receives completed batch processing results and applies ship-specific filters -->
    <!-- (ware basket, illegal wares, blacklists, path availability) before returning results -->
    <!--  -->
    <cue name="SearchLiveTrades_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- 1. Retrieve ship object from signal (used as table key) -->
        <set_value name="$ship" exact="event.param"/>
        
        <!-- 2. Retrieve results from batch processor using ship object as key -->
        <set_value name="$results" exact="@global.$GT_BatchResultsList.{$ship}"/>
        
          <!-- Validate results exist -->
          <do_if value="not $results?">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <debug_text text="'[GT-Resume] Batch results not found for ship ' + $ship.idcode" chance="100"/>
            </do_if>
            
          <!-- Preserve LastRejectionStats when updating global.$GT_SearchResult -->
          <set_value name="$preservedLastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
              <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
            </do_if>
            
            <set_value name="global.$GT_SearchResult.{$ship}" exact="table[
              $Found = false,
              $BestTrade = null,
              $BestScore = 0,
              $TradeList = [],
              $Ship = $ship
            ]"/>
            
            <!-- Restore LastRejectionStats after updating global.$GT_SearchResult -->
            <do_if value="$preservedLastRejectionStats?">
              <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
            </do_if>
            
            <cancel_cue cue="this"/>
          </do_if>
        
        <!-- Extract results -->
        <set_value name="$ship" exact="$results.$ship"/>
        <set_value name="$tradeList" exact="$results.$tradeList"/>
        <!-- Ensure $tradeList is never null - initialize to empty list if null or missing -->
        <!-- Use same pattern as FilterTradeList_Batch check (line 1939) but inverted -->
        <do_if value="not ($tradeList? and $tradeList != null)">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        <set_value name="$crossStationBestTrade" exact="$results.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="$results.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="$results.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="$results.$nonConflictedBestScore"/>
        <!-- Extract rejection statistics from batch processor -->
        <set_value name="$tradesRejectedProfit" exact="0"/>
        <set_value name="$tradesRejectedDocking" exact="0"/>
        <set_value name="$tradesRejectedAmount" exact="0"/>
        <set_value name="$tradesRejectedDistance" exact="0"/>
        <do_if value="$results.$tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="$results.$tradesRejectedProfit"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="$results.$tradesRejectedDocking"/>
        </do_if>
        <do_if value="$results.$tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="$results.$tradesRejectedAmount"/>
        </do_if>
        <do_if value="$results.$tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="$results.$tradesRejectedDistance"/>
        </do_if>
        <set_value name="$bestRejectedTrade" exact="null"/>
        <do_if value="$results.$bestRejectedTrade?">
          <set_value name="$bestRejectedTrade" exact="$results.$bestRejectedTrade"/>
        </do_if>
        
        <!-- Get maxDistance and originalMaxDistance from batch data (still stored for reference) -->
        <set_value name="$maxDistance" exact="null"/>
        <set_value name="$originalMaxDistance" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData?">
          <do_if value="$batchData.$maxDistance?">
            <set_value name="$maxDistance" exact="$batchData.$maxDistance"/>
          </do_if>
          <do_if value="$batchData.$originalMaxDistance?">
            <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
          </do_if>
        </do_if>
        
        <!-- Detect if this is a fallback search (originalMaxDistance != maxDistance) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Processing ' + $tradeList.count + ' trades from batch processor (maxDistance: ' + $maxDistance + ')'" chance="100"/>
        </do_if>
        
        <!-- 3. Apply ship-specific filtering -->
        <!-- 3a. Get ship settings -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        <set_value name="$ignoreCarrierAux" exact="@global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux"/>
        <set_value name="$ignoreBuildStorage" exact="@global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage"/>
        <!-- Get ware basket safely (using library function with null-checking pattern) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetWareBasketSafe" result="$wareBasket">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- 3b. Filter tradeList -->
        <set_value name="$filteredTradeList" exact="[]"/>
        <!-- Track filtering statistics -->
        <set_value name="$filteredByWareBasket" exact="0"/>
        <set_value name="$filteredByIllegal" exact="0"/>
        <set_value name="$filteredByBlacklist" exact="0"/>
        <set_value name="$filteredByPathBlocked" exact="0"/>
        <set_value name="$tradesByWareStats" exact="table[]"/>
        
        <!-- Initialize gatedistance cache for blacklist-aware pathfinding -->
        <!-- Reduces pathfinding calls from 200 (for 100 trades) to ~20-40 unique sector pairs -->
        <!-- (80-90% reduction in expensive gatedistance calculations) -->
        <set_value name="$gatedistanceCache" exact="table[]"/>
        <set_value name="$currentSector" exact="$ship.sector"/>
        
        <!-- Track intra-sector trade statistics -->
        <set_value name="$intraSectorTradesTotal" exact="0"/>
        <set_value name="$intraSectorTradesFiltered" exact="0"/>
        <set_value name="$intraSectorTradesValid" exact="0"/>
        
        <!-- Parallel Filtering with Cooperative Multitasking -->
        <!-- Process trades in batches to prevent blocking the game engine -->
        <!-- This prevents frame stutter when filtering large trade lists (100+ trades) -->
        <!-- Store filtering state in global table (persists across cue instances) -->
        
        <!-- Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Initialize filter state for this ship -->
        <!-- Include batch processor results variables (from SearchLiveTrades_Resume) -->
        <set_value name="$filterState" exact="table[
          $ship = $ship,
          $tradeList = $tradeList,
          $wareBasket = $wareBasket,
          $allowIllegal = $allowIllegal,
          $ignoreCarrierAux = $ignoreCarrierAux,
          $ignoreBuildStorage = $ignoreBuildStorage,
          $blacklistgroup = $blacklistgroup,
          $currentSector = $currentSector,
          $gatedistanceCache = $gatedistanceCache,
          $filteredTradeList = $filteredTradeList,
          $filteredByWareBasket = $filteredByWareBasket,
          $filteredByIllegal = $filteredByIllegal,
          $filteredByBlacklist = $filteredByBlacklist,
          $filteredByPathBlocked = $filteredByPathBlocked,
          $tradesByWareStats = $tradesByWareStats,
          $intraSectorTradesTotal = $intraSectorTradesTotal,
          $intraSectorTradesFiltered = $intraSectorTradesFiltered,
          $intraSectorTradesValid = $intraSectorTradesValid,
          $filterIndex = 0,
          $filterBatchSize = 10,
          $maxDistance = $maxDistance,
          $crossStationBestTrade = $crossStationBestTrade,
          $crossStationBestScore = $crossStationBestScore,
          $nonConflictedBestTrade = $nonConflictedBestTrade,
          $nonConflictedBestScore = $nonConflictedBestScore,
          $tradesRejectedProfit = $tradesRejectedProfit,
          $tradesRejectedDocking = $tradesRejectedDocking,
          $tradesRejectedAmount = $tradesRejectedAmount,
          $tradesRejectedDistance = $tradesRejectedDistance,
          $bestRejectedTrade = $bestRejectedTrade
        ]"/>
        <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
        
        <!-- Signal batch filtering cue to start processing -->
        <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
        
        <!-- Wait for batch filtering to complete (resume cue will signal back) -->
        <!-- Note: We'll resume in FilterTradeList_Resume cue -->
        <!-- Cancel this cue - resume cue will continue processing -->
        <cancel_cue cue="this"/>
      </actions>
    </cue>
    
    <!-- Batch Trade Filtering with Cooperative Multitasking -->
    <cue name="FilterTradeList_Batch" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Calculate delay from global Performance settings -->
        <set_value name="$batchDelay" exact="50"/>
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay?">
          <set_value name="$batchDelay" exact="@global.$GT_GlobalSettings.$Performance.$BatchProcessingDelay"/>
        </do_if>
        <!-- Convert to time value (milliseconds) -->
        <set_value name="this.$batchDelayTime" exact="$batchDelay * 1ms"/>
      </actions>
      <delay exact="this.$batchDelayTime"/>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve state from global table -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- FIX: Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <!-- Filter state missing/invalid (race): recover by returning 0 trades and resuming. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] WARNING: FilterTradeList_Batch missing/invalid filterState for ship ' + $ship.idcode + ' - returning 0 trades (race/cleanup).'" chance="100"/>
          </do_if>
          <set_value name="global.$GT_FilterState.{$ship}" exact="table[
            $ship = $ship,
            $tradeList = [],
            $filteredTradeList = [],
            $filteredByWareBasket = 0,
            $filteredByIllegal = 0,
            $filteredByBlacklist = 0,
            $filteredByPathBlocked = 0,
            $tradesByWareStats = table[],
            $intraSectorTradesTotal = 0,
            $intraSectorTradesFiltered = 0,
            $intraSectorTradesValid = 0,
            $filterIndex = 0,
            $filterBatchSize = 10
          ]"/>
          <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
        <!-- Extract state variables -->
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <!-- Validate critical variables exist before use - wrap all processing in conditional -->
        <do_if value="$tradeList? and $tradeList != null">
          <set_value name="$wareBasket" exact="@$filterState.$wareBasket"/>
          <set_value name="$allowIllegal" exact="@$filterState.$allowIllegal"/>
          <set_value name="$ignoreCarrierAux" exact="@$filterState.$ignoreCarrierAux"/>
          <set_value name="$ignoreBuildStorage" exact="@$filterState.$ignoreBuildStorage"/>
          <set_value name="$blacklistgroup" exact="@$filterState.$blacklistgroup"/>
          <set_value name="$currentSector" exact="@$filterState.$currentSector"/>
          <set_value name="$gatedistanceCache" exact="@$filterState.$gatedistanceCache"/>
          <set_value name="$filterIndex" exact="@$filterState.$filterIndex"/>
          <set_value name="$filterBatchSize" exact="@$filterState.$filterBatchSize"/>
          
          <!-- Initialize filterIndex and filterBatchSize if missing -->
          <do_if value="not $filterIndex?">
            <set_value name="$filterIndex" exact="0"/>
          </do_if>
          <do_if value="not $filterBatchSize?">
            <set_value name="$filterBatchSize" exact="10"/>
          </do_if>
          
          <!-- Get mutable lists/stats from state (or initialize if first batch) -->
          <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
          <do_if value="not $filteredTradeList? or $filteredTradeList == null">
            <set_value name="$filteredTradeList" exact="[]"/>
          </do_if>
          <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
          <do_if value="not $filteredByWareBasket?">
            <set_value name="$filteredByWareBasket" exact="0"/>
          </do_if>
          <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
          <do_if value="not $filteredByIllegal?">
            <set_value name="$filteredByIllegal" exact="0"/>
          </do_if>
          <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
          <do_if value="not $filteredByBlacklist?">
            <set_value name="$filteredByBlacklist" exact="0"/>
          </do_if>
          <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
          <do_if value="not $filteredByPathBlocked?">
            <set_value name="$filteredByPathBlocked" exact="0"/>
          </do_if>
          <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
          <do_if value="not $tradesByWareStats? or $tradesByWareStats == null">
            <set_value name="$tradesByWareStats" exact="table[]"/>
          </do_if>
          <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
          <do_if value="not $intraSectorTradesTotal?">
            <set_value name="$intraSectorTradesTotal" exact="0"/>
          </do_if>
          <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
          <do_if value="not $intraSectorTradesFiltered?">
            <set_value name="$intraSectorTradesFiltered" exact="0"/>
          </do_if>
          <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
          <do_if value="not $intraSectorTradesValid?">
            <set_value name="$intraSectorTradesValid" exact="0"/>
          </do_if>
          
          <!-- Ensure $filterState is not null before setting properties -->
          <do_if value="$filterState == null">
            <set_value name="$filterState" exact="table[]"/>
          </do_if>
          
          <!-- Process one batch of trades -->
          <set_value name="$filterTotalTrades" exact="$tradeList.count"/>
          <set_value name="$batchEnd" exact="[$filterIndex + $filterBatchSize, $filterTotalTrades].min"/>
          <do_all exact="$batchEnd - $filterIndex" counter="$batchOffset">
            <set_value name="$i" exact="$filterIndex + $batchOffset"/>
            <set_value name="$trade" exact="$tradeList.{$i}"/>
            <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
            
            <!-- Initialize ware stats if needed -->
            <do_if value="not $tradesByWareStats.{$ware}?">
              <set_value name="$tradesByWareStats.{$ware}" exact="table[$total=0, $filteredByWareBasket=0, $filteredByIllegal=0, $filteredByBlacklist=0, $filteredByPathBlocked=0, $valid=0]"/>
            </do_if>
            <set_value name="$wareStats" exact="$tradesByWareStats.{$ware}"/>
            <set_value name="$wareStats.$total" exact="$wareStats.$total + 1"/>
            
            <!-- Extract sectors early for intra-sector trade detection -->
            <set_value name="$buySector" exact="@$trade.$BuyStation.sector"/>
            <set_value name="$sellSector" exact="@$trade.$SellStation.sector"/>
            
            <!-- Track if this is a TRUE intra-sector trade -->
            <run_actions ref="md.GT_Libraries_General.GT_IsIntraSectorTrade" result="$isIntraSectorTrade">
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="currentSector" value="$currentSector"/>
            </run_actions>
            <do_if value="$isIntraSectorTrade">
              <set_value name="$intraSectorTradesTotal" exact="$intraSectorTradesTotal + 1"/>
            </do_if>
            
            <!-- Filter trade for ship -->
            <run_actions ref="md.GT_Libraries_General.GT_FilterTradeForShip" result="$filterResult">
              <param name="trade" value="$trade"/>
              <param name="ship" value="$ship"/>
              <param name="ware" value="$ware"/>
              <param name="wareBasket" value="$wareBasket"/>
              <param name="allowIllegal" value="$allowIllegal"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
              <param name="currentSector" value="$currentSector"/>
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="filterStats" value="$wareStats"/>
              <param name="isIntraSectorTrade" value="$isIntraSectorTrade"/>
              <param name="ignoreCarrierAux" value="$ignoreCarrierAux"/>
              <param name="ignoreBuildStorage" value="$ignoreBuildStorage"/>
            </run_actions>
            
            <!-- Update filter statistics -->
            <set_value name="$isAllowed" exact="$filterResult.$IsAllowed"/>
            <set_value name="$filterReason" exact="$filterResult.$FilterReason"/>
            <do_if value="not $isAllowed">
              <do_if value="$filterReason == 'ware_basket'">
                <set_value name="$filteredByWareBasket" exact="$filteredByWareBasket + 1"/>
              </do_if>
              <do_elseif value="$filterReason == 'illegal'">
                <set_value name="$filteredByIllegal" exact="$filteredByIllegal + 1"/>
              </do_elseif>
              <do_elseif value="$filterReason == 'blacklist_intra' or $filterReason == 'blacklist_buy_station' or $filterReason == 'blacklist_sell_station' or $filterReason == 'blacklist_buy_sector' or $filterReason == 'blacklist_sell_sector'">
                <set_value name="$filteredByBlacklist" exact="$filteredByBlacklist + 1"/>
              </do_elseif>
              <do_elseif value="$filterReason == 'path_blocked'">
                <set_value name="$filteredByPathBlocked" exact="$filteredByPathBlocked + 1"/>
              </do_elseif>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
              </do_if>
            </do_if>
            
            <!-- Add to filtered list if valid -->
            <do_if value="$isAllowed">
              <append_to_list name="$filteredTradeList" exact="$trade"/>
              <set_value name="$wareStats.$valid" exact="$wareStats.$valid + 1"/>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesValid" exact="$intraSectorTradesValid + 1"/>
              </do_if>
            </do_if>
            <do_else>
              <do_if value="$isIntraSectorTrade">
                <set_value name="$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered + 1"/>
              </do_if>
            </do_else>
            
            <!-- Update ware stats -->
            <set_value name="$tradesByWareStats.{$ware}" exact="$wareStats"/>
          </do_all>
          
          <!-- Update state for next batch or completion -->
          <!-- Re-validate $filterState before setting properties (might have become null) -->
          <do_if value="$filterState == null">
            <debug_text text="'[GT-Batch] ERROR: $filterState became null for ship ' + $ship.idcode + ' - cannot update state'" chance="100"/>
            <cancel_cue cue="this"/>
          </do_if>
          
          <set_value name="$filterIndex" exact="$batchEnd"/>
          <set_value name="$filterState.$filterIndex" exact="$filterIndex"/>
          <set_value name="$filterState.$filteredTradeList" exact="$filteredTradeList"/>
          <set_value name="$filterState.$filteredByWareBasket" exact="$filteredByWareBasket"/>
          <set_value name="$filterState.$filteredByIllegal" exact="$filteredByIllegal"/>
          <set_value name="$filterState.$filteredByBlacklist" exact="$filteredByBlacklist"/>
          <set_value name="$filterState.$filteredByPathBlocked" exact="$filteredByPathBlocked"/>
          <set_value name="$filterState.$tradesByWareStats" exact="$tradesByWareStats"/>
          <set_value name="$filterState.$intraSectorTradesTotal" exact="$intraSectorTradesTotal"/>
          <set_value name="$filterState.$intraSectorTradesFiltered" exact="$intraSectorTradesFiltered"/>
          <set_value name="$filterState.$intraSectorTradesValid" exact="$intraSectorTradesValid"/>
          <set_value name="global.$GT_FilterState.{$ship}" exact="$filterState"/>
          
          <!-- Check if more batches needed -->
          <do_if value="$filterIndex lt $filterTotalTrades">
            <!-- Signal next batch -->
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Batch" param="$ship"/>
          </do_if>
          <do_else>
            <!-- All batches complete - signal resume cue to continue processing -->
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- $tradeList is null:
               This can happen due to a rare race (delayed batch wakes after state was partially overwritten/cleaned).
               Treat as recoverable ONLY if the ship is still waiting (search lock held).
               If the ship is no longer locked, this is a stale delayed batch wakeup and must be cancelled silently. -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Batch] WARNING: $tradeList is null for ship ' + $ship.idcode + ' - aborting filtering and returning 0 trades (race/cleanup).'" chance="100"/>
          </do_if>
          
          <!-- Check if ship is still waiting for this pipeline (search lock held) -->
          <set_value name="$lockTime" exact="null"/>
          <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
            <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$ship}"/>
          </do_if>
          <do_if value="$lockTime == null">
            <!-- Stale delayed batch wakeup (ship already completed/cleaned); cancel without signalling continuation -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Batch] INFO: Stale FilterTradeList_Batch wakeup for ' + $ship.idcode + ' (no search lock) - cancelling.'" chance="100"/>
            </do_if>
            <cancel_cue cue="this"/>
          </do_if>
          <do_else>
            <!-- Recreate minimal state so Resume can complete safely -->
            <set_value name="global.$GT_FilterState.{$ship}" exact="table[
              $ship = $ship,
              $tradeList = [],
              $filteredTradeList = [],
              $filteredByWareBasket = 0,
              $filteredByIllegal = 0,
              $filteredByBlacklist = 0,
              $filteredByPathBlocked = 0,
              $tradesByWareStats = table[],
              $intraSectorTradesTotal = 0,
              $intraSectorTradesFiltered = 0,
              $intraSectorTradesValid = 0,
              $filterIndex = 0,
              $filterBatchSize = 10
            ]"/>
            <signal_cue_instantly cue="md.GT_Trading_Search.FilterTradeList_Resume" param="$ship"/>
            <cancel_cue cue="this"/>
          </do_else>
        </do_else>
        </do_else>
      </actions>
    </cue>
    
    <!-- Resume cue: Continue processing after batch filtering completes -->
    <cue name="FilterTradeList_Resume" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$ship" exact="event.param"/>
        
        <!-- FIX: Defensive check for race condition (initialization might not have completed yet) -->
        <do_if value="not global.$GT_FilterState?">
          <set_value name="global.$GT_FilterState" exact="table[]"/>
        </do_if>
        
        <!-- Retrieve filtered results from global state -->
        <set_value name="$filterState" exact="@global.$GT_FilterState.{$ship}"/>
        <!-- Proper null check - extract property first, then check if result exists and is valid -->
        <set_value name="$filterStateValid" exact="false"/>
        <do_if value="$filterState?">
          <set_value name="$filterStateKeysCount" exact="@$filterState.keys.count"/>
          <do_if value="$filterStateKeysCount? and $filterStateKeysCount ge 0">
            <set_value name="$filterStateValid" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="not $filterStateValid">
          <cancel_cue cue="this"/>
        </do_if>
        <do_else>
        
        <!-- Extract all filtered results and statistics -->
        <set_value name="$filteredTradeList" exact="@$filterState.$filteredTradeList"/>
        <do_if value="not $filteredTradeList? or $filteredTradeList == null">
          <set_value name="$filteredTradeList" exact="[]"/>
        </do_if>
        <set_value name="$filteredByWareBasket" exact="@$filterState.$filteredByWareBasket"/>
        <do_if value="not $filteredByWareBasket?">
          <set_value name="$filteredByWareBasket" exact="0"/>
        </do_if>
        <set_value name="$filteredByIllegal" exact="@$filterState.$filteredByIllegal"/>
        <do_if value="not $filteredByIllegal?">
          <set_value name="$filteredByIllegal" exact="0"/>
        </do_if>
        <set_value name="$filteredByBlacklist" exact="@$filterState.$filteredByBlacklist"/>
        <do_if value="not $filteredByBlacklist?">
          <set_value name="$filteredByBlacklist" exact="0"/>
        </do_if>
        <set_value name="$filteredByPathBlocked" exact="@$filterState.$filteredByPathBlocked"/>
        <do_if value="not $filteredByPathBlocked?">
          <set_value name="$filteredByPathBlocked" exact="0"/>
        </do_if>
        <set_value name="$tradesByWareStats" exact="@$filterState.$tradesByWareStats"/>
        <do_if value="not $tradesByWareStats? or $tradesByWareStats == null">
          <set_value name="$tradesByWareStats" exact="table[]"/>
        </do_if>
        <set_value name="$intraSectorTradesTotal" exact="@$filterState.$intraSectorTradesTotal"/>
        <do_if value="not $intraSectorTradesTotal?">
          <set_value name="$intraSectorTradesTotal" exact="0"/>
        </do_if>
        <set_value name="$intraSectorTradesFiltered" exact="@$filterState.$intraSectorTradesFiltered"/>
        <do_if value="not $intraSectorTradesFiltered?">
          <set_value name="$intraSectorTradesFiltered" exact="0"/>
        </do_if>
        <set_value name="$intraSectorTradesValid" exact="@$filterState.$intraSectorTradesValid"/>
        <do_if value="not $intraSectorTradesValid?">
          <set_value name="$intraSectorTradesValid" exact="0"/>
        </do_if>
        <set_value name="$tradeList" exact="@$filterState.$tradeList"/>
        <do_if value="not $tradeList? or $tradeList == null">
          <set_value name="$tradeList" exact="[]"/>
        </do_if>
        <set_value name="$maxDistance" exact="@$filterState.$maxDistance"/>
        <do_if value="not $maxDistance?">
          <set_value name="$maxDistance" exact="10"/>
        </do_if>
        
        <!-- Get originalMaxDistance from batch data (if available) -->
        <set_value name="$originalMaxDistance" exact="$maxDistance"/>  <!-- Default: same as maxDistance -->
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <do_if value="$batchData? and $batchData.$originalMaxDistance?">
          <set_value name="$originalMaxDistance" exact="$batchData.$originalMaxDistance"/>
        </do_if>
        
        <!-- Detect if this is a fallback search (originalMaxDistance != maxDistance) -->
        <set_value name="$isFallbackSearch" exact="false"/>
        <do_if value="$originalMaxDistance? and $originalMaxDistance != $maxDistance">
          <set_value name="$isFallbackSearch" exact="true"/>
        </do_if>
        
        <!-- Extract batch processor result variables -->
        <set_value name="$crossStationBestTrade" exact="@$filterState.$crossStationBestTrade"/>
        <set_value name="$crossStationBestScore" exact="@$filterState.$crossStationBestScore"/>
        <set_value name="$nonConflictedBestTrade" exact="@$filterState.$nonConflictedBestTrade"/>
        <set_value name="$nonConflictedBestScore" exact="@$filterState.$nonConflictedBestScore"/>
        <set_value name="$tradesRejectedProfit" exact="@$filterState.$tradesRejectedProfit"/>
        <set_value name="$tradesRejectedDocking" exact="@$filterState.$tradesRejectedDocking"/>
        <set_value name="$tradesRejectedAmount" exact="@$filterState.$tradesRejectedAmount"/>
        <set_value name="$tradesRejectedDistance" exact="@$filterState.$tradesRejectedDistance"/>
        <set_value name="$bestRejectedTrade" exact="@$filterState.$bestRejectedTrade"/>
        
        <!-- Initialize to safe defaults if not set -->
        <do_if value="not $tradesRejectedProfit?">
          <set_value name="$tradesRejectedProfit" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDocking?">
          <set_value name="$tradesRejectedDocking" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedAmount?">
          <set_value name="$tradesRejectedAmount" exact="0"/>
        </do_if>
        <do_if value="not $tradesRejectedDistance?">
          <set_value name="$tradesRejectedDistance" exact="0"/>
        </do_if>
        <do_if value="not $crossStationBestScore?">
          <set_value name="$crossStationBestScore" exact="0"/>
        </do_if>
        <do_if value="not $nonConflictedBestScore?">
          <set_value name="$nonConflictedBestScore" exact="0"/>
        </do_if>
        
        <!-- Clean up filter state -->
        <remove_value name="global.$GT_FilterState.{$ship}"/>
        
        <!-- DEBUG: Log filtering statistics -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract counts safely (ternary operator evaluates both sides, so we need separate checks) -->
          <set_value name="$tradeListCountSafe" exact="0"/>
          <do_if value="$tradeList? and $tradeList != null">
            <set_value name="$tradeListCountSafe" exact="$tradeList.count"/>
          </do_if>
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <set_value name="$filteringStats" exact="'[GT-Resume] (' + $ship.idcode + ') Filtering statistics:' +
            '\n  Total trades: ' + $tradeListCountSafe +
            '\n  TRUE intra-sector trades: ' + (if $intraSectorTradesTotal? then $intraSectorTradesTotal else 0) + ' (filtered: ' + (if $intraSectorTradesFiltered? then $intraSectorTradesFiltered else 0) + ', valid: ' + (if $intraSectorTradesValid? then $intraSectorTradesValid else 0) + ')' +
            '\n  Filtered by ware basket: ' + (if $filteredByWareBasket? then $filteredByWareBasket else 0) +
            '\n  Filtered by illegal: ' + (if $filteredByIllegal? then $filteredByIllegal else 0) +
            '\n  Filtered by blacklist: ' + (if $filteredByBlacklist? then $filteredByBlacklist else 0) +
            '\n  Filtered by path blocked: ' + (if $filteredByPathBlocked? then $filteredByPathBlocked else 0) +
            '\n  Valid trades: ' + $filteredTradeListCountSafe"/>
          <debug_text text="$filteringStats" chance="100"/>
          
          <!-- Log per-ware statistics -->
          <!-- Use safe access for keys check -->
          <set_value name="$tradesByWareStatsKeysCount" exact="if $tradesByWareStats? then @$tradesByWareStats.keys.count else 0"/>
          <do_if value="$tradesByWareStatsKeysCount gt 0">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$wareStatsLog" exact="'[GT-Resume] (' + $ship.idcode + ') Per-ware filtering:'"/>
              <do_all exact="$tradesByWareStatsKeysCount" counter="$wareIdx">
                <set_value name="$ware" exact="$tradesByWareStats.keys.{$wareIdx}"/>
                <set_value name="$stats" exact="$tradesByWareStats.{$ware}"/>
                <set_value name="$wareStatsLog" exact="$wareStatsLog + 
                  '\n  - ' + @$ware.name + ': ' + $stats.$total + ' checked, ' +
                  $stats.$filteredByWareBasket + ' basket, ' +
                  $stats.$filteredByIllegal + ' illegal, ' +
                  $stats.$filteredByBlacklist + ' blacklist, ' +
                  $stats.$filteredByPathBlocked + ' path, ' +
                  $stats.$valid + ' valid'"/>
              </do_all>
              <debug_text text="$wareStatsLog" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract counts safely (ternary operator evaluates both sides) -->
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <set_value name="$tradeListCountSafe" exact="0"/>
          <do_if value="$tradeList? and $tradeList != null">
            <set_value name="$tradeListCountSafe" exact="$tradeList.count"/>
          </do_if>
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') After ship-specific filtering: ' + $filteredTradeListCountSafe + ' trades (from ' + $tradeListCountSafe + ')'" chance="100"/>
        </do_if>
        
        <!-- 4. Build diverse list: Top 5 per ware (minimum-maximum) with early exit -->
        <!-- DEBUG: Log trades before diverse list building -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <!-- Extract count safely (ternary operator evaluates both sides) -->
          <set_value name="$filteredTradeListCountSafe" exact="0"/>
          <do_if value="$filteredTradeList? and $filteredTradeList != null">
            <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
          </do_if>
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Building diverse list from ' + $filteredTradeListCountSafe + ' filtered trades'" chance="100"/>
        </do_if>
        
        <set_value name="$tradesByWare" exact="table[]"/>
        <!-- Extract count safely before loop (ternary operator evaluates both sides) -->
        <set_value name="$filteredTradeListCountSafe" exact="0"/>
        <do_if value="$filteredTradeList? and $filteredTradeList != null">
          <set_value name="$filteredTradeListCountSafe" exact="$filteredTradeList.count"/>
        </do_if>
        <do_if value="$filteredTradeListCountSafe gt 0">
          <do_all exact="$filteredTradeListCountSafe" counter="$i">
            <set_value name="$trade" exact="$filteredTradeList.{$i}"/>
            <set_value name="$ware" exact="$trade.$BuyOffer.ware"/>
            <do_if value="not $tradesByWare.{$ware}?">
              <set_value name="$tradesByWare.{$ware}" exact="[]"/>
            </do_if>
            <append_to_list name="$tradesByWare.{$ware}" exact="$trade"/>
          </do_all>
        </do_if>
        
        <!-- DEBUG: Log wares found -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$wareDebug" exact="'[GT-Resume] (' + $ship.idcode + ') Found ' + $tradesByWare.keys.count + ' wares with trades:'"/>
          <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
            <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
            <set_value name="$wareCount" exact="$tradesByWare.{$ware}.count"/>
            <set_value name="$wareDebug" exact="$wareDebug + '\n  - ' + @$ware.name + ': ' + $wareCount + ' trades'"/>
          </do_all>
          <debug_text text="$wareDebug" chance="100"/>
        </do_if>
        
        <!-- Determine home sector FIRST (same logic as SearchLiveTrades) -->
        <!-- Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <!-- Ships must only trade with stations within maxDistance from HOME SECTOR, not ship position -->
        <set_value name="$homeBase" exact="null"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
              <do_if value="@$commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
          </do_if>
          <do_else>
            <!-- REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
            <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null! This should never happen.'" chance="100"/>
            <!-- Emergency fallback only - this should never happen -->
            <set_value name="$homeBase" exact="$ship.sector"/>
          </do_else>
        </do_if>
        
        <!-- Extract sector -->
        <set_value name="$homeSector" exact="null"/>
        <do_if value="@$homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
          <!-- Emergency fallback only - this should never happen -->
          <set_value name="$homeSector" exact="$ship.sector"/>
        </do_if>
        
        <!-- Log start of fallback search processing -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <set_value name="$filterMaxDistance" exact="$maxDistance"/>
          <do_if value="$originalMaxDistance?">
            <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
          </do_if>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') Fallback search processing started | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance + ' | Trades to evaluate: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <!-- Sort trades by distance from HOME SECTOR (shortest first) per ware, break when exceeding maxDistance -->
        <!-- This matches the requirement: stations must not be farther from home sector than maxDistance -->
        <set_value name="$diverseList" exact="[]"/>
        <do_all exact="$tradesByWare.keys.count" counter="$wareIdx">
          <set_value name="$ware" exact="$tradesByWare.keys.{$wareIdx}"/>
          <set_value name="$wareTrades" exact="$tradesByWare.{$ware}"/>
          
          <!-- Log start of evaluation for this ware -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
            <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
            <set_value name="$filterMaxDistance" exact="$maxDistance"/>
            <do_if value="$originalMaxDistance?">
              <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>
            </do_if>
            <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') Evaluating ' + $wareTrades.count + ' trades for ' + $wareName + ' | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Max distance from current: 2 | Max distance from home: ' + $filterMaxDistance" chance="100"/>
          </do_if>
          
          <!-- For fallback search, filter by HOME SECTOR distance first, then use current distance for sorting -->
          <!-- Distance penalties should only affect SCORING, not FILTERING -->
          <!-- Use library function for fallback trade distance calculation -->
          <set_value name="$currentSector" exact="$ship.sector"/>
          <set_value name="$filterMaxDistance" exact="$maxDistance"/>  <!-- Default: use maxDistance -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and $originalMaxDistance?">
            <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>  <!-- Fallback: use original pilot maxDistance -->
          </do_if>
          
          <!-- Use library function to calculate distances and filter trades -->
          <run_actions ref="md.GT_Libraries_General.GT_CalculateFallbackTradeDistances" result="$distanceResult">
            <param name="wareTrades" value="$wareTrades"/>
            <param name="ship" value="$ship"/>
            <param name="homeSector" value="$homeSector"/>
            <param name="currentSector" value="$currentSector"/>
            <param name="maxDistance" value="$maxDistance"/>
            <param name="originalMaxDistance" value="$originalMaxDistance"/>
            <param name="isFallbackSearch" value="$isFallbackSearch"/>
          </run_actions>
          <set_value name="$tradesWithDistance" exact="$distanceResult.$TradesWithDistance"/>
          <set_value name="$rejectedByUnreachable" exact="$distanceResult.$RejectedByUnreachable"/>
          <set_value name="$rejectedByHomeDistance" exact="$distanceResult.$RejectedByHomeDistance"/>
          <set_value name="$evaluatedCount" exact="$distanceResult.$EvaluatedCount"/>
          
          <!-- Log summary statistics -->
          <!-- NOTE: "Evaluated" counts trades that passed the home distance filter (within maxDistance from home) -->
          <!-- Distance from current position is used only for sorting/prioritization, not filtering -->
          <do_if value="$isFallbackSearch? and $isFallbackSearch and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$wareName" exact="if $ware? then @$ware.name else 'Unknown'"/>
            <set_value name="$totalTrades" exact="$wareTrades.count"/>
            <set_value name="$skippedByDistance" exact="$rejectedByUnreachable + $rejectedByHomeDistance"/>
            <set_value name="$summaryLog" exact="'[GT-Fallback] (' + $ship.idcode + ') Ware: ' + $wareName + ' | Total trades: ' + $totalTrades + ' | Evaluated (within home distance): ' + $evaluatedCount + ' | Accepted: ' + $tradesWithDistance.count + ' | Rejected: ' + ($evaluatedCount - $tradesWithDistance.count) + ' | Skipped (unreachable/home dist): ' + $skippedByDistance + ' (unreachable: ' + $rejectedByUnreachable + ', home dist: ' + $rejectedByHomeDistance + ')'"/>
            <debug_text text="$summaryLog" chance="100"/>
          </do_if>
          
          <!-- Sort by distance (shortest first) -->
          <!-- Use library function for distance-based sorting -->
          <run_actions ref="md.GT_Libraries_General.GT_SortTradesByDistance" result="$sortedTrades">
            <param name="tradesWithDistance" value="$tradesWithDistance"/>
          </run_actions>
          
          <!-- Select top 5 by Score, with early exit when distance exceeds limit -->
          <!-- For fallback search, distance from current position is used ONLY for sorting, not filtering -->
          <!-- All trades have already passed the home distance filter, so we don't need an early exit based on current distance -->
          <!-- For normal search: early exit when distance from home > maxDistance -->
          <!-- Use library function for best trade selection with diversity -->
          <run_actions ref="md.GT_Libraries_General.GT_SelectBestTradesWithDiversity" result="$bestTradesResult">
            <param name="sortedTrades" value="$sortedTrades"/>
            <param name="maxDistance" value="$maxDistance"/>
            <param name="filterMaxDistance" value="$filterMaxDistance"/>
            <param name="isFallbackSearch" value="$isFallbackSearch"/>
            <param name="ware" value="$ware"/>
            <param name="ship" value="$ship"/>
          </run_actions>
          <set_value name="$top3" exact="$bestTradesResult.$TopTrades"/>
          <set_value name="$skippedDueToDistance" exact="$bestTradesResult.$SkippedDueToDistance"/>
          
          <!-- Add up to 5 trades per ware (if less than 5, still include what we have) -->
          <do_if value="$top3.count gt 0">
            <do_all exact="$top3.count" counter="$i">
              <append_to_list name="$diverseList" exact="$top3.{$i}"/>
            </do_all>
          </do_if>
        </do_all>
        
        <!-- Log if no trades were found to evaluate -->
        <do_if value="$isFallbackSearch? and $isFallbackSearch and $tradesByWare.keys.count == 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$currentSectorName" exact="if $ship.sector? then @$ship.sector.knownname else 'Unknown'"/>
          <set_value name="$homeSectorName" exact="if $homeSector? then @$homeSector.knownname else 'Unknown'"/>
          <debug_text text="'[GT-Fallback] (' + $ship.idcode + ') No trades found to evaluate | Current sector: ' + $currentSectorName + ' | Home sector: ' + $homeSectorName + ' | Filtered trade list count: ' + $filteredTradeList.count" chance="100"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Diverse list: ' + $diverseList.count + ' trades (top 5 per ware)'" chance="100"/>
        </do_if>
        
        <!-- Sort diverse list by score (highest first) before storing for AI validation -->
        <!-- This ensures AI validates the best trades first -->
        <!-- Use library function for sorting -->
        <run_actions ref="md.GT_Libraries_General.GT_SortTradesByScore" result="$diverseList">
          <param name="tradeList" value="$diverseList"/>
        </run_actions>
        
        <!-- 5. Cache maintenance: Delete old entries (if cache was refreshed) -->
        <!-- TODO: Track if new trades were added to cache during this search -->
        <!-- For now, assume cache was refreshed if batch processor ran -->
        <set_value name="$cacheRefreshed" exact="true"/>
        <!-- Cleanup per-home-sector cache -->
        <!-- Iterate through all home sectors in cache -->
        <do_if value="$cacheRefreshed">
          <set_value name="$cacheMaxAge" exact="15min"/>
          <set_value name="$deletedCount" exact="0"/>
          <do_if value="global.$GT_TradeCache?">
            <do_all exact="global.$GT_TradeCache.keys.count" counter="$sectorIdx">
              <set_value name="$cacheHomeSector" exact="global.$GT_TradeCache.keys.{$sectorIdx}"/>
              <set_value name="$sectorCache" exact="global.$GT_TradeCache.{$cacheHomeSector}"/>
              <do_if value="(if $sectorCache != null then $sectorCache.count else 0) gt 0">
                <!-- Iterate backwards through this home sector's cache -->
                <set_value name="$sectorCacheCount" exact="$sectorCache.count"/>
                <do_all exact="$sectorCacheCount" counter="$i" reverse="true">
                  <set_value name="$entry" exact="$sectorCache.{$i}"/>
                  <do_if value="$entry? and $entry.$Timestamp?">
                    <set_value name="$entryAge" exact="player.age - $entry.$Timestamp"/>
                    <do_if value="$entryAge gt $cacheMaxAge">
                      <remove_value name="global.$GT_TradeCache.{$cacheHomeSector}.{$i}"/>
                      <set_value name="$deletedCount" operation="add"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$deletedCount gt 0 and global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Cache cleanup: Deleted ' + $deletedCount + ' entries older than 15 minutes'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- 6. Select best trade (for backward compatibility) -->
        <!-- Re-validate distance from home sector AND verify trade exists in final diverseList -->
        <!-- Prevents using stale trades that were filtered out by blacklist/path checks -->
        <set_value name="$bestTrade" exact="null"/>
        <set_value name="$bestScore" exact="0"/>
        
        <!-- Validate nonConflictedBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedNonConflictedTrade" exact="null"/>
        <do_if value="$nonConflictedBestTrade? and $nonConflictedBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$nonConflictedBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$nonConflictedBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $nonConflictedBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $nonConflictedBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $nonConflictedBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedNonConflictedTrade" exact="$nonConflictedBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Validate crossStationBestTrade: Both stations must be within maxDistance from home sector AND exist in diverseList -->
        <set_value name="$validatedCrossStationTrade" exact="null"/>
        <do_if value="$crossStationBestTrade? and $crossStationBestScore gt 0">
          <set_value name="$tradeBuySector" exact="@$crossStationBestTrade.$BuyStation.sector"/>
          <set_value name="$tradeSellSector" exact="@$crossStationBestTrade.$SellStation.sector"/>
          <set_value name="$tradeBuyDistance" exact="-1"/>
          <set_value name="$tradeSellDistance" exact="-1"/>
          
          <do_if value="$tradeBuySector == $homeSector">
            <set_value name="$tradeBuyDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeBuyDistance" exact="$homeSector.gatedistance.{$tradeBuySector}"/>
          </do_else>
          
          <do_if value="$tradeSellSector == $homeSector">
            <set_value name="$tradeSellDistance" exact="0"/>
          </do_if>
          <do_else>
            <set_value name="$tradeSellDistance" exact="$homeSector.gatedistance.{$tradeSellSector}"/>
          </do_else>
          
          <!-- CRITICAL: Check if trade exists in final diverseList (wasn't filtered out) -->
          <set_value name="$tradeExistsInDiverseList" exact="false"/>
          <do_if value="$tradeBuyDistance ge 0 and $tradeSellDistance ge 0 and $tradeBuyDistance le $maxDistance and $tradeSellDistance le $maxDistance">
            <!-- Verify trade wasn't filtered out - check if it exists in diverseList by comparing stations and ware -->
            <do_all exact="$diverseList.count" counter="$i">
              <set_value name="$diverseTrade" exact="$diverseList.{$i}"/>
              <do_if value="$diverseTrade.$BuyStation == $crossStationBestTrade.$BuyStation and 
                             $diverseTrade.$SellStation == $crossStationBestTrade.$SellStation and
                             $diverseTrade.$BuyOffer.ware == $crossStationBestTrade.$BuyOffer.ware">
                <set_value name="$tradeExistsInDiverseList" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            
            <!-- Only use if both distance valid AND trade exists in final filtered list -->
            <do_if value="$tradeExistsInDiverseList">
              <set_value name="$validatedCrossStationTrade" exact="$crossStationBestTrade"/>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="$validatedNonConflictedTrade? and $nonConflictedBestScore gt 0">
          <!-- Prefer non-conflicted from filtered list (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedNonConflictedTrade"/>
          <set_value name="$bestScore" exact="$nonConflictedBestScore"/>
        </do_if>
        <do_elseif value="$validatedCrossStationTrade? and $crossStationBestScore gt 0">
          <!-- Use cross-station trade (only if Score > 0, validated, AND exists in diverseList) -->
          <set_value name="$bestTrade" exact="$validatedCrossStationTrade"/>
          <set_value name="$bestScore" exact="$crossStationBestScore"/>
        </do_elseif>
        <do_else>
          <!-- Fallback: Find best from diverse list -->
          <!-- FIX: Use library function for consistent validation -->
          <do_all exact="$diverseList.count" counter="$i">
            <set_value name="$trade" exact="$diverseList.{$i}"/>
            <run_actions ref="md.GT_Libraries_General.GT_IsTradeValid" result="$isValid">
              <param name="trade" value="$trade"/>
              <param name="minScore" value="$bestScore"/>
            </run_actions>
            <do_if value="$isValid">
              <set_value name="$testScore" exact="@$trade.$Score"/>
              <set_value name="$bestScore" exact="$testScore"/>
              <set_value name="$bestTrade" exact="$trade"/>
            </do_if>
          </do_all>
          <!-- CRITICAL: If bestScore is still 0, all trades have Score = 0 (don't meet profit thresholds) -->
          <!-- Set bestTrade to null so "no trade found" path executes -->
          <do_if value="$bestScore le 0">
            <set_value name="$bestTrade" exact="null"/>
          </do_if>
        </do_else>
        
        <!-- 7. Extract original parameters BEFORE cleanup (so they're available when signaling) -->
        <!-- For fallback searches (maxDistance == 2), ALWAYS use batch data (has relaxed values) -->
        <!-- For normal searches, use queue params if available, otherwise fall back to batch data -->
        <set_value name="$originalParams" exact="null"/>
        <set_value name="$batchData" exact="@global.$GT_BatchDataList.{$ship}"/>
        <set_value name="$isFallbackFromBatch" exact="false"/>
        <!-- Proper null check for batchData and its properties -->
        <set_value name="$batchDataMaxDistance" exact="@$batchData.$maxDistance"/>
        <set_value name="$batchDataOriginalMaxDistance" exact="@$batchData.$originalMaxDistance"/>
        <!-- Detect fallback search: OriginalMaxDistance exists and differs from MaxDistance -->
        <set_value name="$isFallbackSearchFromBatch" exact="false"/>
        <do_if value="$batchData? and $batchDataMaxDistance? and $batchDataOriginalMaxDistance? and $batchDataOriginalMaxDistance != $batchDataMaxDistance">
          <set_value name="$isFallbackSearchFromBatch" exact="true"/>
        </do_if>
        <do_if value="$batchData? and $batchDataMaxDistance? and $isFallbackSearchFromBatch">
          <!-- This is a fallback search - batch data has relaxed profit thresholds, use those instead of queue -->
          <set_value name="$isFallbackFromBatch" exact="true"/>
          <set_value name="$allowIllegalDefault" exact="false"/>
          <set_value name="$originalParams" exact="table[
            $Ship = $ship,
            $MaxDistance = @$batchData.$maxDistance,
            $OriginalMaxDistance = $batchDataOriginalMaxDistance,
            $MinROI = @$batchData.$minROI,
            $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
            $FactionPriority = @$batchData.$factionPriority,
            $AllowIllegal = $allowIllegalDefault
          ]"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Using batch data params for fallback search (relaxed profit: ' + (@$batchData.$minAbsoluteProfit / 100) + ' Cr, OriginalMaxDistance: ' + $batchDataOriginalMaxDistance + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Normal search - try queue params first (cache queue), then live queue params, then batch data -->
          <do_if value="global.$GT_SearchQueue.$Params? and global.$GT_SearchQueue.$Params.{$ship}?">
            <!-- Parameters are stored in search queue when search was initiated -->
            <set_value name="$originalParams" exact="global.$GT_SearchQueue.$Params.{$ship}"/>
            <!-- Ensure OriginalMaxDistance is included if it exists in queue params -->
            <do_if value="not $originalParams.$OriginalMaxDistance? and $batchDataOriginalMaxDistance?">
              <set_value name="$originalParams.$OriginalMaxDistance" exact="$batchDataOriginalMaxDistance"/>
            </do_if>
          </do_if>
          <do_elseif value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$Params? and global.$GT_LiveSearchQueue.$Params.{$ship}?">
            <set_value name="$originalParams" exact="global.$GT_LiveSearchQueue.$Params.{$ship}"/>
            <do_if value="not $originalParams.$OriginalMaxDistance? and $batchDataOriginalMaxDistance?">
              <set_value name="$originalParams.$OriginalMaxDistance" exact="$batchDataOriginalMaxDistance"/>
            </do_if>
          </do_elseif>
          <do_else>
            <!-- Fallback: Reconstruct parameters from batch data (before cleanup) -->
            <do_if value="$batchData?">
              <set_value name="$allowIllegalDefault" exact="false"/>
              <set_value name="$originalParams" exact="table[
                $Ship = $ship,
                $MaxDistance = @$batchData.$maxDistance,
                $OriginalMaxDistance = $batchDataOriginalMaxDistance,
                $MinROI = @$batchData.$minROI,
                $MinAbsoluteProfit = @$batchData.$minAbsoluteProfit,
                $FactionPriority = @$batchData.$factionPriority,
                $AllowIllegal = $allowIllegalDefault,
                $FromLiveQueue = false,
                $LiveSlotAcquired = false,
                $UseSearchQueueCounter = false
              ]"/>
            </do_if>
          </do_else>
        </do_else>
        
        <!-- 8. Return results (including rejection statistics for diagnostics) -->
        <!-- Store trade count before storing in global (for accurate logging) -->
        <set_value name="$finalTradeCount" exact="$diverseList.count"/>
        <set_value name="$waitingFlag" exact="false"/>
        <!-- Combine blacklist and path blocked (both are safety restrictions) -->
        <set_value name="$totalBlacklistAndPath" exact="$filteredByBlacklist + $filteredByPathBlocked"/>
        <!-- Calculate total trades evaluated (valid + filtered) for accurate reporting -->
        <set_value name="$totalTradesEvaluated" exact="$finalTradeCount + $totalBlacklistAndPath + $filteredByIllegal + $filteredByWareBasket"/>
        
        <!-- Preserve LastRejectionStats when updating global.$GT_SearchResult -->
        <!-- FilterTradeList_Resume overwrites global.$GT_SearchResult, which would lose LastRejectionStats -->
        <set_value name="$preservedLastRejectionStats" exact="null"/>
        <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
          <set_value name="$preservedLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
        </do_if>
        
        <set_value name="global.$GT_SearchResult.{$ship}" exact="table[
          $Found = ($finalTradeCount gt 0),
          $BestTrade = $bestTrade,
          $BestScore = $bestScore,
          $TradeList = $diverseList,
          $TradesRejectedProfit = $tradesRejectedProfit,
          $TradesRejectedDocking = $tradesRejectedDocking,
          $TradesRejectedAmount = $tradesRejectedAmount,
          $TradesRejectedDistance = $tradesRejectedDistance,
          $TradesRejectedBlacklist = $totalBlacklistAndPath,
          $BestRejectedTrade = $bestRejectedTrade,
          $WaitingForBatch = $waitingFlag,
          $Ship = $ship,
          $FilteredByBlacklist = $filteredByBlacklist,
          $FilteredByPathBlocked = $filteredByPathBlocked,
          $TotalTradesEvaluated = $totalTradesEvaluated
        ]"/>
        
        <!-- Restore LastRejectionStats after updating global.$GT_SearchResult -->
        <do_if value="$preservedLastRejectionStats?">
          <set_value name="global.$GT_SearchResult.$LastRejectionStats" exact="$preservedLastRejectionStats"/>
        </do_if>
        
        <!-- 9. Cleanup batch data (using ship object as key) -->
        <remove_value name="global.$GT_BatchDataList.{$ship}"/>
        <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Complete. Returning ' + $diverseList.count + ' diverse trades. Best score: ' + $bestScore" chance="100"/>
        </do_if>
        
        <!-- 10. Signal SearchTradeRoutes again with original parameters so it can read the live search results -->
        <!-- IMPORTANT: In MD, $var? can be true even if $var == null. Also guard against stale continuation (no search lock). -->
        <set_value name="$canSignalContinuation" exact="false"/>
        <set_value name="$hasSearchLock" exact="false"/>
        <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
          <set_value name="$hasSearchLock" exact="true"/>
        </do_if>
        <do_if value="$hasSearchLock and $originalParams? and $originalParams != null">
          <do_if value="$originalParams.$MaxDistance? and $originalParams.$MaxDistance != null">
            <set_value name="$canSignalContinuation" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="$canSignalContinuation">
          <!-- Set explicit SearchState based on whether this is a fallback search -->
          <set_value name="$searchState" exact="'live'"/>
          <do_if value="$isFallbackSearchFromBatch">
            <set_value name="$searchState" exact="'fallback'"/>
          </do_if>
          <set_value name="$originalParams.$SearchState" exact="$searchState"/>
          <!-- Route through central scheduler to avoid same-frame bursts -->
          <signal_cue_instantly cue="md.GT_Trading_Queue.EnqueueSearchTradeRoutes" param="$originalParams"/>
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Signaled SearchTradeRoutes to continue with live search results (' + $finalTradeCount + ' trades, state=' + $searchState + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Could not (or should not) signal continuation.
               Common causes:
               - stale delayed resume (no search lock anymore)
               - missing/invalid MaxDistance in params table -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
            <debug_text text="'[GT-Resume] (' + $ship.idcode + ') Not signaling SearchTradeRoutes continuation (hasLock=' + $hasSearchLock + ', params=' + (if $originalParams? then 'exists' else 'missing') + ', maxDist=' + (if $originalParams? and $originalParams != null and $originalParams.$MaxDistance? then $originalParams.$MaxDistance else 'null') + ') - results stored in global.$GT_SearchResult'" chance="100"/>
          </do_if>
        </do_else>
        <!-- Close filterStateValid do_else guard -->
        </do_else>
      </actions>
    </cue>
    
    <!-- Search for Sell Opportunities -->
    <cue name="SearchSellOpportunities" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <!-- Receive parameters directly -->
        <set_value name="$params" exact="event.param"/>
        <set_value name="$ship" exact="$params.$Ship"/>
        <set_value name="$maxDistance" exact="$params.$MaxDistance"/>
        <set_value name="$minProfit" exact="$params.$MinProfit"/>
        
        <!-- DEBUG: Sell search start -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GalaxyTrader MK3 DEBUG] (' + $ship.idcode + ') === SELL SEARCH START ===' + '\nShip: ' + $ship.knownname + '\nCurrent Sector: ' + $ship.sector.knownname + '\nMax Distance: ' + $maxDistance + ' jumps' + '\nMin Profit: ' + $minProfit + ' Cr'" chance="100"/>
        </do_if>
        
        <!-- Determine home sector for sell search (needed for sector list building) -->
        <run_actions ref="md.GT_Libraries_General.GT_GetHomeSector" result="$homeSector">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Determine blacklistgroup (needed for sector list building) -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Build sell sectors list (per-sector queries like vanilla) -->
        <!-- FIX: Query per-sector instead of galaxy-wide to work without initialized market data -->
        <!-- Vanilla pattern: query stations in specific sectors, not galaxy-wide -->
        <set_value name="$sellspaces" exact="[]"/>
        <run_actions ref="md.GT_Libraries_Pathfinding.GT_FindSectorsInRange" result="$sellspaces">
          <param name="refobject" value="$homeSector"/>
          <param name="mingatedistance" value="0"/>
          <param name="maxgatedistance" value="$maxDistance"/>
          <param name="applyblacklist" value="true"/>
          <param name="blacklistgroup" value="$blacklistgroup"/>
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Sell] (' + $ship.idcode + ') Found ' + $sellspaces.count + ' sell sectors within ' + $maxDistance + ' jumps from home sector'" chance="100"/>
        </do_if>
        
        <!-- Find best sell location for current cargo -->
        <set_value name="$bestOffer" exact="null"/>
        <set_value name="$bestPrice" exact="0"/>
        <set_value name="$bestAmount" exact="0"/>
        
        <!-- Get ship's current cargo -->
        <set_value name="$currentCargo" exact="$ship.cargo.list"/>
        
        <do_if value="$currentCargo.count gt 0">
          <!-- Rotate through cargo entries to avoid getting stuck on unsellable wares -->
          <!-- Track last attempted ware index to rotate through cargo list -->
          <!-- If one ware can't be sold (banned, blacklisted, mission-tied), next request tries next ware -->
          <set_value name="$selectedIndex" exact="1"/>
          <do_if value="global.$GT_ForcedSellLastWare? and global.$GT_ForcedSellLastWare.{$ship}?">
            <!-- Get last attempted ware index -->
            <set_value name="$lastWareIndex" exact="global.$GT_ForcedSellLastWare.{$ship}"/>
            <!-- Rotate to next ware (wrap around if needed) -->
            <!-- Use % operator for modulo (X4 MD syntax) -->
            <set_value name="$selectedIndex" exact="(($lastWareIndex % $currentCargo.count) + 1)"/>
          </do_if>
          
          <!-- Select ware at rotated index -->
          <set_value name="$selectedWare" exact="$currentCargo.{$selectedIndex}"/>
          <set_value name="$selectedAmount" exact="$ship.cargo.{$selectedWare}.count"/>
          
          <!-- Store attempted ware index for next rotation -->
          <do_if value="not global.$GT_ForcedSellLastWare?">
            <set_value name="global.$GT_ForcedSellLastWare" exact="table[]"/>
          </do_if>
          <set_value name="global.$GT_ForcedSellLastWare.{$ship}" exact="$selectedIndex"/>
          
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Cargo contains ' + $currentCargo.count + ' ware types, attempting to sell ware ' + $selectedIndex + '/' + $currentCargo.count + ': ' + @$selectedWare.name + ' x' + $selectedAmount + ' (rotating through cargo to avoid stuck on unsellable wares)'" chance="100"/>
          </do_if>
          
          <!-- FIX: Query per-sector instead of galaxy-wide (like vanilla) -->
          <!-- This allows ships to find trades even without initialized market data (satellites) -->
          <!-- Vanilla pattern: iterate through sectors and query stations in each sector -->
          <set_value name="$buyOffers" exact="[]"/>
          <do_all exact="$sellspaces.count" counter="$i">
            <set_value name="$sector" exact="$sellspaces.{$i}"/>
            <do_if value="not $sector? or not $sector.exists">
              <continue/>
            </do_if>
            
            <!-- Initialize per-sector offer list -->
            <set_value name="$sectorBuyOffers" exact="[]"/>
            
            <!-- Query buy offers in this sector (ship sells to stations' buy offers) -->
            <find_buy_offer tradepartner="$ship" space="$sector" result="$sectorBuyOffers" multiple="true" wares="$selectedWare">
              <match_buyer tradesknownto="$ship.owner">
                <match_relation_to object="$ship" relation="dock" comparison="ge"/>
                <match_relation_to faction="$ship.owner" relation="enemy" comparison="not"/>
              </match_buyer>
              <amount min="1"/>
              <totalvolume min="1"/>
            </find_buy_offer>
            
            <!-- Append sector's offers to main list -->
            <set_value name="$sectorBuyOffersCount" exact="0"/>
            <do_if value="$sectorBuyOffers?">
              <set_value name="$sectorBuyOffersCountTemp" exact="@$sectorBuyOffers.count"/>
              <do_if value="$sectorBuyOffersCountTemp?">
                <set_value name="$sectorBuyOffersCount" exact="$sectorBuyOffersCountTemp"/>
              </do_if>
            </do_if>
            <do_all exact="$sectorBuyOffersCount" counter="$j">
              <append_to_list name="$buyOffers" exact="$sectorBuyOffers.{$j}"/>
            </do_all>
          </do_all>
          
          <!-- Debug: Log if no offers found -->
          <do_if value="$buyOffers.count == 0">
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Sell] ' + $ship.idcode + ': No buy offers found for ' + @$selectedWare.name + ' (ship cargo: ' + $selectedAmount + ' units) after querying ' + $sellspaces.count + ' sectors'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Find best price -->
          <do_all exact="$buyOffers.count" counter="$j">
            <set_value name="$offer" exact="$buyOffers.{$j}"/>
            
            <!-- Validate offer is still valid (station may have been destroyed/removed) -->
            <set_value name="$station" exact="@$offer.owner"/>
            <set_value name="$offerValid" exact="false"/>
            <do_if value="@$station.exists">
              <set_value name="$currentSector" exact="$ship.sector"/>
              <set_value name="$stationSector" exact="@$station.sector"/>
              
              <!-- Validate station sector is valid -->
              <do_if value="@$stationSector.exists">
                <set_value name="$offerValid" exact="true"/>
              </do_if>
            </do_if>
            
            <!-- Only process valid offers -->
            <do_if value="$offerValid">
              <!-- tradepartner="$ship" in find_buy_offer already filters by faction relations -->
              <!-- No explicit check needed - C++ engine handles it -->
              
              <!-- Check blacklists before considering offer -->
              <set_value name="$isBlacklisted" exact="false"/>
            
            <!-- Block intra-sector sales in blacklisted sectors (force escape) -->
            <!-- If ship is in blacklisted sector and trying to sell to station in same sector, block -->
            <do_if value="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
              <do_if value="$stationSector == $currentSector">
                <!-- Intra-sector sale in blacklisted sector - BLOCK to force escape -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (intra-sector sale in blacklisted sector - must escape)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check station blacklist (object activity) -->
            <do_if value="not $isBlacklisted and @$station.isblacklisted.{blacklisttype.objectactivity}.{$blacklistgroup}.{$ship}">
              <set_value name="$isBlacklisted" exact="true"/>
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (station blacklisted)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (sector activity) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector activity blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check sector blacklist (travel) - only if station is in different sector -->
            <do_if value="not $isBlacklisted and $stationSector != $currentSector">
              <do_if value="@$stationSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{$ship}">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (sector travel blacklisted)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check if path to station goes through blacklisted sectors -->
            <!-- Uses blacklist-aware gatedistance - returns -1 if path blocked by blacklisted sector -->
            <!-- Vanilla pattern: order.dock.xml:503 -->
            <do_if value="not $isBlacklisted">
              <set_value name="$pathDistance" exact="$ship.gatedistance.{$stationSector}.{$blacklistgroup}.{$ship}"/>
              
              <do_if value="$pathDistance lt 0">
                <!-- Path goes through blacklisted sector or no path exists -->
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                  <!-- <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (path goes through blacklisted sector)'" chance="100"/> -->
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check carrier/aux exclusion (for stations only) -->
            <do_if value="not $isBlacklisted">
              <set_value name="$ignoreCarrierAux" exact="false"/>
              <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux?">
                <set_value name="$ignoreCarrierAux" exact="global.$GT_AIParameters.{$ship}.$IgnoreCarrierAux"/>
              </do_if>
              
              <do_if value="$ignoreCarrierAux and $station.isclass.station">
                <set_value name="$stationPrimaryPurpose" exact="@$station.primarypurpose"/>
                <do_if value="$stationPrimaryPurpose == purpose.auxiliary or $stationPrimaryPurpose == purpose.fight">
                  <set_value name="$isBlacklisted" exact="true"/>
                  <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (carrier/aux excluded)'" chance="100"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check build storage exclusion -->
            <do_if value="not $isBlacklisted">
              <set_value name="$ignoreBuildStorage" exact="false"/>
              <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage?">
                <set_value name="$ignoreBuildStorage" exact="global.$GT_AIParameters.{$ship}.$IgnoreBuildStorage"/>
              </do_if>
              
              <do_if value="$ignoreBuildStorage and $station.isclass.buildstorage">
                <set_value name="$isBlacklisted" exact="true"/>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (build storage excluded)'" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Check operational status -->
            <set_value name="$isOperational" exact="$station.isoperational and not @$station.isclosingdown"/>
            <do_if value="not $isBlacklisted and not $isOperational">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (not operational)'" chance="100"/>
              </do_if>
            </do_if>
            
            <!-- Check technical docking capability - does station have docking bay for this ship size? -->
            <set_value name="$canDock" exact="false"/>
            <do_if value="not $isBlacklisted and $isOperational">
              <find_dockingbay name="$testDock" object="$station" checkoperational="true" multiple="false">
                <match_dock size="$ship.docksize" storage="false"/>
              </find_dockingbay>
              <do_if value="$testDock">
                <!-- Station has docking bay for this ship size - check docking permission -->
                <set_value name="$canDock" exact="$station.dockingallowed.{$ship}"/>
              </do_if>
              <do_else>
                <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (no docking bay for ship size ' + $ship.docksize + ')'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            
            <!-- Check docking permission -->
            <do_if value="not $isBlacklisted and $isOperational and not $canDock">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Rejected ' + @$station.knownname + ' (docking not allowed)'" chance="100"/>
              </do_if>
            </do_if>
            
              <!-- Only consider valid, non-blacklisted, operational, dockable offers -->
              <do_if value="not $isBlacklisted and $isOperational and $canDock and $offer.available">
                <set_value name="$tradeAmount" exact="[$selectedAmount, $offer.amount].min"/>
                
                <!-- CRITICAL: Skip if trade amount is zero or negative (ship has no cargo or offer has no amount) -->
                <do_if value="$tradeAmount gt 0">
                  <set_value name="$profit" exact="$offer.unitprice * $tradeAmount"/>
                  
                  <do_if value="$profit gt $bestPrice">
                    <set_value name="$bestOffer" exact="$offer"/>
                    <set_value name="$bestPrice" exact="$profit"/>
                    <set_value name="$bestAmount" exact="$tradeAmount"/>
                    
                    <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer now: ' + @$station.knownname + ' - ' + $offer.ware.name + ' x' + $tradeAmount + ' @ ' + $offer.unitprice + ' Cr/unit (profit: ' + $profit + ' Cr)'" chance="100"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            <!-- End of $offerValid check -->
          </do_all>
          
          <!-- Execute best sell if found - use normal pipeline (store in GT_PendingTrades, let AI create orders) -->
          <!-- For cargo disposal, accept even zero profit (ship must clear cargo) - use ge instead of gt to allow zero -->
          <do_if value="$bestOffer and $bestPrice ge $minProfit">
            <!-- Validate offer is STILL valid before proceeding -->
            <!-- Offers can become invalid between search and order creation -->
            <set_value name="$offerStillValid" exact="$bestOffer.available and $bestOffer.amount gt 0"/>
            
            <do_if value="$offerStillValid">
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GalaxyTrader MK3] ' + $ship.knownname + ' found sell opportunity'" chance="100"/>
              </do_if>
              
              <!-- Create trade structure compatible with normal pipeline -->
              <!-- For forced sell: ship already has cargo, so we create a sell-only trade structure -->
              <!-- BuyStation = null for sell-only trades (ship already has cargo, no buy station needed) -->
              <!-- Setting BuyStation to ship causes docking checks on ship object which fails -->
              <!-- SellStation = target station buying the cargo -->
              <set_value name="$sellStation" exact="$bestOffer.owner"/>
              
              <!-- Create trade structure matching normal pipeline format -->
              <!-- For sell-only trades, BuyOffer and BuyStation are null (ship already has cargo) -->
              <!-- ExecuteTrade will handle this via $IsSellOnly flag -->
              <set_value name="$sellTrade" exact="table[
                $BuyStation = null,
                $SellStation = $sellStation,
                $Ware = $selectedWare,
                $BuyOffer = null,
                $SellOffer = $bestOffer,
                $Amount = $bestAmount,
                $BuyPrice = 0,
                $SellPrice = $bestOffer.unitprice,
                $Profit = $bestPrice,
                $ROI = 0,
                $Score = $bestPrice,
                $Distance = 0,
                $IsSellOnly = true
              ]"/>
              
              <!-- Store in GT_PendingTrades and send to execution pipeline -->
              <!-- This ensures failure tracking, telemetry, and proper order creation by AI -->
              <signal_cue_instantly cue="md.GT_Trading_Execution.ExecuteTrade" param="table[
                $Ship = $ship,
                $Trade = $sellTrade,
                $TradeList = [$sellTrade],
                $SearchMethod = 'forced_sell'
              ]"/>
              
              <!-- Note: GT_Trade_Found signal now sent FROM ExecuteTrade after storing pending trade -->
            </do_if>
            <do_else>
              <!-- Offer became invalid - don't create order -->
              <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-Sell] ' + $ship.idcode + ': Best offer became invalid before order creation - retrying'" chance="100"/>
              </do_if>
              
              <!-- Signal back to AI script: No Trade Found (will retry) -->
              <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Signal back to AI script: No Trade Found -->
            <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
          </do_else>
        </do_if>
        <do_else>
          <!-- Signal back to AI script: No Trade Found (no cargo) -->
          <signal_objects object="$ship" param="'GT_No_Trade_Found'"/>
        </do_else>
        
        <!-- Release lock and parameters using Request Registry -->
        <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
          <param name="ship" value="$ship"/>
          <param name="reason" value="'search_aborted'"/>
        </run_actions>
      </actions>
    </cue>
  </cues>
</mdscript>
