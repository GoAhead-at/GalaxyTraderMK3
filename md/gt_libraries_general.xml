<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GT_Libraries_General" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/md.xsd">
  <cues>
    <!-- ========================================= -->
    <!-- GENERAL UTILITIES -->
    <!-- Consolidated from: gt_trade_utilities.xml, gt_data_utilities.xml, gt_utilities.xml, gt_ai_script_utilities.xml, gt_logbook_utilities.xml -->
    <!-- ========================================= -->
    <!-- ========================================= -->
    <!-- TRADE UTILITIES -->
    <!-- ========================================= -->
    
    <!-- Is Intra-Sector Trade -->
    <library name="GT_IsIntraSectorTrade" purpose="run_actions">
      <params>
        <param name="buySector" comment="Buy station sector"/>
        <param name="sellSector" comment="Sell station sector"/>
        <param name="currentSector" comment="Ship's current sector"/>
      </params>
      <actions>
        <do_if value="$buySector? and $sellSector? and $currentSector?">
          <do_if value="$buySector == $currentSector and $sellSector == $currentSector">
            <return value="true"/>
          </do_if>
        </do_if>
        <return value="false"/>
      </actions>
    </library>
    
    <!-- Calculate Trade Efficiency -->
    <library name="GT_CalculateTradeEfficiency" purpose="run_actions">
      <params>
        <param name="profit" comment="Trade profit"/>
        <param name="distance" default="0" comment="Trade distance (jumps) - legacy parameter, used as fallback"/>
        <param name="distancePenaltyMultiplier" default="1.0" comment="Distance penalty multiplier (0.0-2.0)"/>
        <param name="factionPriority" default="2" comment="Faction priority (0=Player, 1=Foreign, 2=Equal)"/>
        <param name="buyStationOwner" default="null" comment="Buy station owner faction"/>
        <param name="sellStationOwner" default="null" comment="Sell station owner faction"/>
        <param name="homeSector" default="null" comment="Home sector for path efficiency calculation"/>
        <param name="shipSector" default="null" comment="Ship's current sector"/>
        <param name="buySector" default="null" comment="Buy station sector"/>
        <param name="sellSector" default="null" comment="Sell station sector"/>
        <param name="shipToBuyDistance" default="-1" comment="Distance from ship to buy station (for path efficiency)"/>
        <param name="buyToSellDistance" default="-1" comment="Distance from buy station to sell station"/>
        <param name="homeToBuyDistance" default="-1" comment="Distance from home sector to buy station"/>
        <param name="homeToSellDistance" default="-1" comment="Distance from home sector to sell station"/>
      </params>
      <actions>
        <!-- Multi-factor distance penalty system -->
        <!-- Improved scoring that separately penalizes:
             1. Ship Buy distance (HEAVY weight - ship must travel first)
             2. Buy Sell distance (MODERATE weight - trade route length)
             3. Home distance (LIGHT weight - territorial control)
        -->
        <set_value name="$adjustedDistance" exact="0.0"/>
        
        <!-- Check if we have all required parameters for new multi-factor system -->
        <set_value name="$useMultiFactor" exact="false"/>
        <do_if value="$shipToBuyDistance ge 0 and $buyToSellDistance ge 0 and $homeToBuyDistance ge 0 and $homeToSellDistance ge 0 and $buySector? and $sellSector?">
          <set_value name="$useMultiFactor" exact="true"/>
        </do_if>
        
        <!-- Log which system is being used -->
        <!-- NOTE: This library is called in hot loops (cache scoring). Guard verbose logging behind DiagnosticQueries to avoid CPU/log spikes. -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_Config.$Debug.$DiagnosticQueries and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Efficiency] Multi-factor=' + $useMultiFactor + ', Ship Buy=' + $shipToBuyDistance + ', Buy Sell=' + $buyToSellDistance + ', Home Buy=' + $homeToBuyDistance + ', Home Sell=' + $homeToSellDistance" chance="100"/>
        </do_if>
        
        <do_if value="$useMultiFactor">
          <!-- Factor 1: Ship to Buy Distance Penalty (HEAVY WEIGHT - ship must travel first) -->
          <!-- This is the most important - ship has to get to buy station first -->
          <!-- Weight: 4.0 (increased from 3.0), Quadratic base: 3.5 (steeper penalty for longer distances) -->
          <!-- Example: 7 jumps = 7 * 4 * (1 + 4) = 140 penalty units (with multiplier=2: 280 units) -->
          <!-- Apply user's distance penalty multiplier setting -->
          <set_value name="$shipToBuyBase" exact="3.5"/>
          <set_value name="$shipToBuyRatio" exact="$shipToBuyDistance / $shipToBuyBase"/>
          <set_value name="$shipToBuyNonLinear" exact="1.0 + ($shipToBuyRatio * $shipToBuyRatio)"/>
          <set_value name="$shipToBuyPenalty" exact="$shipToBuyDistance * 4.0 * $shipToBuyNonLinear * $distancePenaltyMultiplier"/>
          
          <!-- Factor 2: Buy to Sell Distance Penalty (MODERATE WEIGHT - trade route length) -->
          <!-- Encourages shorter trade routes between stations -->
          <!-- Weight: 1.5, Quadratic base: 8.0 (moderate penalty) -->
          <!-- Apply user's distance penalty multiplier setting -->
          <set_value name="$buyToSellBase" exact="8.0"/>
          <set_value name="$buyToSellRatio" exact="$buyToSellDistance / $buyToSellBase"/>
          <set_value name="$buyToSellNonLinear" exact="1.0 + ($buyToSellRatio * $buyToSellRatio)"/>
          <set_value name="$buyToSellPenalty" exact="$buyToSellDistance * 1.5 * $buyToSellNonLinear * $distancePenaltyMultiplier"/>
          
          <!-- Factor 3: Home Distance Penalty (LIGHT WEIGHT - territorial control) -->
          <!-- Penalize trades far from home (both stations) - encourages staying near home base -->
          <!-- Weight: 0.5, Quadratic base: 10.0 (light penalty) -->
          <!-- Apply user's distance penalty multiplier setting -->
          <set_value name="$maxHomeDistance" exact="[$homeToBuyDistance, $homeToSellDistance].max"/>
          <set_value name="$homeDistanceBase" exact="10.0"/>
          <set_value name="$homeDistanceRatio" exact="$maxHomeDistance / $homeDistanceBase"/>
          <set_value name="$homeDistanceNonLinear" exact="1.0 + ($homeDistanceRatio * $homeDistanceRatio)"/>
          <set_value name="$homeDistancePenalty" exact="$maxHomeDistance * 0.5 * $homeDistanceNonLinear * $distancePenaltyMultiplier"/>
          
          <!-- Combined Adjusted Distance -->
          <set_value name="$adjustedDistance" exact="$shipToBuyPenalty + $buyToSellPenalty + $homeDistancePenalty"/>
          
          <!-- Log penalty breakdown -->
          <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_Config.$Debug.$DiagnosticQueries and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-Efficiency] Multi-factor penalties (multiplier=' + $distancePenaltyMultiplier + '): Ship Buy=' + $shipToBuyPenalty + ', Buy Sell=' + $buyToSellPenalty + ', Home=' + $homeDistancePenalty + ', Total=' + $adjustedDistance" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Legacy single-factor distance penalty (for batch processor, etc.) -->
          <!-- Formula: adjustedDistance = distance * multiplier * (1 + (distance / 10)^2) -->
          <!-- This creates quadratic penalty: longer distances get exponentially more penalized -->
          <!-- Examples with multiplier=2.0:
               - Distance 1:  1 * 2 * (1 + 0.01) = 2.02   (minimal penalty)
               - Distance 5:  5 * 2 * (1 + 0.25) = 12.5   (25% extra)
               - Distance 10: 10 * 2 * (1 + 1)   = 40     (100% extra = 2x)
               - Distance 20: 20 * 2 * (1 + 4)   = 200    (400% extra = 5x)
          -->
          <set_value name="$distanceBase" exact="10.0"/>
          <set_value name="$distanceRatio" exact="$distance / $distanceBase"/>
          <set_value name="$nonLinearFactor" exact="1.0 + ($distanceRatio * $distanceRatio)"/>
          <set_value name="$adjustedDistance" exact="$distance * $distancePenaltyMultiplier * $nonLinearFactor"/>
        </do_else>
        
        <!-- Convert money to number before division to avoid "Loss of data while converting floating point" error -->
        <!-- Convert profit (money in cents) to numeric value using f suffix to force float conversion -->
        <!-- Pattern from order.trade.perform.xml:243: (money / 1Cr)f forces float conversion -->
        <!-- Apply non-linear profit scaling to reduce profit dominance in scoring -->
        <!-- Formula: profitNum_scaled = profitNum / (1.0 + profitNum / profitBase) -->
        <!-- This creates diminishing returns: higher profits get scaled down more -->
        <!-- Examples:
             - Profit 10,000 Cr   profitNum = 1,000,000   scaled = 1,000,000 / (1 + 1) = 500,000 (50% reduction)
             - Profit 20,000 Cr   profitNum = 2,000,000   scaled = 2,000,000 / (1 + 2) = 666,667 (67% reduction)
             - Profit 260,090 Cr   profitNum = 26,009,000   scaled = 26,009,000 / (1 + 26) = 962,556 (96% reduction)
        -->
        <!-- This means: 2x profit   ~1.33x score (instead of 2x), significantly reducing profit's overwhelming influence -->
        <set_value name="$efficiency" exact="0.0"/>
        <do_if value="$adjustedDistance gt 0">
          <!-- Convert profit from money (cents) to number by dividing by 1ct, then scale by 100 -->
          <!-- Use f suffix to force float conversion (pattern from order.trade.perform.xml:243) -->
          <set_value name="$profitNum" exact="(($profit / 1ct) * 100)f"/>
          
          <!-- Apply diminishing returns to reduce profit dominance -->
          <!-- profitBase controls where scaling kicks in - lower = more aggressive scaling -->
          <!-- Formula: profitNum_scaled = profitNum / (1.0 + profitNum / profitBase) -->
          <set_value name="$profitBase" exact="1000000.0"/>
          <set_value name="$profitRatio" exact="$profitNum / $profitBase"/>
          <set_value name="$profitScalingFactor" exact="1.0 + $profitRatio"/>
          <set_value name="$profitNumScaled" exact="$profitNum / $profitScalingFactor"/>
          
          <!-- Scale adjustedDistance by 10000 for precision -->
          <set_value name="$scaledDistance" exact="$adjustedDistance * 10000.0"/>
          <!-- Division: number / number = number (efficiency scaled by 10000) -->
          <!-- Note: Efficiency is now scaled by 10000, but all comparisons/scoring work correctly with scaled values -->
          <set_value name="$efficiency" exact="$profitNumScaled / $scaledDistance"/>
        </do_if>
        <do_else>
          <!-- If distance is 0, efficiency equals profit (converted to number) with same scaling -->
          <set_value name="$profitNum" exact="(($profit / 1ct) * 100)f"/>
          <set_value name="$profitBase" exact="1000000.0"/>
          <set_value name="$profitRatio" exact="$profitNum / $profitBase"/>
          <set_value name="$profitScalingFactor" exact="1.0 + $profitRatio"/>
          <set_value name="$profitNumScaled" exact="$profitNum / $profitScalingFactor"/>
          <set_value name="$efficiency" exact="$profitNumScaled"/>
        </do_else>
        
        <!-- Apply faction priority boost -->
        <do_if value="$factionPriority == 0 and ($buyStationOwner == faction.player or $sellStationOwner == faction.player)">
          <set_value name="$boost" exact="$efficiency / 5"/>
          <set_value name="$efficiency" exact="$efficiency + $boost"/>
        </do_if>
        <do_elseif value="$factionPriority == 1 and $buyStationOwner != faction.player and $sellStationOwner != faction.player">
          <set_value name="$boost" exact="$efficiency / 5"/>
          <set_value name="$efficiency" exact="$efficiency + $boost"/>
        </do_elseif>
        
        <!-- Apply "same path" bonus for efficient routing -->
        <!-- Favors trades where stations are "in order" relative to home and ship position -->
        <!-- Example: Home=E, Ship=B, Buy=C, Sell=E   Efficient (moves toward home) -->
        <!-- Example: Home=E, Ship=B, Buy=E, Sell=C   Less efficient (backtracks) -->
        <set_value name="$pathBonus" exact="1.0"/>
        <do_if value="$homeSector? and $shipSector? and $buySector? and $sellSector? and $shipToBuyDistance ge 0">
          <!-- Use passed distance parameters if available, otherwise calculate -->
          <set_value name="$homeToBuy" exact="-1"/>
          <set_value name="$homeToSell" exact="-1"/>
          <do_if value="$homeToBuyDistance ge 0 and $homeToSellDistance ge 0">
            <!-- Use passed parameters (from new multi-factor system) -->
            <set_value name="$homeToBuy" exact="$homeToBuyDistance"/>
            <set_value name="$homeToSell" exact="$homeToSellDistance"/>
          </do_if>
          <do_else>
            <!-- Fallback: Calculate distances (for backward compatibility) -->
            <set_value name="$homeToBuy" exact="$homeSector.gatedistance.{$buySector}"/>
            <set_value name="$homeToSell" exact="$homeSector.gatedistance.{$sellSector}"/>
          </do_else>
          
          <!-- Calculate ship sell distance directly (path might differ from ship buy + buy sell) -->
          <set_value name="$shipToSell" exact="$shipSector.gatedistance.{$sellSector}"/>
          
          <!-- Only apply bonus if all distances are valid (non-negative, paths exist) -->
          <do_if value="$homeToBuy ge 0 and $homeToSell ge 0 and $shipToSell ge 0">
            <!-- Case 1: Buy station is further from home than sell station -->
            <!-- Efficient route: Ship   Buy (further)   Sell (closer)   Home -->
            <!-- This is efficient if ship is closer to buy than sell (ship between buy and sell, or beyond buy) -->
            <do_if value="$homeToBuy gt $homeToSell">
              <!-- Efficient if ship is closer to buy station than sell station -->
              <!-- This means ship can move forward (toward sell/home) without backtracking -->
              <do_if value="$shipToBuyDistance le $shipToSell">
                <!-- Same path bonus: 10% efficiency boost -->
                <set_value name="$pathBonus" exact="1.1"/>
              </do_if>
            </do_if>
            <!-- Case 2: Sell station is further from home than buy station -->
            <!-- Efficient route: Ship   Sell (further)   Buy (closer)   Home -->
            <!-- This is efficient if ship is closer to sell than buy -->
            <do_elseif value="$homeToSell gt $homeToBuy">
              <!-- Efficient if ship is closer to sell station than buy station -->
              <do_if value="$shipToSell le $shipToBuyDistance">
                <!-- Same path bonus: 10% efficiency boost -->
                <set_value name="$pathBonus" exact="1.1"/>
              </do_if>
            </do_elseif>
            <!-- Case 3: Both stations same distance from home (same sector or equidistant) -->
            <!-- Already efficient - smaller bonus -->
            <do_elseif value="$homeToBuy == $homeToSell">
              <set_value name="$pathBonus" exact="1.05"/>
            </do_elseif>
          </do_if>
        </do_if>
        
        <!-- Apply path bonus to efficiency -->
        <set_value name="$efficiency" exact="$efficiency * $pathBonus"/>
        
        <return value="$efficiency"/>
      </actions>
    </library>
    
    <!-- Get Distance Penalty Multiplier -->
    <library name="GT_GetDistancePenaltyMultiplier" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to get distance penalty for"/>
        <param name="defaultMultiplier" default="1.0" comment="Default multiplier (for 50% distance penalty)"/>
      </params>
      <actions>
        <set_value name="$distancePenalty" exact="@global.$GT_AIParameters.{$ship}.$DistancePenalty"/>
        <do_if value="$distancePenalty?">
          <!-- Convert 0-100% to 0.0-2.0: 0%=0.0, 50%=1.0, 100%=2.0 -->
          <return value="$distancePenalty / 50.0"/>
        </do_if>
        <return value="$defaultMultiplier"/>
      </actions>
    </library>
    
    <!-- Get Faction Priority Text -->
    <library name="GT_GetFactionPriorityText" purpose="run_actions">
      <params>
        <param name="factionPriority" comment="Faction priority value (0, 1, or 2)"/>
      </params>
      <actions>
        <return value="if $factionPriority == 0 then 'Player Only' else if $factionPriority == 1 then 'Foreign First' else 'Equal Priority'"/>
      </actions>
    </library>
    
    <!-- Calculate ROI from Prices -->
    <library name="GT_CalculateROIFromPrices" purpose="run_actions">
      <params>
        <param name="buyPrice" comment="Price per unit to buy"/>
        <param name="sellPrice" comment="Price per unit to sell"/>
      </params>
      <actions>
        <!-- Calculate ROI as percentage: ((sellPrice - buyPrice) / buyPrice) * 100 -->
        <do_if value="$buyPrice gt 0">
          <return value="(($sellPrice - $buyPrice) * 100) / $buyPrice"/>
        </do_if>
        <return value="0"/>
      </actions>
    </library>
    
    <!-- Request Registry: Acquire Search Lock and Parameters -->
    <!-- Centralizes lock and parameter management to prevent cleanup leaks -->
    <library name="GT_RequestRegistry_Acquire" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship requesting trade search"/>
        <param name="parameters" comment="AI parameters table (must match structure from gt_trading_ai.xml)"/>
      </params>
      <actions>
        <!-- Initialize tables if needed -->
        <do_if value="not global.$GT_SearchLocks?">
          <set_value name="global.$GT_SearchLocks" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_AIParameters?">
          <set_value name="global.$GT_AIParameters" exact="table[]"/>
        </do_if>
        
        <!-- Check if already locked -->
        <set_value name="this.$alreadyLocked" exact="false"/>
        <do_if value="global.$GT_SearchLocks.{$ship}?">
          <set_value name="this.$alreadyLocked" exact="true"/>
          <!-- Log lock already exists -->
          <debug_text text="'[GT-Lock] (' + $ship.idcode + ') LOCK ACQUIRE FAILED - lock already exists (lockTime: ' + global.$GT_SearchLocks.{$ship} + ')'" chance="100"/>
        </do_if>
        
        <!-- Acquire lock and store parameters -->
        <do_if value="not this.$alreadyLocked">
          <set_value name="global.$GT_SearchLocks.{$ship}" exact="player.age"/>
          <set_value name="global.$GT_AIParameters.{$ship}" exact="$parameters"/>
          <set_value name="this.$acquired" exact="true"/>
          <!-- Log successful lock acquisition -->
          <debug_text text="'[GT-Lock] (' + $ship.idcode + ') LOCK ACQUIRED (lockTime: ' + player.age + ')'" chance="100"/>
        </do_if>
        <do_else>
          <set_value name="this.$acquired" exact="false"/>
        </do_else>
      </actions>
    </library>
    
    <!-- Request Registry: Release Search Lock and Parameters -->
    <!-- Centralizes cleanup to prevent leaks and ensure consistent behavior -->
    <!-- FIX: Version-aware cleanup prevents deleting parameters from newer requests -->
    <library name="GT_RequestRegistry_Release" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to release"/>
        <param name="reason" default="'search_complete'" comment="Reason for release (for debugging)"/>
      </params>
      <actions>
        <!-- CRITICAL: Validate ship is valid before accessing any properties (ship may have been destroyed) -->
        <do_if value="not $ship? or not $ship.exists">
          <!-- Ship is invalid (destroyed) - clean up locks/params silently and exit -->
          <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
            <remove_value name="global.$GT_SearchLocks.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}?">
            <remove_value name="global.$GT_AIParameters.{$ship}"/>
          </do_if>
          <return value="false"/>
        </do_if>
        
        <!-- PERFORMANCE FIX: Early exit check for non-GT ships -->
        <!-- If ship is not GT-controlled, exit immediately to prevent stutter -->
        <set_value name="$isGTControlled" exact="false"/>
        
        <!-- Quick check: Does ship have direct GT order? -->
        <do_if value="$ship.defaultorder? and @$ship.defaultorder.id == 'GalaxyTraderMK3'">
          <set_value name="$isGTControlled" exact="true"/>
        </do_if>
        
        <!-- Fallback check: Is ship subordinate to GT commander? -->
        <do_if value="not $isGTControlled and $ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <do_if value="$ship.commander.defaultorder? and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$isGTControlled" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- EARLY EXIT: If ship is not GT-controlled, still clean up locks/params silently but skip logging -->
        <!-- We still clean up to prevent leaks, but don't log for non-GT ships -->
        <set_value name="$shouldLog" exact="$isGTControlled"/>
        
        <!-- Get lock time BEFORE releasing lock (needed for version check) -->
        <set_value name="$lockTime" exact="null"/>
        <do_if value="global.$GT_SearchLocks? and global.$GT_SearchLocks.{$ship}?">
          <set_value name="$lockTime" exact="global.$GT_SearchLocks.{$ship}"/>
        </do_if>
        
        <!-- Release lock -->
        <do_if value="$lockTime != null">
          <remove_value name="global.$GT_SearchLocks.{$ship}"/>
          <!-- Always log lock release with ship ID and reason -->
          <!-- CRITICAL: Validate ship is valid before accessing idcode (ship may have been destroyed or invalidated) -->
          <!-- Use safe operator @ to prevent errors when ship component handle is invalid -->
          <set_value name="$shipIdCode" exact="'INVALID_SHIP'"/>
          <do_if value="$ship? and $ship.exists">
            <set_value name="$tempShipIdCode" exact="@$ship.idcode"/>
            <do_if value="$tempShipIdCode? and $tempShipIdCode != null and $tempShipIdCode != ''">
              <set_value name="$shipIdCode" exact="$tempShipIdCode"/>
            </do_if>
          </do_if>
          <debug_text text="'[GT-Lock] (' + $shipIdCode + ') LOCK RELEASED (reason: ' + $reason + ', lockTime: ' + $lockTime + ', age: ' + (player.age - $lockTime) + ')'" chance="100"/>
        </do_if>
        
        <!-- Clean up parameters ONLY if they belong to this request -->
        <!-- Check RequestTime matches lock time (or lock was null, meaning already released) -->
        <set_value name="$shouldDeleteParams" exact="false"/>
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}?">
          <set_value name="$params" exact="global.$GT_AIParameters.{$ship}"/>
          <set_value name="$paramsRequestTime" exact="@$params.$RequestTime"/>
          
          <!-- Delete parameters if:
               1. Lock time matches params RequestTime (same request), OR
               2. Lock was null (already released, but params still exist - stale cleanup) -->
          <do_if value="$lockTime != null and $paramsRequestTime? and $lockTime == $paramsRequestTime">
            <set_value name="$shouldDeleteParams" exact="true"/>
          </do_if>
          <do_elseif value="$lockTime == null and $paramsRequestTime?">
            <!-- Lock already released (by newer request), but params still exist -->
            <!-- Only delete if params are old (older than 1 minute) to avoid deleting active requests -->
            <do_if value="(player.age - $paramsRequestTime) gt 60s">
              <set_value name="$shouldDeleteParams" exact="true"/>
            </do_if>
          </do_elseif>
          
          <do_if value="$shouldDeleteParams">
            <remove_value name="global.$GT_AIParameters.{$ship}"/>
            <do_if value="$shouldLog and global.$GT_Config? and global.$GT_Config.$Debug? and global.$GT_Config.$Debug.$TradeSearch? and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <!-- Use safe operator to prevent errors with invalid ship objects -->
              <set_value name="$logShipIdCode" exact="@$ship.idcode"/>
              <set_value name="$safeShipIdCode" exact="if ($logShipIdCode? and $logShipIdCode != null and $logShipIdCode != '') then $logShipIdCode else 'INVALID_SHIP'"/>
              <debug_text text="'[GT-Registry] AI parameters cleaned up for ' + $safeShipIdCode + ' (' + $reason + ', RequestTime: ' + $paramsRequestTime + ')'" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Parameters belong to newer request - don't delete -->
            <do_if value="$shouldLog and global.$GT_Config? and global.$GT_Config.$Debug? and global.$GT_Config.$Debug.$TradeSearch? and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <!-- Use safe operator to prevent errors with invalid ship objects -->
              <set_value name="$logShipIdCode2" exact="@$ship.idcode"/>
              <set_value name="$safeShipIdCode2" exact="if ($logShipIdCode2? and $logShipIdCode2 != null and $logShipIdCode2 != '') then $logShipIdCode2 else 'INVALID_SHIP'"/>
              <debug_text text="'[GT-Registry] Skipping parameter cleanup for ' + $safeShipIdCode2 + ' - parameters belong to newer request (lock: ' + $lockTime + ', params: ' + $paramsRequestTime + ')'" chance="100"/>
            </do_if>
          </do_else>
        </do_if>

        <!-- IMPORTANT:
             stale_lock_cleanup should reset MORE than just the registry lock/params.
             Otherwise ships can remain stuck in "live search already in progress (pre-gate)" / batch-wait states
             even after the lock is released, leading to repeat AI timeouts and home-sector refresh blocking.
             Keep this block narrow: only runs for stale_lock_cleanup. -->
        <do_if value="$reason == 'stale_lock_cleanup'">
          <!-- 1) If this ship had acquired a live slot, decrement ActiveLiveSearches to avoid permanent saturation -->
          <set_value name="$hadLiveSlot" exact="false"/>
          <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$Params? and global.$GT_LiveSearchQueue.$Params.{$ship}?">
            <set_value name="$liveParams" exact="global.$GT_LiveSearchQueue.$Params.{$ship}"/>
            <do_if value="$liveParams? and $liveParams.$LiveSlotAcquired? and $liveParams.$LiveSlotAcquired">
              <set_value name="$hadLiveSlot" exact="true"/>
            </do_if>
          </do_if>
          <do_if value="$hadLiveSlot">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveLiveSearches">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
          </do_if>

          <!-- 2) Remove ship from live-search queue structures (params + per-sector queue) -->
          <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$Params? and global.$GT_LiveSearchQueue.$Params.{$ship}?">
            <remove_value name="global.$GT_LiveSearchQueue.$Params.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$BySector?">
            <do_all exact="global.$GT_LiveSearchQueue.$BySector.keys.count" counter="$sectorIdx">
              <set_value name="$sector" exact="global.$GT_LiveSearchQueue.$BySector.keys.{$sectorIdx}"/>
              <do_if value="$sector? and global.$GT_LiveSearchQueue.$BySector.{$sector}? and global.$GT_LiveSearchQueue.$BySector.{$sector}.$Ships? and global.$GT_LiveSearchQueue.$BySector.{$sector}.$Ships.count gt 0">
                <do_all exact="global.$GT_LiveSearchQueue.$BySector.{$sector}.$Ships.count" counter="$i" reverse="true">
                  <do_if value="global.$GT_LiveSearchQueue.$BySector.{$sector}.$Ships.{$i} == $ship">
                    <remove_from_list name="global.$GT_LiveSearchQueue.$BySector.{$sector}.$Ships" exact="$ship"/>
                  </do_if>
                </do_all>
              </do_if>
            </do_all>
          </do_if>

          <!-- 3) Clear per-ship live-search state markers so pre-gate checks don't block retries -->
          <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
            <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_LiveOfferSliceScheduled? and global.$GT_LiveOfferSliceScheduled.{$ship}?">
            <remove_value name="global.$GT_LiveOfferSliceScheduled.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Queued? and global.$GT_LiveOfferSliceQueue.$Queued.{$ship}?">
            <remove_value name="global.$GT_LiveOfferSliceQueue.$Queued.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Params? and global.$GT_LiveOfferSliceQueue.$Params.{$ship}?">
            <remove_value name="global.$GT_LiveOfferSliceQueue.$Params.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_LiveOfferSliceQueue? and global.$GT_LiveOfferSliceQueue.$Ships? and global.$GT_LiveOfferSliceQueue.$Ships.count gt 0">
            <remove_from_list name="global.$GT_LiveOfferSliceQueue.$Ships" exact="$ship"/>
          </do_if>
          <do_if value="global.$GT_CacheMissCooldowns? and global.$GT_CacheMissCooldowns.{$ship}?">
            <remove_value name="global.$GT_CacheMissCooldowns.{$ship}"/>
          </do_if>

          <!-- 4) Clear batch state and remove ship from batch queue/active lists (prevent indefinite batch-wait) -->
          <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
            <remove_value name="global.$GT_BatchDataList.{$ship}"/>
          </do_if>
          <do_if value="global.$GT_BatchResultsList? and global.$GT_BatchResultsList.{$ship}?">
            <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
          </do_if>

          <set_value name="$wasInActiveShips" exact="false"/>
          <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveShips? and global.$GT_BatchProcessorQueue.$ActiveShips.count gt 0">
            <do_all exact="global.$GT_BatchProcessorQueue.$ActiveShips.count" counter="$ai" reverse="true">
              <do_if value="global.$GT_BatchProcessorQueue.$ActiveShips.{$ai} == $ship">
                <set_value name="$wasInActiveShips" exact="true"/>
                <remove_from_list name="global.$GT_BatchProcessorQueue.$ActiveShips" exact="$ship"/>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$wasInActiveShips">
            <run_actions ref="md.GT_Libraries_General.GT_DecrementActiveProcessors">
              <param name="clampToZero" value="true"/>
              <param name="triggerQueueProcessor" value="true"/>
            </run_actions>
          </do_if>

          <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
            <remove_from_list name="global.$GT_BatchProcessorQueue.$Ships" exact="$ship"/>
          </do_if>

          <!-- 5) If this ship was the home-sector live-refresh initiator, release the marker so other ships aren't blocked.
               IMPORTANT: Do NOT call GT_GetHomeSector here. Some stale-lock cleanup cases involve ships that no longer have
               a valid defaultorder.$home / GT_AIParameters.$HomeBase, which would spam GT_GetHomeSector "THIS SHOULD NEVER HAPPEN"
               errors and trigger ship.sector fallback drift.
               Instead, scan the refresh table for any entry whose $Initiator == this ship. -->
          <do_if value="global.$GT_TS_LiveRefreshBySector? and global.$GT_TS_LiveRefreshBySector.keys.count gt 0">
            <do_all exact="global.$GT_TS_LiveRefreshBySector.keys.count" counter="$hsIdx">
              <set_value name="$hs" exact="global.$GT_TS_LiveRefreshBySector.keys.{$hsIdx}"/>
              <do_if value="$hs? and global.$GT_TS_LiveRefreshBySector.{$hs}?">
                <set_value name="$refreshEntry" exact="global.$GT_TS_LiveRefreshBySector.{$hs}"/>
                <do_if value="$refreshEntry? and $refreshEntry.$Initiator? and $refreshEntry.$Initiator == $ship">
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$hs}.$Active" exact="false"/>
                  <set_value name="global.$GT_TS_LiveRefreshBySector.{$hs}.$LastFinished" exact="player.age"/>
                </do_if>
              </do_if>
            </do_all>
          </do_if>

          <do_if value="$shouldLog and global.$GT_Config? and global.$GT_Config.$Debug? and global.$GT_Config.$Debug.$TradeSearch? and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <!-- Use safe operator to prevent errors with invalid ship objects -->
            <set_value name="$logShipIdCode3" exact="@$ship.idcode"/>
            <set_value name="$safeShipIdCode3" exact="if ($logShipIdCode3? and $logShipIdCode3 != null and $logShipIdCode3 != '') then $logShipIdCode3 else 'INVALID_SHIP'"/>
            <debug_text text="'[GT-Registry] stale_lock_cleanup: reset live/batch state for ' + $safeShipIdCode3" chance="100"/>
          </do_if>
        </do_if>
        
        <set_value name="this.$released" exact="true"/>
      </actions>
    </library>
    
    <!-- Get Skill-Based Multiplier -->
    <library name="GT_GetSkillMultiplier" purpose="run_actions">
      <params>
        <param name="skillLevel" comment="Pilot skill level (1-15+)"/>
      </params>
      <actions>
        <!-- Returns multiplier: 0.5 at Lv1   2.0 at Lv15 -->
        <!-- Formula: 0.5 + ((skillLevel - 1) * (1.5 / 14)) -->
        <return value="0.5 + (($skillLevel - 1) * (1.5 / 14))"/>
      </actions>
    </library>
    
    <!-- Get Pilot Level-Based Profit Threshold -->
    <library name="GT_GetPilotLevelProfitThreshold" purpose="run_actions">
      <params>
        <param name="skillLevel" comment="Pilot skill level (1-15+)"/>
        <param name="shipCargoCapacity" comment="Ship's max cargo capacity (for scaling threshold)"/>
        <param name="configBaseProfit" default="10000" comment="Base profit at Level 15 for reference cargo (RAW centicredits). Example: 100Cr = 10000."/>
      </params>
      <actions>
        <!-- Returns profit threshold in raw format (centicredits) based on pilot level:
             Non-linear (quadratic) progression from Level 1 (0 Cr) to Level 15 (configBaseProfit).
             Formula: configBaseProfit * ((skillLevel - 1) / 14)^2
             This creates a quadratic curve that starts at 0 Cr and accelerates to 10000 Cr:
             Level 1: 0 Cr (0 raw)
             Level 15: configBaseProfit (raw)
             
             NEW: Threshold is scaled by ship cargo capacity
             - Reference cargo: 8200 (Merkur - baseline for Level 15 = configBaseProfit)
             - Small ships (2200 cargo) get proportionally lower thresholds
             - Minimum floor: 25% of base threshold (prevents thresholds from being too low)
        -->
        <!-- Level 1-15+: Non-linear (quadratic) progression from 0 Cr to configBaseProfit -->
        <!-- Avoid integer division by rearranging formula:
             Original: configBaseProfit * ((skillLevel - 1) / 14)^2
             Rearranged: ((skillLevel - 1)^2 * configBaseProfit) / 196
        -->
        <!-- This avoids floating-point division issues in MD by doing integer math -->
        <!-- This creates an accelerating curve - lower levels have lower thresholds, -->
        <!-- higher levels require much more profit (more selective traders) -->
        <set_value name="$baseMax" exact="$configBaseProfit"/>
        <do_if value="not $baseMax? or $baseMax == null or $baseMax lt 0">
          <set_value name="$baseMax" exact="10000"/>
        </do_if>
        <set_value name="$numerator" exact="($skillLevel - 1) * ($skillLevel - 1) * $baseMax"/>
        <set_value name="$baseThreshold" exact="$numerator / 196"/>
        
        <!-- Scale threshold by ship cargo capacity -->
        <!-- Reference cargo: 8200 (Merkur - baseline for Level 15 = 10,000 Cr) -->
        <!-- Small ships get proportionally lower thresholds -->
        <set_value name="$referenceCargo" exact="8200"/>
        <do_if value="$shipCargoCapacity? and $shipCargoCapacity gt 0">
          <!-- Calculate scaling factor: shipCargo / referenceCargo -->
          <!-- Use integer math to avoid floating-point issues -->
          <set_value name="$scalingFactor" exact="($shipCargoCapacity * 100) / $referenceCargo"/>
          <set_value name="$scaledThreshold" exact="($baseThreshold * $scalingFactor) / 100"/>
          
          <!-- Apply minimum floor: At least 25% of base threshold -->
          <set_value name="$minFloor" exact="($baseThreshold * 25) / 100"/>
          <set_value name="$result" exact="[$scaledThreshold, $minFloor].max"/>
        </do_if>
        <do_else>
          <!-- Fallback: Use base threshold if cargo capacity not available -->
          <set_value name="$result" exact="$baseThreshold"/>
        </do_else>
        
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Validate Trade -->
    <library name="GT_IsTradeValid" purpose="run_actions">
      <params>
        <param name="trade" comment="Trade object to validate"/>
        <param name="minScore" default="0" comment="Minimum score required (default: 0 = any positive score)"/>
      </params>
      <actions>
        <!-- Validate trade has all required properties -->
        <set_value name="$testBuyOffer" exact="@$trade.$BuyOffer"/>
        <set_value name="$testSellOffer" exact="@$trade.$SellOffer"/>
        <set_value name="$testScore" exact="@$trade.$Score"/>
        <do_if value="$testBuyOffer? and $testSellOffer? and $testScore? and $testScore gt $minScore">
          <set_value name="$testWare" exact="@$testBuyOffer.ware"/>
          <do_if value="$testWare?">
            <return value="true"/>
          </do_if>
        </do_if>
        <return value="false"/>
      </actions>
    </library>
    
    <!-- Calculate Max Tradeable Amount -->
    <library name="GT_CalculateMaxTradeableAmount" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship for cargo capacity calculation"/>
        <param name="ware" comment="Ware to calculate capacity for"/>
        <param name="buyOfferAmount" comment="Buy offer amount"/>
        <param name="sellOfferAmount" comment="Sell offer amount"/>
        <param name="availableMoney" default="999999Cr" comment="Available money"/>
        <param name="buyPrice" default="0" comment="Buy price per unit"/>
      </params>
      <actions>
        <!-- Calculate max cargo capacity for this ware -->
        <set_value name="$maxCargoCapacity" exact="($ship.cargo.free.all / $ware.volume)i"/>
        <!-- Calculate max affordable based on available money -->
        <set_value name="$maxAffordable" exact="99999"/>
        <do_if value="$buyPrice gt 0">
          <set_value name="$maxAffordable" exact="($availableMoney / $buyPrice)i"/>
        </do_if>
        <!-- Return minimum of offer amounts, cargo capacity, and money limit -->
        <return value="[$buyOfferAmount, $sellOfferAmount, $maxCargoCapacity, $maxAffordable].min"/>
      </actions>
    </library>
    
    <!-- Index Offers By Ware -->
    <library name="GT_IndexOffersByWare" purpose="run_actions">
      <params>
        <param name="offersList" comment="List of trade offers to index"/>
      </params>
      <actions>
        <set_value name="$offersByWare" exact="table[]"/>
        
        <!-- Defensive: list may be null/invalid -->
        <do_if value="not $offersList? or $offersList == null">
          <return value="$offersByWare"/>
        </do_if>
        
        <do_all exact="$offersList.count" counter="$i">
          <set_value name="$offer" exact="$offersList.{$i}"/>
          
          <!-- Null-safety: offer handles can be invalid; ware can be null -->
          <set_value name="$ware" exact="@$offer.ware"/>
          <do_if value="not $ware? or $ware == null">
            <continue/>
          </do_if>
          
          <do_if value="not $offersByWare.{$ware}? or $offersByWare.{$ware} == null">
            <set_value name="$offersByWare.{$ware}" exact="[]"/>
          </do_if>
          <append_to_list name="$offersByWare.{$ware}" exact="$offer"/>
        </do_all>
        <return value="$offersByWare"/>
      </actions>
    </library>
    
    <!-- Filter Offers By Distance -->
    <library name="GT_FilterOffersByDistance" purpose="run_actions">
      <params>
        <param name="offersList" comment="List of offers to filter"/>
        <param name="homeSector" comment="Home/base sector for distance calculation"/>
        <param name="maxDistance" comment="Maximum distance (jumps)"/>
      </params>
      <actions>
        <set_value name="$filteredOffers" exact="[]"/>
        <set_value name="$filteredCount" exact="0"/>
        
        <!-- Defensive: list may be null/invalid -->
        <do_if value="not $offersList? or $offersList == null">
          <set_value name="$result" exact="table[]"/>
          <set_value name="$result.$FilteredOffers" exact="$filteredOffers"/>
          <set_value name="$result.$FilteredCount" exact="$filteredCount"/>
          <return value="$result"/>
        </do_if>
        
        <do_all exact="$offersList.count" counter="$i">
          <set_value name="$offer" exact="$offersList.{$i}"/>
          
          <!-- Null-safety: offer.owner can be invalid -->
          <set_value name="$owner" exact="@$offer.owner"/>
          <set_value name="$targetSector" exact="@$owner.sector"/>
          <do_if value="not $targetSector? or $targetSector == null">
            <set_value name="$filteredCount" exact="$filteredCount + 1"/>
            <continue/>
          </do_if>
          
          <!-- Calculate range-only distance (using library function) -->
          <run_actions ref="md.GT_Libraries_Pathfinding.GT_CalculateRangeOnlyDistance" result="$distance">
            <param name="fromSector" value="$homeSector"/>
            <param name="toSector" value="$targetSector"/>
          </run_actions>
          
          <!-- Keep offer if within max distance and path exists (distance >= 0) -->
          <do_if value="$distance ge 0 and $distance le $maxDistance">
            <append_to_list name="$filteredOffers" exact="$offer"/>
          </do_if>
          <do_else>
            <set_value name="$filteredCount" exact="$filteredCount + 1"/>
          </do_else>
        </do_all>
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$FilteredOffers" exact="$filteredOffers"/>
        <set_value name="$result.$FilteredCount" exact="$filteredCount"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Sort and Limit Offers -->
    <library name="GT_SortAndLimitOffers" purpose="run_actions">
      <params>
        <param name="offersList" comment="List of offers to sort and limit"/>
        <param name="maxCount" comment="Maximum number of offers to return"/>
        <param name="sortAscending" default="true" comment="If true, sort ascending (take first N), if false sort descending (take last N)"/>
      </params>
      <actions>
        <set_value name="$offers" exact="$offersList"/>
        <!-- Sort by relativeprice -->
        <sort_trades name="$offers" tradelist="$offers" sorter="relativeprice"/>
        
        <set_value name="$limitedOffers" exact="[]"/>
        <do_if value="$sortAscending">
          <!-- Take first N offers (lowest price for buy offers) -->
          <set_value name="$limitCount" exact="[$offers.count, $maxCount].min"/>
          <do_all exact="$limitCount" counter="$idx">
            <append_to_list name="$limitedOffers" exact="$offers.{$idx}"/>
          </do_all>
        </do_if>
        <do_else>
          <!-- Take last N offers (highest price for sell offers) -->
          <do_if value="$offers.count gt $maxCount">
            <set_value name="$startIndex" exact="$offers.count - $maxCount + 1"/>
            <do_all exact="$maxCount" counter="$idx">
              <set_value name="$actualIndex" exact="$startIndex + $idx - 1"/>
              <append_to_list name="$limitedOffers" exact="$offers.{$actualIndex}"/>
            </do_all>
          </do_if>
          <do_else>
            <!-- Less than limit, take all -->
            <do_all exact="$offers.count" counter="$idx">
              <append_to_list name="$limitedOffers" exact="$offers.{$idx}"/>
            </do_all>
          </do_else>
        </do_else>
        <return value="$limitedOffers"/>
      </actions>
    </library>
    
    <!-- Sort Trades By Score (highest first) -->
    <library name="GT_SortTradesByScore" purpose="run_actions">
      <params>
        <param name="tradeList" comment="List of trades to sort"/>
      </params>
      <actions>
        <!-- Optimize sort for small lists (≤10 items: O(n) vs O(n²)) -->
        <do_if value="(if $tradeList != null then $tradeList.count else 0) gt 1">
          <do_if value="$tradeList.count gt 10">
            <!-- Large list: Full selection sort (necessary for proper ordering) -->
            <set_value name="$sortedTradeList" exact="[]"/>
            <set_value name="$remainingTrades" exact="$tradeList"/>
            <do_all exact="$tradeList.count" counter="$sortIdx">
              <set_value name="$maxScore" exact="-999999999"/>
              <set_value name="$maxIdx" exact="-1"/>
              <do_all exact="$remainingTrades.count" counter="$i">
                <set_value name="$trade" exact="$remainingTrades.{$i}"/>
                <set_value name="$tradeScore" exact="$trade.$Score"/>
                <do_if value="$tradeScore gt $maxScore">
                  <set_value name="$maxScore" exact="$tradeScore"/>
                  <set_value name="$maxIdx" exact="$i"/>
                </do_if>
              </do_all>
              <do_if value="$maxIdx ge 0">
                <append_to_list name="$sortedTradeList" exact="$remainingTrades.{$maxIdx}"/>
                <remove_value name="$remainingTrades.{$maxIdx}"/>
              </do_if>
            </do_all>
            <set_value name="$tradeList" exact="$sortedTradeList"/>
          </do_if>
          <do_elseif value="$tradeList.count gt 1">
            <!-- Small list (2-10): Single pass bubble-like sort (O(nÂ²) but n is small) -->
            <set_value name="$sortedTradeList" exact="$tradeList"/>
            <!-- Single pass: swap adjacent elements if wrong order (n-1 comparisons) -->
            <do_all exact="$tradeList.count - 1" counter="$pass">
              <set_value name="$swapped" exact="false"/>
              <do_all exact="$tradeList.count - 1 - $pass" counter="$i">
                <set_value name="$currentScore" exact="$sortedTradeList.{$i}.$Score"/>
                <set_value name="$nextScore" exact="$sortedTradeList.{$i + 1}.$Score"/>
                <do_if value="$currentScore lt $nextScore">
                  <!-- Swap -->
                  <set_value name="$temp" exact="$sortedTradeList.{$i}"/>
                  <set_value name="$sortedTradeList.{$i}" exact="$sortedTradeList.{$i + 1}"/>
                  <set_value name="$sortedTradeList.{$i + 1}" exact="$temp"/>
                  <set_value name="$swapped" exact="true"/>
                </do_if>
              </do_all>
              <!-- Early exit if no swaps (already sorted) -->
              <do_if value="not $swapped">
                <break/>
              </do_if>
            </do_all>
            <set_value name="$tradeList" exact="$sortedTradeList"/>
          </do_elseif>
          <!-- Single item or empty: no sort needed -->
        </do_if>
        <return value="$tradeList"/>
      </actions>
    </library>
    
    <!-- Filter Trade For Ship (ware basket, illegal, blacklist, path availability) -->
    <library name="GT_FilterTradeForShip" purpose="run_actions">
      <params>
        <param name="trade" comment="Trade to filter"/>
        <param name="ship" comment="Ship that would execute the trade"/>
        <param name="ware" comment="Ware being traded"/>
        <param name="wareBasket" comment="Allowed ware basket (empty = all wares allowed)"/>
        <param name="allowIllegal" default="false" comment="Whether to allow illegal wares"/>
        <param name="blacklistgroup" default="null" comment="Blacklist group"/>
        <param name="currentSector" comment="Ship's current sector"/>
        <param name="buySector" comment="Buy station sector"/>
        <param name="sellSector" comment="Sell station sector"/>
        <param name="filterStats" default="null" comment="Optional filter statistics table to update"/>
        <param name="isIntraSectorTrade" default="false" comment="Whether this is an intra-sector trade"/>
        <param name="ignoreCarrierAux" default="false" comment="Ignore carrier/auxiliary stations"/>
        <param name="ignoreBuildStorage" default="false" comment="Ignore build storage ships"/>
      </params>
      <actions>
        <!-- Initialize result -->
        <set_value name="$isAllowed" exact="true"/>
        <set_value name="$filterReason" exact="''"/>
        
        <!-- Skip wares ship cannot carry -->
        <!-- Some wares (like Methane/gas, Feststoffe/solids) require special cargo bays -->
        <set_value name="$canCarryWareType" exact="false"/>
        <do_if value="$ware? and $ware != null">
          <!-- Check if ship has cargo bay capacity for this specific ware type -->
          <set_value name="$canCarryWareType" exact="$ship.cargo.{$ware}.max gt 0"/>
        </do_if>
        <do_if value="not $canCarryWareType">
          <set_value name="$isAllowed" exact="false"/>
          <set_value name="$filterReason" exact="'incompatible_cargo'"/>
          <do_if value="$filterStats?">
            <!-- Track in filter stats if provided -->
            <do_if value="not $filterStats.$filteredByIncompatibleCargo?">
              <set_value name="$filterStats.$filteredByIncompatibleCargo" exact="0"/>
            </do_if>
            <set_value name="$filterStats.$filteredByIncompatibleCargo" exact="$filterStats.$filteredByIncompatibleCargo + 1"/>
          </do_if>
          <!-- Return early - ship cannot carry this ware type -->
          <set_value name="$result" exact="table[]"/>
          <set_value name="$result.$IsAllowed" exact="$isAllowed"/>
          <set_value name="$result.$FilterReason" exact="$filterReason"/>
          <return value="$result"/>
        </do_if>
        
        <!-- Cheap checks first (ware basket, illegal) -->
        <!-- Ware basket check -->
        <set_value name="$wareAllowed" exact="true"/>
        <do_if value="$wareBasket? and $wareBasket != null and $wareBasket.count gt 0">
          <run_actions ref="md.GT_Libraries_General.GT_IsWareInBasket" result="$wareAllowed">
            <param name="ware" value="$ware"/>
            <param name="basket" value="$wareBasket"/>
          </run_actions>
          <do_if value="not $wareAllowed">
            <set_value name="$isAllowed" exact="false"/>
            <set_value name="$filterReason" exact="'ware_basket'"/>
            <do_if value="$filterStats?">
              <set_value name="$filterStats.$filteredByWareBasket" exact="$filterStats.$filteredByWareBasket + 1"/>
            </do_if>
            <!-- Early return - skip expensive checks (blacklist, pathfinding) -->
            <set_value name="$result" exact="table[]"/>
            <set_value name="$result.$IsAllowed" exact="$isAllowed"/>
            <set_value name="$result.$FilterReason" exact="$filterReason"/>
            <return value="$result"/>
          </do_if>
        </do_if>
        
        <!-- Illegal ware check -->
        <!-- FIX: Explicit gt 0 check to ensure legal wares (illegal=0) are not filtered -->
        <do_if value="$wareAllowed and not $allowIllegal and @$ware.illegal gt 0">
          <set_value name="$wareAllowed" exact="false"/>
          <set_value name="$isAllowed" exact="false"/>
          <set_value name="$filterReason" exact="'illegal'"/>
          <do_if value="$filterStats?">
            <set_value name="$filterStats.$filteredByIllegal" exact="$filterStats.$filteredByIllegal + 1"/>
          </do_if>
          <!-- PERFORMANCE OPTIMIZATION: Early return - skip expensive checks (blacklist, pathfinding) -->
          <set_value name="$result" exact="table[]"/>
          <set_value name="$result.$IsAllowed" exact="$isAllowed"/>
          <set_value name="$result.$FilterReason" exact="$filterReason"/>
          <return value="$result"/>
        </do_if>
        
        <!-- PERFORMANCE OPTIMIZATION: Expensive checks only if cheap checks pass -->
        <!-- Blacklist check -->
        <set_value name="$isBlacklisted" exact="false"/>
        <do_if value="$wareAllowed">
          <!-- FIX: Block intra-sector trades in blacklisted sectors (force escape) -->
          <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$currentSectorIsBlacklisted">
            <param name="sector" value="$currentSector"/>
            <param name="ship" value="$ship"/>
            <param name="blacklistgroup" value="$blacklistgroup"/>
          </run_actions>
          <do_if value="$currentSectorIsBlacklisted">
            <do_if value="$buySector == $currentSector and $sellSector == $currentSector">
              <!-- Intra-sector trade in blacklisted sector - BLOCK to force escape -->
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'blacklist_intra'"/>
              <do_if value="$filterStats?">
                <set_value name="$filterStats.$filteredByBlacklist" exact="$filterStats.$filteredByBlacklist + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check buy station blacklist -->
          <do_if value="not $isBlacklisted">
            <set_value name="$buyStation" exact="@$trade.$BuyStation"/>
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsStationBlacklisted" result="$buyStationBlacklisted">
              <param name="station" value="$buyStation"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
            <do_if value="$buyStationBlacklisted">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'blacklist_buy_station'"/>
              <do_if value="$filterStats?">
                <set_value name="$filterStats.$filteredByBlacklist" exact="$filterStats.$filteredByBlacklist + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check sell station blacklist -->
          <do_if value="not $isBlacklisted">
            <set_value name="$sellStation" exact="@$trade.$SellStation"/>
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsStationBlacklisted" result="$sellStationBlacklisted">
              <param name="station" value="$sellStation"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
            <do_if value="$sellStationBlacklisted">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'blacklist_sell_station'"/>
              <do_if value="$filterStats?">
                <set_value name="$filterStats.$filteredByBlacklist" exact="$filterStats.$filteredByBlacklist + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check carrier/aux exclusion (for stations only) -->
          <do_if value="not $isBlacklisted and $ignoreCarrierAux">
            <set_value name="$buyStation" exact="@$trade.$BuyStation"/>
            <set_value name="$sellStation" exact="@$trade.$SellStation"/>
            
            <!-- Check buy station: carrier/aux (stations only, not ships) -->
            <set_value name="$buyIsCarrierAux" exact="false"/>
            <do_if value="$buyStation? and $buyStation.isclass.station">
              <set_value name="$buyPrimaryPurpose" exact="@$buyStation.primarypurpose"/>
              <do_if value="$buyPrimaryPurpose == purpose.auxiliary or $buyPrimaryPurpose == purpose.fight">
                <set_value name="$buyIsCarrierAux" exact="true"/>
              </do_if>
            </do_if>
            
            <!-- Check sell station: carrier/aux (stations only, not ships) -->
            <set_value name="$sellIsCarrierAux" exact="false"/>
            <do_if value="$sellStation? and $sellStation.isclass.station">
              <set_value name="$sellPrimaryPurpose" exact="@$sellStation.primarypurpose"/>
              <do_if value="$sellPrimaryPurpose == purpose.auxiliary or $sellPrimaryPurpose == purpose.fight">
                <set_value name="$sellIsCarrierAux" exact="true"/>
              </do_if>
            </do_if>
            
            <do_if value="$buyIsCarrierAux or $sellIsCarrierAux">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'carrier_aux_excluded'"/>
              <do_if value="$filterStats?">
                <do_if value="not $filterStats.$filteredByCarrierAux?">
                  <set_value name="$filterStats.$filteredByCarrierAux" exact="0"/>
                </do_if>
                <set_value name="$filterStats.$filteredByCarrierAux" exact="$filterStats.$filteredByCarrierAux + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check build storage exclusion -->
          <do_if value="not $isBlacklisted and $isAllowed and $ignoreBuildStorage">
            <set_value name="$buyStation" exact="@$trade.$BuyStation"/>
            <set_value name="$sellStation" exact="@$trade.$SellStation"/>
            
            <!-- Check buy station: build storage -->
            <set_value name="$buyIsBuildStorage" exact="false"/>
            <do_if value="$buyStation?">
              <set_value name="$buyIsBuildStorage" exact="$buyStation.isclass.buildstorage"/>
            </do_if>
            
            <!-- Check sell station: build storage -->
            <set_value name="$sellIsBuildStorage" exact="false"/>
            <do_if value="$sellStation?">
              <set_value name="$sellIsBuildStorage" exact="$sellStation.isclass.buildstorage"/>
            </do_if>
            
            <do_if value="$buyIsBuildStorage or $sellIsBuildStorage">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'buildstorage_excluded'"/>
              <do_if value="$filterStats?">
                <do_if value="not $filterStats.$filteredByBuildStorage?">
                  <set_value name="$filterStats.$filteredByBuildStorage" exact="0"/>
                </do_if>
                <set_value name="$filterStats.$filteredByBuildStorage" exact="$filterStats.$filteredByBuildStorage + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check buy sector blacklist -->
          <do_if value="not $isBlacklisted">
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$buySectorBlacklisted">
              <param name="sector" value="$buySector"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
            <do_if value="$buySectorBlacklisted">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'blacklist_buy_sector'"/>
              <do_if value="$filterStats?">
                <set_value name="$filterStats.$filteredByBlacklist" exact="$filterStats.$filteredByBlacklist + 1"/>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Check sell sector blacklist -->
          <do_if value="not $isBlacklisted">
            <run_actions ref="md.GT_Libraries_Blacklist.GT_IsSectorBlacklisted" result="$sellSectorBlacklisted">
              <param name="sector" value="$sellSector"/>
              <param name="ship" value="$ship"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
            <do_if value="$sellSectorBlacklisted">
              <do_if value="$sellSector != $currentSector">
                <!-- Ship needs to travel TO a blacklisted sector - BLOCK -->
                <set_value name="$isBlacklisted" exact="true"/>
                <set_value name="$isAllowed" exact="false"/>
                <set_value name="$filterReason" exact="'blacklist_sell_sector'"/>
                <do_if value="$filterStats?">
                  <set_value name="$filterStats.$filteredByBlacklist" exact="$filterStats.$filteredByBlacklist + 1"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- Path availability check -->
          <do_if value="not $isBlacklisted">
            <run_actions ref="md.GT_Libraries_Pathfinding.GT_CalculateTradePathDistances" result="$pathResult">
              <param name="ship" value="$ship"/>
              <param name="currentSector" value="$currentSector"/>
              <param name="buySector" value="$buySector"/>
              <param name="sellSector" value="$sellSector"/>
              <param name="blacklistgroup" value="$blacklistgroup"/>
            </run_actions>
            
            <!-- Debug logging (if enabled) -->
            <!-- FIX: Only log intra-sector trades for isolated ships (they're common for non-isolated ships) -->
            <!-- Always log unreachable paths as they indicate problems -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch">
              <set_value name="$shouldLogIntraSector" exact="false"/>
              <do_if value="$pathResult.$IsIntraSectorTrade">
                <!-- Check if ship is isolated - only log intra-sector trades for isolated ships -->
                <do_if value="$currentSector?">
                  <run_actions ref="md.GT_Libraries_Blacklist.GT_CheckConnectedSectorsBlacklisted" result="$isolationCheck">
                    <param name="sector" value="$currentSector"/>
                    <param name="ship" value="$ship"/>
                    <param name="returnDetails" value="false"/>
                  </run_actions>
                  <set_value name="$isolatedValue" exact="@$isolationCheck.$IsIsolated"/>
                  <set_value name="$shouldLogIntraSector" exact="if $isolatedValue? and ($isolatedValue == true or $isolatedValue == 1) then true else false"/>
                </do_if>
              </do_if>
              <do_if value="$shouldLogIntraSector or not $pathResult.$IsReachable">
                <set_value name="$buySectorName" exact="@$buySector.knownname"/>
                <set_value name="$sellSectorName" exact="@$sellSector.knownname"/>
                <set_value name="$currentSectorName" exact="@$currentSector.knownname"/>
                <set_value name="$wareName" exact="@$ware.name"/>
                <set_value name="$tradeType" exact="if $pathResult.$IsIntraSectorTrade then 'INTRA-SECTOR' else 'CROSS-SECTOR'"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-Resume] ' + $ship.idcode + ': ' + $tradeType + ' trade (' + $wareName + '):' +
                    '\n  Current sector: ' + $currentSectorName + ' (blacklisted: ' + $pathResult.$CurrentSectorIsBlacklisted + ')' +
                    '\n  Buy sector: ' + $buySectorName + ' (distance: ' + $pathResult.$BuyPathDistance + ', same as current: ' + ($buySector == $currentSector) + ')' +
                    '\n  Sell sector: ' + $sellSectorName + ' (distance: ' + $pathResult.$SellPathDistance + ', same as buy: ' + ($sellSector == $buySector) + ', same as current: ' + ($sellSector == $currentSector) + ')' +
                    (if not $pathResult.$IsReachable then ' [PATH BLOCKED]' else '')"
                    chance="100"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- Block if paths are unreachable -->
            <do_if value="not $pathResult.$IsReachable">
              <set_value name="$isBlacklisted" exact="true"/>
              <set_value name="$isAllowed" exact="false"/>
              <set_value name="$filterReason" exact="'path_blocked'"/>
              <do_if value="$filterStats?">
                <set_value name="$filterStats.$filteredByPathBlocked" exact="$filterStats.$filteredByPathBlocked + 1"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Return result -->
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$IsAllowed" exact="$isAllowed"/>
        <set_value name="$result.$FilterReason" exact="$filterReason"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Build Docking Cache -->
    <library name="GT_BuildDockingCache" purpose="run_actions">
      <params>
        <param name="sellOffers" comment="List of sell offers"/>
        <param name="buyOffers" comment="List of buy offers"/>
        <param name="ship" comment="Ship to check docking for"/>
      </params>
      <actions>
        <set_value name="$dockingCache" exact="table[]"/>
        <set_value name="$uniqueStations" exact="table[]"/>
        
        <!-- Collect all unique stations from sell offers -->
        <do_all exact="$sellOffers.count" counter="$i">
          <set_value name="$offer" exact="$sellOffers.{$i}"/>
          <set_value name="$station" exact="@$offer.owner"/>
          <!-- Validate station is valid before using as table key -->
          <set_value name="$stationValid" exact="false"/>
          <do_if value="$station? and not ($station == null)">
            <set_value name="$stationId" exact="@$station.idcode"/>
            <do_if value="$stationId?">
              <set_value name="$stationValid" exact="true"/>
            </do_if>
          </do_if>
          <do_if value="$stationValid and $station? and not ($station == null)">
            <do_if value="not $uniqueStations.{$station}?">
              <set_value name="$uniqueStations.{$station}" exact="true"/>
            </do_if>
          </do_if>
        </do_all>
        
        <!-- Collect all unique stations from buy offers -->
        <do_all exact="$buyOffers.count" counter="$i">
          <set_value name="$offer" exact="$buyOffers.{$i}"/>
          <set_value name="$station" exact="@$offer.owner"/>
          <!-- Validate station is valid before using as table key -->
          <set_value name="$stationValid" exact="false"/>
          <do_if value="$station? and not ($station == null)">
            <set_value name="$stationId" exact="@$station.idcode"/>
            <do_if value="$stationId?">
              <set_value name="$stationValid" exact="true"/>
            </do_if>
          </do_if>
          <do_if value="$stationValid and $station? and not ($station == null)">
            <do_if value="not $uniqueStations.{$station}?">
              <set_value name="$uniqueStations.{$station}" exact="true"/>
            </do_if>
          </do_if>
        </do_all>
        
        <!-- Pre-cache docking permissions for all unique stations -->
        <do_all exact="$uniqueStations.keys.count" counter="$stationIdx">
          <set_value name="$station" exact="$uniqueStations.keys.{$stationIdx}"/>
          <set_value name="$canDock" exact="@$station.dockingallowed.{$ship}"/>
          <set_value name="$dockingCache.{$station}" exact="$canDock"/>
        </do_all>
        
        <return value="$dockingCache"/>
      </actions>
    </library>
    
    <!-- Separate Offers By Sector -->
    <library name="GT_SeparateOffersBySector" purpose="run_actions">
      <params>
        <param name="sellOffers" comment="List of sell offers"/>
        <param name="buyOffers" comment="List of buy offers"/>
        <param name="currentSector" comment="Current sector to compare against"/>
      </params>
      <actions>
        <set_value name="$intraSectorSellOffers" exact="[]"/>
        <set_value name="$intraSectorBuyOffers" exact="[]"/>
        <set_value name="$crossSectorSellOffers" exact="[]"/>
        <set_value name="$crossSectorBuyOffers" exact="[]"/>
        
        <!-- FIX: Validate currentSector is set and not null -->
        <do_if value="not $currentSector?">
          <!-- If currentSector is null, all offers are cross-sector -->
          <set_value name="$crossSectorSellOffers" exact="$sellOffers"/>
          <set_value name="$crossSectorBuyOffers" exact="$buyOffers"/>
        </do_if>
        <do_else>
          <!-- Separate sell offers -->
          <do_all exact="$sellOffers.count" counter="$idx">
            <set_value name="$offer" exact="$sellOffers.{$idx}"/>
            <set_value name="$offerSector" exact="@$offer.owner.sector"/>
            <!-- FIX: Compare sectors directly - == should work for same component reference -->
            <do_if value="$offerSector? and $offerSector == $currentSector">
              <append_to_list name="$intraSectorSellOffers" exact="$offer"/>
            </do_if>
            <do_else>
              <append_to_list name="$crossSectorSellOffers" exact="$offer"/>
            </do_else>
          </do_all>
          
          <!-- Separate buy offers -->
          <do_all exact="$buyOffers.count" counter="$idx">
            <set_value name="$offer" exact="$buyOffers.{$idx}"/>
            <set_value name="$offerSector" exact="@$offer.owner.sector"/>
            <!-- FIX: Compare sectors directly - == should work for same component reference -->
            <do_if value="$offerSector? and $offerSector == $currentSector">
              <append_to_list name="$intraSectorBuyOffers" exact="$offer"/>
            </do_if>
            <do_else>
              <append_to_list name="$crossSectorBuyOffers" exact="$offer"/>
            </do_else>
          </do_all>
        </do_else>
        
        <!-- Return result table -->
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$IntraSectorSell" exact="$intraSectorSellOffers"/>
        <set_value name="$result.$IntraSectorBuy" exact="$intraSectorBuyOffers"/>
        <set_value name="$result.$CrossSectorSell" exact="$crossSectorSellOffers"/>
        <set_value name="$result.$CrossSectorBuy" exact="$crossSectorBuyOffers"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Calculate Trade Thresholds -->
    <library name="GT_CalculateTradeThresholds" purpose="run_actions">
      <params>
        <param name="minROI" comment="Base minimum ROI"/>
        <param name="minAbsoluteProfit" comment="Base minimum profit"/>
        <param name="useAdvancedAnalytics" default="false" comment="Apply 95% multiplier"/>
        <param name="isIntraSector" default="false" comment="Is intra-sector trade"/>
        <param name="isIsolated" default="false" comment="Is ship isolated"/>
      </params>
      <actions>
        <set_value name="$roiThreshold" exact="$minROI"/>
        <set_value name="$profitThreshold" exact="$minAbsoluteProfit"/>
        
        <!-- Apply advanced analytics adjustment -->
        <!-- FIX: Use integer math to avoid floating-point to money conversion warnings -->
        <!-- CRITICAL: $profitThreshold is already in raw format (centicredits), so don't use Cr suffix -->
        <do_if value="$useAdvancedAnalytics">
          <set_value name="$roiThreshold" exact="$roiThreshold * 0.95"/>
          <set_value name="$profitThreshold" exact="$profitThreshold * 95 / 100"/>
        </do_if>
        
        <!-- Apply intra-sector/isolation adjustments -->
        <!-- FIX: Use integer math to avoid floating-point to money conversion warnings -->
        <!-- CRITICAL: $profitThreshold is already in raw format (centicredits), so divide by 2 (or multiply by 50/100) without Cr suffix -->
        <do_if value="$isIntraSector">
          <do_if value="$isIsolated">
            <!-- Isolated intra-sector: 25% of threshold -->
            <set_value name="$roiThreshold" exact="$roiThreshold * 0.25"/>
            <set_value name="$profitThreshold" exact="$profitThreshold * 25 / 100"/>
          </do_if>
          <do_else>
            <!-- Normal intra-sector: 50% of threshold -->
            <set_value name="$roiThreshold" exact="$roiThreshold * 0.5"/>
            <set_value name="$profitThreshold" exact="$profitThreshold / 2"/>
          </do_else>
        </do_if>
        
        <!-- Return result table -->
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$ROIThreshold" exact="$roiThreshold"/>
        <set_value name="$result.$ProfitThreshold" exact="$profitThreshold"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Create Trade Object -->
    <library name="GT_CreateTradeObject" purpose="run_actions">
      <params>
        <param name="sellOffer" comment="Sell offer"/>
        <param name="buyOffer" comment="Buy offer"/>
        <param name="sellStation" comment="Sell station"/>
        <param name="buyStation" comment="Buy station"/>
        <param name="amount" comment="Trade amount"/>
        <param name="profit" comment="Trade profit"/>
        <param name="roi" comment="Trade ROI"/>
        <param name="efficiency" comment="Trade efficiency score"/>
        <param name="buyPrice" comment="Buy price"/>
        <param name="sellPrice" comment="Sell price"/>
        <param name="distance" default="0" comment="Route distance"/>
        <param name="risk" default="0" comment="Trade risk"/>
      </params>
      <actions>
        <set_value name="$trade" exact="table[
          $BuyOffer = $sellOffer,
          $SellOffer = $buyOffer,
          $BuyStation = $sellStation,
          $SellStation = $buyStation,
          $Amount = $amount,
          $Profit = $profit,
          $ROI = $roi,
          $Score = $efficiency,
          $BuyPrice = $buyPrice,
          $SellPrice = $sellPrice,
          $Distance = $distance,
          $Risk = $risk
        ]"/>
        <return value="$trade"/>
      </actions>
    </library>
    
    <!-- Add Intra-Sector Offers -->
    <library name="GT_AddIntraSectorOffers" purpose="run_actions">
      <params>
        <param name="originalSellOffers" comment="Original sell offers before limiting"/>
        <param name="originalBuyOffers" comment="Original buy offers before limiting"/>
        <param name="limitedSellOffers" comment="Limited sell offers (will be modified)"/>
        <param name="limitedBuyOffers" comment="Limited buy offers (will be modified)"/>
        <param name="currentSector" comment="Current sector"/>
        <param name="currentSectorIsBlacklisted" default="false" comment="Is current sector blacklisted"/>
      </params>
      <actions>
        <set_value name="$addedSellCount" exact="0"/>
        <set_value name="$addedBuyCount" exact="0"/>
        
        <!-- Only add intra-sector offers if current sector is not blacklisted -->
        <do_if value="$currentSector? and not $currentSectorIsBlacklisted">
          <!-- Scan original sell offers for intra-sector ones not in limited list -->
          <do_all exact="$originalSellOffers.count" counter="$idx">
            <set_value name="$offer" exact="$originalSellOffers.{$idx}"/>
            <set_value name="$offerSector" exact="@$offer.owner.sector"/>
            <do_if value="$offerSector? and $offerSector == $currentSector">
              <!-- Check if already in limited list -->
              <set_value name="$alreadyIncluded" exact="false"/>
              <do_all exact="$limitedSellOffers.count" counter="$checkIdx">
                <do_if value="$limitedSellOffers.{$checkIdx} == $offer">
                  <set_value name="$alreadyIncluded" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
              <!-- Add if not already included -->
              <do_if value="not $alreadyIncluded">
                <append_to_list name="$limitedSellOffers" exact="$offer"/>
                <set_value name="$addedSellCount" operation="add"/>
              </do_if>
            </do_if>
          </do_all>
          
          <!-- Scan original buy offers for intra-sector ones not in limited list -->
          <do_all exact="$originalBuyOffers.count" counter="$idx">
            <set_value name="$offer" exact="$originalBuyOffers.{$idx}"/>
            <set_value name="$offerSector" exact="@$offer.owner.sector"/>
            <do_if value="$offerSector? and $offerSector == $currentSector">
              <!-- Check if already in limited list -->
              <set_value name="$alreadyIncluded" exact="false"/>
              <do_all exact="$limitedBuyOffers.count" counter="$checkIdx">
                <do_if value="$limitedBuyOffers.{$checkIdx} == $offer">
                  <set_value name="$alreadyIncluded" exact="true"/>
                  <break/>
                </do_if>
              </do_all>
              <!-- Add if not already included -->
              <do_if value="not $alreadyIncluded">
                <append_to_list name="$limitedBuyOffers" exact="$offer"/>
                <set_value name="$addedBuyCount" operation="add"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Return result table -->
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$UpdatedSellOffers" exact="$limitedSellOffers"/>
        <set_value name="$result.$UpdatedBuyOffers" exact="$limitedBuyOffers"/>
        <set_value name="$result.$AddedSellCount" exact="$addedSellCount"/>
        <set_value name="$result.$AddedBuyCount" exact="$addedBuyCount"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Validate Trade Offer Pair -->
    <library name="GT_ValidateTradeOfferPair" purpose="run_actions">
      <params>
        <param name="sellOffer" comment="Sell offer to validate"/>
        <param name="buyOffer" comment="Buy offer to validate"/>
      </params>
      <actions>
        <!-- Validate sell offer -->
        <set_value name="$sellOfferOwner" exact="@$sellOffer.owner"/>
        <set_value name="$sellOfferPrice" exact="@$sellOffer.unitprice"/>
        <do_if value="not $sellOffer? or not $sellOfferOwner? or not $sellOfferPrice?">
          <return value="false"/>
        </do_if>
        
        <!-- Validate buy offer -->
        <set_value name="$buyOfferOwner" exact="@$buyOffer.owner"/>
        <set_value name="$buyOfferPrice" exact="@$buyOffer.unitprice"/>
        <do_if value="not $buyOffer? or not $buyOfferOwner? or not $buyOfferPrice?">
          <return value="false"/>
        </do_if>
        
        <!-- Different stations only -->
        <do_if value="$sellOfferOwner == $buyOfferOwner">
          <return value="false"/>
        </do_if>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Check Failed Sector Pair -->
    <library name="GT_CheckFailedSectorPair" purpose="run_actions">
      <params>
        <param name="buySector" comment="Buy station sector"/>
        <param name="sellSector" comment="Sell station sector"/>
        <param name="failedTrades" comment="List of failed trades to check against"/>
      </params>
      <actions>
        <set_value name="$isFailed" exact="false"/>
        <do_if value="$failedTrades.count gt 0">
          <do_all exact="$failedTrades.count" counter="$failIdx">
            <set_value name="$failedTrade" exact="$failedTrades.{$failIdx}"/>
            <do_if value="$failedTrade.$BuySector? and $failedTrade.$SellSector?">
              <do_if value="$buySector == $failedTrade.$BuySector and $sellSector == $failedTrade.$SellSector">
                <set_value name="$isFailed" exact="true"/>
                <break/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <return value="$isFailed"/>
      </actions>
    </library>
    
    <!-- Check Route Conflict -->
    <library name="GT_CheckRouteConflict" purpose="run_actions">
      <params>
        <param name="sellStation" comment="Sell station"/>
        <param name="buyStation" comment="Buy station"/>
        <param name="ware" comment="Ware being traded"/>
        <param name="reservedRoutes" comment="List of reserved route keys"/>
      </params>
      <actions>
        <set_value name="$isConflicted" exact="false"/>
        <do_if value="$reservedRoutes.count gt 0">
          <set_value name="$tradeCacheKey" exact="$sellStation.idcode + '_' + $buyStation.idcode + '_' + $ware"/>
          <!-- FIX: Use explicit loop instead of unreliable indexof check -->
          <do_all exact="$reservedRoutes.count" counter="$i">
            <do_if value="$reservedRoutes.{$i} == $tradeCacheKey">
              <set_value name="$isConflicted" exact="true"/>
              <break/>
            </do_if>
          </do_all>
        </do_if>
        <return value="$isConflicted"/>
      </actions>
    </library>
    
    <!-- Update Trade Quota -->
    <library name="GT_UpdateTradeQuota" purpose="run_actions">
      <params>
        <param name="tradesPerWare" comment="Table of trades per ware (may be null or invalid)"/>
        <param name="ware" comment="Ware to update quota for"/>
        <param name="increment" default="1" comment="Amount to increment"/>
      </params>
      <actions>
        <!-- Ensure tradesPerWare is a valid table -->
        <set_value name="$validTable" exact="$tradesPerWare"/>
        <set_value name="$keysCheck" exact="@$validTable.keys"/>
        <set_value name="$countCheck" exact="@$keysCheck.count"/>
        <do_if value="not $countCheck? or $countCheck lt 0">
          <set_value name="$validTable" exact="table[]"/>
        </do_if>
        
        <!-- Get current count for this ware -->
        <set_value name="$currentCount" exact="0"/>
        <do_if value="$validTable.{$ware}?">
          <set_value name="$currentCount" exact="$validTable.{$ware}"/>
        </do_if>
        
        <!-- Update count -->
        <set_value name="$newCount" exact="$currentCount + $increment"/>
        <set_value name="$validTable.{$ware}" exact="$newCount"/>
        
        <!-- Return updated table and new count -->
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$UpdatedTable" exact="$validTable"/>
        <set_value name="$result.$NewCount" exact="$newCount"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Clear Pending Trade Data -->
    <!-- EXTRACTED: Cleanup function for pending trade data to avoid code duplication -->
    <!-- Phase 3: Enhanced to clean up reservations, work items, and scheduler state -->
    <library name="GT_ClearPendingTradeData" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to clear pending trade data for"/>
      </params>
      <actions>
        <!-- Clear pending trade list -->
        <do_if value="global.$GT_PendingTrades? and global.$GT_PendingTrades.{$ship}?">
          <remove_value name="global.$GT_PendingTrades.{$ship}"/>
        </do_if>
        
        <!-- Clear search method tracking -->
        <do_if value="global.$GT_PendingTradesSearchMethod? and global.$GT_PendingTradesSearchMethod.{$ship}?">
          <remove_value name="global.$GT_PendingTradesSearchMethod.{$ship}"/>
        </do_if>

        <!-- Clear active trade tracking (used for failure route bookkeeping) -->
        <do_if value="global.$GT_ActiveTrade? and global.$GT_ActiveTrade.{$ship}?">
          <remove_value name="global.$GT_ActiveTrade.{$ship}"/>
        </do_if>
        
        <!-- Clear fallback flags (trade completed successfully, reset fallback state) -->
        <do_if value="global.$GT_FallbackAttempted? and global.$GT_FallbackAttempted.{$ship}?">
          <remove_value name="global.$GT_FallbackAttempted.{$ship}"/>
        </do_if>
        <do_if value="global.$GT_FallbackLogbookWritten? and global.$GT_FallbackLogbookWritten.{$ship}?">
          <remove_value name="global.$GT_FallbackLogbookWritten.{$ship}"/>
        </do_if>
        
        <!-- Phase 3: Release all reservations for this ship -->
        <!-- CRITICAL: global.$GT_Reservations can exist but be null or a non-table (savegame compatibility / corruption).
             Never access .keys unless it is a real table. -->
        <do_if value="not global.$GT_Reservations? or typeof global.$GT_Reservations != datatype.table">
          <set_value name="global.$GT_Reservations" exact="table[]"/>
        </do_if>
        <set_value name="$reservationKeysCount" exact="@global.$GT_Reservations.keys.count"/>
        <do_if value="$reservationKeysCount != null and $reservationKeysCount gt 0">
          <set_value name="$reservationsToRemove" exact="[]"/>
          <do_all exact="$reservationKeysCount" counter="$i">
            <set_value name="$tradeKey" exact="global.$GT_Reservations.keys.{$i}"/>
            <set_value name="$reservation" exact="global.$GT_Reservations.{$tradeKey}"/>
            <set_value name="$reservedByShip" exact="@$reservation.$Ship"/>
            <do_if value="$reservedByShip == $ship">
              <append_to_list name="$reservationsToRemove" exact="$tradeKey"/>
            </do_if>
          </do_all>
          <do_for_each name="$tradeKeyToRemove" in="$reservationsToRemove">
            <run_actions ref="md.GT_Libraries_General.GT_ReleaseTrade">
              <param name="tradeKey" value="$tradeKeyToRemove"/>
              <param name="reason" value="'ship_destroyed'"/>
              <param name="traceId" value="'0'"/>
            </run_actions>
          </do_for_each>
        </do_if>
        
        <!-- Phase 3: Clean up scheduler work items for this ship -->
        <do_if value="global.$GT_Scheduler?">
          <!-- Remove from work queue -->
          <do_if value="global.$GT_Scheduler.$WorkQueue?">
            <set_value name="$workQueue" exact="global.$GT_Scheduler.$WorkQueue"/>
            <set_value name="$filteredQueue" exact="[]"/>
            <do_all exact="$workQueue.count" counter="$i">
              <set_value name="$workItem" exact="$workQueue.{$i}"/>
              <do_if value="$workItem.$Payload?">
                <set_value name="$workShip" exact="@$workItem.$Payload.$Ship"/>
                <do_if value="$workShip != $ship">
                  <append_to_list name="$filteredQueue" exact="$workItem"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- Keep work items without ship payload (shouldn't happen, but be safe) -->
                <append_to_list name="$filteredQueue" exact="$workItem"/>
              </do_else>
            </do_all>
            <set_value name="global.$GT_Scheduler.$WorkQueue" exact="$filteredQueue"/>
          </do_if>
          
          <!-- Remove from active work (keyed by ship, so direct lookup) -->
          <do_if value="global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.{$ship}?">
            <set_value name="$workItem" exact="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
            <!-- Mark work item as failed -->
            <run_actions ref="md.GT_Libraries_General.GT_UpdateWorkItemState">
              <param name="key" value="if $workItem.$Key? then $workItem.$Key else 'unknown'"/>
              <param name="newState" value="'failed'"/>
              <param name="traceId" value="if $workItem.$TraceId? then $workItem.$TraceId else '0'"/>
              <param name="reason" value="'ship_destroyed'"/>
              <param name="workItem" value="$workItem"/>
            </run_actions>
            <remove_value name="global.$GT_Scheduler.$ActiveWork.{$ship}"/>
          </do_if>
        </do_if>
        
        <!-- Phase 3: Release request registry lock -->
        <run_actions ref="md.GT_Libraries_General.GT_RequestRegistry_Release">
          <param name="ship" value="$ship"/>
          <param name="reason" value="'ship_destroyed'"/>
        </run_actions>
        
        <!-- Phase 3: Clear search state -->
        <do_if value="global.$GT_SearchLiveTrades_State? and global.$GT_SearchLiveTrades_State.{$ship}?">
          <remove_value name="global.$GT_SearchLiveTrades_State.{$ship}"/>
        </do_if>
        
        <!-- Phase 3: Clear batch data -->
        <do_if value="global.$GT_BatchDataList? and global.$GT_BatchDataList.{$ship}?">
          <remove_value name="global.$GT_BatchDataList.{$ship}"/>
        </do_if>
        <do_if value="global.$GT_BatchResultsList? and global.$GT_BatchResultsList.{$ship}?">
          <remove_value name="global.$GT_BatchResultsList.{$ship}"/>
        </do_if>
        
        <!-- Phase 3: Clear AI parameters -->
        <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}?">
          <remove_value name="global.$GT_AIParameters.{$ship}"/>
        </do_if>
        
        <!-- Phase 4: Clear scheduler entry queue (GT_TS) -->
        <do_if value="global.$GT_TS?">
          <!-- Remove from queue list -->
          <do_if value="global.$GT_TS.$Queue? and global.$GT_TS.$Queue.count gt 0">
            <remove_from_list name="global.$GT_TS.$Queue" exact="$ship"/>
          </do_if>
          <!-- Remove queue markers -->
          <do_if value="global.$GT_TS.$Queued? and global.$GT_TS.$Queued.{$ship}?">
            <remove_value name="global.$GT_TS.$Queued.{$ship}"/>
          </do_if>
          <!-- Remove enqueue timestamp -->
          <do_if value="global.$GT_TS.$EnqueuedAt? and global.$GT_TS.$EnqueuedAt.{$ship}?">
            <remove_value name="global.$GT_TS.$EnqueuedAt.{$ship}"/>
          </do_if>
          <!-- Remove request params -->
          <do_if value="global.$GT_TS.$Requests? and global.$GT_TS.$Requests.{$ship}?">
            <remove_value name="global.$GT_TS.$Requests.{$ship}"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- CACHE UTILITIES -->
    <!-- ========================================= -->
    
    <!-- Calculate Total Cache Count -->
    <library name="GT_CalculateTotalCacheCount" purpose="run_actions">
      <params>
      </params>
      <actions>
        <!-- PERFORMANCE OPTIMIZATION v5: Calculate total cache count from all home sectors -->
        <!-- global.$GT_TradeCache is now a table indexed by home sector -->
        <!-- Returns total count of all trades across all home sector caches -->
        <set_value name="$totalCount" exact="0"/>
        <do_if value="global.$GT_TradeCache?">
          <!-- Prefer explicit home registry (more reliable than .keys in some saves) -->
          <set_value name="$homes" exact="[]"/>
          <do_if value="global.$GT_TradeCacheHomes?">
            <set_value name="$homes" exact="@global.$GT_TradeCacheHomes"/>
          </do_if>
          <do_else>
            <set_value name="$homes" exact="@global.$GT_TradeCache.keys"/>
            <do_if value="$homes == null">
              <set_value name="$homes" exact="[]"/>
            </do_if>
          </do_else>
          
          <do_all exact="$homes.count" counter="$sectorIdx">
            <set_value name="$home" exact="$homes.{$sectorIdx}"/>
            <set_value name="$sectorCache" exact="@global.$GT_TradeCache.{$home}"/>
            <do_if value="$sectorCache != null">
              <set_value name="$totalCount" exact="$totalCount + $sectorCache.count"/>
            </do_if>
          </do_all>
        </do_if>
        <return value="$totalCount"/>
      </actions>
    </library>
    
    <!-- Get Home Sector Cache -->
    <library name="GT_GetHomeSectorCache" purpose="run_actions">
      <params>
        <param name="homeSector" comment="Home sector to get cache for"/>
      </params>
      <actions>
        <!-- Returns the cache list for a specific home sector, or null if not found -->
        <!-- PERFORMANCE OPTIMIZATION v5: Per-home-sector cache -->
        <set_value name="$cache" exact="null"/>
        <!-- IMPORTANT: don't use @ with .exists in boolean expressions -->
        <set_value name="$homeSectorObj" exact="$homeSector"/>
        <do_if value="$homeSectorObj? and $homeSectorObj.exists and global.$GT_TradeCache? and global.$GT_TradeCache.{$homeSectorObj}?">
          <set_value name="$cache" exact="global.$GT_TradeCache.{$homeSectorObj}"/>
        </do_if>
        <return value="$cache"/>
      </actions>
    </library>

    <!-- Purge cache entries by offer-pair across ALL home-sector caches -->
    <!-- Motivation:
         With per-home-sector caching, the same BuyOffer/SellOffer pair can be cached under multiple home sectors.
         If we only remove from the executing ship's home sector, other home caches retain stale entries and ships revalidate "ghost" trades.
         This helper removes matching entries from:
           - global.$GT_TradeCache.{home}
           - global.$GT_TradeCacheByWare.{home}.{wareKey} (best-effort for both ware object key and ware.id string key) -->
    <library name="GT_PurgeCacheOfferPair_AllHomes" purpose="run_actions">
      <params>
        <param name="ship" default="null" comment="Ship for logging context (optional)"/>
        <param name="buyOffer" default="null" comment="Buy offer object (may be null for sell-only)"/>
        <param name="sellOffer" comment="Sell offer object (required)"/>
        <param name="reason" default="'unknown'" comment="Reason for purge (debug)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <set_value name="$removedTotal" exact="0"/>

        <!-- Validate required offer handle -->
        <do_if value="$sellOffer == null">
          <return value="table[$Removed = 0, $Homes = 0, $UsedIndex = false]"/>
        </do_if>

        <!-- PHASE 1: Use index-based lookup (O(1)) - ERROR if index missing -->
        <set_value name="$usedIndex" exact="false"/>
        <set_value name="$homes" exact="[]"/>
        
        <!-- Generate trade key -->
        <!-- CRITICAL: Validate sellOffer has valid ID before generating trade key -->
        <set_value name="$tradeKey" exact="''"/>
        <set_value name="$sellOfferIdValid" exact="false"/>
        
        <!-- Validate sellOffer exists and has valid ID -->
        <do_if value="$sellOffer? and $sellOffer != null and $sellOffer.exists">
          <set_value name="$tempSellId" exact="@$sellOffer.id"/>
          <do_if value="$tempSellId? and $tempSellId != null">
            <set_value name="$sellOfferIdValid" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Only generate trade key if sellOffer has valid ID -->
        <do_if value="$sellOfferIdValid">
          <run_actions ref="md.GT_Libraries_General.GT_GenerateTradeKey" result="$tradeKey">
            <param name="buyOffer" value="$buyOffer"/>
            <param name="sellOffer" value="$sellOffer"/>
            <param name="traceId" value="$traceId"/>
          </run_actions>
        </do_if>
        
        <!-- Validate trade key was generated -->
        <!-- CRITICAL FIX: This is expected behavior when offers become invalid - log as INFO, not ERROR -->
        <do_if value="$tradeKey == ''">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheInvalidate'"/>
              <param name="action" value="'Info'"/>
              <param name="details" value="'reason=invalid_tradeKey reason=' + $reason + ' note=expected_when_offers_become_invalid'"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-INFO] GT_PurgeCacheOfferPair_AllHomes: Failed to generate trade key - cannot invalidate cache (offer may have been removed, trade executed but cache purge skipped)'" chance="100"/>
          </do_else>
          <return value="table[$Removed = 0, $Homes = 0, $UsedIndex = false]"/>
        </do_if>
        
        <!-- Validate index exists -->
        <do_if value="not global.$GT_TradeIndex?">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheInvalidate'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=index_not_initialized trade=' + $tradeKey + ' reason=' + $reason"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_PurgeCacheOfferPair_AllHomes: Trade index not initialized - tradeKey=' + $tradeKey" chance="100"/>
          </do_else>
          <return value="table[$Removed = 0, $Homes = 0, $UsedIndex = false]"/>
        </do_if>
        
        <!-- Look up homes from index -->
        <run_actions ref="md.GT_Libraries_General.GT_GetTradeIndexHomes" result="$indexHomes">
          <param name="tradeKey" value="$tradeKey"/>
        </run_actions>
        
        <!-- Validate index lookup returned valid result -->
        <do_if value="not $indexHomes?">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheInvalidate'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=index_lookup_failed trade=' + $tradeKey + ' reason=' + $reason"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_PurgeCacheOfferPair_AllHomes: Index lookup returned null - tradeKey=' + $tradeKey" chance="100"/>
          </do_else>
          <return value="table[$Removed = 0, $Homes = 0, $UsedIndex = false]"/>
        </do_if>
        
        <!-- Use index homes -->
        <set_value name="$homes" exact="$indexHomes"/>
        <set_value name="$usedIndex" exact="true"/>
        
        <!-- Log index-based invalidation -->
        <do_if value="$traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'CacheInvalidate'"/>
            <param name="action" value="'IndexLookup'"/>
            <param name="details" value="'trade=' + $tradeKey + ' homes=' + $homes.count + ' reason=' + $reason"/>
            <param name="logLevel" value="1"/>
          </run_actions>
        </do_if>
        
        <!-- ERROR if index lookup returned empty list but trade should exist -->
        <do_if value="$homes.count == 0">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheInvalidate'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=index_entry_not_found trade=' + $tradeKey + ' reason=' + $reason"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_PurgeCacheOfferPair_AllHomes: Trade not found in index - tradeKey=' + $tradeKey + ' (trade may not be cached or index incomplete)'" chance="100"/>
          </do_else>
          <!-- Continue with empty homes list - will result in 0 removals, which is correct -->
        </do_if>

        <do_all exact="$homes.count" counter="$hi">
          <set_value name="$home" exact="$homes.{$hi}"/>
          <do_if value="$home? and global.$GT_TradeCache? and global.$GT_TradeCache.{$home}?">
            <set_value name="$sectorCache" exact="global.$GT_TradeCache.{$home}"/>
            <do_all exact="$sectorCache.count" counter="$i" reverse="true">
              <set_value name="$entry" exact="$sectorCache.{$i}"/>
              <do_if value="$entry != null">
                <set_value name="$buyOfferMatches" exact="false"/>
                <set_value name="$sellOfferMatches" exact="false"/>

                <!-- Sell-only match: buyOffer is null => only match sell offer -->
                <do_if value="$buyOffer == null">
                  <set_value name="$buyOfferMatches" exact="true"/>
                  <do_if value="$entry.$SellOffer? and $entry.$SellOffer == $sellOffer">
                    <set_value name="$sellOfferMatches" exact="true"/>
                  </do_if>
                </do_if>
                <do_else>
                  <do_if value="$entry.$BuyOffer? and $entry.$BuyOffer == $buyOffer">
                    <set_value name="$buyOfferMatches" exact="true"/>
                  </do_if>
                  <do_if value="$entry.$SellOffer? and $entry.$SellOffer == $sellOffer">
                    <set_value name="$sellOfferMatches" exact="true"/>
                  </do_if>
                </do_else>

                <do_if value="$buyOfferMatches and $sellOfferMatches">
                  <!-- Remove from main cache -->
                  <remove_value name="global.$GT_TradeCache.{$home}.{$i}"/>
                  <set_value name="$removedTotal" operation="add"/>

                  <!-- Best-effort: remove from per-ware index (handles both ware-object keys and legacy ware-id keys) -->
                  <do_if value="global.$GT_TradeCacheByWare? and global.$GT_TradeCacheByWare.{$home}?">
                    <set_value name="$wareObj" exact="null"/>
                    <set_value name="$wareIdKey" exact="null"/>
                    <do_if value="$entry.$BuyOffer?">
                      <set_value name="$wareObj" exact="@$entry.$BuyOffer.ware"/>
                      <do_if value="$wareObj?">
                        <set_value name="$wareIdKey" exact="@$wareObj.id"/>
                      </do_if>
                    </do_if>
                    <do_elseif value="$entry.$WareId?">
                      <set_value name="$wareIdKey" exact="@$entry.$WareId"/>
                    </do_elseif>

                    <!-- Remove by ware object key -->
                    <do_if value="$wareObj? and global.$GT_TradeCacheByWare.{$home}.{$wareObj}?">
                      <remove_from_list name="global.$GT_TradeCacheByWare.{$home}.{$wareObj}" exact="$entry"/>
                    </do_if>
                    <!-- Remove by ware id key (legacy / mixed saves) -->
                    <do_if value="$wareIdKey? and global.$GT_TradeCacheByWare.{$home}.{$wareIdKey}?">
                      <remove_from_list name="global.$GT_TradeCacheByWare.{$home}.{$wareIdKey}" exact="$entry"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>

            <!-- Clean up empty home cache lists -->
            <do_if value="global.$GT_TradeCache.{$home}? and global.$GT_TradeCache.{$home}.count == 0">
              <remove_value name="global.$GT_TradeCache.{$home}"/>
              <do_if value="global.$GT_TradeCacheByWare? and global.$GT_TradeCacheByWare.{$home}?">
                <remove_value name="global.$GT_TradeCacheByWare.{$home}"/>
              </do_if>
            </do_if>
          </do_if>
        </do_all>

        <!-- PHASE 1: Remove from index after invalidation -->
        <do_if value="$tradeKey != '' and $removedTotal gt 0">
          <run_actions ref="md.GT_Libraries_General.GT_RemoveTradeFromIndex">
            <param name="tradeKey" value="$tradeKey"/>
            <param name="homeSector" value="null"/>
            <param name="traceId" value="$traceId"/>
          </run_actions>
        </do_if>
        
        <!-- Log invalidation completion -->
        <do_if value="$traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'CacheInvalidate'"/>
            <param name="action" value="'Complete'"/>
            <param name="details" value="'trade=' + (if $tradeKey != '' then $tradeKey else 'unknown') + ' removed=' + $removedTotal + ' homes=' + $homes.count + ' usedIndex=' + (if $usedIndex then 'true' else 'false') + ' reason=' + $reason"/>
            <param name="logLevel" value="1"/>
          </run_actions>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$shipId" exact="if $ship != null then $ship.idcode else 'N/A'"/>
          <debug_text text="'[GT-Cache] Purged offer-pair across homes: removed=' + $removedTotal + ', homes=' + $homes.count + ', ship=' + $shipId + ', reason=' + $reason + ', usedIndex=' + $usedIndex" chance="100"/>
        </do_if>

        <return value="table[$Removed = $removedTotal, $Homes = $homes.count, $UsedIndex = $usedIndex]"/>
      </actions>
    </library>

    <!-- Pick Best Cached Trade (lightweight, hard-budget friendly) -->
    <!-- Design:
         - Cache list is already sorted by Profit desc (insertion sort at write time).
         - Validate only the top N entries (default 5) and return the first valid one.
         - This is intentionally much cheaper than SearchCachedTrades' deep diagnostics/statistics.
         - Blacklist/route failures are still handled by AI feedback (ForceLiveSearch) + failed sector pairs. -->
    <library name="GT_TS_CachePickBest" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship requesting a trade"/>
        <param name="homeSector" comment="Home sector anchor for range validation"/>
        <param name="maxDistance" comment="Max allowed distance from home sector (jumps)"/>
        <param name="minROI" default="0" comment="Minimum ROI percent"/>
        <param name="minAbsoluteProfit" default="0Cr" comment="Minimum absolute profit"/>
        <param name="ignoreBuildStorage" default="false" comment="Skip build storage targets"/>
        <param name="ignoreCarrierAux" default="false" comment="Skip carrier/aux targets"/>
        <param name="maxEntries" default="5" comment="Minimum number of top cache entries to validate. Will be increased automatically if maxReturnTrades requires more entries (to account for filtered invalid entries)."/>
        <param name="cacheMaxAge" default="600s" comment="TTL for cache entries"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <set_value name="$result" exact="table[
          $Found = false,
          $Trade = null,
          $BestScore = 0,
          $Trades = []
        ]"/>

        <!-- Return up to MaxTradesToReturn valid candidates (configurable via global settings).
             This prevents fleet-coordination claim-check from stalling when the best trade is already reserved. -->
        <set_value name="$validTrades" exact="[]"/>
        <set_value name="$maxReturnTrades" exact="20"/> <!-- Default fallback -->
        <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn?">
          <set_value name="$maxReturnTrades" exact="global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn"/>
        </do_if>
        <!-- Clamp to valid range (1-100) -->
        <do_if value="$maxReturnTrades lt 1">
          <set_value name="$maxReturnTrades" exact="1"/>
        </do_if>
        <do_if value="$maxReturnTrades gt 100">
          <set_value name="$maxReturnTrades" exact="100"/>
        </do_if>

        <!-- IMPORTANT: don't use @ with .exists in boolean expressions; split into safe object + exists check -->
        <set_value name="$homeSectorObj" exact="$homeSector"/>
        <do_if value="not $ship? or not $ship.exists or not $homeSectorObj? or not $homeSectorObj.exists">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheQuery'"/>
              <param name="action" value="'InvalidParams'"/>
              <param name="details" value="'ship=' + (if $ship? then $ship.idcode else 'null') + ' homeSector=' + (if $homeSectorObj? then 'valid' else 'null')"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          <return value="$result"/>
        </do_if>

        <do_if value="not global.$GT_TradeCache? or not global.$GT_TradeCache.{$homeSector}?">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheQuery'"/>
              <param name="action" value="'Miss'"/>
              <param name="details" value="'reason=no_cache_for_sector'"/>
              <param name="logLevel" value="1"/>
            </run_actions>
          </do_if>
          <return value="$result"/>
        </do_if>

        <set_value name="$cache" exact="global.$GT_TradeCache.{$homeSector}"/>
        <do_if value="$cache == null or $cache.count le 0">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheQuery'"/>
              <param name="action" value="'Miss'"/>
              <param name="details" value="'reason=empty_cache count=' + (if $cache? then $cache.count else '0')"/>
              <param name="logLevel" value="1"/>
            </run_actions>
          </do_if>
          <return value="$result"/>
        </do_if>

        <!-- Log cache query start -->
        <do_if value="$traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'CacheQuery'"/>
            <param name="action" value="'Start'"/>
            <param name="details" value="'cacheCount=' + $cache.count + ' maxEntries=' + $maxEntries + ' maxReturnTrades=' + $maxReturnTrades"/>
            <param name="logLevel" value="2"/>
          </run_actions>
        </do_if>

        <!-- CRITICAL: maxEntries must be at least maxReturnTrades to allow returning multiple trades.
             If maxEntries < maxReturnTrades, we can only return as many trades as entries validated.
             Add buffer (2x) to account for invalid entries that get filtered out. -->
        <set_value name="$effectiveMaxEntries" exact="[$maxEntries, $maxReturnTrades * 2].max"/>
        <set_value name="$limit" exact="[$cache.count, $effectiveMaxEntries].min"/>
        <set_value name="$shipDockSize" exact="$ship.docksize"/>

        <!-- Respect illegal-wares setting: if not allowed, skip illegal cache entries entirely (no execution-time rejection). -->
        <set_value name="$allowIllegal" exact="@global.$GT_AIParameters.{$ship}.$AllowIllegal"/>
        <do_if value="$allowIllegal == null">
          <set_value name="$allowIllegal" exact="false"/>
        </do_if>

        <!-- Prefer entries with the lowest FailCount; skip entries already failed by this ship. -->
        <set_value name="$minFailCount" exact="999999"/>

        <!-- Determine blacklist group once (used for reachability check) -->
        <run_actions ref="md.GT_Libraries_Blacklist.GT_GetBlacklistGroup" result="$blacklistgroup">
          <param name="ship" value="$ship"/>
        </run_actions>

        <!-- CRITICAL: Load GT_FailedSectorPairs for ship's current sector (prefilter failed sector pairs) -->
        <!-- This prevents revalidating entries that previously failed due to blacklisted routes -->
        <!-- Ships in the same sector share failed sector pairs (same connectivity/blacklist context) -->
        <!-- Ships in different sectors may still try (different path might exist) -->
        <set_value name="$currentSector" exact="$ship.sector"/>
        <set_value name="$failedTrades" exact="[]"/>
        <do_if value="$currentSector? and $currentSector.exists and global.$GT_FailedSectorPairs? and global.$GT_FailedSectorPairs.{$currentSector}?">
          <set_value name="$failedTradesRaw" exact="global.$GT_FailedSectorPairs.{$currentSector}"/>
          <set_value name="$failedTradesExpired" exact="[]"/>
          <set_value name="$expirationTime" exact="1800s"/> <!-- 30 minutes -->
          
          <!-- Filter out expired entries -->
          <do_all exact="$failedTradesRaw.count" counter="$f">
            <set_value name="$failedTrade" exact="$failedTradesRaw.{$f}"/>
            <set_value name="$tradeAge" exact="player.age - $failedTrade.$Timestamp"/>
            <do_if value="$tradeAge le $expirationTime">
              <!-- Entry still valid - keep it -->
              <append_to_list name="$failedTrades" exact="$failedTrade"/>
            </do_if>
            <do_else>
              <!-- Entry expired - mark for removal -->
              <append_to_list name="$failedTradesExpired" exact="$f"/>
            </do_else>
          </do_all>
          
          <!-- Update global storage with cleaned list -->
          <do_if value="$failedTradesExpired.count gt 0">
            <set_value name="global.$GT_FailedSectorPairs.{$currentSector}" exact="$failedTrades"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$sectorName" exact="@$currentSector.knownname"/>
              <debug_text text="'[GT-Cache] Cleaned ' + $failedTradesExpired.count + ' expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (older than 30 minutes)'" chance="100"/>
            </do_if>
          </do_if>
          <do_elseif value="$failedTrades.count == 0">
            <!-- All entries expired - clear the list entirely -->
            <remove_value name="global.$GT_FailedSectorPairs.{$currentSector}"/>
          </do_elseif>
        </do_if>

        <do_all exact="$limit" counter="$i">
          <set_value name="$entry" exact="$cache.{$i}"/>

          <!-- Structure + TTL -->
          <do_if value="$entry == null or not $entry.$BuyOffer? or not $entry.$SellOffer? or not $entry.$Timestamp?">
            <continue/>
          </do_if>
          <do_if value="player.age - $entry.$Timestamp gt $cacheMaxAge">
            <continue/>
          </do_if>

          <!-- Offers + stations still valid -->
          <do_if value="not $entry.$BuyOffer.exists or not $entry.$SellOffer.exists">
            <continue/>
          </do_if>
          <do_if value="not $entry.$BuyOffer.available or not $entry.$SellOffer.available">
            <continue/>
          </do_if>
          <do_if value="not @$entry.$BuyOffer.owner.isoperational or not @$entry.$SellOffer.owner.isoperational">
            <continue/>
          </do_if>

          <!-- Docking permission (ship-specific): skip entries this ship cannot dock at.
               Vanilla property is dockingallowed.{$ship} (see x4Original/libraries/scriptproperties.xml). -->
          <do_if value="not @$entry.$BuyOffer.owner.dockingallowed.{$ship} or not @$entry.$SellOffer.owner.dockingallowed.{$ship}">
            <continue/>
          </do_if>

          <!-- Illegal-ware filter (ship setting). -->
          <!-- FIX: Explicit gt 0 check to ensure legal wares (illegal=0) are not filtered -->
          <do_if value="not $allowIllegal">
            <set_value name="$ware" exact="@$entry.$BuyOffer.ware"/>
            <do_if value="$ware != null and @$ware.illegal gt 0">
              <continue/>
            </do_if>
          </do_if>

          <!-- Failure-distribution filter: skip if this ship already failed this entry. -->
          <set_value name="$failedShips" exact="@$entry.$FailedShips"/>
          <do_if value="$failedShips == null">
            <set_value name="$failedShips" exact="[]"/>
          </do_if>
          <set_value name="$shipAlreadyFailedThisEntry" exact="false"/>
          <do_all exact="$failedShips.count" counter="$f">
            <do_if value="$failedShips.{$f} == $ship">
              <set_value name="$shipAlreadyFailedThisEntry" exact="true"/>
              <break/>
            </do_if>
          </do_all>
          <do_if value="$shipAlreadyFailedThisEntry">
            <continue/>
          </do_if>

          <!-- CRITICAL: Prefilter by GT_FailedSectorPairs - skip sector pairs that previously failed from this sector -->
          <!-- This prevents revalidating entries that will fail due to blacklisted routes -->
          <!-- Ships in the same sector share failed sector pairs (same connectivity/blacklist context) -->
          <!-- One failure in a sector pair blocks ALL station combinations in that route for ships in this sector -->
          <set_value name="$skipFailedSectorPair" exact="false"/>
          <do_if value="$failedTrades.count gt 0">
            <set_value name="$entryBuySector" exact="$entry.$BuyOffer.owner.sector"/>
            <set_value name="$entrySellSector" exact="$entry.$SellOffer.owner.sector"/>
            <do_all exact="$failedTrades.count" counter="$failIdx">
              <set_value name="$failedTrade" exact="$failedTrades.{$failIdx}"/>
              <!-- CRITICAL: Validate failed trade has complete sector data before comparing -->
              <do_if value="$failedTrade.$BuySector? and $failedTrade.$SellSector?">
                <do_if value="$entryBuySector == $failedTrade.$BuySector and $entrySellSector == $failedTrade.$SellSector">
                  <set_value name="$skipFailedSectorPair" exact="true"/>
                  <break/>
                </do_if>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$skipFailedSectorPair">
            <!-- Debug logging: cache entry skipped due to failed sector pair -->
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$entryBuySectorName" exact="@$entryBuySector.knownname"/>
              <set_value name="$entrySellSectorName" exact="@$entrySellSector.knownname"/>
              <set_value name="$currentSectorName" exact="@$currentSector.knownname"/>
              <debug_text text="'[GT-Cache] Skipped cache entry (failed sector pair): ' + $ship.idcode + 
                ' | Sector: ' + (if $currentSectorName? then $currentSectorName else 'Unknown') + 
                ' | Route: ' + (if $entryBuySectorName? then $entryBuySectorName else 'Unknown') + ' → ' + (if $entrySellSectorName? then $entrySellSectorName else 'Unknown') + 
                ' | Previously failed from this sector (blacklisted route)'" 
                chance="100"/>
            </do_if>
            <continue/> <!-- Skip this entry - sector pair previously failed due to blacklisted route -->
          </do_if>

          <set_value name="$failCount" exact="@$entry.$FailCount"/>
          <do_if value="$failCount == null">
            <set_value name="$failCount" exact="0"/>
          </do_if>

          <!-- Range validation (prefer precomputed distances) -->
          <set_value name="$homeToBuy" exact="@$entry.$HomeToBuyDistance"/>
          <set_value name="$homeToSell" exact="@$entry.$HomeToSellDistance"/>
          <do_if value="not $homeToBuy? or not $homeToSell?">
            <set_value name="$homeToBuy" exact="$homeSector.gatedistance.{$entry.$BuyOffer.owner.sector}"/>
            <set_value name="$homeToSell" exact="$homeSector.gatedistance.{$entry.$SellOffer.owner.sector}"/>
          </do_if>
          <set_value name="$maxHomeDist" exact="[$homeToBuy, $homeToSell].max"/>
          <do_if value="$homeToBuy lt 0 or $homeToSell lt 0 or $maxHomeDist gt $maxDistance">
            <continue/>
          </do_if>

          <!-- Target-type filters -->
          <do_if value="$ignoreBuildStorage or $ignoreCarrierAux">
            <set_value name="$buyType" exact="@$entry.$BuyTargetType"/>
            <set_value name="$sellType" exact="@$entry.$SellTargetType"/>
            <do_if value="$ignoreBuildStorage and ($buyType == 'Buildstorage' or $sellType == 'Buildstorage')">
              <continue/>
            </do_if>
            <do_elseif value="$ignoreCarrierAux and (($buyType == 'Aux' or $buyType == 'Carrier') or ($sellType == 'Aux' or $sellType == 'Carrier'))">
              <continue/>
            </do_elseif>
          </do_if>

          <!-- Dock size compatibility (use cached caps if present) -->
          <set_value name="$buyCaps" exact="@$entry.$BuyDockCaps"/>
          <set_value name="$sellCaps" exact="@$entry.$SellDockCaps"/>
          <do_if value="$buyCaps == null or $sellCaps == null">
            <continue/>
          </do_if>
          <do_if value="$shipDockSize == tag.dock_s and (not $buyCaps.$S or not $sellCaps.$S)">
            <continue/>
          </do_if>
          <do_elseif value="$shipDockSize == tag.dock_m and (not $buyCaps.$M or not $sellCaps.$M)">
            <continue/>
          </do_elseif>
          <do_elseif value="$shipDockSize == tag.dock_l and (not $buyCaps.$L or not $sellCaps.$L)">
            <continue/>
          </do_elseif>
          <do_elseif value="$shipDockSize == tag.dock_xl and (not $buyCaps.$XL or not $sellCaps.$XL)">
            <continue/>
          </do_elseif>

          <!-- Profit thresholds -->
          <set_value name="$profit" exact="@$entry.$Profit"/>
          <set_value name="$roi" exact="@$entry.$ROI"/>
          <do_if value="$profit == null">
            <set_value name="$profit" exact="0Cr"/>
          </do_if>
          <do_if value="$roi == null">
            <set_value name="$roi" exact="0"/>
          </do_if>
          <do_if value="$profit lt $minAbsoluteProfit or $roi lt $minROI">
            <continue/>
          </do_if>

          <!-- Live offer sanity: cached trade entries can become stale under fleet load.
               Ensure current offers are still available AND have enough amount for this trade. -->
          <set_value name="$tradeAmount" exact="@$entry.$Amount"/>
          <do_if value="$tradeAmount == null or $tradeAmount le 0">
            <continue/>
          </do_if>
          <set_value name="$buyOfferObj" exact="@$entry.$BuyOffer"/>
          <set_value name="$sellOfferObj" exact="@$entry.$SellOffer"/>
          <do_if value="not $buyOfferObj? or $buyOfferObj == null or not $buyOfferObj.exists or not $sellOfferObj? or $sellOfferObj == null or not $sellOfferObj.exists">
            <continue/>
          </do_if>
          <set_value name="$buyAvailNow" exact="@$buyOfferObj.available"/>
          <set_value name="$sellAvailNow" exact="@$sellOfferObj.available"/>
          <set_value name="$buyAmtNow" exact="@$buyOfferObj.amount"/>
          <set_value name="$sellAmtNow" exact="@$sellOfferObj.amount"/>
          <do_if value="$buyAmtNow == null">
            <set_value name="$buyAmtNow" exact="0"/>
          </do_if>
          <do_if value="$sellAmtNow == null">
            <set_value name="$sellAmtNow" exact="0"/>
          </do_if>
          <do_if value="not $buyAvailNow or not $sellAvailNow or $buyAmtNow lt $tradeAmount or $sellAmtNow lt $tradeAmount">
            <continue/>
          </do_if>

          <!-- Reachability (cheap sanity): ship to buy-sector must have a path (blacklist-aware) -->
          <set_value name="$buySector" exact="$entry.$BuyOffer.owner.sector"/>
          <set_value name="$shipToBuy" exact="$ship.gatedistance.{$buySector}.{$blacklistgroup}.{$ship}"/>
          <do_if value="$shipToBuy lt 0">
            <continue/>
          </do_if>

          <!-- Phase 3: Reservation check - skip trades reserved by other ships -->
          <set_value name="$entryTradeKey" exact="''"/>
          <run_actions ref="md.GT_Libraries_General.GT_GenerateTradeKey" result="$entryTradeKey">
            <param name="buyOffer" value="$entry.$BuyOffer"/>
            <param name="sellOffer" value="$entry.$SellOffer"/>
            <param name="traceId" value="$traceId"/>
          </run_actions>
          
          <do_if value="$entryTradeKey != ''">
            <run_actions ref="md.GT_Libraries_General.GT_IsTradeReserved" result="$isReserved">
              <param name="tradeKey" value="$entryTradeKey"/>
              <param name="ship" value="$ship"/>
              <param name="traceId" value="$traceId"/>
            </run_actions>
            <do_if value="$isReserved">
              <!-- Trade is reserved by another ship - skip it -->
              <continue/>
            </do_if>
          </do_if>

          <!-- Build canonical trade object for execution -->
          <set_value name="$trade" exact="table[
            $BuyOffer = $entry.$BuyOffer,
            $SellOffer = $entry.$SellOffer,
            $Amount = $entry.$Amount,
            $BuyPrice = $entry.$BuyPrice,
            $SellPrice = $entry.$SellPrice,
            $Profit = $entry.$Profit,
            $ROI = $entry.$ROI,
            $Distance = $entry.$Distance,
            $Score = $entry.$Profit
          ]"/>

          <!-- Collect candidate(s) with the LOWEST failcount only (tie-breaker keeps profit order from cache). -->
          <do_if value="$failCount lt $minFailCount">
            <set_value name="$minFailCount" exact="$failCount"/>
            <set_value name="$validTrades" exact="[]"/>
            <append_to_list name="$validTrades" exact="$trade"/>
            <set_value name="$result.$Found" exact="true"/>
            <set_value name="$result.$Trade" exact="$trade"/>
            <set_value name="$result.$BestScore" exact="$trade.$Score"/>
          </do_if>
          <do_elseif value="$failCount == $minFailCount and $validTrades.count lt $maxReturnTrades">
            <append_to_list name="$validTrades" exact="$trade"/>
          </do_elseif>

          <!-- Stop early once we have enough candidates at the optimal failcount (0 is best possible). -->
          <do_if value="$minFailCount == 0 and $validTrades.count ge $maxReturnTrades">
            <break/>
          </do_if>
        </do_all>

        <!-- Debug: explain why small candidate lists happen (top-N validation + filters + maxReturnTrades cap) -->
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-Cache] (' + $ship.idcode + ') CachePickBest summary: cacheCount=' + $cache.count +
            ', maxReturnTrades=' + $maxReturnTrades +
            ', effectiveMaxEntries=' + $effectiveMaxEntries +
            ', validatedTop=' + $limit +
            ', returned=' + $validTrades.count +
            ', minFailCount=' + $minFailCount" chance="100"/>
        </do_if>

        <!-- Log cache query result -->
        <do_if value="$traceId != ''">
          <do_if value="$result.$Found">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheQuery'"/>
              <param name="action" value="'Hit'"/>
              <param name="details" value="'trades=' + $validTrades.count + ' bestScore=' + $result.$BestScore + ' validatedTop=' + $limit + ' minFailCount=' + $minFailCount"/>
              <param name="logLevel" value="1"/>
            </run_actions>
          </do_if>
          <do_else>
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheQuery'"/>
              <param name="action" value="'Miss'"/>
              <param name="details" value="'reason=no_valid_trades validatedTop=' + $limit"/>
              <param name="logLevel" value="1"/>
            </run_actions>
          </do_else>
        </do_if>

        <set_value name="$result.$Trades" exact="$validTrades"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Calculate Fallback Distance -->
    <library name="GT_CalculateFallbackDistance" purpose="run_actions">
      <params>
        <param name="maxDistance" comment="Maximum distance (pilot's maxJumps)"/>
        <param name="skillLevel" comment="Pilot skill level (for capping fallback distance)"/>
      </params>
      <actions>
        <!-- Calculates fallback search distance: max(1, min(pilotMaxJumps, maxDistance / 3)) -->
        <!-- Formula: 1/3 of maxDistance, capped by pilot level capability, minimum 1 jump -->
        <!-- This compensates for lower profit thresholds in fallback search -->
        
        <!-- Calculate pilot's max jump capability based on skill level -->
        <set_value name="$pilotMaxJumps" exact="1"/>
        <do_if value="$skillLevel le 2">
          <set_value name="$pilotMaxJumps" exact="1"/>
        </do_if>
        <do_elseif value="$skillLevel le 5">
          <set_value name="$pilotMaxJumps" exact="3"/>
        </do_elseif>
        <do_elseif value="$skillLevel le 8">
          <set_value name="$pilotMaxJumps" exact="5"/>
        </do_elseif>
        <do_elseif value="$skillLevel le 11">
          <set_value name="$pilotMaxJumps" exact="10"/>
        </do_elseif>
        <do_elseif value="$skillLevel le 13">
          <set_value name="$pilotMaxJumps" exact="15"/>
        </do_elseif>
        <do_else>
          <set_value name="$pilotMaxJumps" exact="25"/>
        </do_else>
        
        <!-- Calculate 1/3 of maxDistance -->
        <set_value name="$calculatedDistance" exact="($maxDistance / 3)"/>
        
        <!-- Cap by pilot capability, then ensure minimum of 1 -->
        <set_value name="$fallbackDistance" exact="[$calculatedDistance, $pilotMaxJumps].min"/>
        <set_value name="$fallbackDistance" exact="[$fallbackDistance, 1].max"/>  <!-- Minimum: 1 jump -->
        
        <return value="$fallbackDistance"/>
      </actions>
    </library>
    
    <!-- Check Batch Status -->
    <library name="GT_CheckBatchStatus" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to check batch status for"/>
      </params>
      <actions>
        <!-- Checks if batch processing is in progress and returns status information -->
        <!-- Returns table with: $IsBatchActive, $BatchShip, $ShouldProceed, $IsForThisShip -->
        <set_value name="$waitingForBatch" exact="false"/>
        <set_value name="$batchShip" exact="null"/>
        <do_if value="global.$GT_SearchResult.{$ship}?">
          <set_value name="$shipResults" exact="global.$GT_SearchResult.{$ship}"/>
          <do_if value="$shipResults.$WaitingForBatch? and $shipResults.$WaitingForBatch">
            <set_value name="$waitingForBatch" exact="true"/>
            <do_if value="$shipResults.$Ship?">
              <set_value name="$batchShip" exact="$shipResults.$Ship"/>
            </do_if>
          </do_if>
        </do_if>
        
        <set_value name="$isForThisShip" exact="false"/>
        <do_if value="$waitingForBatch and $batchShip? and $batchShip == $ship">
          <set_value name="$isForThisShip" exact="true"/>
        </do_if>
        
        <set_value name="$shouldProceed" exact="true"/>
        <do_if value="$waitingForBatch and $isForThisShip">
          <set_value name="$shouldProceed" exact="false"/>
        </do_if>
        
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$IsBatchActive" exact="$waitingForBatch"/>
        <set_value name="$result.$BatchShip" exact="$batchShip"/>
        <set_value name="$result.$ShouldProceed" exact="$shouldProceed"/>
        <set_value name="$result.$IsForThisShip" exact="$isForThisShip"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Update Rejection Stats -->
    <library name="GT_UpdateRejectionStats" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to update stats for"/>
        <param name="stats" comment="Rejection statistics table"/>
      </params>
      <actions>
        <!-- Updates LastRejectionStats in global.$GT_SearchResult for a ship -->
        <!-- Preserves existing entries for other ships, updates/adds entry for this ship -->
        <!-- SIMPLIFIED: Initialization guarantees global.$GT_SearchResult exists -->
        <!-- CRITICAL: Validate ship parameter before using it as table key -->
        <do_if value="not $ship?">
          <!-- Ship is null - cannot update stats, exit silently -->
          <return/>
        </do_if>
        
        <set_value name="$existingLastRejectionStats" exact="null"/>
        <do_if value="global.$GT_SearchResult.$LastRejectionStats?">
          <set_value name="$existingLastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats"/>
        </do_if>
        
        <!-- Build new $LastRejectionStats: preserve existing entries, update/add per-ship entry -->
        <set_value name="$newLastRejectionStats" exact="table[]"/>
        <!-- Copy existing entries if valid -->
        <do_if value="$existingLastRejectionStats?">
          <set_value name="$existingStatsKeys" exact="@$existingLastRejectionStats.keys"/>
          <do_if value="$existingStatsKeys?">
            <set_value name="$existingStatsKeysCount" exact="@$existingStatsKeys.count"/>
            <do_if value="$existingStatsKeysCount? and $existingStatsKeysCount gt 0">
              <do_all exact="$existingStatsKeysCount" counter="$k">
                <set_value name="$key" exact="$existingStatsKeys.{$k}"/>
                <do_if value="$key != $ship">
                  <set_value name="$newLastRejectionStats.{$key}" exact="@$existingLastRejectionStats.{$key}"/>
                </do_if>
              </do_all>
            </do_if>
          </do_if>
        </do_if>
        <!-- Add/update per-ship entry -->
        <!-- CRITICAL: $ship is validated above, safe to use as table key -->
        <set_value name="$newLastRejectionStats.{$ship}" exact="$stats"/>
        
        <!-- Build new $searchResultTable: preserve existing properties, set new $LastRejectionStats -->
        <set_value name="$newSearchResultTable" exact="table[$LastRejectionStats = $newLastRejectionStats]"/>
        <!-- Copy other existing properties -->
        <set_value name="$existingSearchResult" exact="global.$GT_SearchResult"/>
        <do_if value="$existingSearchResult?">
          <set_value name="$existingKeys" exact="@$existingSearchResult.keys"/>
          <do_if value="$existingKeys?">
            <set_value name="$existingKeysCount" exact="@$existingKeys.count"/>
            <do_if value="$existingKeysCount? and $existingKeysCount gt 0">
              <do_all exact="$existingKeysCount" counter="$tk">
                <set_value name="$tableKey" exact="$existingKeys.{$tk}"/>
                <do_if value="$tableKey != 'LastRejectionStats'">
                  <set_value name="$newSearchResultTable.{$tableKey}" exact="@$existingSearchResult.{$tableKey}"/>
                </do_if>
              </do_all>
            </do_if>
          </do_if>
        </do_if>
        <!-- Set atomically to global -->
        <set_value name="global.$GT_SearchResult" exact="$newSearchResultTable"/>
      </actions>
    </library>
    
    <!-- Get Price Range -->
    <library name="GT_GetPriceRange" purpose="run_actions">
      <params>
        <param name="shipIsIsolated" default="false" comment="Whether ship is isolated"/>
      </params>
      <actions>
        <!-- Returns price range from config: $sellPriceMax, $buyPriceMin -->
        <!-- For isolated ships, uses isolated-specific price ranges -->
        <set_value name="$sellPriceMax" exact="1.0"/>  <!-- Default fallback: +100% -->
        <set_value name="$buyPriceMin" exact="-1.0"/>  <!-- Default fallback: -100% -->
        <do_if value="global.$GT_Config? and global.$GT_Config.$Trading?">
          <do_if value="$shipIsIsolated">
            <!-- Isolated ships: Use isolated-specific price ranges -->
            <do_if value="global.$GT_Config.$Trading.$IsolatedSellPriceMax?">
              <set_value name="$sellPriceMax" exact="@global.$GT_Config.$Trading.$IsolatedSellPriceMax"/>
            </do_if>
            <do_if value="global.$GT_Config.$Trading.$IsolatedBuyPriceMin?">
              <set_value name="$buyPriceMin" exact="@global.$GT_Config.$Trading.$IsolatedBuyPriceMin"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Normal ships: Use standard price ranges -->
            <do_if value="global.$GT_Config.$Trading.$SellPriceMax?">
              <set_value name="$sellPriceMax" exact="@global.$GT_Config.$Trading.$SellPriceMax"/>
            </do_if>
            <do_if value="global.$GT_Config.$Trading.$BuyPriceMin?">
              <set_value name="$buyPriceMin" exact="@global.$GT_Config.$Trading.$BuyPriceMin"/>
            </do_if>
          </do_else>
        </do_if>
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$SellPriceMax" exact="$sellPriceMax"/>
        <set_value name="$result.$BuyPriceMin" exact="$buyPriceMin"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Sort Trades By Distance -->
    <library name="GT_SortTradesByDistance" purpose="run_actions">
      <params>
        <param name="tradesWithDistance" comment="List of trades with Distance field"/>
      </params>
      <actions>
        <!-- Sorts trades by distance (shortest first) using selection sort -->
        <!-- Input: List of tables with $Trade and $Distance fields -->
        <!-- Output: Sorted list (shortest distance first) -->
        <!-- Uses same pattern as original: check if already sorted to avoid duplicates -->
        <set_value name="$sortedTrades" exact="[]"/>
        <do_all exact="$tradesWithDistance.count" counter="$sortIdx">
          <set_value name="$minDistance" exact="999999999"/>
          <set_value name="$minIdx" exact="-1"/>
          <do_all exact="$tradesWithDistance.count" counter="$i">
            <set_value name="$alreadySorted" exact="false"/>
            <do_all exact="$sortedTrades.count" counter="$j">
              <do_if value="$sortedTrades.{$j}.$Trade == $tradesWithDistance.{$i}.$Trade">
                <set_value name="$alreadySorted" exact="true"/>
                <break/>
              </do_if>
            </do_all>
            <do_if value="not $alreadySorted">
              <set_value name="$tradeDistance" exact="@$tradesWithDistance.{$i}.$Distance"/>
              <do_if value="$tradeDistance? and $tradeDistance lt $minDistance">
                <set_value name="$minDistance" exact="$tradeDistance"/>
                <set_value name="$minIdx" exact="$i"/>
              </do_if>
            </do_if>
          </do_all>
          <do_if value="$minIdx ge 0">
            <append_to_list name="$sortedTrades" exact="$tradesWithDistance.{$minIdx}"/>
          </do_if>
        </do_all>
        <return value="$sortedTrades"/>
      </actions>
    </library>
    
    <!-- Calculate Fallback Trade Distances -->
    <library name="GT_CalculateFallbackTradeDistances" purpose="run_actions">
      <params>
        <param name="wareTrades" comment="List of trades for a specific ware"/>
        <param name="ship" comment="Ship executing the trade"/>
        <param name="homeSector" comment="Home sector for distance calculations"/>
        <param name="currentSector" comment="Current sector (ship's current position)"/>
        <param name="maxDistance" comment="Maximum distance from home sector"/>
        <param name="originalMaxDistance" comment="Original max distance (for fallback search)"/>
        <param name="isFallbackSearch" default="false" comment="Whether this is a fallback search"/>
      </params>
      <actions>
        <!-- Calculates distances for fallback search trades -->
        <!-- For fallback search: Filters by CURRENT LOCATION distance (2 jumps max), calculates home distance for reference -->
        <!-- For normal search: Filters by HOME SECTOR distance, calculates current distance for sorting -->
        <!-- Returns: $tradesWithDistance list, $rejectionStats -->
        <set_value name="$tradesWithDistance" exact="[]"/>
        <set_value name="$rejectedByUnreachable" exact="0"/>
        <set_value name="$rejectedByHomeDistance" exact="0"/>
        <set_value name="$evaluatedCount" exact="0"/>
        
        <!-- Get filterMaxDistance (home sector distance limit) -->
        <set_value name="$filterMaxDistance" exact="$maxDistance"/>  <!-- Default: use maxDistance -->
        <do_if value="$isFallbackSearch and $originalMaxDistance?">
          <set_value name="$filterMaxDistance" exact="$originalMaxDistance"/>  <!-- Fallback: use original pilot maxDistance (respects trading range) -->
        </do_if>
        
        <do_all exact="$wareTrades.count" counter="$i">
          <set_value name="$trade" exact="$wareTrades.{$i}"/>
          <set_value name="$buySector" exact="@$trade.$BuyStation.sector"/>
          <set_value name="$sellSector" exact="@$trade.$SellStation.sector"/>
          <set_value name="$buyStation" exact="@$trade.$BuyStation"/>
          <set_value name="$sellStation" exact="@$trade.$SellStation"/>
          <set_value name="$ware" exact="@$trade.$BuyOffer.ware"/>
          
          <do_if value="$isFallbackSearch">
            <!-- FALLBACK SEARCH: Filter by HOME SECTOR distance (respects pilot's trading range) -->
            <!-- Sector list was built from current location, but trades must still respect home sector range -->
            <set_value name="$buyDistance" exact="-1"/>
            <set_value name="$sellDistance" exact="-1"/>
            
            <do_if value="$buySector == $homeSector">
              <set_value name="$buyDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$buyDistance" exact="$homeSector.gatedistance.{$buySector}"/>
            </do_else>
            
            <do_if value="$sellSector == $homeSector">
              <set_value name="$sellDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$sellDistance" exact="$homeSector.gatedistance.{$sellSector}"/>
            </do_else>
            
            <set_value name="$maxStationDistance" exact="[$buyDistance, $sellDistance].max"/>
            
            <!-- Filter by home sector distance (using originalMaxDistance to respect pilot's trading range) -->
            <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
              <!-- Unreachable from home sector - skip -->
              <set_value name="$rejectedByUnreachable" exact="$rejectedByUnreachable + 1"/>
              <continue/>
            </do_if>
            <do_if value="$maxStationDistance gt $filterMaxDistance">
              <!-- Too far from home sector - skip (respects pilot's trading range) -->
              <set_value name="$rejectedByHomeDistance" exact="$rejectedByHomeDistance + 1"/>
              <continue/>
            </do_if>
            
            <!-- Calculate current location distance for SORTING (prioritize nearby trades) -->
            <set_value name="$currentToBuyDistance" exact="-1"/>
            <set_value name="$currentToSellDistance" exact="-1"/>
            <do_if value="$buySector == $currentSector">
              <set_value name="$currentToBuyDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$currentToBuyDistance" exact="$currentSector.gatedistance.{$buySector}"/>
            </do_else>
            <do_if value="$sellSector == $currentSector">
              <set_value name="$currentToSellDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$currentToSellDistance" exact="$currentSector.gatedistance.{$sellSector}"/>
            </do_else>
            <set_value name="$maxDistanceFromCurrent" exact="[$currentToBuyDistance, $currentToSellDistance].max"/>
            
            <!-- Count trade as evaluated (passed home sector filter) -->
            <set_value name="$evaluatedCount" exact="$evaluatedCount + 1"/>
            
            <!-- Sort by distance from current position (prioritize nearby trades) -->
            <set_value name="$sortDistance" exact="$maxDistanceFromCurrent"/>
          </do_if>
          <do_else>
            <!-- NORMAL SEARCH: Filter by HOME SECTOR distance -->
            <set_value name="$buyDistance" exact="-1"/>
            <set_value name="$sellDistance" exact="-1"/>
            
            <do_if value="$buySector == $homeSector">
              <set_value name="$buyDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$buyDistance" exact="$homeSector.gatedistance.{$buySector}"/>
            </do_else>
            
            <do_if value="$sellSector == $homeSector">
              <set_value name="$sellDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$sellDistance" exact="$homeSector.gatedistance.{$sellSector}"/>
            </do_else>
            
            <!-- Use max distance (farthest station from home) for filtering -->
            <set_value name="$maxStationDistance" exact="[$buyDistance, $sellDistance].max"/>
            
            <!-- Filter by home distance -->
            <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
              <!-- Unreachable from home sector - skip -->
              <set_value name="$rejectedByUnreachable" exact="$rejectedByUnreachable + 1"/>
              <continue/>
            </do_if>
            <do_if value="$maxStationDistance gt $filterMaxDistance">
              <!-- Too far from home sector - skip -->
              <set_value name="$rejectedByHomeDistance" exact="$rejectedByHomeDistance + 1"/>
              <continue/>
            </do_if>
            
            <!-- Trade passed home distance filter - calculate distance from current for SCORING/SORTING -->
            <set_value name="$currentToBuyDistance" exact="-1"/>
            <set_value name="$currentToSellDistance" exact="-1"/>
            <set_value name="$maxDistanceFromCurrent" exact="-1"/>
            <do_if value="$buySector == $currentSector">
              <set_value name="$currentToBuyDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$currentToBuyDistance" exact="$currentSector.gatedistance.{$buySector}"/>
            </do_else>
            <do_if value="$sellSector == $currentSector">
              <set_value name="$currentToSellDistance" exact="0"/>
            </do_if>
            <do_else>
              <set_value name="$currentToSellDistance" exact="$currentSector.gatedistance.{$sellSector}"/>
            </do_else>
            <set_value name="$maxDistanceFromCurrent" exact="[$currentToBuyDistance, $currentToSellDistance].max"/>
            
            <!-- Count trade as evaluated (passed home distance filter) -->
            <set_value name="$evaluatedCount" exact="$evaluatedCount + 1"/>
            
            <!-- Sort by distance from home -->
            <set_value name="$sortDistance" exact="$maxStationDistance"/>
          </do_else>
          
          <append_to_list name="$tradesWithDistance" exact="table[
            $Trade = $trade,
            $Distance = $sortDistance,
            $HomeDistance = $maxStationDistance
          ]"/>
        </do_all>
        
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$TradesWithDistance" exact="$tradesWithDistance"/>
        <set_value name="$result.$RejectedByUnreachable" exact="$rejectedByUnreachable"/>
        <set_value name="$result.$RejectedByHomeDistance" exact="$rejectedByHomeDistance"/>
        <set_value name="$result.$EvaluatedCount" exact="$evaluatedCount"/>
        <return value="$result"/>
      </actions>
    </library>
    
    <!-- Select Best Trades With Diversity -->
    <library name="GT_SelectBestTradesWithDiversity" purpose="run_actions">
      <params>
        <param name="sortedTrades" comment="List of trades sorted by distance"/>
        <param name="maxDistance" comment="Maximum distance limit"/>
        <param name="filterMaxDistance" comment="Filter max distance (for fallback search)"/>
        <param name="isFallbackSearch" default="false" comment="Whether this is a fallback search"/>
        <param name="ware" comment="Ware being traded (for logging)"/>
        <param name="ship" comment="Ship executing the trade"/>
      </params>
      <actions>
        <!-- Selects top 5 trades with station pair diversity -->
        <!-- Returns: $topTrades list (up to 5 trades), $skippedDueToDistance -->
        <set_value name="$topTrades" exact="[]"/>
        <set_value name="$skippedDueToDistance" exact="0"/>
        <set_value name="$distanceLimit" exact="$maxDistance"/>  <!-- Default: use maxDistance (home sector) -->
        <do_if value="$isFallbackSearch">
          <set_value name="$distanceLimit" exact="$filterMaxDistance"/>  <!-- Fallback: use home distance limit -->
        </do_if>
        
        <do_all exact="$sortedTrades.count" counter="$i">
          <!-- Early exit: If this trade exceeds distance limit, all subsequent trades are also too far -->
          <do_if value="$sortedTrades.{$i}.$HomeDistance gt $distanceLimit">
            <set_value name="$skippedDueToDistance" exact="$sortedTrades.count - $i"/>
            <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$distanceType" exact="'home sector'"/>  <!-- Always home sector for distance limit check -->
              <debug_text text="'[GT-Resume] (' + $ship.idcode + ') EARLY EXIT for ware ' + @$ware.name + ': Reached distance limit (' + $distanceLimit + ' jumps from ' + $distanceType + ') at trade ' + $i + '/' + $sortedTrades.count + ' (skipped ' + $skippedDueToDistance + ' trades)'" chance="100"/>
            </do_if>
            <break/>
          </do_if>
          
          <!-- Trade is within distance - select top 5 by Score with STATION PAIR DIVERSITY -->
          <set_value name="$trade" exact="$sortedTrades.{$i}.$Trade"/>
          <set_value name="$buyStation" exact="$trade.$BuyStation"/>
          <set_value name="$sellStation" exact="$trade.$SellStation"/>
          
          <!-- Check if this station pair already exists in topTrades -->
          <set_value name="$stationPairExists" exact="false"/>
          <do_all exact="$topTrades.count" counter="$j">
            <set_value name="$existingBuyStation" exact="$topTrades.{$j}.$BuyStation"/>
            <set_value name="$existingSellStation" exact="$topTrades.{$j}.$SellStation"/>
            <do_if value="$existingBuyStation == $buyStation and $existingSellStation == $sellStation">
              <set_value name="$stationPairExists" exact="true"/>
              <break/>
            </do_if>
          </do_all>
          
          <!-- Skip if station pair already exists (ensure diversity) -->
          <do_if value="not $stationPairExists">
            <set_value name="$shouldAdd" exact="false"/>
            <do_if value="$topTrades.count lt 5">
              <!-- Still building initial top 5 - add unique station pair -->
              <set_value name="$shouldAdd" exact="true"/>
            </do_if>
            <do_else>
              <!-- Top 5 full - check if this trade's Score is better than worst -->
              <set_value name="$worstScore" exact="999999999"/>
              <set_value name="$worstIdx" exact="-1"/>
              <do_all exact="5" counter="$j">
                <do_if value="$topTrades.{$j}.$Score lt $worstScore">
                  <set_value name="$worstScore" exact="$topTrades.{$j}.$Score"/>
                  <set_value name="$worstIdx" exact="$j"/>
                </do_if>
              </do_all>
              <do_if value="$trade.$Score gt $worstScore">
                <!-- Replace worst with this trade (unique station pair) -->
                <set_value name="$shouldAdd" exact="true"/>
              </do_if>
            </do_else>
            <do_if value="$shouldAdd">
              <do_if value="$topTrades.count lt 5">
                <append_to_list name="$topTrades" exact="$trade"/>
              </do_if>
              <do_else>
                <!-- Replace worst trade in top5 -->
                <set_value name="$worstScore" exact="999999999"/>
                <set_value name="$worstIdx" exact="-1"/>
                <do_all exact="5" counter="$j">
                  <do_if value="$topTrades.{$j}.$Score lt $worstScore">
                    <set_value name="$worstScore" exact="$topTrades.{$j}.$Score"/>
                    <set_value name="$worstIdx" exact="$j"/>
                  </do_if>
                </do_all>
                <do_if value="$worstIdx ge 0">
                  <set_value name="$topTrades.{$worstIdx}" exact="$trade"/>
                </do_if>
              </do_else>
            </do_if>
          </do_if>
        </do_all>
        
        <set_value name="$result" exact="table[]"/>
        <set_value name="$result.$TopTrades" exact="$topTrades"/>
        <set_value name="$result.$SkippedDueToDistance" exact="$skippedDueToDistance"/>
        <return value="$result"/>
      </actions>
    </library>

<!-- Register pilot with the GT system -->
    <library name="Register_Pilot">
      <params>
        <param name="pilot" comment="Pilot to register"/>
        <param name="ship" comment="Ship associated with pilot"/>
        <param name="debuglevel" default="1" comment="Debug output level"/>
      </params>
      <actions>
        <!-- Initialize global pilot registry if needed -->
        <!-- SIMPLIFIED: Initialization guarantees global.$GT_Pilots exists -->
        
        <!-- Check if pilot is new or existing -->
        <do_if value="not global.$GT_Pilots.{$pilot}?">
          <!-- New pilot - initialize data -->
          <set_value name="global.$GT_Pilots.{$pilot}" exact="table[
            $Name = $pilot.name,
            $RegistrationTime = player.age,
            $LastActiveTime = player.age,
            $TotalXP = 0,
            $TradesCompleted = 0,
            $ProfitGenerated = 0Cr,
            $RequiresTraining = false,
            $CurrentlyTraining = false,
            $Ship = $ship
          ]"/>
          
          <do_if value="$debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Registered new pilot: ' + $pilot.name + ' for ship ' + $ship.idcode" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Existing pilot - update activity -->
          <set_value name="global.$GT_Pilots.{$pilot}.$LastActiveTime" exact="player.age"/>
          <set_value name="global.$GT_Pilots.{$pilot}.$Ship" exact="$ship"/>
          
          <do_if value="$debuglevel ge 2 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Updated existing pilot: ' + $pilot.name + ' for ship ' + $ship.idcode" chance="100"/>
          </do_if>
        </do_else>
      </actions>
    </library>
    
    <!-- Register ship with the GT system -->
    <library name="Register_Ship">
      <params>
        <param name="ship" comment="Ship to register"/>
        <param name="debuglevel" default="1" comment="Debug output level"/>
      </params>
      <actions>
        <!-- Initialize global ship registry if needed -->
        <!-- SIMPLIFIED: Initialization guarantees global.$GT_Ships exists -->
        
        <!-- Register or update ship -->
        <do_if value="not global.$GT_Ships.{$ship}?">
          <!-- New ship - initialize data -->
          <set_value name="global.$GT_Ships.{$ship}" exact="table[
            $Name = $ship.knownname,
            $IDCode = $ship.idcode,
            $RegistrationTime = player.age,
            $LastActiveTime = player.age,
            $IsSubordinate = false,
            $Commander = null,
            $FleetPosition = 0,
            $TotalTrades = 0,
            $TotalProfit = 0,
            $LastTradeTime = null
          ]"/>
          
          <!-- Check if ship is subordinate -->
          <do_if value="$ship.commander and $ship.commander != $ship">
            <set_value name="global.$GT_Ships.{$ship}.$IsSubordinate" exact="true"/>
            <set_value name="global.$GT_Ships.{$ship}.$Commander" exact="$ship.commander"/>
            
            <!-- FleetPosition removed: Not used (Get_Fleet_Startup_Delay library not called) -->
            <!-- Trade search queue already prevents simultaneous searches via MaxConcurrent -->
            <!-- FleetPosition calculation caused stutter with many subordinates (O(n) loop) -->
            <!-- FleetPosition remains initialized to 0 (default value) -->
          </do_if>
          
          <!-- OPTIMIZATION: Update cached active trader count incrementally -->
          <!-- Only increment if ship is operational (matches counting logic) -->
          <do_if value="$ship.exists and $ship.isoperational">
            <do_if value="not global.$GT_ActiveTraderCount?">
              <set_value name="global.$GT_ActiveTraderCount" exact="0"/>
            </do_if>
            <set_value name="global.$GT_ActiveTraderCount" operation="add"/>
          </do_if>
          
          <do_if value="$debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Registered new ship: ' + $ship.knownname + ' (' + $ship.idcode + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Existing ship - update activity -->
          <set_value name="global.$GT_Ships.{$ship}.$LastActiveTime" exact="player.age"/>
          
          <do_if value="$debuglevel ge 2 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Updated existing ship: ' + $ship.knownname + ' (' + $ship.idcode + ')'" chance="100"/>
          </do_if>
        </do_else>
      </actions>
    </library>
    
    <!-- Initialize global systems if needed -->
    <library name="Ensure_Global_Systems">
      <params>
        <param name="debuglevel" default="1" comment="Debug output level"/>
      </params>
      <actions>
        <set_value name="$systemsInitialized" exact="0"/>
        
        <!-- Initialize ThreatIntelligence system -->
        <do_if value="not global.$GT_ThreatIntelligence?">
          <set_value name="global.$GT_ThreatIntelligence" exact="table[]"/>
          <set_value name="$systemsInitialized" exact="$systemsInitialized + 1"/>
        </do_if>
        
        <!-- Trade cache is NOT pre-initialized - X4 locks empty table[] -->
        <!-- It will be created WITH data on first cache write -->
        
        <!-- Initialize global configuration if needed -->
        <do_if value="not global.$GT_GlobalSettings?">
          <set_value name="global.$GT_GlobalSettings" exact="table[
            $XP = table[
              $EnableXPProgression = true,
              $AutoTraining = true,
              $BaseXPPerTrade = 25,
              $DistanceBonus = 20,
              $RiskBonus = 25
            ],
            $Fleet = table[
              $EnableFleetCoordination = true,
              $EnableTradeCache = true,
              $CacheProfitThreshold = 20,
              $CacheDropoffTolerance = 15,
              $CacheTTL = 5min
            ],
            $Debug = table[
              $DebugLevel = 1,
              $TradeEvaluation = false
            ]
          ]"/>
          <set_value name="$systemsInitialized" exact="$systemsInitialized + 1"/>
        </do_if>
        
        <do_if value="$systemsInitialized gt 0 and $debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT Data] Initialized ' + $systemsInitialized + ' global systems'" chance="100"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Clean up pilot data (safe removal) -->
    <library name="Cleanup_Pilot_Data">
      <params>
        <param name="pilot" comment="Pilot to remove data for"/>
        <param name="debuglevel" default="1" comment="Debug output level"/>
      </params>
      <actions>
        <do_if value="$pilot? and global.$GT_Pilots? and global.$GT_Pilots.{$pilot}?">
          <remove_value name="global.$GT_Pilots.{$pilot}"/>
          
          <do_if value="$debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Cleaned up data for pilot: ' + $pilot.name" chance="100"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- Clean up ship data (safe removal) -->
    <library name="Cleanup_Ship_Data">
      <params>
        <param name="ship" comment="Ship to remove data for"/>
        <param name="debuglevel" default="1" comment="Debug output level"/>
      </params>
      <actions>
        <do_if value="$ship? and global.$GT_Ships? and global.$GT_Ships.{$ship}?">
          <!-- OPTIMIZATION: Update cached active trader count incrementally -->
          <!-- Only decrement if ship was operational (matches counting logic) -->
          <do_if value="$ship.exists and $ship.isoperational and global.$GT_ActiveTraderCount? and global.$GT_ActiveTraderCount gt 0">
            <set_value name="global.$GT_ActiveTraderCount" operation="subtract"/>
          </do_if>
          
          <remove_value name="global.$GT_Ships.{$ship}"/>
          
          <do_if value="$debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT Data] Cleaned up data for ship: ' + $ship.knownname + ' (' + $ship.idcode + ')'" chance="100"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- Get fleet coordination delay for subordinate -->
    <library name="Get_Fleet_Startup_Delay" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to calculate delay for"/>
      </params>
      <actions>
        <set_value name="$delay" exact="0"/>
        
        <!-- Check if ship is subordinate -->
        <do_if value="global.$GT_Ships.{$ship}? and global.$GT_Ships.{$ship}.$IsSubordinate">
          <set_value name="$fleetPosition" exact="global.$GT_Ships.{$ship}.$FleetPosition"/>
          
          <!-- Calculate staggered startup delay -->
          <set_value name="$delay" exact="$fleetPosition * 30s"/>
          
          <!-- Cap maximum delay -->
          <do_if value="$delay gt 300s">
            <set_value name="$delay" exact="300s"/>
          </do_if>
        </do_if>
        
        <set_value name="this.$result" exact="$delay"/>
      </actions>
    </library>

<!-- ========================================= -->
    <!-- NOTIFICATION SYSTEM -->
    <!-- ========================================= -->
    
    <!-- Show Notification -->
    <library name="GT_ShowNotification" purpose="run_actions">
      <params>
        <param name="text" comment="Notification text"/>
        <param name="category" default="'info'" comment="Notification category"/>
        <param name="timeout" default="5s" comment="Notification timeout"/>
      </params>
      <actions>
        <show_notification text="$text" timeout="$timeout"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- VALIDATION HELPERS -->
    <!-- ========================================= -->
    
    <!-- Validate Ship -->
    <library name="GT_ValidateShip" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship object to validate"/>
      </params>
      <actions>
        <do_if value="@$ship.exists and @$ship.isoperational and (@$ship.iswreck == false) and (@$ship.pilot != null)">
          <return value="true"/>
        </do_if>
        <return value="false"/>
      </actions>
    </library>
    
    <!-- Validate Station -->
    <library name="GT_ValidateStation" purpose="run_actions">
      <params>
        <param name="station" comment="Station object to validate"/>
        <param name="ship" default="null" comment="Optional: Ship parameter (reserved for future use)"/>
      </params>
      <actions>
        <!-- 
          DESIGN NOTE: Threat avoidance is now handled by vanilla pathfinding
          - Trade orders created with internal="true" use strictblacklist mode
          - Vanilla pathfinding routes AROUND blacklisted sectors automatically
          - If no route exists, the order fails gracefully and ship requests new trade
          - No need for manual sector filtering here
        -->
        <do_if value="@$station.exists and @$station.isoperational">
          <return value="true"/>
        </do_if>
        <return value="false"/>
      </actions>
    </library>
    
    <!-- Check if Ware is Allowed -->
    <library name="GT_IsWareAllowed" purpose="run_actions">
      <params>
        <param name="ware" comment="Ware to check"/>
        <param name="allowIllegal" default="true" comment="Whether to allow illegal wares"/>
        <param name="zone" default="null" comment="Optional: Zone context for illegal check"/>
        <param name="shipOwner" default="null" comment="Optional: Ship owner for license check"/>
      </params>
      <actions>
        <!-- Context-aware illegal check when zone and ship owner are provided -->
        <do_if value="not $allowIllegal">
          <do_if value="$zone and $shipOwner">
            <!-- Check if ware is illegal to police faction in this zone, considering ship owner's licenses -->
            <set_value name="$policeFaction" exact="$zone.policefaction"/>
            <do_if value="$policeFaction and $policeFaction != $shipOwner">
              <do_if value="$ware.illegalto.{$policeFaction}.{$shipOwner}">
                <return value="false"/>
              </do_if>
            </do_if>
          </do_if>
          <do_else>
            <!-- Fallback: Global illegal check (may be overly restrictive - use context-aware check when possible) -->
            <!-- FIX: Use safe operator and explicit gt 0 check to ensure legal wares (illegal=0) are not filtered -->
            <do_if value="@$ware.illegal gt 0">
              <return value="false"/>
            </do_if>
          </do_else>
        </do_if>
        
        <!-- Check blacklist -->
        <do_if value="global.$GT_Config.$WareFilter.$BlacklistedWares?">
          <do_all exact="global.$GT_Config.$WareFilter.$BlacklistedWares.count" counter="$i">
            <do_if value="global.$GT_Config.$WareFilter.$BlacklistedWares.{$i} == $ware">
              <return value="false"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Check whitelist if exists -->
        <do_if value="global.$GT_Config.$WareFilter.$WhitelistedWares? and global.$GT_Config.$WareFilter.$WhitelistedWares.count gt 0">
          <do_all exact="global.$GT_Config.$WareFilter.$WhitelistedWares.count" counter="$j">
            <do_if value="global.$GT_Config.$WareFilter.$WhitelistedWares.{$j} == $ware">
              <return value="true"/>
            </do_if>
          </do_all>
          <return value="false"/>
        </do_if>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- XP CALCULATIONS -->
    <!-- ========================================= -->
    
    <!-- Calculate XP Award -->
    <library name="GT_CalculateXP" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship that completed trade"/>
        <param name="profit" comment="Trade profit amount"/>
        <param name="jumps" default="1" comment="Number of jumps"/>
      </params>
      <actions>
        <!-- Get base XP from config -->
        <set_value name="$baseXP" exact="@global.$GT_Config.$XP.$BaseXPPerTrade"/>
        <do_if value="not $baseXP">
          <set_value name="$baseXP" exact="100"/>
        </do_if>
        
        <!-- Calculate distance bonus -->
        <set_value name="$distanceBonusPerJump" exact="@global.$GT_Config.$XP.$DistanceBonus"/>
        <do_if value="not $distanceBonusPerJump">
          <set_value name="$distanceBonusPerJump" exact="20"/>
        </do_if>
        <set_value name="$distanceBonus" exact="$jumps * $distanceBonusPerJump"/>
        
        <!-- Calculate risk bonus -->
        <set_value name="$riskBonus" exact="0"/>
              <!-- Risk bonus calculation disabled - sector security property uncertain -->
      <set_value name="$riskBonus" exact="0"/>
        
        <!-- Return total XP -->
        <return value="$baseXP + $distanceBonus + $riskBonus"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- CONFIGURATION HELPERS -->
    <!-- ========================================= -->
    
    <!-- Get Configuration Value -->
    <library name="GT_GetConfigValue" purpose="run_actions">
      <params>
        <param name="section" comment="Configuration section"/>
        <param name="key" comment="Configuration key"/>
        <param name="default" default="null" comment="Default value if not found"/>
      </params>
      <actions>
        <do_if value="global.$GT_Config? and global.$GT_Config.{$section}? and global.$GT_Config.{$section}.{$key}?">
          <return value="@global.$GT_Config.{$section}.{$key}"/>
        </do_if>
        <return value="$default"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- TRADE FILTERING AND ANALYSIS -->
    <!-- ========================================= -->
    
    <!-- Filter Trade Offer -->
    <library name="GT_FilterTradeOffer" purpose="run_actions">
      <params>
        <param name="offer" comment="Trade offer to filter"/>
        <param name="ship" comment="Ship that would execute the trade"/>
        <param name="allowIllegal" default="true" comment="Whether to allow illegal wares"/>
      </params>
      <actions>
        <!-- Check if ware is allowed (with context for illegal check) -->
        <run_actions ref="GT_IsWareAllowed" result="$wareAllowed">
          <param name="ware" value="$offer.ware"/>
          <param name="allowIllegal" value="$allowIllegal"/>
          <param name="zone" value="$offer.owner.zone"/>
          <param name="shipOwner" value="$ship.owner"/>
        </run_actions>
        <do_if value="not $wareAllowed">
          <return value="false"/>
        </do_if>
        
        <!-- Check if ship can carry this ware -->
        <do_if value="$ship.cargo.{$offer.ware}.max le 0">
          <return value="false"/>
        </do_if>
        
        <!-- Check if offer has sufficient amount -->
        <do_if value="$offer.amount le 0">
          <return value="false"/>
        </do_if>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Calculate Trade Profit -->
    <library name="GT_CalculateProfit" purpose="run_actions">
      <params>
        <param name="buyPrice" comment="Price to buy at"/>
        <param name="sellPrice" comment="Price to sell at"/>
        <param name="amount" comment="Amount to trade"/>
        <param name="expenses" default="0Cr" comment="Additional expenses"/>
      </params>
      <actions>
        <set_value name="$revenue" exact="$sellPrice * $amount"/>
        <set_value name="$cost" exact="$buyPrice * $amount"/>
        <return value="$revenue - $cost - $expenses"/>
      </actions>
    </library>
    
    <!-- Calculate ROI (Return on Investment) -->
    <library name="GT_CalculateROI" purpose="run_actions">
      <params>
        <param name="investment" comment="Investment amount in credits"/>
        <param name="profit" comment="Profit amount in credits"/>
      </params>
      <actions>
        <!-- Returns ROI as percentage (21 = 21%) to avoid integer division issues -->
        <!-- OLD approach with decimals (0.15 = 15%) failed due to X4 MD integer truncation -->
        <do_if value="$investment gt 0">
          <return value="(($profit * 100) / $investment)"/>
        </do_if>
        <return value="0"/>
      </actions>
    </library>
    
    <!-- Calculate Trade Risk -->
    <library name="GT_CalculateRisk" purpose="run_actions">
      <params>
        <param name="sector" comment="Sector to assess risk for"/>
        <param name="ship" comment="Ship that would travel there"/>
      </params>
      <actions>
              <!-- Calculate security based on faction relations and sector characteristics -->
      <set_value name="$sectorSecurity" exact="0.5"/>
      
      <do_if value="$sector? and $sector.owner?">
                      <set_value name="$relation" exact="faction.player.relationto.{$sector.owner}"/>
        <do_if value="$relation ge 0.1">
          <set_value name="$sectorSecurity" exact="1.0"/>  <!-- Friendly = very safe -->
        </do_if>
        <do_elseif value="$relation ge -0.1">
          <set_value name="$sectorSecurity" exact="0.75"/> <!-- Neutral = safe -->
        </do_elseif>
        <do_elseif value="$relation ge -0.5">
          <set_value name="$sectorSecurity" exact="0.5"/>  <!-- Hostile = moderate -->
        </do_elseif>
        <do_else>
          <set_value name="$sectorSecurity" exact="0.25"/> <!-- Very hostile = dangerous -->
        </do_else>
        
        <!-- Extra danger for Xenon/Kha'ak sectors -->
        <do_if value="$sector.owner.id == 'xenon' or $sector.owner.id == 'khaak'">
          <set_value name="$sectorSecurity" exact="0.1"/>
        </do_if>
      </do_if>
      
      <!-- Base risk from security level -->
      <set_value name="$securityRisk" exact="1.0 - $sectorSecurity"/>
        
        <!-- Distance risk factor -->
        <set_value name="$distance" exact="$ship.distanceto.{$sector}"/>
        <set_value name="$distanceRisk" exact="[$distance / 100000, 0.5].min"/>
        
        <!-- Faction relation risk -->
        <set_value name="$relationRisk" exact="0"/>
        <do_if value="$sector.owner != $ship.owner">
          <set_value name="$relation" exact="$ship.owner.relationto.{$sector.owner}"/>
          <do_if value="$relation lt 0">
            <set_value name="$relationRisk" exact="($relation * -1) / 100"/>
          </do_if>
        </do_if>
        
        <!-- Combined risk (weighted average) -->
        <set_value name="$combinedRisk" exact="($securityRisk * 0.5) + ($distanceRisk * 0.3) + ($relationRisk * 0.2)"/>
        <return value="[$combinedRisk, 1.0].min"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- SHIP/SECTOR UTILITIES -->
    <!-- ========================================= -->
    
    <!-- Get Home Sector -->
    <library name="GT_GetHomeSector" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to get home sector for"/>
      </params>
      <actions>
        <!-- CRITICAL: Subordinates ALWAYS use commander's home sector (not a fallback!) -->
        <set_value name="$homeBase" exact="null"/>
        <do_if value="$ship.commander? and $ship.commander.exists and $ship.commander != $ship">
          <!-- Ship is a subordinate - ALWAYS use commander's home sector -->
          <do_if value="$ship.commander.defaultorder?">
            <set_value name="$commanderHome" exact="@$ship.commander.defaultorder.$home"/>
            <do_if value="@$commanderHome.exists">
              <set_value name="$homeBase" exact="$commanderHome"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
        <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <set_value name="$homeBase" exact="@$ship.defaultorder.$home"/>
        </do_if>
        
        <!-- Fallback: Only if defaultorder.$home is not available, check GT_AIParameters -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{$ship}? and global.$GT_AIParameters.{$ship}.$HomeBase?">
            <set_value name="$homeBase" exact="global.$GT_AIParameters.{$ship}.$HomeBase"/>
          </do_if>
        </do_if>
        
        <!-- REMOVED: Never fall back to $ship.sector (causes cascading drift) -->
        <!-- If home is still null, log critical error and return null -->
        <do_if value="not $homeBase? or not $homeBase.exists">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-ERROR] Home sector not found for ' + $ship.idcode + ' - defaultorder.$home is null and GT_AIParameters.$HomeBase is null! This should never happen. Returning null to prevent drift.'" chance="100"/>
          </do_if>
          <!-- Return null instead of ship.sector to prevent drift -->
          <return value="null"/>
        </do_if>
        
        <!-- Extract sector from home base (station/sector) -->
        <set_value name="$homeSector" exact="null"/>
        <do_if value="@$homeBase.exists">
          <do_if value="$homeBase.isclass.station">
            <set_value name="$homeSector" exact="$homeBase.sector"/>
          </do_if>
          <do_elseif value="$homeBase.isclass.sector">
            <set_value name="$homeSector" exact="$homeBase"/>
          </do_elseif>
        </do_if>
        
        <!-- Validate final home sector - return null if extraction failed (prevents drift) -->
        <do_if value="not $homeSector? or not $homeSector.exists">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-ERROR] Failed to extract home sector from homeBase for ' + $ship.idcode + ' - returning null to prevent drift!'" chance="100"/>
          </do_if>
          <!-- Return null instead of ship.sector to prevent drift -->
          <return value="null"/>
        </do_if>
        
        <return value="$homeSector"/>
      </actions>
    </library>
    
    <!-- Get Sector Name Safe -->
    <library name="GT_GetSectorNameSafe" purpose="run_actions">
      <params>
        <param name="sector" default="null" comment="Sector to get name for (or null to use ship.sector)"/>
        <param name="ship" default="null" comment="Ship to get sector from if sector not provided"/>
      </params>
      <actions>
        <set_value name="$targetSector" exact="$sector"/>
        <do_if value="not $targetSector?">
          <do_if value="$ship?">
            <set_value name="$targetSector" exact="$ship.sector"/>
          </do_if>
        </do_if>
        <set_value name="$sectorName" exact="@$targetSector.knownname"/>
        <do_if value="not $sectorName?">
          <set_value name="$sectorName" exact="'Unknown Sector'"/>
        </do_if>
        <return value="$sectorName"/>
      </actions>
    </library>
    
    <!-- Get Ware Basket Safe (with null-checking pattern) -->
    <library name="GT_GetWareBasketSafe" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to get ware basket for"/>
      </params>
      <actions>
        <!-- CRITICAL: Initialize to safe default FIRST (memory:10529400 - ? checks existence, not null) -->
        <set_value name="$wareBasket" exact="[]"/>
        <!-- Step 2: Check if source exists -->
        <do_if value="global.$GT_AIParameters.{$ship}.$WareBasket?">
          <!-- Step 3: Get value with @ (returns null if missing) -->
          <set_value name="$tempBasket" exact="@global.$GT_AIParameters.{$ship}.$WareBasket"/>
          <!-- Step 4: Extract count property with @ to check if result is valid list -->
          <set_value name="$tempCount" exact="@$tempBasket.count"/>
          <!-- Step 5: Check if COUNT result exists and is valid (>= 0 means it's a list, not null) -->
          <do_if value="$tempCount? and $tempCount ge 0">
            <!-- Step 6: Now safe to use the original temp value -->
            <set_value name="$wareBasket" exact="$tempBasket"/>
          </do_if>
        </do_if>
        <return value="$wareBasket"/>
      </actions>
    </library>
    
    <!-- Check if Ware is in Basket -->
    <library name="GT_IsWareInBasket" purpose="run_actions">
      <params>
        <param name="ware" comment="Ware to check"/>
        <param name="basket" comment="Ware basket list to check against"/>
      </params>
      <actions>
        <!-- Use explicit loop for reliable list membership check (indexof unreliable) -->
        <set_value name="$found" exact="false"/>
        <do_if value="(if $basket != null then $basket.count else 0) gt 0">
          <do_all exact="$basket.count" counter="$i">
            <do_if value="$basket.{$i} == $ware">
              <set_value name="$found" exact="true"/>
              <break/>
            </do_if>
          </do_all>
        </do_if>
        <return value="$found"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- MARKET ANALYSIS -->
    <!-- ========================================= -->
    
    <!-- Find Best Trade -->
    <library name="GT_FindBestTrade">
      <params>
        <param name="ship" comment="Ship to find trade for"/>
        <param name="warebasket" comment="List of allowed wares"/>
      </params>
      <actions>
        <set_value name="$return" exact="null"/>
        <set_value name="$bestProfit" exact="0"/>
        
        <!-- Find buy offers -->
        <!-- CRITICAL: Include tradepartner to respect trade rules (e.g., "internal only") -->
        <find_buy_offer space="player.galaxy" tradepartner="this.ship" result="$buyoffers" multiple="true">
          <match_buyer tradesknownto="@this.owner"/>
          <match_seller tradesknownto="@this.owner"/>
        </find_buy_offer>
        
        <!-- Evaluate trades -->
        <do_all exact="[$buyoffers.count, 20].min" counter="$i">
          <set_value name="$buyoffer" exact="$buyoffers.{$i}"/>
          
          <!-- Check if ware is in basket using explicit loop (indexof unreliable for lists) -->
          <set_value name="$wareInBasket" exact="false"/>
          <do_all exact="$warebasket.count" counter="$k">
            <do_if value="$warebasket.{$k} == $buyoffer.ware">
              <set_value name="$wareInBasket" exact="true"/>
              <break/>
            </do_if>
          </do_all>
          
          <do_if value="$wareInBasket">
            <!-- Find sell offers -->
            <!-- CRITICAL: Include tradepartner to respect trade rules (e.g., "internal only") -->
            <find_sell_offer buyer="$buyoffer.buyer" wares="$buyoffer.ware" tradepartner="this.ship" result="$selloffer">
              <match_seller tradesknownto="@this.owner"/>
            </find_sell_offer>
            
            <do_if value="$selloffer">
              <!-- Calculate profit -->
              <set_value name="$amount" exact="[this.ship.cargo.{$buyoffer.ware}.free, $buyoffer.amount, $selloffer.amount].min"/>
              <do_if value="$amount gt 0">
                <set_value name="$profit" exact="($selloffer.unitprice - $buyoffer.unitprice) * $amount"/>
                
                <!-- Check ROI and absolute profit thresholds -->
                <set_value name="$minROI" exact="@global.$GT_Config.$Trading.$MinROI"/>
                <do_if value="not $minROI">
                  <set_value name="$minROI" exact="0.10"/>
                </do_if>
                
                <set_value name="$minAbsoluteProfit" exact="@global.$GT_Config.$Trading.$MinAbsoluteProfit"/>
                <do_if value="not $minAbsoluteProfit">
                  <set_value name="$minAbsoluteProfit" exact="10000"/> <!-- 100 Cr in RAW format -->
                </do_if>
                
                <!-- Calculate ROI -->
                <set_value name="$investment" exact="$buyoffer.unitprice * $amount"/>
                <set_value name="$roi" exact="if $investment gt 0 then (($profit * 100.0) / $investment) else 0.0"/>
                
                <do_if value="$roi ge ($minROI * 100) and $profit ge $minAbsoluteProfit and $profit gt $bestProfit">
                  <set_value name="$bestProfit" exact="$profit"/>
                  <set_value name="$return" exact="$buyoffer"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
        </do_all>
      </actions>
    </library>
    
    <!-- Analyze Route Threat -->
    <library name="GT_AnalyzeRouteThreat" purpose="run_actions">
      <params>
        <param name="buyStation" comment="Station to buy from"/>
        <param name="sellStation" comment="Station to sell to"/>
        <param name="ship" comment="Ship for context"/>
      </params>
      <actions>
        <!-- Initialize return table -->
        <set_value name="$return" exact="table[]"/>
        <set_value name="$return.$MaxThreat" exact="0"/>
        <set_value name="$return.$TotalThreatScore" exact="0"/>
        <set_value name="$return.$ThreatSectors" exact="[]"/>
        <set_value name="$return.$SectorCount" exact="0"/>
        
        <!-- Check if threat avoidance is enabled -->
        <do_if value="not global.$GT_GlobalSettings.$ThreatAvoidance? or not global.$GT_GlobalSettings.$ThreatAvoidance.$Enabled">
          <return value="$return"/>
        </do_if>
        
        <!-- Check if dynamic blacklist is enabled (required for blacklist-aware pathfinding) -->
        <set_value name="$useDynamicBlacklist" exact="false"/>
        <do_if value="global.$GT_GlobalSettings.$ThreatAvoidance.$UseDynamicBlacklist?">
          <set_value name="$useDynamicBlacklist" exact="@global.$GT_GlobalSettings.$ThreatAvoidance.$UseDynamicBlacklist"/>
        </do_if>
        
        <!-- Get threat expiry time -->
        <set_value name="$threatExpiry" exact="if global.$GT_GlobalSettings.$ThreatAvoidance.$ThreatExpiry? then global.$GT_GlobalSettings.$ThreatAvoidance.$ThreatExpiry else 600s"/>
        
        <!-- Build list of sectors to check: buy sector and sell sector -->
        <set_value name="$sectorsToCheck" exact="[]"/>
        
        <!-- Add buy station sector -->
        <append_to_list name="$sectorsToCheck" exact="$buyStation.sector"/>
        
        <!-- Add sell station sector if different -->
        <do_if value="$sellStation.sector != $buyStation.sector">
          <append_to_list name="$sectorsToCheck" exact="$sellStation.sector"/>
        </do_if>
        
        <!-- Check if preferred route goes through threatened sectors -->
        <!-- Compare normal vs blacklist-aware gatedistance to detect threats in path (only if dynamic blacklist enabled) -->
        <do_if value="$ship? and $sellStation.sector != $buyStation.sector and $useDynamicBlacklist">
          <!-- Extract sectors before gatedistance calculation (property chains in curly braces can fail) -->
          <set_value name="$sellSector" exact="@$sellStation.sector"/>
          <do_if value="$sellSector?">
            <!-- Calculate distance from ship to sell station WITHOUT blacklist (preferred path) -->
            <set_value name="$normalDistance" exact="$ship.gatedistance.{$sellSector}"/>
            
            <!-- Calculate distance WITH blacklist (avoiding threats) -->
            <!-- Vanilla pattern: order.dock.xml:503 -->
            <set_value name="$blacklistDistance" exact="$ship.gatedistance.{$sellSector}.{blacklistgroup.civilian}.{$ship}"/>
          </do_if>
          <do_else>
            <!-- Sector extraction failed - skip threat check -->
            <set_value name="$normalDistance" exact="-1"/>
            <set_value name="$blacklistDistance" exact="-1"/>
          </do_else>
          
          <!-- If blacklist distance > normal, preferred path goes through threat! -->
          <!-- Apply heavy penalty to discourage this route -->
          <do_if value="($normalDistance ge 0) and ($blacklistDistance gt $normalDistance or $blacklistDistance lt 0)">
            <!-- Route goes through threatened sector(s) - apply heavy threat penalty -->
            <set_value name="$return.$MaxThreat" exact="5"/>
            <set_value name="$return.$TotalThreatScore" exact="10"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Threat] Route analysis: Preferred path threatened (normal: %s, blacklist: %s) - heavy penalty applied'.[$normalDistance, $blacklistDistance]" chance="0"/>
            </do_if>
          </do_if>
        </do_if>
        
        <set_value name="$return.$SectorCount" exact="$sectorsToCheck.count"/>
        
        <!-- Check threat level for each sector -->
        <do_all exact="$sectorsToCheck.count" counter="$i">
          <set_value name="$sector" exact="$sectorsToCheck.{$i}"/>
          
          <!-- Check if we have threat data for this sector -->
          <do_if value="global.$GT_ThreatIntelligence.{$sector}?">
            <set_value name="$threatData" exact="global.$GT_ThreatIntelligence.{$sector}"/>
            
            <!-- Check if threat data is still valid (not expired) -->
            <do_if value="$threatData.$Timestamp?">
              <set_value name="$age" exact="player.age - $threatData.$Timestamp"/>
              
              <do_if value="$age le $threatExpiry">
                <set_value name="$threatLevel" exact="@$threatData.$ThreatLevel"/>
                
                <do_if value="$threatLevel?">
                  <!-- Update max threat -->
                  <do_if value="$threatLevel gt $return.$MaxThreat">
                    <set_value name="$return.$MaxThreat" exact="$threatLevel"/>
                  </do_if>
                  
                  <!-- Add to total threat score -->
                  <set_value name="$return.$TotalThreatScore" exact="$return.$TotalThreatScore + $threatLevel"/>
                  
                  <!-- Add sector to threat list if threat level > 1 -->
                  <do_if value="$threatLevel gt 1">
                    <set_value name="$threatSectorInfo" exact="table[]"/>
                    <set_value name="$threatSectorInfo.$Sector" exact="$sector"/>
                    <set_value name="$threatSectorInfo.$ThreatLevel" exact="$threatLevel"/>
                    <set_value name="$threatSectorInfo.$HostileCount" exact="@$threatData.$HostileCount"/>
                    <append_to_list name="$return.$ThreatSectors" exact="$threatSectorInfo"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
        </do_all>
        
        <!-- Calculate average threat -->
        <set_value name="$return.$AverageThreat" exact="if $return.$SectorCount gt 0 then ($return.$TotalThreatScore / $return.$SectorCount) else 0"/>
        
        <!-- Return threat analysis result -->
        <return value="$return"/>
      </actions>
    </library>
    
    <!-- Validate Table Safe (null-checking pattern) -->
    <library name="GT_ValidateTableSafe" purpose="run_actions">
      <params>
        <param name="table" comment="Table to validate (may be null)"/>
      </params>
      <actions>
        <!-- CRITICAL: X4 MD null-checking pattern -->
        <!-- null? = true, so we check if .keys.count exists and is >= 0 -->
        <set_value name="$keysCheck" exact="@$table.keys"/>
        <set_value name="$countCheck" exact="@$keysCheck.count"/>
        <do_if value="$table? and $keysCheck? and $countCheck? and $countCheck ge 0">
          <return value="$table"/>
        </do_if>
        <!-- Return empty table if invalid -->
        <return value="table[]"/>
      </actions>
    </library>

<!-- Initialize AI Script Configuration -->
    <library name="Initialize_AI_Script">
      <params>
        <param name="ship" comment="Ship being initialized"/>
        <param name="order_params" comment="Order parameters"/>
      </params>
      <actions>
        <!-- Create configuration using the Configuration Manager -->
        <run_actions ref="md.GT_Configuration.Create_Ship_Config" result="$shipConfig">
          <param name="order_params" value="$order_params"/>
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Register ship and pilot -->
        <do_if value="$ship.pilot">
          <run_actions ref="md.GT_Ship_Management.Register_Ship">
            <param name="ship" value="$ship"/>
            <param name="pilot" value="$ship.pilot"/>
            <param name="config" value="$shipConfig"/>
          </run_actions>
        </do_if>
        
        <!-- Return the configuration for use in the AI script -->
        <set_value name="this.$result" exact="$shipConfig"/>
      </actions>
    </library>
    
    <!-- Validate Runtime Parameters -->
    <library name="Validate_Runtime_Parameters" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to validate"/>
        <param name="config" comment="Ship configuration"/>
      </params>
      <actions>
        <set_value name="$validationResult" exact="table[]"/>
        <set_value name="$isValid" exact="true"/>
        <create_list name="$warnings"/>
        <create_list name="$corrections"/>
        
        <!-- Get current skill level -->
        <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
          <param name="ship" value="$ship"/>
        </run_actions>
        
        <!-- Calculate skill-based jump distance -->
        <run_actions ref="md.GT_Ship_Management.Calculate_Jump_Distance" result="$skillMaxDistance">
          <param name="skill_level" value="$skillInfo.$Level"/>
        </run_actions>
        
        <!-- Check if pilot is XP blocked -->
        <set_value name="$pilotXPBlocked" exact="false"/>
        <do_if value="$ship.pilot and global.$GT_Pilots.{$ship.pilot}? and global.$GT_Pilots.{$ship.pilot}.$XPBlocked?">
          <set_value name="$pilotXPBlocked" exact="true"/>
        </do_if>
        
        <!-- Validate and correct MaxBuy distance -->
        <do_if value="not $pilotXPBlocked and $config.$MaxBuy gt $skillMaxDistance">
          <append_to_list name="$warnings" exact="'MaxBuy (' + $config.$MaxBuy + ') exceeds skill limit (' + $skillMaxDistance + ')'"/>
          <append_to_list name="$corrections" exact="'MaxBuy corrected to ' + $skillMaxDistance"/>
          <set_value name="$config.$MaxBuy" exact="$skillMaxDistance"/>
          <set_value name="$config.$MaxBuyDistance" exact="$skillMaxDistance"/>
        </do_if>
        
        <!-- Validate and correct MaxSell distance -->
        <do_if value="not $pilotXPBlocked and $config.$MaxSell gt $skillMaxDistance">
          <append_to_list name="$warnings" exact="'MaxSell (' + $config.$MaxSell + ') exceeds skill limit (' + $skillMaxDistance + ')'"/>
          <append_to_list name="$corrections" exact="'MaxSell corrected to ' + $skillMaxDistance"/>
          <set_value name="$config.$MaxSell" exact="$skillMaxDistance"/>
          <set_value name="$config.$MaxSellDistance" exact="$skillMaxDistance"/>
        </do_if>
        
        <!-- Store validation results -->
        <set_value name="$validationResult.$IsValid" exact="$isValid"/>
        <set_value name="$validationResult.$Warnings" exact="$warnings"/>
        <set_value name="$validationResult.$Corrections" exact="$corrections"/>
        <set_value name="$validationResult.$SkillInfo" exact="$skillInfo"/>
        <set_value name="$validationResult.$SkillMaxDistance" exact="$skillMaxDistance"/>
        <set_value name="$validationResult.$PilotXPBlocked" exact="$pilotXPBlocked"/>
        
        <set_value name="this.$result" exact="$validationResult"/>
      </actions>
    </library>
    
    <!-- Handle Fleet Coordination -->
    <library name="Handle_Fleet_Coordination" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship joining fleet"/>
        <param name="config" comment="Ship configuration"/>
      </params>
      <actions>
        <set_value name="$fleetResult" exact="table[]"/>
        <set_value name="$startupDelay" exact="0"/>
        <set_value name="$isSubordinate" exact="false"/>
        
        <!-- Check if fleet coordination is enabled AND pilot level gate passed (>= 12) -->
        <do_if value="$config.$FleetCoordination">
          <set_value name="$fleetGatePassed" exact="false"/>
          <run_actions ref="md.GT_Ship_Management.Calculate_Skill_Level" result="$skillInfo">
            <param name="ship" value="$ship"/>
          </run_actions>
          <do_if value="$skillInfo? and $skillInfo.$Level? and $skillInfo.$Level ge 12">
            <set_value name="$fleetGatePassed" exact="true"/>
          </do_if>
          
          <!-- Only apply coordination delay if gate passed -->
          <do_if value="$fleetGatePassed">
          <!-- OPTIMIZED: Use cached active trader count instead of expensive O(n) loop -->
          <!-- Cache is maintained incrementally during ship registration/unregistration -->
          <set_value name="$activeTraders" exact="0"/>
          <do_if value="global.$GT_ActiveTraderCount?">
            <set_value name="$activeTraders" exact="global.$GT_ActiveTraderCount"/>
          </do_if>
          <do_else>
            <!-- Fallback: Cache not initialized - count manually (shouldn't happen, but safe) -->
            <set_value name="$activeTraders" exact="0"/>
            <do_if value="global.$GT_Ships? and global.$GT_Ships.keys.count gt 0">
              <set_value name="$shipKeys" exact="global.$GT_Ships.keys.list"/>
              <do_all exact="$shipKeys.count" counter="$i">
                <set_value name="$existingShip" exact="$shipKeys.{$i}"/>
                <do_if value="$existingShip.exists and $existingShip.isoperational and $existingShip != $ship">
                  <set_value name="$activeTraders" exact="$activeTraders + 1"/>
                </do_if>
              </do_all>
            </do_if>
            <!-- Initialize cache with counted value -->
            <set_value name="global.$GT_ActiveTraderCount" exact="$activeTraders"/>
          </do_else>
          
          <!-- Apply fleet coordination delay -->
          <do_if value="$activeTraders gt 0">
            <set_value name="$startupDelay" exact="[$activeTraders * 5, 30].min"/>
            <set_value name="$isSubordinate" exact="true"/>
            
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + $ship.idcode + ': Fleet coordination: delaying startup for ' + $startupDelay + 's (found ' + $activeTraders + ' active traders, cached)'" chance="100"/>
            </do_if>
          </do_if>
          </do_if>
          <do_if value="not $fleetGatePassed">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + $ship.idcode + ': Fleet coordination gated by level (requires 12), current=' + (if @$skillInfo.$Level != null then @$skillInfo.$Level else 1)" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fleet coordination disabled - skip expensive count (Option 2: Skip if disabled) -->
          <set_value name="$activeTraders" exact="0"/>
        </do_else>
        
        <!-- Store results -->
        <set_value name="$fleetResult.$StartupDelay" exact="$startupDelay"/>
        <set_value name="$fleetResult.$IsSubordinate" exact="$isSubordinate"/>
        <set_value name="$fleetResult.$ActiveTraders" exact="$activeTraders"/>
        
        <set_value name="this.$result" exact="$fleetResult"/>
      </actions>
    </library>
    
    <!-- Check Training Requirements -->
    <library name="Check_Training_Requirements" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to check"/>
        <param name="pilot" comment="Pilot to check"/>
        <param name="config" comment="Ship configuration"/>
      </params>
      <actions>
        <set_value name="$trainingResult" exact="table[]"/>
        <set_value name="$needsTraining" exact="false"/>
        <set_value name="$trainingAction" exact="'none'"/>
        
        <!-- Only check if auto-training is enabled -->
        <do_if value="$config.$AutoTraining and $pilot">
          <!-- Check training requirements using XP system -->
          <set_value name="$trainingStatus" exact="table[$Required = false, $Level = 1, $IsBlocked = false]"/>
          <do_if value="$pilot and global.$GT_Pilots.{$pilot}?">
            <set_value name="$currentLevel" exact="@global.$GT_Pilots.{$pilot}.$Level"/>
            <do_if value="not $currentLevel">
              <set_value name="$currentLevel" exact="1"/>
            </do_if>
            
            <!-- Check if training is beneficial (level < 5) -->
            <do_if value="$currentLevel lt 5">
              <set_value name="$trainingStatus.$Required" exact="true"/>
              <set_value name="$trainingStatus.$Level" exact="$currentLevel + 1"/>
            </do_if>
          </do_if>
          
          <set_value name="$needsTraining" exact="$trainingStatus.$Required"/>
          
          <do_if value="$needsTraining">
            <!-- Find training station -->
            <set_value name="$stationResult" exact="table[$Found = false, $Station = null]"/>
            <find_station name="$nearestStation" space="$ship.zone">
              <match class="class.station"/>
            </find_station>
            <do_if value="$nearestStation">
              <set_value name="$stationResult.$Found" exact="true"/>
              <set_value name="$stationResult.$Station" exact="$nearestStation"/>
            </do_if>
            
            <do_if value="$stationResult.$Found">
              <set_value name="$trainingAction" exact="'start_training'"/>
              <set_value name="$trainingResult.$TrainingStation" exact="$stationResult.$Station"/>
              <set_value name="$trainingResult.$RequiredLevel" exact="$trainingStatus.$Level"/>
            </do_if>
            <do_else>
              <set_value name="$trainingAction" exact="'no_station'"/>
            </do_else>
          </do_if>
          <do_elseif value="$trainingStatus.$IsBlocked">
            <!-- Pilot is blocked but no training needed - this shouldn't happen -->
            <set_value name="$trainingAction" exact="'clear_block'"/>
          </do_elseif>
        </do_if>
        
        <!-- Store results -->
        <set_value name="$trainingResult.$NeedsTraining" exact="$needsTraining"/>
        <set_value name="$trainingResult.$Action" exact="$trainingAction"/>
        <set_value name="$trainingResult.$TrainingStatus" exact="@$trainingStatus"/>
        
        <set_value name="this.$result" exact="$trainingResult"/>
      </actions>
    </library>
    
    <!-- Extract Configuration Variables for AI Script Compatibility -->
    <library name="Extract_Config_Variables" purpose="run_actions">
      <params>
        <param name="config" comment="Ship configuration"/>
      </params>
      <actions>
        <!-- Extract all configuration values into individual variables for backward compatibility -->
        <set_value name="$variables" exact="table[]"/>
        
        <!-- Basic trading settings -->
        <set_value name="$variables.$gt_allowillegal" exact="$config.$AllowIllegal"/>
        <set_value name="$variables.$gt_distancepenalty" exact="$config.$DistancePenalty"/>
        <set_value name="$variables.$gt_cargotarget" exact="$config.$CargoTarget"/>
        <set_value name="$variables.$gt_marketupdatefreq" exact="$config.$MarketUpdateFreq"/>
        
        <!-- System settings -->
        <set_value name="$variables.$gt_enablexp" exact="$config.$EnableXP"/>
        <set_value name="$variables.$gt_autotraining" exact="$config.$AutoTraining"/>
        <set_value name="$variables.$gt_fleetcoord" exact="$config.$FleetCoordination"/>
        <set_value name="$variables.$gt_tradecache" exact="$config.$TradeCache"/>
        <set_value name="$variables.$gt_cachethreshold" exact="$config.$CacheThreshold"/>
        <set_value name="$variables.$gt_cachettl" exact="$config.$CacheTTL"/>
        <set_value name="$variables.$gt_cachedropoff" exact="$config.$CacheDropoffTolerance"/>
        <set_value name="$variables.$gt_debuglevel" exact="$config.$DebugLevel"/>
        
        <!-- Jump distances -->
        <set_value name="$variables.$maxbuy" exact="$config.$MaxBuyDistance"/>
        <set_value name="$variables.$maxsell" exact="$config.$MaxSellDistance"/>
        
        <!-- Ware settings -->
        <set_value name="$variables.$warebasket" exact="$config.$WareBasket"/>
        <set_value name="$variables.$gt_notifications" exact="$config.$Notifications"/>
        <set_value name="$variables.$gt_tradeeval" exact="$config.$TradeEval"/>
        
        <!-- Debug settings -->
        <set_value name="$variables.$debugchance" exact="100"/>
        
        <set_value name="this.$result" exact="$variables"/>
      </actions>
    </library>
    
    <!-- Log Configuration Summary -->
    <library name="Log_Configuration_Summary">
      <params>
        <param name="ship" comment="Ship being configured"/>
        <param name="config" comment="Ship configuration"/>
        <param name="debug_level" default="1" comment="Minimum debug level to log"/>
      </params>
      <actions>
        <do_if value="$config.$DebugLevel ge $debug_level and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + $ship.idcode + ': === CONFIGURATION SUMMARY ==='" chance="100"/>
          <debug_text text="'[GT-AI] ' + $ship.idcode + ': Illegal=' + $config.$AllowIllegal + ', DistancePenalty=' + $config.$DistancePenalty + '%'" chance="100"/>
          <debug_text text="'[GT-AI] ' + $ship.idcode + ': XP=' + $config.$EnableXP + ', AutoTraining=' + $config.$AutoTraining + ', Fleet=' + $config.$FleetCoordination" chance="100"/>
          <debug_text text="'[GT-AI] ' + $ship.idcode + ': Distance limits: MaxBuy=' + $config.$MaxBuyDistance + ' jumps, MaxSell=' + $config.$MaxSellDistance + ' jumps'" chance="100"/>
          <debug_text text="'[GT-AI] ' + $ship.idcode + ': Ware basket: ' + $config.$WareBasket.count + ' wares configured (AutoWares=' + $config.$AutoWares + ')'" chance="100"/>
          
          <!-- Log skill information if available -->
          <do_if value="$config.$SkillInfo?">
            <debug_text text="'[GT-AI] ' + $ship.idcode + ': Skill Level=' + $config.$SkillInfo.$Level + ', Using MD System=' + $config.$SkillInfo.$UsingMDSystem" chance="100"/>
          </do_if>
        </do_if>
        
        <set_value name="this.$result" exact="true"/>
      </actions>
    </library>
    
    <!-- Handle Order Parameter Updates -->
    <library name="Update_Order_Parameters">
      <params>
        <param name="ship" comment="Ship with order to update"/>
        <param name="config" comment="Current configuration"/>
        <param name="pilot_xp_blocked" default="false" comment="Whether pilot is XP blocked"/>
      </params>
      <actions>
        <!-- Only update order parameters if pilot is not XP blocked to prevent restart loops -->
        <do_if value="not $pilot_xp_blocked and $ship.order?">
          <!-- Update MaxBuy parameter if corrected -->
          <do_if value="$config.$MaxBuy != $config.$MaxBuyDistance">
            <edit_order_param order="$ship.order" param="'maxbuy'" value="$config.$MaxBuyDistance"/>
          </do_if>
          
          <!-- Update MaxSell parameter if corrected -->
          <do_if value="$config.$MaxSell != $config.$MaxSellDistance">
            <edit_order_param order="$ship.order" param="'maxsell'" value="$config.$MaxSellDistance"/>
          </do_if>
        </do_if>
        
        <set_value name="this.$result" exact="true"/>
      </actions>
    </library>
    
    <!-- Clean Up Stale Flags -->
    <library name="Cleanup_Stale_Flags">
      <params>
        <param name="ship" comment="Ship to clean up"/>
      </params>
      <actions>
        <!-- Clear stale predictive training flags -->
        <do_if value="$ship.$TrainingRequiredAfterThisTrade?">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + $ship.idcode + ': Clearing stale predictive training flag'" chance="100"/>
          </do_if>
          <remove_value name="$ship.$TrainingRequiredAfterThisTrade"/>
        </do_if>
        
        <!-- Clear stale training in progress flags (older than 5 minutes) -->
        <do_if value="$ship.$TrainingInProgress? and $ship.$TrainingStartTime?">
          <do_if value="(player.age - $ship.$TrainingStartTime) gt 300s">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + $ship.idcode + ': Clearing stale training-in-progress flag (older than 5 minutes)'" chance="100"/>
            </do_if>
            <remove_value name="$ship.$TrainingInProgress"/>
            <remove_value name="$ship.$TrainingStartTime"/>
          </do_if>
        </do_if>
        
        <set_value name="this.$result" exact="true"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- NUMBER FORMATTING UTILITIES -->
    <!-- ========================================= -->
    
    <!-- Format Number with Thousand Separators and M Suffix -->
    <!-- Formats numbers according to global settings: thousand separator, decimal separator, M suffix threshold -->
    <library name="GT_FormatNumber" purpose="run_actions">
      <params>
        <param name="number" comment="Number to format (in credits, not RAW format)"/>
        <param name="suffix" default="' Cr'" comment="Suffix to append (default: ' Cr')"/>
      </params>
      <actions>
        <!-- Get formatting settings from global config -->
        <set_value name="$format" exact="if global.$GT_GlobalSettings.$NumberFormat.$Format? then global.$GT_GlobalSettings.$NumberFormat.$Format else 'german'"/>
        <!-- Set separators based on format choice -->
        <set_value name="$thousandSep" exact="if $format == 'german' then '.' else ','"/>
        <set_value name="$decimalSep" exact="if $format == 'german' then ',' else '.'"/>
        <set_value name="$useMSuffix" exact="if global.$GT_GlobalSettings.$NumberFormat.$UseMSuffix? then global.$GT_GlobalSettings.$NumberFormat.$UseMSuffix else true"/>
        <set_value name="$mThreshold" exact="if global.$GT_GlobalSettings.$NumberFormat.$MSuffixThreshold? then global.$GT_GlobalSettings.$NumberFormat.$MSuffixThreshold else 999999"/>
        
        <!-- Handle negative numbers -->
        <set_value name="$isNegative" exact="false"/>
        <set_value name="$absNumber" exact="$number"/>
        <do_if value="$number lt 0">
          <set_value name="$isNegative" exact="true"/>
          <set_value name="$absNumber" exact="-$number"/>
        </do_if>
        
        <!-- Check if we should use M suffix -->
        <set_value name="$useM" exact="false"/>
        <do_if value="$useMSuffix and $absNumber gt $mThreshold">
          <set_value name="$useM" exact="true"/>
        </do_if>
        
        <!-- Format the number -->
        <set_value name="$formatted" exact="''"/>
        <do_if value="$useM">
          <!-- Format as M suffix: e.g., "1,0 M" or "1.0 M" -->
          <!-- Use integer arithmetic: calculate value in tenths of millions, then round to nearest tenth -->
          <!-- Example: 1500000 -> 15 tenths -> 1.5 M -->
          <!-- Example: 1550000 -> 15.5 tenths -> round to 16 tenths -> 1.6 M -->
          <!-- Calculate value in hundredths for rounding precision -->
          <set_value name="$mValueTimes100" exact="($absNumber * 100) / 1000000"/>
          <!-- Round to nearest tenth: add 5 hundredths, then divide by 10 to get rounded tenths -->
          <set_value name="$mRoundedTimes10" exact="($mValueTimes100 + 5) / 10"/>
          <!-- Extract integer part (millions) -->
          <set_value name="$mInt" exact="$mRoundedTimes10 / 10"/>
          <!-- Extract decimal part (tenths) -->
          <set_value name="$mDec" exact="$mRoundedTimes10 - ($mInt * 10)"/>
          
          <!-- Build formatted string: "1,0" or "1.0" -->
          <set_value name="$mStr" exact="$mInt + ''"/>
          <do_if value="$mDec gt 0">
            <set_value name="$mStr" exact="$mStr + $decimalSep + $mDec"/>
          </do_if>
          <do_else>
            <!-- Always show at least one decimal: "1,0" or "1.0" -->
            <set_value name="$mStr" exact="$mStr + $decimalSep + '0'"/>
          </do_else>
          
          <set_value name="$formatted" exact="$mStr + ' M'"/>
        </do_if>
        <do_else>
          <!-- Format with thousand separators: e.g., "123.456" or "123,456" -->
          <!-- Use integer arithmetic to extract digits (more reliable than string operations) -->
          <set_value name="$result" exact="''"/>
          <set_value name="$remaining" exact="$absNumber"/>
          <set_value name="$digitCount" exact="0"/>
          
          <!-- Handle zero case -->
          <do_if value="$remaining == 0">
            <set_value name="$formatted" exact="'0'"/>
          </do_if>
          <do_else>
            <!-- Extract digits from right to left using integer arithmetic (no mod operator) -->
            <do_while value="$remaining gt 0">
              <!-- Get last digit using integer arithmetic: remaining - (remaining / 10) * 10 -->
              <set_value name="$digit" exact="$remaining - ($remaining / 10) * 10"/>
              <set_value name="$remaining" exact="$remaining / 10"/>
              
              <!-- Insert thousand separator every 3 digits (but not before first digit) -->
              <!-- Check if digitCount is divisible by 3 using integer arithmetic -->
              <set_value name="$digitCountDiv3" exact="$digitCount / 3"/>
              <set_value name="$digitCountMod3" exact="$digitCount - ($digitCountDiv3 * 3)"/>
              <do_if value="$digitCount gt 0 and $digitCountMod3 == 0">
                <set_value name="$result" exact="$thousandSep + $result"/>
              </do_if>
              
              <!-- Prepend digit to result -->
              <set_value name="$result" exact="$digit + $result"/>
              <set_value name="$digitCount" exact="$digitCount + 1"/>
            </do_while>
            
            <set_value name="$formatted" exact="$result"/>
          </do_else>
        </do_else>
        
        <!-- Add negative sign if needed -->
        <do_if value="$isNegative">
          <set_value name="$formatted" exact="'-' + $formatted"/>
        </do_if>
        
        <!-- Add suffix -->
        <set_value name="$formatted" exact="$formatted + $suffix"/>
        
        <!-- Return formatted string -->
        <return value="$formatted"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- LOGBOOK UTILITIES -->
    <!-- ========================================= -->
    
    <!-- Is Logbook Enabled -->
    <library name="GT_IsLogbookEnabled" purpose="run_actions">
      <params>
        <param name="ship" comment="Ship to check logbook setting for"/>
      </params>
      <actions>
        <set_value name="$logEnabled" exact="false"/>
        <do_if value="@$ship.defaultorder.id == 'GalaxyTraderMK3' and @$ship.defaultorder.$logbookentries">
          <set_value name="$logEnabled" exact="true"/>
        </do_if>
        <do_elseif value="@$ship.defaultorder.id == 'Assist' and @$ship.commander.defaultorder.id == 'GalaxyTraderMK3' and @$ship.commander.defaultorder.$logbookentries">
          <set_value name="$logEnabled" exact="true"/>
        </do_elseif>
        <return value="$logEnabled"/>
      </actions>
    </library>
    
    <!-- Write Logbook Message -->
    <!-- Centralized logbook message creation for MD scripts -->
    <!-- IMPORTANT: X4 TextDB doesn't support list variables, so callers must construct message string first -->
    <!-- Use: {77000,ID}.[param1, param2, ...] to create message, then pass as Message parameter -->
    <library name="WriteLogbookMessage" purpose="run_actions">
      <params>
        <param name="Message" comment="Message string (REQUIRED - construct using {77000,ID}.[params] before calling)"/>
        <param name="Category" comment="Logbook category: alerts, upkeep, news, general, tips"/>
        <param name="Title" comment="Logbook entry title"/>
        <param name="Object" default="null" comment="Object to attach message to (ship, station, etc.)"/>
        <param name="Interaction" default="null" comment="Interaction type: 'showonmap' or null"/>
        <param name="Highlighted" default="false" comment="Whether to highlight message (true/false)"/>
        <param name="Money" default="null" comment="Money amount to display (negative for expenses, positive for income)"/>
        <param name="Bonus" default="null" comment="Bonus amount to display (typically profit)"/>
        <param name="CheckGlobalSettings" default="true" comment="Check global logbook settings before writing (default true)"/>
      </params>
      <actions>
        <!-- DEBUG MODE: Check if debug logging is enabled (if CheckGlobalSettings is true) -->
        <!-- Logbook messages now only write when debug is enabled -->
        <set_value name="$shouldWrite" exact="true"/>
        <do_if value="$CheckGlobalSettings">
          <set_value name="$shouldWrite" exact="false"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Debug? and global.$GT_GlobalSettings.$Debug.$EnableDebugLogging? and global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$shouldWrite" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Write logbook if enabled -->
        <do_if value="$shouldWrite">
          <!-- Message is already constructed by caller using TextDB syntax -->
          <!-- Example: {77000,3218}.[@$newSector.knownname, @$currentDestination.knownname, ...] -->
          <!-- Determine object value -->
          <set_value name="$objectValue" exact="null"/>
          <do_if value="$Object? and $Object != null">
            <set_value name="$objectValue" exact="$Object"/>
          </do_if>
        <set_value name="$hasObject" exact="$objectValue? and $objectValue != null"/>
          
          <!-- Check if interaction is 'showonmap' -->
          <set_value name="$hasInteraction" exact="false"/>
          <do_if value="$Interaction? and $Interaction != null and $Interaction == 'showonmap'">
            <set_value name="$hasInteraction" exact="true"/>
          </do_if>
        <!-- If no object is provided, do not use interaction (vanilla player logbook entries omit object/interaction). -->
        <do_if value="not $hasObject">
          <set_value name="$hasInteraction" exact="false"/>
        </do_if>
          
          <!-- Debug: Log before writing logbook -->
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Debug? and global.$GT_GlobalSettings.$Debug.$EnableDebugLogging? and global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$msgExists" exact="if $Message? then 'true' else 'false'"/>
            <set_value name="$msgNull" exact="if $Message == null then 'true' else 'false'"/>
            <set_value name="$msgEmpty" exact="if $Message == '' then 'true' else 'false'"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-Logbook] WriteLogbookMessage: Category=' + $Category + ', Title=' + $Title" chance="100"/>
              <debug_text text="'[GT-Logbook] Message exists=' + $msgExists + ', null=' + $msgNull + ', empty=' + $msgEmpty" chance="100"/>
            </do_if>
          </do_if>
          
        <!-- Write logbook entry with conditional blocks for: hasObject -> interaction -> category -> money/bonus -->
        <!-- XSD requires literal values for category and interaction attributes -->
        <do_if value="not $hasObject">
          <!-- Player logbook only: omit object attribute entirely (vanilla pattern: write_to_logbook without object=...) -->
          <do_if value="$Category == 'alerts'">
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="alerts" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="alerts" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="alerts" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="alerts" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_if>
          <do_elseif value="$Category == 'upkeep'">
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="upkeep" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="upkeep" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="upkeep" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="upkeep" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_elseif>
          <do_elseif value="$Category == 'news'">
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="news" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="news" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="news" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="news" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_elseif>
          <do_elseif value="$Category == 'general'">
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_elseif>
          <do_elseif value="$Category == 'tips'">
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="tips" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="tips" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="tips" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="tips" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_elseif>
          <do_else>
            <!-- Default to 'general' if category not recognized -->
            <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
            </do_if>
            <do_elseif value="$Money? and $Money != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" money="$Money"/>
            </do_elseif>
            <do_elseif value="$Bonus? and $Bonus != null">
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted" bonus="$Bonus"/>
            </do_elseif>
            <do_else>
              <write_to_logbook category="general" title="$Title" text="$Message" highlighted="$Highlighted"/>
            </do_else>
          </do_else>
        </do_if>
        <do_elseif value="$hasInteraction">
            <!-- WITH interaction="showonmap" -->
            <do_if value="$Category == 'alerts'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="alerts" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_if>
            <do_elseif value="$Category == 'upkeep'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="upkeep" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'news'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="news" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="news" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="news" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="news" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'general'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'tips'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="tips" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_else>
              <!-- Default to 'general' if category not recognized -->
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="general" title="$Title" text="$Message" interaction="showonmap" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_else>
          </do_elseif>
          <do_else>
            <!-- WITHOUT interaction attribute -->
            <do_if value="$Category == 'alerts'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="alerts" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="alerts" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_if>
            <do_elseif value="$Category == 'upkeep'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="upkeep" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="upkeep" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'news'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="news" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="news" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="news" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="news" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'general'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$Category == 'tips'">
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="tips" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="tips" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_elseif>
            <do_else>
              <!-- Default to 'general' if category not recognized -->
              <do_if value="$Money? and $Money != null and $Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money" bonus="$Bonus"/>
              </do_if>
              <do_elseif value="$Money? and $Money != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" money="$Money"/>
              </do_elseif>
              <do_elseif value="$Bonus? and $Bonus != null">
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted" bonus="$Bonus"/>
              </do_elseif>
              <do_else>
                <write_to_logbook category="general" title="$Title" text="$Message" object="$objectValue" highlighted="$Highlighted"/>
              </do_else>
            </do_else>
          </do_else>
        </do_if>
      </actions>
    </library>
    
    <!-- Handle Logbook Message from AI Scripts -->
    <!-- AI scripts cannot call MD libraries directly, so they signal this cue -->
    <!-- AI scripts construct messages using TextDB syntax before sending (vanilla pattern) -->
    <cue name="HandleLogbookMessage" instantiate="true">
      <conditions>
        <event_object_signalled object="player.galaxy" param="'GT_WriteLogbook'"/>
      </conditions>
      <actions>
        <set_value name="$data" exact="event.param2"/>
        
        <!-- Call library with data from signal -->
        <!-- Message is already constructed by AI script using TextDB syntax -->
        <run_actions ref="md.GT_Libraries_General.WriteLogbookMessage">
          <param name="Message" value="$data.$Message"/>
          <param name="Category" value="$data.$Category"/>
          <param name="Title" value="$data.$Title"/>
          <param name="Object" value="if $data.$Object? then $data.$Object else null"/>
          <param name="Interaction" value="if $data.$Interaction? then $data.$Interaction else null"/>
          <param name="Highlighted" value="if $data.$Highlighted? then $data.$Highlighted else false"/>
          <param name="Money" value="if $data.$Money? then $data.$Money else null"/>
          <param name="Bonus" value="if $data.$Bonus? then $data.$Bonus else null"/>
          <param name="CheckGlobalSettings" value="if $data.$CheckGlobalSettings? then $data.$CheckGlobalSettings else true"/>
        </run_actions>
      </actions>
    </cue>

    <!-- ========================================= -->
    
    <!-- Counter Management Library Functions -->
    <!-- Centralized counter management to prevent leaks and ensure consistency -->
    
    <!-- Increment Counter (with initialization check) -->
    <library name="GT_IncrementCounter" purpose="run_actions">
      <params>
        <param name="counterPath" comment="Path to counter (e.g., 'global.$GT_SearchQueue.$ActiveSearches')"/>
        <param name="initializeIfMissing" default="true" comment="Initialize counter to 0 if it doesn't exist"/>
      </params>
      <actions>
        <!-- Extract counter object and property name -->
        <!-- For now, we'll use a simpler approach: pass the counter object and property name separately -->
        <!-- Actually, MD doesn't support dynamic property access, so we need a different approach -->
        <!-- We'll create specific functions for each counter type -->
      </actions>
    </library>
    
    <!-- Decrement Counter (with negative clamp) -->
    <library name="GT_DecrementCounter" purpose="run_actions">
      <params>
        <param name="counterPath" comment="Path to counter"/>
        <param name="clampToZero" default="true" comment="Clamp counter to 0 if it goes negative"/>
      </params>
      <actions>
        <!-- Similar limitation - MD doesn't support dynamic property access -->
        <!-- We'll create specific functions for each counter type -->
      </actions>
    </library>
    
    <!-- Increment ActiveSearches Counter -->
    <library name="GT_IncrementActiveSearches" purpose="run_actions">
      <params>
        <param name="initializeIfMissing" default="true" comment="Initialize counter to 0 if it doesn't exist"/>
      </params>
      <actions>
        <!-- Initialize counter if missing -->
        <do_if value="$initializeIfMissing">
          <do_if value="not global.$GT_SearchQueue?">
            <set_value name="global.$GT_SearchQueue" exact="table[]"/>
          </do_if>
          <do_if value="not global.$GT_SearchQueue.$ActiveSearches?">
            <set_value name="global.$GT_SearchQueue.$ActiveSearches" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Increment counter -->
        <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches?">
          <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="add"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Decrement ActiveSearches Counter (with negative clamp) -->
    <library name="GT_DecrementActiveSearches" purpose="run_actions">
      <params>
        <param name="clampToZero" default="true" comment="Clamp counter to 0 if it goes negative"/>
        <param name="triggerQueueProcessor" default="false" comment="Signal ProcessSearchQueue after decrement if ships are waiting"/>
      </params>
      <actions>
        <!-- Decrement counter -->
        <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches gt 0">
          <set_value name="global.$GT_SearchQueue.$ActiveSearches" operation="subtract"/>
        </do_if>
        
        <!-- Hard clamp: ActiveSearches must never go negative -->
        <do_if value="$clampToZero">
          <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$ActiveSearches? and global.$GT_SearchQueue.$ActiveSearches lt 0">
            <set_value name="global.$GT_SearchQueue.$ActiveSearches" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Trigger queue processor if requested and ships are waiting -->
        <do_if value="$triggerQueueProcessor">
          <do_if value="global.$GT_SearchQueue? and global.$GT_SearchQueue.$Ships? and global.$GT_SearchQueue.$Ships.count gt 0">
            <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessSearchQueue"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- Increment ActiveLiveSearches Counter -->
    <library name="GT_IncrementActiveLiveSearches" purpose="run_actions">
      <params>
        <param name="initializeIfMissing" default="true" comment="Initialize counter to 0 if it doesn't exist"/>
      </params>
      <actions>
        <!-- Initialize counter if missing -->
        <do_if value="$initializeIfMissing">
          <do_if value="not global.$GT_LiveSearchQueue?">
            <set_value name="global.$GT_LiveSearchQueue" exact="table[]"/>
          </do_if>
          <do_if value="not global.$GT_LiveSearchQueue.$ActiveLiveSearches?">
            <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Increment counter -->
        <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$ActiveLiveSearches?">
          <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" operation="add"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Decrement ActiveLiveSearches Counter (with negative clamp) -->
    <library name="GT_DecrementActiveLiveSearches" purpose="run_actions">
      <params>
        <param name="clampToZero" default="true" comment="Clamp counter to 0 if it goes negative"/>
        <param name="triggerQueueProcessor" default="false" comment="Signal ProcessLiveSearchQueue after decrement if ships are waiting"/>
      </params>
      <actions>
        <!-- Decrement counter -->
        <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$ActiveLiveSearches? and global.$GT_LiveSearchQueue.$ActiveLiveSearches gt 0">
          <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" operation="subtract"/>
        </do_if>
        
        <!-- Hard clamp: ActiveLiveSearches must never go negative -->
        <do_if value="$clampToZero">
          <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$ActiveLiveSearches? and global.$GT_LiveSearchQueue.$ActiveLiveSearches lt 0">
            <set_value name="global.$GT_LiveSearchQueue.$ActiveLiveSearches" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Trigger queue processor if requested and ships are waiting -->
        <!-- FIX: Check actual queue structure ($Sectors + $BySector.{sector}.$Ships), not non-existent $Ships field -->
        <do_if value="$triggerQueueProcessor">
          <set_value name="$hasQueuedShips" exact="false"/>
          <do_if value="global.$GT_LiveSearchQueue? and global.$GT_LiveSearchQueue.$Sectors? and global.$GT_LiveSearchQueue.$Sectors.count gt 0">
            <do_all exact="global.$GT_LiveSearchQueue.$Sectors.count" counter="$i">
              <set_value name="$sec" exact="global.$GT_LiveSearchQueue.$Sectors.{$i}"/>
              <do_if value="$sec? and global.$GT_LiveSearchQueue.$BySector? and global.$GT_LiveSearchQueue.$BySector.{$sec}? and global.$GT_LiveSearchQueue.$BySector.{$sec}.$Ships.count gt 0">
                <set_value name="$hasQueuedShips" exact="true"/>
                <break/>
              </do_if>
            </do_all>
          </do_if>
          <do_if value="$hasQueuedShips">
            <signal_cue_instantly cue="md.GT_Trading_Queue.ProcessLiveSearchQueue"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- Increment ActiveProcessors Counter -->
    <library name="GT_IncrementActiveProcessors" purpose="run_actions">
      <params>
        <param name="initializeIfMissing" default="true" comment="Initialize counter to 0 if it doesn't exist"/>
      </params>
      <actions>
        <!-- Initialize counter if missing -->
        <do_if value="$initializeIfMissing">
          <do_if value="not global.$GT_BatchProcessorQueue?">
            <set_value name="global.$GT_BatchProcessorQueue" exact="table[]"/>
          </do_if>
          <do_if value="not global.$GT_BatchProcessorQueue.$ActiveProcessors?">
            <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Increment counter -->
        <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors?">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="add"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Decrement ActiveProcessors Counter (with negative clamp) -->
    <library name="GT_DecrementActiveProcessors" purpose="run_actions">
      <params>
        <param name="clampToZero" default="true" comment="Clamp counter to 0 if it goes negative"/>
        <param name="triggerQueueProcessor" default="false" comment="Signal ProcessBatchProcessorQueue after decrement if ships are waiting"/>
      </params>
      <actions>
        <!-- Decrement counter -->
        <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors gt 0">
          <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" operation="subtract"/>
        </do_if>
        
        <!-- Hard clamp: ActiveProcessors must never go negative -->
        <do_if value="$clampToZero">
          <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$ActiveProcessors? and global.$GT_BatchProcessorQueue.$ActiveProcessors lt 0">
            <set_value name="global.$GT_BatchProcessorQueue.$ActiveProcessors" exact="0"/>
          </do_if>
        </do_if>
        
        <!-- Trigger queue processor if requested and ships are waiting -->
        <do_if value="$triggerQueueProcessor">
          <do_if value="global.$GT_BatchProcessorQueue? and global.$GT_BatchProcessorQueue.$Ships? and global.$GT_BatchProcessorQueue.$Ships.count gt 0">
            <signal_cue_instantly cue="md.GT_Trading_Batch_Processor.ProcessBatchProcessorQueue"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- TRADE SEARCH PIPELINE LOGGING -->
    <!-- ========================================= -->
    
    <!-- ========================================= -->
    <!-- TRADE INDEX (Cross-Cache Invalidation) -->
    <!-- ========================================= -->
    
    <!-- ========================================= -->
    <!-- CENTRAL SCHEDULER (Phase 2) -->
    <!-- ========================================= -->
    
    <!-- Create Work Item for Scheduler -->
    <!-- Work items represent units of work in the trade search pipeline -->
    <library name="GT_CreateWorkItem" purpose="run_actions">
      <params>
        <param name="type" comment="Work item type: 'Request', 'CacheQuery', 'SearchContinuation', 'HomeSearch', 'OfferCollect', 'Match', 'Finalize'"/>
        <param name="key" comment="Unique key for this work item (typically ship.idcode + '_' + type)"/>
        <param name="traceId" comment="Trace ID for this work item"/>
        <param name="payload" default="table[]" comment="Type-specific payload data"/>
      </params>
      <actions>
        <!-- Validate inputs - ERROR if missing -->
        <do_if value="$type == '' or $key == ''">
          <debug_text text="'[GT-ERROR] GT_CreateWorkItem: type or key is empty - type=' + $type + ' key=' + $key" chance="100"/>
          <return value="null"/>
        </do_if>
        
        <set_value name="$workItem" exact="table[
          $Type = $type,
          $Key = $key,
          $TraceId = $traceId,
          $CreatedAt = player.age,
          $UpdatedAt = player.age,
          $State = 'queued',
          $Payload = $payload
        ]"/>
        
        <return value="$workItem"/>
      </actions>
    </library>
    
    <!-- Enqueue Work Item to Scheduler -->
    <library name="GT_EnqueueWorkItem" purpose="run_actions">
      <params>
        <param name="workItem" comment="Work item to enqueue"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- CRITICAL: Initialize scheduler if missing (defensive initialization) -->
        <!-- This handles race conditions where work items are enqueued before SystemInit completes -->
        <do_if value="not global.$GT_Scheduler?">
          <set_value name="global.$GT_Scheduler" exact="table[
            $WorkQueue = [],
            $ActiveWork = table[],
            $Budgets = table[
              $CheapOpsPerTick = 10,
              $OfferOpsPerTick = 5,
              $MatchOpsPerTick = 1,
              $MaxActiveHomeSearches = 1
            ],
            $Counters = table[
              $Queued = 0,
              $Active = 0,
              $Completed = 0,
              $Failed = 0
            ],
            $Processing = false,
            $LastStatsLog = player.age
          ]"/>
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Initialized'"/>
              <param name="details" value="'reason=auto_init_on_enqueue type=' + (if $workItem? and $workItem.$Type? then $workItem.$Type else 'unknown')"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-WARN] GT_EnqueueWorkItem: Scheduler auto-initialized (should have been initialized by SystemInit)'" chance="100"/>
          </do_else>
        </do_if>
        <!-- Ensure required properties exist (defensive check) -->
        <do_if value="not global.$GT_Scheduler.$WorkQueue?">
          <set_value name="global.$GT_Scheduler.$WorkQueue" exact="[]"/>
        </do_if>
        <!-- CRITICAL: Ensure ActiveWork exists - but DON'T fix corruption here -->
        <!-- Corruption detection/fixing is handled by ProcessWorkQueue (authoritative processor) -->
        <!-- This prevents race conditions where multiple places try to fix corruption simultaneously -->
        <do_if value="not global.$GT_Scheduler.$ActiveWork?">
          <set_value name="global.$GT_Scheduler.$ActiveWork" exact="table[]"/>
        </do_if>
        <!-- NOTE: We don't check for corruption here - ProcessWorkQueue handles that -->
        <!-- If ActiveWork is corrupted, ProcessWorkQueue will detect and fix it on its next tick -->
        
        <!-- Validate work item - ERROR if missing -->
        <do_if value="not $workItem? or not $workItem.$Type? or not $workItem.$Key?">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=invalid_workItem'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_EnqueueWorkItem: Work item is null or missing required fields'" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Ensure WorkQueue exists -->
        <do_if value="not global.$GT_Scheduler.$WorkQueue?">
          <set_value name="global.$GT_Scheduler.$WorkQueue" exact="[]"/>
        </do_if>
        <!-- NOTE: ActiveWork type check already done above (lines 4788-4800) - no need to check again -->
        <do_if value="not global.$GT_Scheduler.$Processing?">
          <set_value name="global.$GT_Scheduler.$Processing" exact="false"/>
        </do_if>
        
        <!-- Add to queue -->
        <append_to_list name="global.$GT_Scheduler.$WorkQueue" exact="$workItem"/>
        
        <!-- Update counters -->
        <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
          <param name="counterName" value="'Queued'"/>
          <param name="delta" value="1"/>
        </run_actions>
        
        <!-- Log work item queued -->
        <set_value name="$logTraceId" exact="if $traceId != '' then $traceId else (if $workItem.$TraceId? then $workItem.$TraceId else '0')"/>
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$logTraceId"/>
          <param name="stage" value="'Scheduler'"/>
          <param name="action" value="'WorkItemQueued'"/>
          <param name="details" value="'type=' + $workItem.$Type + ' key=' + $workItem.$Key + ' queue=' + global.$GT_Scheduler.$WorkQueue.count"/>
          <param name="logLevel" value="2"/>
        </run_actions>
        
        <!-- Trigger scheduler processing if not already running (single signal, no duplicate) -->
        <!-- ROOT CAUSE FIX: Use ProcessWorkQueueDelayed instead of direct signal to prevent stutter -->
        <!-- Direct signal can cause multiple ProcessWorkQueue instances in same frame -->
        <do_if value="not global.$GT_Scheduler.$Processing">
          <signal_cue_instantly cue="md.GT_TradeSearch_Scheduler.ProcessWorkQueueDelayed"/>
        </do_if>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Update Work Item State -->
    <library name="GT_UpdateWorkItemState" purpose="run_actions">
      <params>
        <param name="key" comment="Work item key"/>
        <param name="newState" comment="New state: 'queued', 'active', 'completed', 'failed'"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
        <param name="reason" default="''" comment="Failure reason (if state='failed')"/>
        <param name="workItem" default="null" comment="Work item object (optional - if provided, skips lookup)"/>
      </params>
      <actions>
        <!-- Validate scheduler exists - ERROR if missing -->
        <do_if value="not global.$GT_Scheduler?">
          <debug_text text="'[GT-ERROR] GT_UpdateWorkItemState: Scheduler not initialized - key=' + $key" chance="100"/>
          <return value="false"/>
        </do_if>
        
        <!-- Use provided work item or find it in WorkQueue -->
        <!-- NOTE: ActiveWork is now keyed by ship, not by string key, so we can't look it up by key -->
        <set_value name="$oldState" exact="'unknown'"/>
        <set_value name="$workShip" exact="null"/>
        
        <do_if value="$workItem != null">
          <!-- Use provided work item -->
          <set_value name="$oldState" exact="if $workItem.$State? then $workItem.$State else 'unknown'"/>
          <!-- Extract ship from payload for ActiveWork operations -->
          <do_if value="$workItem.$Payload?">
            <set_value name="$workShip" exact="@$workItem.$Payload.$Ship"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Find work item in WorkQueue (can't look up ActiveWork by key anymore - it's keyed by ship) -->
          <set_value name="$workItem" exact="null"/>
          
          <!-- Check WorkQueue -->
          <do_if value="global.$GT_Scheduler.$WorkQueue?">
            <do_all exact="global.$GT_Scheduler.$WorkQueue.count" counter="$i">
              <do_if value="global.$GT_Scheduler.$WorkQueue.{$i}.$Key == $key">
                <set_value name="$workItem" exact="global.$GT_Scheduler.$WorkQueue.{$i}"/>
                <set_value name="$oldState" exact="if $workItem.$State? then $workItem.$State else 'unknown'"/>
                <!-- Extract ship from payload -->
                <do_if value="$workItem.$Payload?">
                  <set_value name="$workShip" exact="@$workItem.$Payload.$Ship"/>
                </do_if>
                <break/>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- ERROR if work item not found -->
          <do_if value="not $workItem? or $workItem == null">
            <do_if value="$traceId != ''">
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="$traceId"/>
                <param name="stage" value="'Scheduler'"/>
                <param name="action" value="'Error'"/>
                <param name="details" value="'reason=workItem_not_found key=' + $key + ' newState=' + $newState"/>
                <param name="logLevel" value="0"/>
              </run_actions>
            </do_if>
            <do_else>
              <debug_text text="'[GT-ERROR] GT_UpdateWorkItemState: Work item not found - key=' + $key" chance="100"/>
            </do_else>
            <return value="false"/>
          </do_if>
        </do_else>
        
        <!-- CRITICAL FIX: Validate workItem is not null before accessing properties -->
        <do_if value="not $workItem? or $workItem == null">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Scheduler'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=workItem_is_null key=' + $key + ' newState=' + $newState"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_UpdateWorkItemState: Work item is null - key=' + $key" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Update state -->
        <set_value name="$workItem.$State" exact="$newState"/>
        <set_value name="$workItem.$UpdatedAt" exact="player.age"/>
        
        <!-- Update in ActiveWork if present (keyed by ship, not by key) -->
        <do_if value="$workShip? and global.$GT_Scheduler.$ActiveWork? and global.$GT_Scheduler.$ActiveWork.{$workShip}?">
          <set_value name="global.$GT_Scheduler.$ActiveWork.{$workShip}" exact="$workItem"/>
        </do_if>
        
        <!-- Log state transition -->
        <!-- CRITICAL FIX: Use safe property access for logging -->
        <set_value name="$logTraceId" exact="if $traceId != '' then $traceId else (if $workItem? and $workItem.$TraceId? then $workItem.$TraceId else '0')"/>
        <set_value name="$workItemType" exact="if $workItem? and $workItem.$Type? then $workItem.$Type else 'unknown'"/>
        <set_value name="$details" exact="'type=' + $workItemType + ' key=' + $key + ' state=' + $oldState + '->' + $newState"/>
        <do_if value="$newState == 'failed' and $reason != ''">
          <set_value name="$details" exact="$details + ' reason=' + $reason"/>
        </do_if>
        <do_if value="$newState == 'completed'">
          <!-- CRITICAL FIX: Use safe property access -->
          <do_if value="$workItem? and $workItem.$CreatedAt?">
            <set_value name="$duration" exact="player.age - $workItem.$CreatedAt"/>
            <set_value name="$details" exact="$details + ' duration=' + ($duration / 1ms) + 'ms'"/>
          </do_if>
        </do_if>
        
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$logTraceId"/>
          <param name="stage" value="'Scheduler'"/>
          <param name="action" value="'WorkItemStateChange'"/>
          <param name="details" value="$details"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <!-- Update counters -->
        <do_if value="$oldState == 'queued' and $newState == 'active'">
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Queued'"/>
            <param name="delta" value="-1"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Active'"/>
            <param name="delta" value="1"/>
          </run_actions>
        </do_if>
        <do_elseif value="$oldState == 'active' and $newState == 'completed'">
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Active'"/>
            <param name="delta" value="-1"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Completed'"/>
            <param name="delta" value="1"/>
          </run_actions>
        </do_elseif>
        <do_elseif value="$oldState == 'active' and $newState == 'failed'">
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Active'"/>
            <param name="delta" value="-1"/>
          </run_actions>
          <run_actions ref="md.GT_Libraries_General.GT_UpdatePipelineCounter">
            <param name="counterName" value="'Failed'"/>
            <param name="delta" value="1"/>
          </run_actions>
        </do_elseif>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Generate Trade Key (Option A: BuyOffer.id + SellOffer.id) -->
    <!-- Simple approach: uses offer IDs which are unique per offer instance -->
    <!-- Trade key format: "buyOfferId_sellOfferId" or "null_sellOfferId" for sell-only -->
    <library name="GT_GenerateTradeKey" purpose="run_actions">
      <params>
        <param name="buyOffer" default="null" comment="Buy offer object (may be null for sell-only trades)"/>
        <param name="sellOffer" comment="Sell offer object (required)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <set_value name="$tradeKey" exact="''"/>
        
        <!-- Validate sell offer - ERROR if missing -->
        <do_if value="not $sellOffer? or not $sellOffer.exists">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=missing_sellOffer'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_GenerateTradeKey: sellOffer is null or missing - cannot generate trade key'" chance="100"/>
          </do_else>
          <return value="''"/>
        </do_if>
        
        <!-- Get offer IDs -->
        <set_value name="$buyOfferId" exact="'null'"/>
        <set_value name="$sellOfferId" exact="''"/>
        
        <do_if value="$buyOffer? and $buyOffer.exists">
          <set_value name="$tempBuyId" exact="@$buyOffer.id"/>
          <do_if value="$tempBuyId? and $tempBuyId != null">
            <set_value name="$buyOfferId" exact="'' + $tempBuyId"/>
          </do_if>
        </do_if>
        
        <!-- Validate sellOffer has valid ID before generating key -->
        <!-- CRITICAL: Check if sellOffer.id exists and is not null before converting to string -->
        <set_value name="$tempSellId" exact="@$sellOffer.id"/>
        <do_if value="$tempSellId? and $tempSellId != null and typeof $tempSellId != datatype.null">
          <!-- Valid ID - convert to string -->
          <set_value name="$sellOfferId" exact="'' + $tempSellId"/>
          <!-- Double-check: ensure sellOfferId is not empty or 'null' string -->
          <do_if value="$sellOfferId == '' or $sellOfferId == 'null'">
            <!-- ID conversion failed - log error and return empty key -->
            <do_if value="$traceId != ''">
              <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
                <param name="traceId" value="$traceId"/>
                <param name="stage" value="'CacheIndex'"/>
                <param name="action" value="'Error'"/>
                <param name="details" value="'reason=invalid_sellOffer_id_conversion tempSellId=' + (if $tempSellId? then $tempSellId else 'null') + ' sellOfferId=' + $sellOfferId"/>
                <param name="logLevel" value="0"/>
              </run_actions>
            </do_if>
            <do_else>
              <debug_text text="'[GT-ERROR] GT_GenerateTradeKey: sellOffer.id conversion failed - tempSellId=' + (if $tempSellId? then $tempSellId else 'null') + ', sellOfferId=' + $sellOfferId" chance="100"/>
            </do_else>
            <return value="''"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Fallback (Method B): offer.id is not available in many X4 trade-offer objects.
               Use the SELL offer object itself as the reservation key.
               This restores reservation behavior under fleet load and prevents mass cache collisions. -->
          <set_value name="$tradeKey" exact="$sellOffer"/>
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'KeyGenerated'"/>
              <param name="details" value="'trade=SellOfferObj method=B buyOffer=' + (if $buyOffer? then 'valid' else 'null') + ' sellOffer=valid'"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          <return value="$tradeKey"/>
        </do_else>
        
        <!-- Generate key: "buyOfferId_sellOfferId" -->
        <!-- CRITICAL: Validate sellOfferId is not empty before generating key -->
        <do_if value="$sellOfferId == ''">
          <!-- sellOfferId is empty - this should have been caught earlier, but double-check -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=empty_sellOfferId buyOfferId=' + $buyOfferId"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_GenerateTradeKey: sellOfferId is empty - cannot generate trade key'" chance="100"/>
          </do_else>
          <return value="''"/>
        </do_if>
        
        <set_value name="$tradeKey" exact="$buyOfferId + '_' + $sellOfferId"/>
        
        <!-- Validate generated key is not null_null (indicates invalid offer IDs) -->
        <do_if value="$tradeKey == 'null_null'">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=invalid_offer_ids buyOfferId=' + $buyOfferId + ' sellOfferId=' + $sellOfferId"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_GenerateTradeKey: Generated invalid trade key null_null - buyOfferId=' + $buyOfferId + ', sellOfferId=' + $sellOfferId" chance="100"/>
          </do_else>
          <return value="''"/>
        </do_if>
        
        <!-- Log key generation -->
        <do_if value="$traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'CacheIndex'"/>
            <param name="action" value="'KeyGenerated'"/>
            <param name="details" value="'trade=' + $tradeKey + ' method=A buyOffer=' + (if $buyOffer? then 'valid' else 'null') + ' sellOffer=valid'"/>
            <param name="logLevel" value="3"/>
          </run_actions>
        </do_if>
        
        <return value="$tradeKey"/>
      </actions>
    </library>
    
    <!-- Initialize Trade Index Structure -->
    <library name="GT_InitializeTradeIndex" purpose="run_actions">
      <actions>
        <do_if value="not global.$GT_TradeIndex?">
          <set_value name="global.$GT_TradeIndex" exact="table[]"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Add Trade to Index -->
    <!-- Called when writing to cache: adds home sector to index entry -->
    <library name="GT_AddTradeToIndex" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
        <param name="homeSector" comment="Home sector where this trade is cached"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Initialize index if needed -->
        <run_actions ref="md.GT_Libraries_General.GT_InitializeTradeIndex"/>
        
        <!-- Validate inputs - ERROR if missing or invalid (null_null indicates invalid offers) -->
        <do_if value="$tradeKey == '' or $tradeKey == 'null_null'">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=' + (if $tradeKey == 'null_null' then 'invalid_tradeKey_null_null' else 'empty_tradeKey')"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_AddTradeToIndex: tradeKey is empty or invalid (' + $tradeKey + ') - cannot add to index'" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        <do_if value="not $homeSector? or not $homeSector.exists">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=invalid_homeSector tradeKey=' + $tradeKey"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_AddTradeToIndex: homeSector is null or invalid - tradeKey=' + $tradeKey" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Get or create index entry -->
        <set_value name="$indexEntry" exact="null"/>
        <do_if value="global.$GT_TradeIndex.{$tradeKey}?">
          <set_value name="$indexEntry" exact="global.$GT_TradeIndex.{$tradeKey}"/>
        </do_if>
        <do_else>
          <set_value name="$indexEntry" exact="table[
            $Homes = [],
            $ReservedBy = null,
            $ReservedUntil = null
          ]"/>
          <set_value name="global.$GT_TradeIndex.{$tradeKey}" exact="$indexEntry"/>
        </do_else>
        
        <!-- Add home sector to list if not already present -->
        <set_value name="$homeExists" exact="false"/>
        <do_if value="$indexEntry.$Homes?">
          <do_all exact="$indexEntry.$Homes.count" counter="$i">
            <do_if value="$indexEntry.$Homes.{$i} == $homeSector">
              <set_value name="$homeExists" exact="true"/>
              <break/>
            </do_if>
          </do_all>
        </do_if>
        
        <do_if value="not $homeExists">
          <append_to_list name="global.$GT_TradeIndex.{$tradeKey}.$Homes" exact="$homeSector"/>
          
          <!-- Log index update -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Added'"/>
              <param name="details" value="'trade=' + $tradeKey + ' home=' + (if $homeSector? then @$homeSector.knownname else 'null') + ' homes=' + global.$GT_TradeIndex.{$tradeKey}.$Homes.count"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
        </do_if>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Remove Trade from Index -->
    <!-- Called when invalidating: removes home sector from index entry, removes entry if empty -->
    <library name="GT_RemoveTradeFromIndex" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
        <param name="homeSector" comment="Home sector to remove (null to remove all)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Validate index exists - ERROR if missing -->
        <do_if value="not global.$GT_TradeIndex?">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=index_not_initialized trade=' + $tradeKey"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_RemoveTradeFromIndex: Trade index not initialized - tradeKey=' + $tradeKey" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Validate trade key entry exists -->
        <do_if value="not global.$GT_TradeIndex.{$tradeKey}?">
          <!-- This is expected if trade was never cached - log but don't error -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Warning'"/>
              <param name="details" value="'reason=entry_not_found trade=' + $tradeKey"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
          <return value="false"/>
        </do_if>
        
        <set_value name="$indexEntry" exact="global.$GT_TradeIndex.{$tradeKey}"/>
        
        <!-- Remove specific home sector or all -->
        <do_if value="$homeSector? and $homeSector.exists">
          <!-- Remove specific home sector -->
          <do_if value="$indexEntry.$Homes?">
            <remove_from_list name="global.$GT_TradeIndex.{$tradeKey}.$Homes" exact="$homeSector"/>
          </do_if>
        </do_if>
        <do_else>
          <!-- Remove all home sectors (trade fully consumed) -->
          <set_value name="global.$GT_TradeIndex.{$tradeKey}.$Homes" exact="[]"/>
        </do_else>
        
        <!-- Remove index entry if no homes remain -->
        <do_if value="not global.$GT_TradeIndex.{$tradeKey}.$Homes? or global.$GT_TradeIndex.{$tradeKey}.$Homes.count == 0">
          <remove_value name="global.$GT_TradeIndex.{$tradeKey}"/>
          
          <!-- Log index removal -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Removed'"/>
              <param name="details" value="'trade=' + $tradeKey + ' reason=no_homes'"/>
              <param name="logLevel" value="2"/>
            </run_actions>
          </do_if>
        </do_if>
        <do_else>
          <!-- Log partial removal -->
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'CacheIndex'"/>
              <param name="action" value="'Updated'"/>
              <param name="details" value="'trade=' + $tradeKey + ' homes=' + global.$GT_TradeIndex.{$tradeKey}.$Homes.count"/>
              <param name="logLevel" value="3"/>
            </run_actions>
          </do_if>
        </do_else>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Get Home Sectors for Trade Key -->
    <!-- Returns list of home sectors where this trade is cached -->
    <!-- ERROR if index not initialized or entry missing -->
    <library name="GT_GetTradeIndexHomes" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
      </params>
      <actions>
        <set_value name="$homes" exact="[]"/>
        
        <!-- Validate index exists -->
        <do_if value="not global.$GT_TradeIndex?">
          <debug_text text="'[GT-ERROR] GT_GetTradeIndexHomes: Trade index not initialized - tradeKey=' + $tradeKey" chance="100"/>
          <return value="$homes"/>
        </do_if>
        
        <!-- Validate trade key entry exists -->
        <do_if value="not global.$GT_TradeIndex.{$tradeKey}?">
          <!-- This is expected if trade was never cached - return empty list -->
          <return value="$homes"/>
        </do_if>
        
        <!-- Validate Homes list exists -->
        <do_if value="not global.$GT_TradeIndex.{$tradeKey}.$Homes?">
          <debug_text text="'[GT-ERROR] GT_GetTradeIndexHomes: Index entry missing $Homes property - tradeKey=' + $tradeKey" chance="100"/>
          <return value="$homes"/>
        </do_if>
        
        <set_value name="$homes" exact="global.$GT_TradeIndex.{$tradeKey}.$Homes"/>
        
        <return value="$homes"/>
      </actions>
    </library>
    
    <!-- Failure Reason Constants -->
    <!-- Standardized failure reasons for trade search pipeline -->
    <library name="GT_GetFailureReason" purpose="run_actions">
      <params>
        <param name="reason" comment="Failure reason code"/>
      </params>
      <actions>
        <!-- Initialize failure reason constants if not exists -->
        <do_if value="not global.$GT_FailureReasons?">
          <set_value name="global.$GT_FailureReasons" exact="table[
            $NoSectors = 'no_sectors',
            $NoOffers = 'no_offers',
            $NoProfitableMatches = 'no_profitable_matches',
            $DockingBlocked = 'docking_blocked',
            $IllegalBlocked = 'illegal_blocked',
            $BlacklistBlocked = 'blacklist_blocked',
            $PathBlocked = 'path_blocked',
            $ReservedConflict = 'reserved_conflict',
            $CacheMiss = 'cache_miss',
            $CacheEmpty = 'cache_empty',
            $CacheNoValidTrades = 'cache_no_valid_trades',
            $ShipDestroyed = 'ship_destroyed',
            $NoGTOrder = 'no_gt_order',
            $ShipBusy = 'ship_busy',
            $InvalidParams = 'invalid_params',
            $StaleState = 'stale_state',
            $BatchStall = 'batch_stall',
            $Timeout = 'timeout',
            $StateCorruption = 'state_corruption',
            $Unknown = 'unknown'
          ]"/>
        </do_if>
        
        <!-- Return failure reason string -->
        <set_value name="$reasonStr" exact="'unknown'"/>
        <do_if value="global.$GT_FailureReasons.{$reason}?">
          <set_value name="$reasonStr" exact="global.$GT_FailureReasons.{$reason}"/>
        </do_if>
        <return value="$reasonStr"/>
      </actions>
    </library>
    
    <!-- Log Trade Search Event (Simple Format) -->
    <library name="GT_LogTradeSearch" purpose="run_actions">
      <params>
        <param name="traceId" default="0" comment="Trace ID for request correlation"/>
        <param name="stage" default="'Unknown'" comment="Stage name (Request, CacheQuery, HomeSearch, OfferCollect, Match, Finalize, Scheduler, Reservation, Cache, Error)"/>
        <param name="action" default="'Event'" comment="Action name (Start, End, Hit, Miss, Error, etc.)"/>
        <param name="details" default="''" comment="Details string (key=value pairs)"/>
        <param name="chance" default="100" comment="Log chance (0-100)"/>
        <param name="logLevel" default="1" comment="Log level (0=error/critical, 1=important, 2=info, 3=debug) - maps to chance if chance not provided"/>
      </params>
      <actions>
        <!-- Map logLevel to chance if chance not explicitly provided (default 100) -->
        <set_value name="$logChance" exact="$chance"/>
        <do_if value="$chance == 100 and $logLevel != 1">
          <!-- logLevel 0,1,2 = always log (100), logLevel 3 = debug (100 for now, user said "log all") -->
          <set_value name="$logChance" exact="100"/>
        </do_if>
        
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$timestamp" exact="player.age"/>
          <set_value name="$logMsg" exact="'[GT-TS] ' + $timestamp + ' ' + $traceId + ' ' + $stage + ' ' + $action + ' ' + $details"/>
          <debug_text text="$logMsg" chance="$logChance"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Log Trade Search Event (Structured Format for PS Scripts) -->
    <library name="GT_LogTradeSearchStructured" purpose="run_actions">
      <params>
        <param name="traceId" default="0" comment="Trace ID for request correlation"/>
        <param name="stage" default="'Unknown'" comment="Stage name"/>
        <param name="action" default="'Event'" comment="Action name"/>
        <param name="fields" default="table[]" comment="Key-value pairs table for structured logging"/>
      </params>
      <actions>
        <do_if value="global.$GT_Config.$Debug.$Enabled and global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$timestamp" exact="player.age"/>
          <set_value name="$detailStr" exact="''"/>
          <do_if value="$fields? and $fields.keys?">
            <do_all exact="$fields.keys.count" counter="$i">
              <set_value name="$key" exact="$fields.keys.{$i}"/>
              <set_value name="$value" exact="@$fields.{$key}"/>
              <set_value name="$separator" exact="if $i lt $fields.keys.count then ' ' else ''"/>
              <set_value name="$detailStr" exact="$detailStr + $key + '=' + $value + $separator"/>
            </do_all>
          </do_if>
          <set_value name="$logMsg" exact="'[GT-TS] ' + $timestamp + ' ' + $traceId + ' ' + $stage + ' ' + $action + ' ' + $detailStr"/>
          <debug_text text="$logMsg" chance="100"/>
        </do_if>
      </actions>
    </library>
    
    <!-- Generate Next Trace ID -->
    <library name="GT_GenerateTraceId" purpose="run_actions">
      <params>
      </params>
      <actions>
        <!-- Initialize trace ID counter if missing -->
        <do_if value="not global.$GT_TraceIdCounter?">
          <set_value name="global.$GT_TraceIdCounter" exact="1"/>
        </do_if>
        
        <!-- Get current trace ID and increment -->
        <set_value name="$traceId" exact="global.$GT_TraceIdCounter"/>
        <set_value name="global.$GT_TraceIdCounter" operation="add"/>
        
        <!-- Return trace ID -->
        <return value="$traceId"/>
      </actions>
    </library>
    
    <!-- Update Pipeline Counter -->
    <library name="GT_UpdatePipelineCounter" purpose="run_actions">
      <params>
        <param name="counterName" comment="Counter name (Queued, Active, Completed, Failed)"/>
        <param name="delta" default="1" comment="Delta value (positive to increment, negative to decrement)"/>
      </params>
      <actions>
        <!-- Initialize counters structure if missing -->
        <do_if value="not global.$GT_PipelineCounters?">
          <set_value name="global.$GT_PipelineCounters" exact="table[
            $Queued = 0,
            $Active = 0,
            $Completed = 0,
            $Failed = 0
          ]"/>
        </do_if>
        
        <!-- Update counter -->
        <do_if value="global.$GT_PipelineCounters.{$counterName}?">
          <do_if value="$delta gt 0">
            <do_all exact="$delta" counter="$i">
              <set_value name="global.$GT_PipelineCounters.{$counterName}" operation="add"/>
            </do_all>
          </do_if>
          <do_elseif value="$delta lt 0">
            <set_value name="$absDelta" exact="-$delta"/>
            <do_all exact="$absDelta" counter="$i">
              <set_value name="global.$GT_PipelineCounters.{$counterName}" operation="subtract"/>
            </do_all>
          </do_elseif>
          <!-- Clamp to zero (never negative) -->
          <do_if value="global.$GT_PipelineCounters.{$counterName} lt 0">
            <set_value name="global.$GT_PipelineCounters.{$counterName}" exact="0"/>
          </do_if>
        </do_if>
      </actions>
    </library>
    
    <!-- ========================================= -->
    <!-- RESERVATION SYSTEM (Phase 3) -->
    <!-- ========================================= -->
    
    <!-- Reserve Trade -->
    <!-- Creates a reservation for a trade key, preventing other ships from selecting it -->
    <library name="GT_ReserveTrade" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
        <param name="ship" comment="Ship reserving the trade"/>
        <param name="ttl" default="10s" comment="Time-to-live for reservation (default: 10 seconds)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Validate inputs - ERROR if missing -->
        <do_if value="$tradeKey == ''">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Reservation'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=empty_tradeKey'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_ReserveTrade: tradeKey is empty - cannot reserve'" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <do_if value="not $ship? or not $ship.exists">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Reservation'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=invalid_ship tradeKey=' + $tradeKey"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_ReserveTrade: ship is null or invalid - tradeKey=' + $tradeKey" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Initialize reservations if needed -->
        <do_if value="not global.$GT_Reservations?">
          <set_value name="global.$GT_Reservations" exact="table[]"/>
        </do_if>
        
        <!-- Check if already reserved -->
        <set_value name="$alreadyReserved" exact="false"/>
        <set_value name="$existingReservation" exact="null"/>
        <do_if value="global.$GT_Reservations.{$tradeKey}?">
          <set_value name="$existingReservation" exact="global.$GT_Reservations.{$tradeKey}"/>
          <set_value name="$reservedUntil" exact="@$existingReservation.$Until"/>
          <do_if value="$reservedUntil? and player.age lt $reservedUntil">
            <set_value name="$alreadyReserved" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- If already reserved by another ship, log conflict -->
        <do_if value="$alreadyReserved">
          <set_value name="$reservedBy" exact="@$existingReservation.$Ship"/>
          <do_if value="$reservedBy? and $reservedBy != $ship">
            <do_if value="not global.$GT_ReservationStats?">
              <set_value name="global.$GT_ReservationStats" exact="table[$Active = 0, $Expired = 0, $Conflicts = 0, $Created = 0, $Cleared = 0]"/>
            </do_if>
            <set_value name="global.$GT_ReservationStats.$Conflicts" operation="add"/>
            
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Reservation'"/>
              <param name="action" value="'Conflict'"/>
              <param name="details" value="'trade=' + $tradeKey + ' ship=' + $ship.idcode + ' reservedBy=' + $reservedBy.idcode + ' until=' + ($reservedUntil / 1s) + 's'"/>
              <param name="logLevel" value="1"/>
            </run_actions>
            <return value="false"/>
          </do_if>
        </do_if>
        
        <!-- Create or update reservation -->
        <set_value name="$reservationUntil" exact="player.age + $ttl"/>
        <set_value name="global.$GT_Reservations.{$tradeKey}" exact="table[
          $Ship = $ship,
          $Until = $reservationUntil
        ]"/>
        
        <!-- Update statistics -->
        <do_if value="not global.$GT_ReservationStats?">
          <set_value name="global.$GT_ReservationStats" exact="table[$Active = 0, $Expired = 0, $Conflicts = 0, $Created = 0, $Cleared = 0]"/>
        </do_if>
        <set_value name="global.$GT_ReservationStats.$Created" operation="add"/>
        <set_value name="global.$GT_ReservationStats.$Active" operation="add"/>
        
        <!-- Update trade index reservation fields (if index entry exists) -->
        <do_if value="global.$GT_TradeIndex? and global.$GT_TradeIndex.{$tradeKey}?">
          <set_value name="global.$GT_TradeIndex.{$tradeKey}.$ReservedBy" exact="$ship"/>
          <set_value name="global.$GT_TradeIndex.{$tradeKey}.$ReservedUntil" exact="$reservationUntil"/>
        </do_if>
        
        <!-- Log reservation creation -->
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$traceId"/>
          <param name="stage" value="'Reservation'"/>
          <param name="action" value="'Create'"/>
          <param name="details" value="'trade=' + $tradeKey + ' ship=' + $ship.idcode + ' ttl=' + ($ttl / 1s) + 's'"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Release Trade Reservation -->
    <!-- Removes a reservation for a trade key -->
    <library name="GT_ReleaseTrade" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
        <param name="reason" default="'consumed'" comment="Reason for release (consumed, invalidated, expired, etc.)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Validate trade key - ERROR if empty -->
        <do_if value="$tradeKey == ''">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Reservation'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=empty_tradeKey'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <do_else>
            <debug_text text="'[GT-ERROR] GT_ReleaseTrade: tradeKey is empty - cannot release'" chance="100"/>
          </do_else>
          <return value="false"/>
        </do_if>
        
        <!-- Check if reservation exists -->
        <do_if value="not global.$GT_Reservations? or not global.$GT_Reservations.{$tradeKey}?">
          <!-- No reservation exists - this is OK, just log and return -->
          <return value="true"/>
        </do_if>
        
        <!-- Remove reservation -->
        <remove_value name="global.$GT_Reservations.{$tradeKey}"/>
        
        <!-- Update statistics -->
        <do_if value="global.$GT_ReservationStats?">
          <set_value name="global.$GT_ReservationStats.$Cleared" operation="add"/>
          <do_if value="global.$GT_ReservationStats.$Active gt 0">
            <set_value name="global.$GT_ReservationStats.$Active" operation="subtract"/>
          </do_if>
        </do_if>
        
        <!-- Clear trade index reservation fields -->
        <do_if value="global.$GT_TradeIndex? and global.$GT_TradeIndex.{$tradeKey}?">
          <set_value name="global.$GT_TradeIndex.{$tradeKey}.$ReservedBy" exact="null"/>
          <set_value name="global.$GT_TradeIndex.{$tradeKey}.$ReservedUntil" exact="null"/>
        </do_if>
        
        <!-- Log reservation release -->
        <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
          <param name="traceId" value="$traceId"/>
          <param name="stage" value="'Reservation'"/>
          <param name="action" value="'Clear'"/>
          <param name="details" value="'trade=' + $tradeKey + ' reason=' + $reason"/>
          <param name="logLevel" value="1"/>
        </run_actions>
        
        <return value="true"/>
      </actions>
    </library>
    
    <!-- Check if Trade is Reserved -->
    <!-- Returns true if trade is reserved by another ship, false otherwise -->
    <library name="GT_IsTradeReserved" purpose="run_actions">
      <params>
        <param name="tradeKey" comment="Trade key (from GT_GenerateTradeKey)"/>
        <param name="ship" default="null" comment="Ship checking reservation (if null, checks if reserved by any ship)"/>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Validate trade key - ERROR if empty -->
        <do_if value="$tradeKey == ''">
          <do_if value="$traceId != ''">
            <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
              <param name="traceId" value="$traceId"/>
              <param name="stage" value="'Reservation'"/>
              <param name="action" value="'Error'"/>
              <param name="details" value="'reason=empty_tradeKey'"/>
              <param name="logLevel" value="0"/>
            </run_actions>
          </do_if>
          <return value="false"/>
        </do_if>
        
        <!-- Check if reservation exists -->
        <set_value name="$isReserved" exact="false"/>
        <do_if value="global.$GT_Reservations? and global.$GT_Reservations.{$tradeKey}?">
          <set_value name="$reservation" exact="global.$GT_Reservations.{$tradeKey}"/>
          <set_value name="$reservedUntil" exact="@$reservation.$Until"/>
          <set_value name="$reservedBy" exact="@$reservation.$Ship"/>
          
          <!-- Check if reservation is still valid (not expired) -->
          <do_if value="$reservedUntil? and player.age lt $reservedUntil">
            <!-- Check if reserved by different ship -->
            <do_if value="$ship == null or ($reservedBy? and $reservedBy != $ship)">
              <set_value name="$isReserved" exact="true"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Log reservation check -->
        <do_if value="$traceId != ''">
          <set_value name="$logDetails" exact="'trade=' + $tradeKey + ' reserved=' + $isReserved"/>
          <do_if value="$isReserved and $reservedBy?">
            <set_value name="$logDetails" exact="$logDetails + ' reservedBy=' + $reservedBy.idcode"/>
          </do_if>
          <do_if value="$ship?">
            <set_value name="$logDetails" exact="$logDetails + ' ship=' + $ship.idcode"/>
          </do_if>
          
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'Reservation'"/>
            <param name="action" value="'Check'"/>
            <param name="details" value="$logDetails"/>
            <param name="logLevel" value="3"/>
          </run_actions>
        </do_if>
        
        <return value="$isReserved"/>
      </actions>
    </library>
    
    <!-- Cleanup Expired Reservations -->
    <!-- Called periodically to remove expired reservations and clean up invalid ones -->
    <library name="GT_CleanupExpiredReservations" purpose="run_actions">
      <params>
        <param name="traceId" default="''" comment="Trace ID for logging"/>
      </params>
      <actions>
        <!-- Ensure reservations table exists and is a table (savegame compatibility / corruption guard) -->
        <do_if value="not global.$GT_Reservations? or typeof global.$GT_Reservations != datatype.table">
          <set_value name="global.$GT_Reservations" exact="table[]"/>
          <return value="table[$Expired = 0, $Cleared = 0]"/>
        </do_if>
        
        <set_value name="$expiredCount" exact="0"/>
        <set_value name="$clearedCount" exact="0"/>
        <set_value name="$keysToRemove" exact="[]"/>
        
        <!-- Check all reservations -->
        <set_value name="$reservationKeysCount" exact="@global.$GT_Reservations.keys.count"/>
        <do_if value="$reservationKeysCount != null and $reservationKeysCount gt 0">
          <do_all exact="$reservationKeysCount" counter="$i">
            <set_value name="$tradeKey" exact="global.$GT_Reservations.keys.{$i}"/>
            <set_value name="$reservation" exact="global.$GT_Reservations.{$tradeKey}"/>
            <set_value name="$shouldRemove" exact="false"/>
            <set_value name="$removeReason" exact="'unknown'"/>
            
            <!-- Check expiration -->
            <set_value name="$reservedUntil" exact="@$reservation.$Until"/>
            <do_if value="not $reservedUntil? or player.age ge $reservedUntil">
              <set_value name="$shouldRemove" exact="true"/>
              <set_value name="$removeReason" exact="'ttl_expired'"/>
            </do_if>
            
            <!-- Check if ship still exists -->
            <set_value name="$reservedShip" exact="@$reservation.$Ship"/>
            <do_if value="not $reservedShip? or not $reservedShip.exists">
              <set_value name="$shouldRemove" exact="true"/>
              <set_value name="$removeReason" exact="'ship_destroyed'"/>
            </do_if>
            
            <!-- Check if ship still has GT order -->
            <do_if value="$reservedShip? and $reservedShip.exists">
              <set_value name="$hasGTOrder" exact="false"/>
              <do_if value="$reservedShip.orders.count gt 0">
                <do_all exact="$reservedShip.orders.count" counter="$oi">
                  <set_value name="$order" exact="$reservedShip.orders.{$oi}"/>
                  <do_if value="$order? and $order.owner? and $order.owner == $reservedShip">
                    <set_value name="$orderName" exact="@$order.name"/>
                    <do_if value="$orderName == 'trade.galaxytrader'">
                      <set_value name="$hasGTOrder" exact="true"/>
                      <break/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_if>
              <do_if value="not $hasGTOrder">
                <set_value name="$shouldRemove" exact="true"/>
                <set_value name="$removeReason" exact="'no_gt_order'"/>
              </do_if>
            </do_if>
            
            <!-- Remove if needed -->
            <do_if value="$shouldRemove">
              <append_to_list name="$keysToRemove" exact="$tradeKey"/>
              <set_value name="$expiredCount" operation="add"/>
            </do_if>
          </do_all>
        </do_if>
        
        <!-- Remove expired reservations -->
        <do_all exact="$keysToRemove.count" counter="$j">
          <set_value name="$tradeKey" exact="$keysToRemove.{$j}"/>
          <run_actions ref="md.GT_Libraries_General.GT_ReleaseTrade">
            <param name="tradeKey" value="$tradeKey"/>
            <param name="reason" value="if $removeReason == 'ttl_expired' then 'expired' else $removeReason"/>
            <param name="traceId" value="$traceId"/>
          </run_actions>
          <set_value name="$clearedCount" operation="add"/>
          
          <!-- Update statistics -->
          <do_if value="global.$GT_ReservationStats?">
            <set_value name="global.$GT_ReservationStats.$Expired" operation="add"/>
          </do_if>
        </do_all>
        
        <!-- Log cleanup results -->
        <do_if value="$expiredCount gt 0 and $traceId != ''">
          <run_actions ref="md.GT_Libraries_General.GT_LogTradeSearch">
            <param name="traceId" value="$traceId"/>
            <param name="stage" value="'Reservation'"/>
            <param name="action" value="'Expire'"/>
            <param name="details" value="'count=' + $expiredCount + ' cleared=' + $clearedCount"/>
            <param name="logLevel" value="2"/>
          </run_actions>
        </do_if>
        
        <return value="table[$Expired = $expiredCount, $Cleared = $clearedCount]"/>
      </actions>
    </library>
    
    <!-- ========================================= -->
  </cues>
</mdscript>