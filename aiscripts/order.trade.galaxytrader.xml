<?xml version="1.0" encoding="utf-8"?>
<aiscript name="order.trade.galaxytrader" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/aiscripts.xsd" version="3">
  <order id="GalaxyTraderMK3" name="{77000, 10002}" description="{77000, 10102}" category="trade" infinite="true" allowinloop="false" canplayercancel="true">
    <params>
      <!-- ========================================== -->
      <!-- BASIC TRADING SETTINGS                    -->
      <!-- ========================================== -->
              <param name="home" default="this.sector" type="object" text="{77000,1002}" comment="Home base for trading operations (sector or station)">
        <input_param name="class" value="[class.sector,class.station]"/>
      </param>
      <param name="maxbuy" default="[if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 2) then 1 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 5) then 3 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 8) then 5 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 11) then 10 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 13) then 15 else 25, 1].max" type="number" text="{1041, 10054}" comment="Maximum gate distance for buy opportunities (skill-based: Lv1-2=1j, Lv3-5=3j, Lv6-8=5j, Lv9-11=10j, Lv12-13=15j, Lv14+=25j)">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 2) then 1 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 5) then 3 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 8) then 5 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 11) then 10 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 13) then 15 else 25, 1].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="maxsell" default="[if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 2) then 1 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 5) then 3 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 8) then 5 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 11) then 10 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 13) then 15 else 25, 1].max" type="number" text="{1041, 10057}" comment="Maximum gate distance for sell opportunities (skill-based: Lv1-2=1j, Lv3-5=3j, Lv6-8=5j, Lv9-11=10j, Lv12-13=15j, Lv14+=25j)">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 2) then 1 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 5) then 3 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 8) then 5 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 11) then 10 else if ([@this.ship.pilot.skill.management, @this.ship.commander.tradenpc.skill.management].max le 13) then 15 else 25, 1].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="allowillegal" default="false" type="bool" text="{77000,1011}" comment="{77000,1025}"/>
      <param name="ignorecarrieraux" default="false" type="bool" text="{77000,1054}" comment="{77000,1055}"/>
      <param name="ignorebuildstorage" default="false" type="bool" text="{77000,1056}" comment="{77000,1057}"/>
      <param name="ignoretraderules" default="false" type="bool" text="{77000,1058}" comment="{77000,1059}"/>
      <param name="logbookentries" default="true" type="bool" text="{77000,1012}" comment="{77000,1041}"/>
      <param name="factionpriority" default="1" type="number" text="{77000,1014}" comment="Trading priority: 0=Player stations only, 1=Foreign factions first (recommended), 2=All factions equally">
        <input_param name="min" value="0"/>
        <input_param name="max" value="2"/>
        <input_param name="step" value="1"/>
      </param>
      
      <!-- ========================================== -->
      <!-- WARE SELECTION                           -->
      <!-- ========================================== -->
      <param name="autowares" default="true" type="bool" text="{77000,1015}" comment="{77000,1023}"/>
      <param name="warebasket" default="[]" type="list" text="{1041, 10179}" comment="Manual ware selection (only used if Auto Wares is disabled)">
        <input_param name="type" value="'ware'"/>
        <input_param name="cancarry" value="this.ship"/>
      </param>
      <param name="sectorwhitelist" default="[]" type="list" text="{77000,1052}" comment="{77000,1053}">
        <input_param name="type" value="'object'"/>
        <input_param name="class" value="[class.sector]"/>
      </param>
      
      <!-- ========================================== -->
      <!-- TRADING RANGE (Ship-specific)             -->
      <!-- ========================================== -->
      <param name="distancepenalty" default="50" type="number" text="{77000,1016}" comment="Distance impact on trade scoring: 0%=Ignore distance (pure profit), 50%=Balanced, 100%=Prefer close trades (2x distance penalty)">
        <input_param name="min" value="0"/>
        <input_param name="max" value="100"/>
        <input_param name="step" value="5"/>
      </param>
      
      <!-- ========================================== -->
      <!-- NOTIFICATION LEVEL (Global setting override) -->
      <!-- ========================================== -->
      <param name="notifications" default="1" type="number" text="{77000,1017}" comment="{77000,1032}">
        <input_param name="min" value="0"/>
        <input_param name="max" value="2"/>
        <input_param name="step" value="1"/>
      </param>
      
      <!-- ========================================== -->
      <!-- ADVANCED SETTINGS                         -->
      <!-- ========================================== -->
      <param name="fleetcoordination" default="true" type="bool" text="{77000,1018}" advanced="true" comment="{77000,1029}"/>
      <param name="cargotarget" default="90" type="number" text="{77000,1019}" advanced="true" comment="{77000,1033}">
        <input_param name="min" value="50"/>
        <input_param name="max" value="100"/>
        <input_param name="step" value="5"/>
      </param>
      <param name="marketupdatefreq" default="60s" type="time" text="{77000,1050}" advanced="true" comment="{77000,1034}">
        <input_param name="min" value="30s"/>
        <input_param name="max" value="300s"/>
        <input_param name="step" value="30s"/>
      </param>
      <param name="debuglevel" default="1" type="number" text="{1041, 10086}" advanced="true" comment="{77000,1035}">
        <input_param name="min" value="0"/>
        <input_param name="max" value="2"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="tradeeval" default="false" type="bool" text="{77000,1051}" advanced="true" comment="{77000,1040}"/>
    </params>
    <requires>
      <match shiptype="shiptype.lasertower" negate="true"/>
    </requires>
  </order>
  
  <interrupts>
    <handler ref="SectorChangeHandler"/>
    
    <handler ref="AttackHandler"/>
    <handler ref="MissileLockHandler"/>
    <handler ref="ScannedHandler"/>
    <handler ref="InspectedHandler"/>
    <handler ref="FoundAbandonedHandler"/>
    <handler ref="FoundLockboxHandler"/>
    <handler ref="ResupplyHandler"/>
    <handler ref="TargetInvalidHandler"/>
    <handler ref="TideHandler"/>
    
    <!-- Trade Found Event Handler: Catches GT_Trade_Found signal regardless of ship state -->
    <!-- This ensures trades are processed immediately even if ship is in main_loop or other code paths -->
    <!-- Note: Cannot use <resume> in interrupt handlers, so we set a flag that main_loop checks -->
    <!-- Trade data is passed in signal param2 (like GT_Training_Station_Found) -->
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'GT_Trade_Found'"/>
      </conditions>
      <actions>
        <!-- Extract trade data from signal param2 (like GT_Training_Station_Found handler) -->
        <set_value name="$signalData" exact="event.param2"/>
        <set_value name="$signalTradeList" exact="[]"/>
        <set_value name="$signalSearchMethod" exact="''"/>
        <do_if value="$signalData? and $signalData != null">
          <set_value name="$signalTradeList" exact="@$signalData.$TradeList"/>
          <set_value name="$signalSearchMethod" exact="@$signalData.$SearchMethod"/>
        </do_if>
        
        <!-- FALLBACK: If param2 is empty or null, read from global storage (backward compatibility) -->
        <!-- This handles cases where ProcessTradeFoundSignalQueue fails to populate param2 -->
        <do_if value="($signalTradeList == null or $signalTradeList.count == 0) and global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
          <set_value name="$signalTradeList" exact="global.$GT_TradesAwaitingValidation.{this.ship}"/>
          <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
            <set_value name="$signalSearchMethod" exact="@global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
          </do_if>
        </do_if>
        
        <!-- Store in instance variables for main_loop to use -->
        <set_value name="this.$tradeFoundViaInterrupt" exact="true"/>
        <set_value name="this.$tradeListFromSignal" exact="if $signalTradeList != null then $signalTradeList else []"/>
        <set_value name="this.$searchMethodFromSignal" exact="if $signalSearchMethod != null and $signalSearchMethod != '' then $signalSearchMethod else ''"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$tradeCountForDebug" exact="if $signalTradeList != null then $signalTradeList.count else 0"/>
          <set_value name="$dataSource" exact="if ($signalTradeList != null and $signalTradeList.count gt 0 and event.param2? and event.param2 != null) then 'param2' else 'global storage'"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT_Trade_Found signal received via interrupt handler - stored ' + $tradeCountForDebug + ' trades from ' + $dataSource" chance="100"/>
        </do_if>
      </actions>
    </handler>
    
    <!-- High-Performance Training Event Handlers -->
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'GT_Training_Station_Found'"/>
      </conditions>
      <actions>
        <set_value name="$trainingData" exact="event.param2"/>
        <set_value name="$trainingStation" exact="$trainingData.$Station"/>
        <set_value name="$requiredLevel" exact="$trainingData.$Level"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ðŸŽ“ Training station found: ' + $trainingStation.knownname + ' for level ' + $requiredLevel" chance="100"/>
        </do_if>
        
        <!-- Create training order immediately (event-driven, no polling) -->
        <create_order object="this.ship" id="'DockAndTrain'" immediate="true">
          <param name="destination" value="$trainingStation"/>
          <param name="debugchance" value="this.$debugchance"/>
        </create_order>
        
        <!-- Set flag to indicate training is in progress -->
        <set_value name="this.$training_in_progress" exact="true"/>
        <!-- Set flag to indicate training transition for on_abort handler -->
        <set_value name="this.$training_transition" exact="true"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': DockAndTrain order created for ' + $trainingStation.knownname" chance="100"/>
        </do_if>
        
        <!-- Set flag to prevent race condition in on_abort handler -->
        <!-- Ensures the on_abort handler knows a training order was just created -->
        <set_value name="this.$training_order_created" exact="player.age"/>
      </actions>
    </handler>
    
    <!-- Event-Driven Mobile Satellite Intelligence: Detect stations entering radar range -->
    <!-- 
    OPTIMIZED: Event-driven station detection (replaces polling-based MobileSatelliteIntelligence)
    - Uses vanilla gravidar scan events (zero CPU when no stations detected)
    - Only Level 9+ pilots can detect stations (skill gate maintained)
    - Signals MD immediately when stations detected (no polling overhead)
    - Same functionality as old polling system but much more efficient
    -->
    <handler comment="Detect stations entering radar range for mobile satellite intelligence">
      <conditions>
        <event_gravidar_has_scanned object="this.ship"/>
        <check_value value="this.ship.pilot? and global.$GT_Pilots.{this.ship.pilot}?"/>
        <check_value value="this.sector"/>
        <!-- Only Level 9+ pilots and when Mobile Intel is enabled -->
        <check_value value="@global.$GT_Pilots.{this.ship.pilot}.$Level ge 9"/>
        <check_value value="not global.$GT_GlobalSettings.$MobileIntel? or global.$GT_GlobalSettings.$MobileIntel.$Enable"/>
        <!-- PERFORMANCE: Do not run actions unless there is at least 1 station contact -->
        <!-- Vanilla pattern: use count_gravidar_contacts with min="1" to avoid per-scan work when nothing is detected -->
        <count_gravidar_contacts result="$_detectedStations" object="this.ship" class="class.station" docked="false" checkoperational="true" multiple="true" min="1"/>
      </conditions>
      <actions>
        <!-- Stations were detected (min=1 in conditions). Process a small capped number per scan to smooth spikes. -->
        <set_value name="$level" exact="@global.$GT_Pilots.{this.ship.pilot}.$Level"/>
        <set_value name="$detectedStations" exact="$_detectedStations"/>
        
        <!-- Cap work per scan event (prevents large bursts when many stations are in radar range) -->
        <set_value name="$stationsToProcess" exact="[$detectedStations.count, 5].min"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI-Intel] ' + this.ship.idcode + ' detected ' + $detectedStations.count + ' station(s) - processing ' + $stationsToProcess" chance="20"/>
        </do_if>
        
        <do_all exact="$stationsToProcess" counter="$i">
          <set_value name="$station" exact="$detectedStations.{$i}"/>
          <do_if value="$station.exists and $station.isoperational">
            <!-- Signal MD to process this station -->
            <signal_objects object="player.galaxy" param="'GT_Station_Detected'" param2="table[$ship=this.ship, $station=$station, $pilotLevel=$level]"/>
          </do_if>
        </do_all>
      </actions>
    </handler>

    <!-- Event-Driven Threat Avoidance: Detect hostile ships entering radar range (gravidar) -->
    <!-- Uses vanilla event_gravidar_has_scanned + count_gravidar_contacts (no polling).
         Only broadcasts when computed threat level meets ThreatAvoidance.BlacklistThreshold to avoid spam. -->
    <handler comment="ThreatAvoidance: hostile gravidar contact detection">
      <conditions>
        <event_gravidar_has_scanned object="this.ship"/>
        <check_value value="this.sector"/>
        <!-- Feature gate -->
        <check_value value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$ThreatAvoidance? and global.$GT_GlobalSettings.$ThreatAvoidance.$Enabled"/>
        <check_value value="global.$GT_GlobalSettings.$ThreatAvoidance.$UseDynamicBlacklist"/>
        <!-- Only run actions if at least 1 hostile ship contact exists -->
        <count_gravidar_contacts result="$_detectedHostiles" object="this.ship" class="[class.ship_s, class.ship_m, class.ship_l, class.ship_xl]" maybeattackedby="this.ship" checkoperational="false" masstraffic="false" docked="false" multiple="true" min="1">
          <match_context macro="this.sector.macro"/>
          <match_context class="class.highway" negate="true"/>
          <match state="componentstate.wreck" negate="true"/>
        </count_gravidar_contacts>
      </conditions>
      <actions>
        <!-- Get pilot skill level - only Level 6+ pilots can broadcast threat warnings to fleet -->
        <set_value name="$pilotLevel" exact="1"/>
        <do_if value="this.ship.pilot? and global.$GT_Pilots.{this.ship.pilot}?">
          <set_value name="$pilotLevel" exact="@global.$GT_Pilots.{this.ship.pilot}.$Level"/>
        </do_if>
        
        <!-- Shared throttle with move.generic detection (single source of truth across scripts).
             This prevents duplicate logs/broadcasts when both move.generic and this order detect the same contact. -->
        <do_if value="not global.$GT_ThreatDetectThrottle?">
          <set_value name="global.$GT_ThreatDetectThrottle" exact="table[]"/>
        </do_if>
        <set_value name="$_last" exact="@global.$GT_ThreatDetectThrottle.{this.ship}"/>
        <do_if value="$_last == null">
          <set_value name="$_last" exact="0s"/>
        </do_if>
        <set_value name="$_logAllowed" exact="player.age - $_last ge 10s"/>
        <set_value name="$_broadcastAllowed" exact="player.age - $_last ge 30s"/>

        <set_value name="$hostiles" exact="$_detectedHostiles"/>
        <!-- IMPORTANT: $hostiles.count may include non-operational contacts (checkoperational="false").
             We want HostileCount to match the class breakdown we compute below, so we derive it from class counters. -->
        <set_value name="$hostileListCount" exact="$hostiles.count"/>
        <set_value name="$hostileCount" exact="0"/>

        <!-- Compute threat score and class breakdown (cheap: based on detected hostiles only) -->
        <set_value name="$threatScore" exact="0"/>
        <set_value name="$shipClass_XL" exact="0"/>
        <set_value name="$shipClass_L" exact="0"/>
        <set_value name="$shipClass_M" exact="0"/>
        <set_value name="$shipClass_S" exact="0"/>
        <set_value name="$factionCounts" exact="table[]"/>

        <do_all exact="$hostileListCount" counter="$i">
          <set_value name="$h" exact="$hostiles.{$i}"/>
          <do_if value="@$h.exists and @$h.isoperational">
            <do_if value="$h.isclass.ship_xl">
              <set_value name="$threatScore" exact="$threatScore + 5"/>
              <set_value name="$shipClass_XL" operation="add"/>
            </do_if>
            <do_elseif value="$h.isclass.ship_l">
              <set_value name="$threatScore" exact="$threatScore + 3"/>
              <set_value name="$shipClass_L" operation="add"/>
            </do_elseif>
            <do_elseif value="$h.isclass.ship_m">
              <set_value name="$threatScore" exact="$threatScore + 2"/>
              <set_value name="$shipClass_M" operation="add"/>
            </do_elseif>
            <do_else>
              <set_value name="$threatScore" exact="$threatScore + 1"/>
              <set_value name="$shipClass_S" operation="add"/>
            </do_else>

            <do_if value="@$h.owner != null">
              <set_value name="$f" exact="$h.owner"/>
              <set_value name="$factionCounts.{$f}" exact="@$factionCounts.{$f} + 1"/>
            </do_if>
          </do_if>
        </do_all>

        <!-- Make HostileCount match class counters -->
        <set_value name="$hostileCount" exact="$shipClass_XL + $shipClass_L + $shipClass_M + $shipClass_S"/>

        <!-- Determine primary faction -->
        <set_value name="$primaryFaction" exact="null"/>
        <set_value name="$maxFactionCount" exact="0"/>
        <do_all exact="$factionCounts.keys.count" counter="$fi">
          <set_value name="$f" exact="$factionCounts.keys.{$fi}"/>
          <do_if value="$factionCounts.{$f} gt $maxFactionCount">
            <set_value name="$primaryFaction" exact="$f"/>
            <set_value name="$maxFactionCount" exact="$factionCounts.{$f}"/>
          </do_if>
        </do_all>

        <!-- Convert score to threat level (1-5), matching GT_ThreatIntelligence receiver expectations -->
        <set_value name="$threatLevel" exact="2"/>
        <do_if value="$shipClass_XL gt 0 or $shipClass_L gt 0">
          <set_value name="$threatLevel" exact="4"/>
        </do_if>
        <do_elseif value="$threatScore ge 6">
          <set_value name="$threatLevel" exact="3"/>
        </do_elseif>

        <!-- Compare to configured threshold -->
        <set_value name="$threshold" exact="global.$GT_GlobalSettings.$ThreatAvoidance.$BlacklistThreshold"/>
        <do_if value="not $threshold?">
          <set_value name="$threshold" exact="3"/>
        </do_if>

        <!-- Only Level 6+ pilots broadcast to fleet (matches ShipUnderAttack handler pattern) -->
        <do_if value="$pilotLevel ge 6">
          <do_if value="$hostileCount gt 0 and $_broadcastAllowed and $threatLevel ge $threshold">
            <!-- Broadcast to MD threat system (event-driven) -->
            <signal_objects object="player.galaxy" param="'GT_Threat_Warning'" param2="table[
              $Sector = this.sector,
              $DetectedBy = this.ship,
              $HostileCount = $hostileCount,
              $PrimaryFaction = $primaryFaction,
              $ShipClass_XL = $shipClass_XL,
              $ShipClass_L = $shipClass_L,
              $ShipClass_M = $shipClass_M,
              $ShipClass_S = $shipClass_S,
              $ThreatScore = $threatScore,
              $Timestamp = player.age
            ]"/>
          </do_if>
        </do_if>

        <!-- Logging: emit whenever detection fires (hostiles detected), but respect shared log throttle -->
        <!-- Lower level pilots (1-5) can detect but don't broadcast - log for debugging -->
        <do_if value="$hostileCount gt 0 and $_logAllowed">
          <set_value name="global.$GT_ThreatDetectThrottle.{this.ship}" exact="player.age"/>
          <set_value name="$_primaryFactionName" exact="if $primaryFaction? then @$primaryFaction.knownname else 'UNKNOWN'"/>
          <set_value name="$_broadcasted" exact="if ($pilotLevel ge 6 and $_broadcastAllowed and $threatLevel ge $threshold) then 'YES' else 'NO'"/>
          <set_value name="$_broadcastReason" exact="if $pilotLevel lt 6 then 'PILOT LEVEL TOO LOW (Lv.' + $pilotLevel + ', requires Lv.6+)' else if not $_broadcastAllowed then 'THROTTLED' else if $threatLevel lt $threshold then 'THREAT BELOW THRESHOLD' else 'OK'"/>
          <debug_text text="'[GT-Threat-Detect] ' + this.ship.idcode + ' (Pilot Lv.' + $pilotLevel + ') in ' + this.sector.knownname
            + ' - hostiles=' + $hostileCount
            + ' (XL=' + $shipClass_XL + ', L=' + $shipClass_L + ', M=' + $shipClass_M + ', S=' + $shipClass_S + ')'
            + ', threatScore=' + $threatScore + ', threatLevel=' + $threatLevel + ', threshold=' + $threshold
            + ', primaryFaction=' + $_primaryFactionName
            + ', broadcasted=' + $_broadcasted + ' (' + $_broadcastReason + ')'" chance="100"/>
        </do_if>
      </actions>
    </handler>
    
    <!-- Subordinate Resync Handler: Listen for commander order changes (like vanilla order.assist) -->
    <handler comment="Subordinate resync on commander order change">
      <conditions>
        <check_all>
          <event_object_order_ready object="this.ship.commander" check="false" comment="Commander's order ready"/>
          <check_value value="event.param == event.object.defaultorder" comment="It's the default order"/>
        </check_all>
      </conditions>
      <actions>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Commander order changed - restarting to resync settings'" chance="100"/>
        </do_if>
        <!-- Use abort_called_scripts like vanilla - forcefully restart at init label -->
        <abort_called_scripts resume="init"/>
      </actions>
    </handler>
    
    <!-- Commander change detection handler -->
    <!-- Tests if commander change detection interferes with trade execution -->
    <!-- This handler fires BEFORE the subordinate resync handler restarts the script -->
    <!-- Using this.assignedcontrolled like vanilla order.assist.xml -->
    <handler comment="Commander removed or changed">
      <conditions>
        <event_object_commander_set object="this.assignedcontrolled"/>
      </conditions>
      <actions>
        <set_value name="$newCommander" exact="event.param"/>
        
        <!-- Update state machine BEFORE script restarts -->
        <set_value name="$newCommanderHasGT" exact="false"/>
        <do_if value="@$newCommander.exists">
          <do_if value="$newCommander.defaultorder? and @$newCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$newCommanderHasGT" exact="true"/>
          </do_if>
        </do_if>
        
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'Commander_Changed',
          $Commander = $newCommander,
          $CommanderHasGT = $newCommanderHasGT
        ]"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 6: Commander change detected for ' + this.ship.idcode + ' (commander: ' + (if @$newCommander.exists then @$newCommander.idcode else 'NONE') + ', has GT: ' + $newCommanderHasGT + ')'" chance="100"/>
        </do_if>
        
        <!-- NOTE: Script will restart via subordinate resync handler if commander has order change -->
        <!-- But signal is sent FIRST, so state manager can process it -->
      </actions>
    </handler>
    
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'GT_Training_Complete'"/>
      </conditions>
      <actions>
        <set_value name="$completionData" exact="event.param2"/>
        <set_value name="$completedLevel" exact="$completionData.$Level"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training completed for level ' + $completedLevel + ' - setting flag to resume trading'" chance="100"/>
        </do_if>
        
        <!-- Set flag to resume trading (can't use resume in interrupt handler) -->
        <set_value name="this.$training_complete" exact="true"/>
        <remove_value name="this.$training_in_progress"/>
        <remove_value name="this.$training_transition"/>
        <remove_value name="this.$training_order_created"/>
      </actions>
    </handler>
    
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'GT_Training_Failed'"/>
      </conditions>
      <actions>
        <set_value name="$failureData" exact="event.param2"/>
        <set_value name="$reason" exact="$failureData.$Reason"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training failed: ' + $reason + ' - setting flag to resume trading'" chance="100"/>
        </do_if>
        
        <!-- Set flag to resume trading (can't use resume in interrupt handler) -->
        <set_value name="this.$training_complete" exact="true"/>
        <remove_value name="this.$training_in_progress"/>
        <remove_value name="this.$training_transition"/>
        <remove_value name="this.$training_order_created"/>
      </actions>
    </handler>
    
    <!-- Order cancellation detection handler -->
    <!-- Detects when GT default order is cancelled -->
    <!-- Note: Ships always have a default order (Wait, Assist, etc.), so we check:
         1. If cancelled order was GT order (event.param.id == 'GalaxyTraderMK3')
         2. If ship is still GT-controlled (direct GT order OR subordinate with GT commander via Assist)
         3. Only act if ship is no longer GT-controlled -->
    <handler comment="GT order cancelled">
      <conditions>
        <event_object_order_cancelled object="this.ship" immediate="true"/>
        <!-- Note: Ships always have a default order (Wait, Assist, etc.), so we check the cancelled order ID and current default order -->
      </conditions>
      <actions>
        <!-- Check which order was cancelled -->
        <set_value name="$cancelledOrderId" exact="@event.param.id"/>
        <set_value name="$currentDefaultOrder" exact="@this.ship.defaultorder.id"/>
        
        <!-- Unified GT order status check (inline for AI scripts) -->
        <set_value name="$hasDirectGTOrder" exact="false"/>
        <set_value name="$hasGTCommander" exact="false"/>
        <set_value name="$isGTControlled" exact="false"/>
        
        <!-- Check direct GT order -->
        <do_if value="$currentDefaultOrder == 'GalaxyTraderMK3'">
          <set_value name="$hasDirectGTOrder" exact="true"/>
          <set_value name="$isGTControlled" exact="true"/>
        </do_if>
        
        <!-- Check commander status -->
        <do_if value="not $hasDirectGTOrder and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$hasGTCommander" exact="true"/>
            <do_if value="$currentDefaultOrder == 'Assist'">
              <set_value name="$isGTControlled" exact="true"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Only act if GT order was actually cancelled (ship is no longer GT-controlled) -->
        <do_if value="not $isGTControlled">
          <!-- Check if GT order was explicitly cancelled OR if current default is not GT/Assist-with-GT-commander -->
          <do_if value="$cancelledOrderId == 'GalaxyTraderMK3' or not $cancelledOrderId">
            <!-- GT order is being cancelled â†’ send Phase 7 signal -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (interrupt handler, cancelled order: ' + (if $cancelledOrderId then $cancelledOrderId else 'NONE') + ', current default: ' + (if $currentDefaultOrder then $currentDefaultOrder else 'NONE') + ', still GT-controlled: ' + $isGTControlled + ')'" chance="100"/>
            </do_if>
            <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
              $Ship = this.ship,
              $UpdateType = 'GT_Order_Cancelled'
            ]"/>
            
            <!-- EVENT-DRIVEN: Trigger orphaned ship check -->
            <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}?">
              <signal_objects object="player.galaxy" param="'GT_Check_Ship_Orphaned'" param2="table[$Ship = this.ship]"/>
            </do_if>
            
            <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
            <do_if value="not $hasDirectGTOrder and not $hasGTCommander and this.ship.pilot?">
              <set_value name="$originalName" exact="null"/>
              <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
                <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
              </do_if>
              
              <do_if value="$originalName">
                <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                  $Ship = this.ship,
                  $Pilot = this.ship.pilot,
                  $Reason = 'GT order cancelled - restoring original name',
                  $OriginalName = $originalName
                ]"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        <do_else>
          <!-- Ship is still GT-controlled (direct GT order or subordinate with GT commander) - skip -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Order cancelled interrupt fired but ship still GT-controlled (cancelled: ' + (if $cancelledOrderId then $cancelledOrderId else 'NONE') + ', current default: ' + (if $currentDefaultOrder then $currentDefaultOrder else 'NONE') + ', still GT-controlled: ' + $isGTControlled + ') - skipping Phase 7'" chance="100"/>
          </do_if>
        </do_else>
      </actions>
    </handler>

    <!-- Work Unit Processing Handler -->
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'GT_ProcessWorkUnit'"/>
      </conditions>
      <actions>
        <!-- Process work unit in background -->
        <set_value name="this.$workUnitPending" exact="true"/>
        <set_value name="this.$workUnitData" exact="event.param2"/>
        <set_value name="$workUnit" exact="event.param2"/>
        <set_value name="$workType" exact="if $workUnit? and $workUnit.$WorkType? then $workUnit.$WorkType else 'unknown'"/>
        <set_value name="$traceId" exact="if $workUnit? and $workUnit.$TraceId? then $workUnit.$TraceId else '0'"/>
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Work unit RECEIVED type=' + $workType + ' traceId=' + $traceId" chance="100"/>
      </actions>
    </handler>

  </interrupts>
  
  <init>
    <set_order_syncpoint_reached order="this.ship.order"/>
    <set_command command="command.searchtrades"/>
    <set_command_action commandaction="commandaction.searchingtrades"/>

    <!-- CRITICAL: Ensure instance wait time storage ALWAYS exists before any <wait ...> evaluates it.
         Vanilla pattern: instance vars are accessed with safe operator @this.$var (e.g. @this.$resupplier...). -->
    <!-- Purpose A: Pre-request wait for GT_Trade_Found signal (milliseconds) -->
    <set_value name="this.$tradeFoundSignalWaitTime" exact="5ms"/>
    <!-- Purpose B: No-trade retry cooldown (seconds) -->
    <set_value name="this.$retryCooldown" exact="10s"/>
    
    <!-- Legacy persistent variables removed - no longer needed with unified maintenance system -->
    
    <!-- ============================================================================= -->
    <!-- SAVE GAME CLEANUP: Clear stale tracking data when loading from a save game  -->
    <!-- ============================================================================= -->
    <!-- Check if resupply tracking exists and verify if the order is still active.   -->
    <!-- Only remove tracking if the order no longer exists (stale data).             -->
    <!-- ============================================================================= -->
    <!-- PERFORMANCE: Optimized resupply order check - use order.id property instead of iterating all orders -->
    <do_if value="global.$GT_ResupplyOrders? and global.$GT_ResupplyOrders.{this.ship}?">
      <!-- Check if ship has active resupply/repair/equipment order using order.id (more efficient than iterating) -->
      <set_value name="$hasActiveResupplyOrder" exact="false"/>
      <!-- Our resupply uses order.build.equip, whose order id is 'Equip' (vanilla) -->
      <do_if value="this.ship.order? and (this.ship.order.id == 'Resupply' or this.ship.order.id == 'Repair' or this.ship.order.id == 'Equip')">
        <set_value name="$hasActiveResupplyOrder" exact="true"/>
      </do_if>
      
      <do_if value="not $hasActiveResupplyOrder">
        <!-- No active order - tracking is stale, remove it -->
        <remove_value name="global.$GT_ResupplyOrders.{this.ship}"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cleared stale resupply tracking (no active order)'" chance="100"/>
        </do_if>
      </do_if>
      <do_else>
        <!-- Order still active - keep tracking -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Resupply order still active after save load - keeping tracking'" chance="100"/>
        </do_if>
      </do_else>
    </do_if>
    
    <!-- ============================================================================= -->
    <!-- MODULAR INITIALIZATION - REPLACES ~200 LINES OF COMPLEX INITIALIZATION CODE -->
    <!-- ============================================================================= -->
    
    <!-- CRITICAL DEBUG: Log that init block started -->
    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': === INIT BLOCK STARTED === (Ship: ' + this.ship.knownname + ', Pilot: ' + (if this.ship.pilot then this.ship.pilot.name else 'NONE') + ')'" chance="100"/>
    
    <!-- Create order parameters table for library compatibility -->
    <set_value name="$orderParams" exact="table[]"/>
    
    <!-- Legacy maintenance variables removed - no longer needed with unified maintenance system -->
    
    <!-- SUBORDINATE HOME BASE INHERITANCE: If subordinate, ALWAYS inherit commander's home -->
    <set_value name="$effectiveHome" exact="$home"/>
    <do_if value="this.ship.commander and this.ship.commander.exists and this.ship.commander != this.ship">
      <!-- Ship is a subordinate - ALWAYS inherit commander's home sector -->
      <do_if value="this.ship.commander.defaultorder and this.ship.commander.defaultorder.$home?">
        <set_value name="$effectiveHome" exact="this.ship.commander.defaultorder.$home"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Subordinate inheriting home base from commander ' + this.ship.commander.idcode + ': ' + $effectiveHome.knownname" chance="100"/>
        </do_if>
      </do_if>
    </do_if>
    
    <!-- Store as script variable for persistence throughout execution -->
    <set_value name="this.$effectiveHome" exact="$effectiveHome"/>
    
    <!-- ============================================================================= -->
    <!-- SUBORDINATE SETTINGS INHERITANCE: Inherit strategic settings from commander -->
    <!-- ============================================================================= -->
    <set_value name="$isSubordinate" exact="this.ship.commander and this.ship.commander.exists and this.ship.commander != this.ship"/>
    <set_value name="$commanderOrder" exact="null"/>
    <do_if value="$isSubordinate">
      <set_value name="$commanderOrder" exact="this.ship.commander.defaultorder"/>
    </do_if>
    
    <!-- Sector Whitelist -->
    <set_value name="$effectiveSectorWhitelist" exact="$sectorwhitelist"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$sectorwhitelist?">
      <set_value name="$effectiveSectorWhitelist" exact="$commanderOrder.$sectorwhitelist"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Subordinate inheriting sector whitelist from commander ' + this.ship.commander.idcode" chance="100"/>
        </do_if>
    </do_if>
    
    <!-- Fleet Coordination -->
    <set_value name="$effectiveFleetCoordination" exact="$fleetcoordination"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$fleetcoordination?">
      <set_value name="$effectiveFleetCoordination" exact="$commanderOrder.$fleetcoordination"/>
    </do_if>
    
    <!-- Allow Illegal Wares -->
    <set_value name="$effectiveAllowIllegal" exact="$allowillegal"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$allowillegal?">
      <set_value name="$effectiveAllowIllegal" exact="$commanderOrder.$allowillegal"/>
    </do_if>
    
    <!-- Ignore Carrier/Aux -->
    <!-- Initialize with safe default first to prevent property lookup errors -->
    <set_value name="$effectiveIgnoreCarrierAux" exact="false"/>
    <do_if value="$ignorecarrieraux?">
      <set_value name="$effectiveIgnoreCarrierAux" exact="$ignorecarrieraux"/>
    </do_if>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$ignorecarrieraux?">
      <set_value name="$effectiveIgnoreCarrierAux" exact="$commanderOrder.$ignorecarrieraux"/>
    </do_if>
    
    <!-- Ignore Build Storage -->
    <!-- Initialize with safe default first to prevent property lookup errors -->
    <set_value name="$effectiveIgnoreBuildStorage" exact="false"/>
    <do_if value="$ignorebuildstorage?">
      <set_value name="$effectiveIgnoreBuildStorage" exact="$ignorebuildstorage"/>
    </do_if>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$ignorebuildstorage?">
      <set_value name="$effectiveIgnoreBuildStorage" exact="$commanderOrder.$ignorebuildstorage"/>
    </do_if>

    <!-- Ignore Trade Rules -->
    <!-- Initialize with safe default first to prevent property lookup errors -->
    <set_value name="$effectiveIgnoreTradeRules" exact="false"/>
    <do_if value="$ignoretraderules?">
      <set_value name="$effectiveIgnoreTradeRules" exact="$ignoretraderules"/>
    </do_if>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$ignoretraderules?">
      <set_value name="$effectiveIgnoreTradeRules" exact="$commanderOrder.$ignoretraderules"/>
    </do_if>
    
    <!-- Faction Priority -->
    <set_value name="$effectiveFactionPriority" exact="$factionpriority"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$factionpriority?">
      <set_value name="$effectiveFactionPriority" exact="$commanderOrder.$factionpriority"/>
    </do_if>
    
    <!-- Auto Wares -->
    <set_value name="$effectiveAutoWares" exact="$autowares"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$autowares?">
      <set_value name="$effectiveAutoWares" exact="$commanderOrder.$autowares"/>
    </do_if>
    
    <!-- Ware Basket -->
    <set_value name="$effectiveWareBasket" exact="$warebasket"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$warebasket?">
      <set_value name="$effectiveWareBasket" exact="$commanderOrder.$warebasket"/>
    </do_if>
    
    <!-- Distance Penalty -->
    <set_value name="$effectiveDistancePenalty" exact="$distancepenalty"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$distancepenalty?">
      <set_value name="$effectiveDistancePenalty" exact="$commanderOrder.$distancepenalty"/>
    </do_if>
    
    <!-- Logbook Entries -->
    <set_value name="$effectiveLogbookEntries" exact="$logbookentries"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$logbookentries?">
      <set_value name="$effectiveLogbookEntries" exact="$commanderOrder.$logbookentries"/>
    </do_if>
    
    <!-- Notifications -->
    <set_value name="$effectiveNotifications" exact="$notifications"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$notifications?">
      <set_value name="$effectiveNotifications" exact="$commanderOrder.$notifications"/>
    </do_if>
    
    <!-- Debug Level -->
    <set_value name="$effectiveDebugLevel" exact="$debuglevel"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$debuglevel?">
      <set_value name="$effectiveDebugLevel" exact="$commanderOrder.$debuglevel"/>
    </do_if>
    
    <!-- Trade Evaluation Logging -->
    <set_value name="$effectiveTradeEval" exact="$tradeeval"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$tradeeval?">
      <set_value name="$effectiveTradeEval" exact="$commanderOrder.$tradeeval"/>
    </do_if>
    
    <!-- PERFORMANCE: Calculate pilot skill once and reuse for both MaxBuy and MaxSell -->
    <!-- Calculate subordinate's pilot capability (only if subordinate) -->
    <set_value name="$pilotMaxJumps" exact="null"/>
    <do_if value="$isSubordinate and $commanderOrder">
      <!-- Calculate pilot skill once (management). Do NOT fall back to fake values if skill isn't available yet. -->
      <set_value name="$pilotSkill" exact="if (@this.ship.pilot and @this.ship.pilot.skill.management != null) then @this.ship.pilot.skill.management else null"/>

      <!-- Only compute pilot capability if we successfully read the pilot management skill -->
      <do_if value="$pilotSkill != null">
        <do_if value="$pilotSkill le 2">
          <set_value name="$pilotMaxJumps" exact="1"/>
        </do_if>
        <do_elseif value="$pilotSkill le 5">
          <set_value name="$pilotMaxJumps" exact="3"/>
        </do_elseif>
        <do_elseif value="$pilotSkill le 8">
          <set_value name="$pilotMaxJumps" exact="5"/>
        </do_elseif>
        <do_elseif value="$pilotSkill le 11">
          <set_value name="$pilotMaxJumps" exact="10"/>
        </do_elseif>
        <do_elseif value="$pilotSkill le 13">
          <set_value name="$pilotMaxJumps" exact="15"/>
        </do_elseif>
        <do_else>
          <set_value name="$pilotMaxJumps" exact="25"/>
        </do_else>
      </do_if>
    </do_if>
    
    <!-- Max Buy Distance - Inherit from commander, capped at pilot capability -->
    <set_value name="$effectiveMaxBuy" exact="$maxbuy"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$maxbuy? and $pilotMaxJumps != null">
      <!-- Inherit commander's max, but cap at pilot capability (reuse calculated $pilotMaxJumps) -->
      <set_value name="$commanderMaxBuy" exact="$commanderOrder.$maxbuy"/>
      <set_value name="$effectiveMaxBuy" exact="[$commanderMaxBuy, $pilotMaxJumps].min"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': MaxBuy inherited: commander=' + $commanderMaxBuy + ', pilot_cap=' + $pilotMaxJumps + ', effective=' + $effectiveMaxBuy" chance="100"/>
      </do_if>
    </do_if>
    
    <!-- Max Sell Distance - Inherit from commander, capped at pilot capability -->
    <set_value name="$effectiveMaxSell" exact="$maxsell"/>
    <do_if value="$isSubordinate and $commanderOrder and $commanderOrder.$maxsell? and $pilotMaxJumps != null">
      <!-- Inherit commander's max, but cap at pilot capability (reuse calculated $pilotMaxJumps) -->
      <set_value name="$commanderMaxSell" exact="$commanderOrder.$maxsell"/>
      <set_value name="$effectiveMaxSell" exact="[$commanderMaxSell, $pilotMaxJumps].min"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': MaxSell inherited: commander=' + $commanderMaxSell + ', pilot_cap=' + $pilotMaxJumps + ', effective=' + $effectiveMaxSell" chance="100"/>
      </do_if>
    </do_if>

    <!-- Persist effective distances on the cue instance so they are available outside init (e.g. main loop / start_trading) -->
    <set_value name="this.$effectiveMaxBuy" exact="$effectiveMaxBuy"/>
    <set_value name="this.$effectiveMaxSell" exact="$effectiveMaxSell"/>
    
    <!-- Debug message for subordinates showing inherited settings -->
    <!-- PERFORMANCE: Only build inherited settings string if debug logging is enabled -->
    <!-- Skip expensive string concatenation loop if not needed -->
    <do_if value="$isSubordinate and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <set_value name="$inheritedSettings" exact="[]"/>
      <do_if value="$effectiveFleetCoordination != $fleetcoordination"><append_to_list name="$inheritedSettings" exact="'FleetCoord=' + $effectiveFleetCoordination"/></do_if>
      <do_if value="$effectiveAllowIllegal != $allowillegal"><append_to_list name="$inheritedSettings" exact="'AllowIllegal=' + $effectiveAllowIllegal"/></do_if>
      <do_if value="$effectiveFactionPriority != $factionpriority"><append_to_list name="$inheritedSettings" exact="'FactionPri=' + $effectiveFactionPriority"/></do_if>
      <do_if value="$effectiveAutoWares != $autowares"><append_to_list name="$inheritedSettings" exact="'AutoWares=' + $effectiveAutoWares"/></do_if>
      <do_if value="$effectiveDistancePenalty != $distancepenalty"><append_to_list name="$inheritedSettings" exact="'DistPenalty=' + $effectiveDistancePenalty + '%'"/></do_if>
      <do_if value="$effectiveLogbookEntries != $logbookentries"><append_to_list name="$inheritedSettings" exact="'Logbook=' + $effectiveLogbookEntries"/></do_if>
      <do_if value="$effectiveNotifications != $notifications"><append_to_list name="$inheritedSettings" exact="'Notify=' + $effectiveNotifications"/></do_if>
      <do_if value="$effectiveDebugLevel != $debuglevel"><append_to_list name="$inheritedSettings" exact="'Debug=' + $effectiveDebugLevel"/></do_if>
      <do_if value="$effectiveTradeEval != $tradeeval"><append_to_list name="$inheritedSettings" exact="'TradeEval=' + $effectiveTradeEval"/></do_if>
      <do_if value="$effectiveMaxBuy != $maxbuy"><append_to_list name="$inheritedSettings" exact="'MaxBuy=' + $effectiveMaxBuy + 'j'"/></do_if>
      <do_if value="$effectiveMaxSell != $maxsell"><append_to_list name="$inheritedSettings" exact="'MaxSell=' + $effectiveMaxSell + 'j'"/></do_if>
      
      <do_if value="$inheritedSettings.count gt 0">
        <set_value name="$inheritedSettingsText" exact="''"/>
        <do_all exact="$inheritedSettings.count" counter="$i">
          <set_value name="$inheritedSettingsText" exact="$inheritedSettingsText + $inheritedSettings.{$i}"/>
          <do_if value="$i lt $inheritedSettings.count">
            <set_value name="$inheritedSettingsText" exact="$inheritedSettingsText + ', '"/>
          </do_if>
        </do_all>
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Subordinate inherited settings from ' + this.ship.commander.idcode + ': ' + $inheritedSettingsText" chance="100"/>
      </do_if>
    </do_if>
    
    <set_value name="$orderParams.$home" exact="$effectiveHome"/>
    <set_value name="$orderParams.$maxbuy" exact="$effectiveMaxBuy"/>
    <set_value name="$orderParams.$maxsell" exact="$effectiveMaxSell"/>
    <set_value name="$orderParams.$allowillegal" exact="$effectiveAllowIllegal"/>
    <set_value name="$orderParams.$factionpriority" exact="$effectiveFactionPriority"/>
    <set_value name="$orderParams.$autowares" exact="$effectiveAutoWares"/>
    <set_value name="$orderParams.$warebasket" exact="$effectiveWareBasket"/>
    <set_value name="$orderParams.$distancepenalty" exact="$effectiveDistancePenalty"/>
    <set_value name="$orderParams.$notifications" exact="$effectiveNotifications"/>
    <set_value name="$orderParams.$cargotarget" exact="$cargotarget"/>
    <set_value name="$orderParams.$marketupdatefreq" exact="$marketupdatefreq"/>
    <set_value name="$orderParams.$debuglevel" exact="$effectiveDebugLevel"/>
    <set_value name="$orderParams.$tradeeval" exact="$effectiveTradeEval"/>
    <set_value name="$orderParams.$fleetcoordination" exact="$effectiveFleetCoordination"/>
    <set_value name="$orderParams.$logbookentries" exact="$effectiveLogbookEntries"/>
    <set_value name="$orderParams.$sectorwhitelist" exact="$effectiveSectorWhitelist"/>
    
    <!-- =========================================== -->
    <!-- HIGH-PERFORMANCE INITIALIZATION (Option A) -->
    <!-- =========================================== -->
    
    <!-- Fast variable assignment - using effective (inherited) values -->
    <set_value name="$gt_debuglevel" exact="$effectiveDebugLevel"/>
    <!-- Only set debugchance > 0 if GT debug logging is enabled globally -->
    <set_value name="$debugchance" exact="0"/>
    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <set_value name="$debugchance" exact="if $gt_debuglevel ge 2 then 100 else if $gt_debuglevel ge 1 then 50 else 0"/>
    </do_if>
    <set_value name="this.$debugchance" exact="$debugchance"/>
    
    <!-- Cache blacklistgroup once (avoids 6 repeated lookups) -->
    <set_value name="this.$blacklistgroup" exact="blacklistgroup.civilian"/>
    <do_if value="(@this.assignedcontrolled.primarypurpose == purpose.fight) or (@this.assignedcontrolled.primarypurpose == purpose.auxiliary)">
      <set_value name="this.$blacklistgroup" exact="blacklistgroup.military"/>
    </do_if>
    
    <!-- Core trading parameters (performance optimized) - using effective (inherited) values -->
    <set_value name="$gt_allowillegal" exact="$effectiveAllowIllegal"/>
    <set_value name="$gt_factionpriority" exact="$effectiveFactionPriority"/>
    <!-- Convert distance penalty from 0-100% to multiplier: 0%=0.0, 50%=1.0, 100%=2.0 -->
    <set_value name="$gt_distancepenalty" exact="$effectiveDistancePenalty / 50.0"/>
    <set_value name="$gt_cargotarget" exact="$cargotarget"/>
    <set_value name="$gt_marketupdatefreq" exact="$marketupdatefreq"/>
    <set_value name="$gt_logbookentries" exact="$effectiveLogbookEntries"/>
    
    <!-- Global defaults (fastest approach - direct assignment) -->
    <set_value name="$gt_autotraining" exact="true"/>
    <set_value name="$gt_fleetcoord" exact="false"/>
    
    <!-- Ware selection (optimized) - using effective inherited values -->
    <set_value name="$warebasket" exact="if $effectiveAutoWares then [] else $effectiveWareBasket"/>
    
    <!-- Single non-blocking signal to MD system -->
    <signal_objects object="player.galaxy" param="'GT_AI_Started'" param2="table[
      $Ship = this.ship,
      $Config = table[
        $allowillegal = $gt_allowillegal,
        $debuglevel = $gt_debuglevel,
        $autotraining = $gt_autotraining
      ]
    ]"/>
    
    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': High-performance initialization complete'" chance="this.$debugchance"/>
      <do_if value="@$effectiveHome.exists">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Operating with home base: ' + @$effectiveHome.knownname + ' (maxbuy=' + $effectiveMaxBuy + ', maxsell=' + $effectiveMaxSell + ')'" chance="this.$debugchance"/>
      </do_if>
    </do_if>
    
    <!-- Log configuration summary -->
    <do_if value="$gt_debuglevel ge 1 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': === CONFIGURATION SUMMARY ==='" chance="100"/>
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Illegal=' + $effectiveAllowIllegal + ', DistancePenalty=' + $effectiveDistancePenalty + '%'" chance="100"/>
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FleetCoord=' + $effectiveFleetCoordination + ', LogbookEntries=' + $effectiveLogbookEntries + ', Notifications=' + $effectiveNotifications" chance="100"/>
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Distance limits: MaxBuy=' + $effectiveMaxBuy + ' jumps, MaxSell=' + $effectiveMaxSell + ' jumps'" chance="100"/>
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': AutoWares=' + $effectiveAutoWares + ', WareBasket=' + $effectiveWareBasket.count + ' wares, TradeEval=' + $effectiveTradeEval" chance="100"/>
    </do_if>
    
    <!-- ============================================================================= -->
    <!-- END MODULAR INITIALIZATION                                                   -->
    <!-- ============================================================================= -->
    
    <!-- Initialize pilot tracking for event-driven pilot change detection -->
    <!-- Pilot changes are detected at natural restart points: -->
    <!-- - After successful trade completion (trade_completed label) -->
    <!-- - On script restart (init label) -->
    <set_value name="this.$trackedPilot" exact="this.ship.pilot"/>
    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Tracking pilot: ' + @this.$trackedPilot.name + ' (event-driven detection enabled)'" chance="this.$debugchance"/>
    </do_if>
    
    <!-- Do not initialize commander tracking here - let init label handle it -->
    <!-- This prevents false positives when script restarts after commander assignment -->
    <!-- The init label will detect changes by comparing with previous value -->
    
    <!-- Register pilot on first run (for initial assignment or ship with existing cargo) -->
    <!-- This ensures ships get renamed even when first assigned to GT order -->
    <do_if value="this.ship.pilot">
      <!-- NOTE: Cannot use wait/do_while in init block - pilot transfer check moved to main loop -->
      <!-- Pilot transfer takes time (crew transfer pod travel), but UI shows pilot as assigned immediately -->
      <!-- Main loop will check if pilot is actually on ship before proceeding -->
      
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INITIAL REGISTRATION: Registering pilot ' + @this.ship.pilot.name + ' on order start'" chance="100"/>
      </do_if>
      <signal_objects object="player.galaxy" param="'GT_Update_Ship'" param2="table[
        $updateType = 'pilot_change',
        $ship = this.ship,
        $pilot = this.ship.pilot,
        $oldPilot = null
      ]"/>
      
      <!-- NOTE: Cannot use wait in init block - registration check will happen in main loop -->
      <!-- Registration happens synchronously via run_actions, but signal processing is asynchronous -->
      <!-- Main loop will check registration status before requesting trade search -->
    </do_if>
    
    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <debug_text text="'[GalaxyTrader MK3] ' + this.ship.idcode + ': === INITIALIZATION COMPLETE === Starting main trading loop...'" chance="100"/>
    </do_if>
    
  </init>
  
  <attention min="unknown">
    <actions>
      
      <!-- Debug: Confirm we entered attention block -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': === ATTENTION BLOCK ENTERED ==='" chance="100"/>
      </do_if>
      
      <!-- Subordinate reinitialization: Jump here to restart and re-inherit commander settings -->
      <label name="init"/>

      <!-- CRITICAL: Ensure instance wait time storage ALWAYS exists on restarts/resumes. -->
      <!-- Purpose A: Pre-request wait for GT_Trade_Found signal (milliseconds) -->
      <set_value name="this.$tradeFoundSignalWaitTime" exact="5ms"/>
      <!-- Purpose B: No-trade retry cooldown (seconds) -->
      <set_value name="this.$retryCooldown" exact="10s"/>
      
      <!-- ======================================= -->
      <!-- PILOT CHANGE DETECTION (Script Restart) -->
      <!-- ======================================= -->
      <!-- Check for pilot changes when script restarts (natural restart point) -->
      <set_value name="$currentPilot" exact="@this.ship.pilot"/>
      <do_if value="this.$trackedPilot? and $currentPilot != this.$trackedPilot">
        <!-- Pilot changed! Send signal to MD system -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': PILOT CHANGE DETECTED on script restart! Old: ' + @this.$trackedPilot.name + ', New: ' + @$currentPilot.name" chance="100"/>
        </do_if>
        
        <signal_objects object="player.galaxy" param="'GT_Update_Ship'" param2="table[
          $updateType = 'pilot_change',
          $ship = this.ship,
          $pilot = $currentPilot,
          $oldPilot = this.$trackedPilot
        ]"/>
      </do_if>
      <!-- Update tracked pilot (always, even if no change) -->
      <set_value name="this.$trackedPilot" exact="$currentPilot"/>
      
      <!-- CRITICAL: Check if pilot is missing (pilot was transferred away) -->
      <!-- If GT order is running but ship has no pilot, cleanup and self-cancel -->
      <do_if value="not $currentPilot">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': MISSING PILOT DETECTED - pilot was transferred away, cleaning up and self-canceling GT order'" chance="100"/>
        </do_if>
        
        <!-- Get original ship name from ship registry -->
        <set_value name="$originalName" exact="null"/>
        <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$OriginalShipName?">
          <set_value name="$originalName" exact="global.$GT_Ships.{this.ship}.$OriginalShipName"/>
        </do_if>
        
        <!-- Send cleanup signal (name restoration handled by MD system) -->
        <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
          $Ship = this.ship,
          $Pilot = null,
          $Reason = 'Pilot transferred away - GT order cannot run without pilot',
          $OriginalName = $originalName
        ]"/>
        
        <!-- Cancel all active orders (trade orders, etc.) -->
        <cancel_all_orders object="this.ship"/>
        
        <!-- Self-cancel GT order -->
        <cancel_order order="this.ship.defaultorder"/>
        <return/>
      </do_if>
      
      <!-- Restore XPBlocked if BlockedLevel still exists (ship restart/reinit) -->
      <!-- Also update ship name to show ADVANCE label when XPBlocked is restored -->
      <do_if value="this.ship.pilot and global.$GT_Pilots.{this.ship.pilot}?">
        <do_if value="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel? and not global.$GT_Pilots.{this.ship.pilot}.$XPBlocked?">
          <set_value name="global.$GT_Pilots.{this.ship.pilot}.$XPBlocked" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] Restored XPBlocked for pilot ' + this.ship.pilot.name + ' on ship restart (BlockedLevel: ' + global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel + ')'" chance="100"/>
          </do_if>
          
          <!-- Update ship name to show ADVANCE label when XPBlocked is restored -->
          <!-- This ensures the ship name reflects the blocked state after restart -->
          <!-- Calculate rank title based on blocked level -->
          <set_value name="$blockedLevel" exact="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel"/>
          <set_value name="$rankTitle" exact="'Lehrling'"/>
          <do_if value="global.$GT_Config? and global.$GT_Config.$XP? and global.$GT_Config.$XP.$TraderTitles?">
            <set_value name="$rankIndex" exact="($blockedLevel / 3)i + 1"/>
            <do_if value="$rankIndex gt global.$GT_Config.$XP.$TraderTitles.keys.count">
              <set_value name="$rankIndex" exact="global.$GT_Config.$XP.$TraderTitles.keys.count"/>
            </do_if>
            <do_if value="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}?">
              <set_value name="$rankTitle" exact="global.$GT_Config.$XP.$TraderTitles.{$rankIndex}"/>
            </do_if>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
            $ship = this.ship,
            $pilot = this.ship.pilot,
            $xp = @global.$GT_Pilots.{this.ship.pilot}.$XP,
            $level = $blockedLevel,
            $rank = $rankTitle,
            $nameType = 'blocked'
          ]"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] Updated ship name to show ADVANCE label after XPBlocked restoration: ' + this.ship.knownname" chance="100"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- Initialize default order tracking -->
      <!-- Track the current default order to detect when GT order is removed -->
      <set_value name="$currentDefaultOrder" exact="@this.ship.defaultorder.id"/>
      <do_if value="not this.$trackedDefaultOrder?">
        <!-- First time - initialize tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
        
        <!-- Send GT_Order_Assigned signal when GT order is first assigned -->
        <do_if value="$currentDefaultOrder == 'GalaxyTraderMK3'">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] GT order assigned to ' + this.ship.idcode + ' - sending GT_Order_Assigned signal'" chance="100"/>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'GT_Order_Assigned',
            $MacroShipName = @this.ship.macro.name
          ]"/>
        </do_if>
      </do_if>
      <do_if value="this.$trackedDefaultOrder == 'GalaxyTraderMK3' and $currentDefaultOrder != 'GalaxyTraderMK3'">
        <!-- CRITICAL FIX: Check if ship is still GT-controlled via commander BEFORE sending cancellation -->
        <!-- When a subordinate is assigned to a commander, default order changes from GalaxyTraderMK3 to Assist -->
        <!-- But ship is still GT-controlled via commander - don't send cancellation signal -->
        <set_value name="$isStillGTControlled" exact="false"/>
        
        <!-- Check 1: Direct GT order -->
        <do_if value="$currentDefaultOrder == 'GalaxyTraderMK3'">
          <set_value name="$isStillGTControlled" exact="true"/>
        </do_if>
        
        <!-- Check 2: Subordinate to GT commander with Assist order -->
        <do_if value="not $isStillGTControlled and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <do_if value="$currentDefaultOrder == 'Assist'">
              <set_value name="$isStillGTControlled" exact="true"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Only send cancellation signal if ship is NO LONGER GT-controlled -->
        <do_if value="not $isStillGTControlled">
          <!-- GT order was removed â†’ send Phase 7 signal -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in init label, old: ' + this.$trackedDefaultOrder + ', new: ' + (if $currentDefaultOrder then $currentDefaultOrder else 'NONE') + ', still GT-controlled: ' + $isStillGTControlled + ')'" chance="100"/>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'GT_Order_Cancelled'
          ]"/>
          
          <!-- EVENT-DRIVEN: Trigger orphaned ship check -->
          <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}?">
            <signal_objects object="player.galaxy" param="'GT_Check_Ship_Orphaned'" param2="table[$Ship = this.ship]"/>
          </do_if>
        </do_if>
        <do_else>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] PHASE 7: Default order changed from GalaxyTraderMK3 to ' + (if $currentDefaultOrder then $currentDefaultOrder else 'NONE') + ' BUT ship still GT-controlled via commander - NOT sending cancellation'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
        <set_value name="$isSubordinateOfGTCommander" exact="false"/>
        <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$isSubordinateOfGTCommander" exact="true"/>
          </do_if>
        </do_if>
        
        <do_if value="not $isSubordinateOfGTCommander and this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'GT order cancelled - restoring original name',
              $OriginalName = $originalName
            ]"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (original name: ' + $originalName + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Update tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
      </do_if>
      <do_elseif value="this.$trackedDefaultOrder != $currentDefaultOrder">
        <!-- Default order changed (but not GT removal) - just update tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
      </do_elseif>
      
      <!-- Initialize commander tracking and detect commander assignment -->
      <!-- This runs when script restarts (e.g., after commander assignment) -->
      <!-- Check for changes BEFORE initializing trackedCommander -->
      <set_value name="$currentCommander" exact="null"/>
      <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
        <set_value name="$currentCommander" exact="this.ship.commander"/>
      </do_if>
      
      <!-- Store previous tracked commander BEFORE checking/updating -->
      <set_value name="$previousTrackedCommander" exact="null"/>
      <do_if value="this.$trackedCommander?">
        <set_value name="$previousTrackedCommander" exact="this.$trackedCommander"/>
      </do_if>
      
      <!-- Log current state -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] PHASE 6 DEBUG: ' + this.ship.idcode + ' - currentCommander: ' + (if @$currentCommander.exists then @$currentCommander.idcode else 'NONE') + ', previousTrackedCommander: ' + (if @$previousTrackedCommander.exists then @$previousTrackedCommander.idcode else 'NONE')" chance="100"/>
      </do_if>
      
      <!-- Check if commander changed (compare with previous tracked value BEFORE updating) -->
      <do_if value="not this.$trackedCommander?">
        <!-- First time - initialize tracked commander and send signal if commander exists -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
        <do_if value="@$currentCommander.exists">
          <!-- Commander exists on first check - send initialization signal -->
          <set_value name="$newCommanderHasGT" exact="false"/>
          <do_if value="$currentCommander.defaultorder? and @$currentCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$newCommanderHasGT" exact="true"/>
          </do_if>
          
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'Commander_Changed',
            $Commander = $currentCommander,
            $CommanderHasGT = $newCommanderHasGT
          ]"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] PHASE 6: Commander initialized for ' + this.ship.idcode + ' (commander: ' + $currentCommander.idcode + ', has GT: ' + $newCommanderHasGT + ')'" chance="100"/>
          </do_if>
        </do_if>
      </do_if>
      <do_elseif value="((@$previousTrackedCommander.exists == true) and not (@$currentCommander.exists == true)) or (not (@$previousTrackedCommander.exists == true) and (@$currentCommander.exists == true))">
        <!-- Commander state changed (was null, now exists OR was exists, now null) -->
        <set_value name="$oldCommander" exact="$previousTrackedCommander"/>
        <set_value name="$newCommander" exact="$currentCommander"/>
        
        <!-- Check if old commander had GT order (for name restoration when subordinate removed) -->
        <set_value name="$oldCommanderHasGT" exact="false"/>
        <do_if value="@$oldCommander.exists">
          <do_if value="$oldCommander.defaultorder? and @$oldCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$oldCommanderHasGT" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Check if new commander has GT order -->
        <set_value name="$newCommanderHasGT" exact="false"/>
        <do_if value="@$newCommander.exists">
          <do_if value="$newCommander.defaultorder? and @$newCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$newCommanderHasGT" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Send state update signal -->
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'Commander_Changed',
          $Commander = $newCommander,
          $CommanderHasGT = $newCommanderHasGT
        ]"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 6: Commander change detected for ' + this.ship.idcode + ' (old: ' + (if @$oldCommander.exists then @$oldCommander.idcode else 'NONE') + ', new: ' + (if @$newCommander.exists then @$newCommander.idcode else 'NONE') + ', has GT: ' + $newCommanderHasGT + ')'" chance="100"/>
        </do_if>
        
        <!-- If ship was subordinate to GT commander and is no longer subordinate, restore name -->
        <!-- This handles the case where a subordinate is removed from a GT commander -->
        <do_if value="$oldCommanderHasGT and not $newCommanderHasGT and this.ship.pilot?">
          <!-- Ship was subordinate to GT commander, now is not (either no commander or different commander without GT) -->
          <!-- Check if ship has direct GT order -->
          <set_value name="$hasDirectGTOrder" exact="false"/>
          <do_if value="this.ship.defaultorder? and @this.ship.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$hasDirectGTOrder" exact="true"/>
          </do_if>
          
          <!-- Restore name if ship doesn't have direct GT order -->
          <!-- If ship has direct GT order, it will keep GT name (independent GT ship) -->
          <do_if value="not $hasDirectGTOrder">
            <set_value name="$originalName" exact="null"/>
            <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
              <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
            </do_if>
            
            <do_if value="$originalName">
              <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                $Ship = this.ship,
                $Pilot = this.ship.pilot,
                $Reason = 'Subordinate removed from GT commander - restoring original name',
                $OriginalName = $originalName
              ]"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] PHASE 6: Name restoration signal sent for ' + this.ship.idcode + ' (removed from GT commander, no direct GT order, original name: ' + $originalName + ')'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Update tracked commander -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
      </do_elseif>
      <do_elseif value="(@$previousTrackedCommander.exists == true) and (@$currentCommander.exists == true) and $previousTrackedCommander != $currentCommander">
        <!-- Commander changed to different commander -->
        <set_value name="$oldCommander" exact="$previousTrackedCommander"/>
        <set_value name="$newCommander" exact="$currentCommander"/>
        
        <!-- Check if new commander has GT order -->
        <set_value name="$newCommanderHasGT" exact="false"/>
        <do_if value="$newCommander.defaultorder? and @$newCommander.defaultorder.id == 'GalaxyTraderMK3'">
          <set_value name="$newCommanderHasGT" exact="true"/>
        </do_if>
        
        <!-- Send state update signal -->
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'Commander_Changed',
          $Commander = $newCommander,
          $CommanderHasGT = $newCommanderHasGT
        ]"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 6: Commander change detected for ' + this.ship.idcode + ' (old: ' + $oldCommander.idcode + ', new: ' + $newCommander.idcode + ', has GT: ' + $newCommanderHasGT + ')'" chance="100"/>
        </do_if>
        
        <!-- Update tracked commander -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
      </do_elseif>
      <do_else>
        <!-- Commander is the same - no change, but ensure tracked value is updated -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
      </do_else>
      
      <!-- Re-inherit settings from commander if this is a subordinate -->
      <do_if value="this.ship.commander and this.ship.commander.exists and this.ship.commander != this.ship">
        <set_value name="$commanderOrder" exact="this.ship.commander.defaultorder"/>
        <do_if value="$commanderOrder?">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Re-inheriting settings from commander ' + this.ship.commander.idcode" chance="100"/>
          </do_if>
          <!-- Re-inherit all commander settings -->
          <do_if value="$commanderOrder.$fleetcoordination?"><set_value name="$effectiveFleetCoordination" exact="$commanderOrder.$fleetcoordination"/></do_if>
          <do_if value="$commanderOrder.$allowillegal?"><set_value name="$effectiveAllowIllegal" exact="$commanderOrder.$allowillegal"/></do_if>
          <do_if value="$commanderOrder.$factionpriority?"><set_value name="$effectiveFactionPriority" exact="$commanderOrder.$factionpriority"/></do_if>
          <do_if value="$commanderOrder.$ignorecarrieraux?"><set_value name="$effectiveIgnoreCarrierAux" exact="$commanderOrder.$ignorecarrieraux"/></do_if>
          <do_if value="$commanderOrder.$ignorebuildstorage?"><set_value name="$effectiveIgnoreBuildStorage" exact="$commanderOrder.$ignorebuildstorage"/></do_if>
          <do_if value="$commanderOrder.$ignoretraderules?"><set_value name="$effectiveIgnoreTradeRules" exact="$commanderOrder.$ignoretraderules"/></do_if>
          <do_if value="$commanderOrder.$home?"><set_value name="$effectiveHome" exact="$commanderOrder.$home"/></do_if>
          <do_if value="$commanderOrder.$sectorwhitelist?"><set_value name="$effectiveSectorWhitelist" exact="$commanderOrder.$sectorwhitelist"/></do_if>
          <!-- Ware filter / scoring settings -->
          <do_if value="$commanderOrder.$autowares?"><set_value name="$effectiveAutoWares" exact="$commanderOrder.$autowares"/></do_if>
          <do_if value="$commanderOrder.$warebasket?"><set_value name="$effectiveWareBasket" exact="$commanderOrder.$warebasket"/></do_if>
          <do_if value="$commanderOrder.$distancepenalty?"><set_value name="$effectiveDistancePenalty" exact="$commanderOrder.$distancepenalty"/></do_if>
          <do_if value="$commanderOrder.$logbookentries?"><set_value name="$effectiveLogbookEntries" exact="$commanderOrder.$logbookentries"/></do_if>
          <do_if value="$commanderOrder.$notifications?"><set_value name="$effectiveNotifications" exact="$commanderOrder.$notifications"/></do_if>
          <do_if value="$commanderOrder.$debuglevel?"><set_value name="$effectiveDebugLevel" exact="$commanderOrder.$debuglevel"/></do_if>
          <do_if value="$commanderOrder.$tradeeval?"><set_value name="$effectiveTradeEval" exact="$commanderOrder.$tradeeval"/></do_if>
          <!-- Re-inherit max jump distances with pilot capability cap -->
          <do_if value="$commanderOrder.$maxbuy?">
            <!-- Calculate pilot capability (management); if skill is temporarily missing, keep prior effective values -->
            <set_value name="$pilotSkill" exact="1"/>
            <do_if value="@this.ship.pilot and @this.ship.pilot.skill.management != null">
              <set_value name="$pilotSkill" exact="@this.ship.pilot.skill.management"/>
            </do_if>
            <set_value name="$pilotMaxJumps" exact="1"/>
            <do_if value="$pilotSkill le 2"><set_value name="$pilotMaxJumps" exact="1"/></do_if>
            <do_elseif value="$pilotSkill le 5"><set_value name="$pilotMaxJumps" exact="3"/></do_elseif>
            <do_elseif value="$pilotSkill le 8"><set_value name="$pilotMaxJumps" exact="5"/></do_elseif>
            <do_elseif value="$pilotSkill le 11"><set_value name="$pilotMaxJumps" exact="10"/></do_elseif>
            <do_elseif value="$pilotSkill le 13"><set_value name="$pilotMaxJumps" exact="15"/></do_elseif>
            <do_else><set_value name="$pilotMaxJumps" exact="25"/></do_else>
            <set_value name="$effectiveMaxBuy" exact="[$commanderOrder.$maxbuy, $pilotMaxJumps].min"/>
          </do_if>
          <do_if value="$commanderOrder.$maxsell?">
            <!-- Calculate pilot capability -->
            <set_value name="$pilotSkill" exact="1"/>
            <do_if value="@this.ship.pilot and @this.ship.pilot.skill.management != null">
              <set_value name="$pilotSkill" exact="@this.ship.pilot.skill.management"/>
            </do_if>
            <set_value name="$pilotMaxJumps" exact="1"/>
            <do_if value="$pilotSkill le 2"><set_value name="$pilotMaxJumps" exact="1"/></do_if>
            <do_elseif value="$pilotSkill le 5"><set_value name="$pilotMaxJumps" exact="3"/></do_elseif>
            <do_elseif value="$pilotSkill le 8"><set_value name="$pilotMaxJumps" exact="5"/></do_elseif>
            <do_elseif value="$pilotSkill le 11"><set_value name="$pilotMaxJumps" exact="10"/></do_elseif>
            <do_elseif value="$pilotSkill le 13"><set_value name="$pilotMaxJumps" exact="15"/></do_elseif>
            <do_else><set_value name="$pilotMaxJumps" exact="25"/></do_else>
            <set_value name="$effectiveMaxSell" exact="[$commanderOrder.$maxsell, $pilotMaxJumps].min"/>
          </do_if>
          <!-- Refresh derived variables used by the trading loop / MD requests -->
          <set_value name="$gt_allowillegal" exact="$effectiveAllowIllegal"/>
          <set_value name="$gt_distancepenalty" exact="$effectiveDistancePenalty / 50.0"/>
          <set_value name="$gt_logbookentries" exact="$effectiveLogbookEntries"/>
          <set_value name="$warebasket" exact="if $effectiveAutoWares then [] else $effectiveWareBasket"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Settings re-inherited successfully'" chance="100"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- effectiveMaxBuy/effectiveMaxSell always initialized in <init> block -->
      <!-- Persist effective distances for later labels (start_trading) -->
      <set_value name="this.$effectiveMaxBuy" exact="$effectiveMaxBuy"/>
      <set_value name="this.$effectiveMaxSell" exact="$effectiveMaxSell"/>
      
      <!-- Initialize subordinate count tracking -->
      <!-- Track when this ship becomes a commander (gets subordinates) -->
      <set_value name="$currentSubordinateCount" exact="0"/>
      <do_if value="this.ship.subordinates?">
        <set_value name="$currentSubordinateCount" exact="this.ship.subordinates.count"/>
      </do_if>
      <do_if value="not this.$trackedSubordinateCount?">
        <!-- First time - initialize tracked count -->
        <set_value name="this.$trackedSubordinateCount" exact="$currentSubordinateCount"/>
      </do_if>
      
      <!-- Reset was_subordinate flag based on CURRENT state, not previous state -->
      <!-- This prevents false positives when a ship transitions from subordinate â†’ independent -->
      <!-- If ship has a direct GT order, it's independent, not orphaned -->
      <set_value name="$hasDirectGTOrder" exact="false"/>
      <do_if value="this.ship.defaultorder? and @this.ship.defaultorder.id == 'GalaxyTraderMK3'">
        <set_value name="$hasDirectGTOrder" exact="true"/>
      </do_if>
      
      <!-- Reset was_subordinate based on current commander status -->
      <set_value name="$isCurrentlySubordinate" exact="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship"/>
      <set_value name="this.$was_subordinate" exact="$isCurrentlySubordinate"/>
      
      <!-- If ship has direct GT order but was previously subordinate, clear the flag -->
      <!-- This allows ships to transition from subordinate â†’ independent without being treated as orphaned -->
      <do_if value="$hasDirectGTOrder and not $isCurrentlySubordinate">
        <set_value name="this.$was_subordinate" exact="false"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Reset was_subordinate flag (has direct GT order, not subordinate)'" chance="100"/>
        </do_if>
      </do_if>
      
      <!-- =============================================== -->
      <!-- MAIN TRADING LOOP (Modularized)                -->
      <!-- =============================================== -->
      
      <label name="main_loop"/>
      
      <!-- NOTE: Signal check removed from here - maintenance must ALWAYS run before trade execution -->
      <!-- Signals will be checked AFTER maintenance completes (line 2147) to ensure maintenance is never skipped -->
      <!-- NOTE: Do NOT clear global.$GT_TradesAwaitingValidation here - it may contain fresh trade data -->
      <!-- The data will be cleared after trade execution completes (in trade_completed label) -->
      <!-- Cache will be checked by MD system when trade request is sent -->
      <!-- MD system will trigger cache search work unit if cache entries exist -->
      <!-- Cache search work unit will properly filter entries by distance/profit/etc before signaling back -->
      
      <!-- Check for pending work unit and process it -->
      <do_if value="this.$workUnitPending? and this.$workUnitPending">
        <set_value name="this.$workUnitPending" exact="false"/>
        <set_value name="$workUnit" exact="this.$workUnitData"/>
        <set_value name="$workType" exact="if $workUnit? and $workUnit.$WorkType? then $workUnit.$WorkType else 'unknown'"/>
        <set_value name="$traceId" exact="if $workUnit? and $workUnit.$TraceId? then $workUnit.$TraceId else '0'"/>
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Processing work unit type=' + $workType + ' traceId=' + $traceId" chance="100"/>
        
        <!-- Route to work unit processor -->
        <do_if value="$workType == 'cache_search'">
          <resume label="process_cache_workunit"/>
        </do_if>
        <do_elseif value="$workType == 'live_offers'">
          <resume label="process_live_offers_workunit"/>
        </do_elseif>
        <do_elseif value="$workType == 'trade_matching'">
          <resume label="process_trade_matching_workunit"/>
        </do_elseif>
        <do_else>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ERROR - Unknown work unit type=' + $workType" chance="100"/>
        </do_else>
      </do_if>
      
      <!-- Clear ESCAPE state once we are no longer in a blacklisted sector -->
      <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$Escaping? and global.$GT_Ships.{this.ship}.$Escaping">
        <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
        <set_value name="$currentSector" exact="this.ship.sector"/>
        <set_value name="$curActivityBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
        <set_value name="$curTravelBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
        <do_if value="not ($curActivityBL or $curTravelBL)">
          <remove_value name="global.$GT_Ships.{this.ship}.$Escaping"/>
          <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship=this.ship,
              $pilot=this.ship.pilot,
              $xp=global.$GT_Pilots.{this.ship.pilot}.$XP,
              $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
              $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
              $nameType='trader'
            ]"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- Debug: Confirm we reached main loop -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': === MAIN LOOP STARTED === (Pilot: ' + (if this.ship.pilot then this.ship.pilot.name else 'NONE') + ')'" chance="100"/>
      </do_if>
      
      <!-- Read MinPlayerMoney once per loop iteration â€” used by money gates, authoritative guard, and logbook.
           Persisted on instance so it survives <wait> yields within this iteration. -->
      <set_value name="this.$minPlayerMoney" exact="1000"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Fleet? and global.$GT_GlobalSettings.$Fleet.$MinPlayerMoney?">
        <set_value name="$tmpMinMoney" exact="@global.$GT_GlobalSettings.$Fleet.$MinPlayerMoney"/>
        <do_if value="$tmpMinMoney? and $tmpMinMoney != null and $tmpMinMoney gt 0">
          <set_value name="this.$minPlayerMoney" exact="$tmpMinMoney"/>
        </do_if>
      </do_if>
      
      <!-- Check if GT order was removed (main loop detection) -->
      <!-- This catches cases where GT order is manually removed but script continues running -->
      <set_value name="$currentDefaultOrder" exact="@this.ship.defaultorder.id"/>
      <do_if value="not this.$trackedDefaultOrder?">
        <!-- First time - initialize tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
      </do_if>
      <do_if value="this.$trackedDefaultOrder == 'GalaxyTraderMK3' and $currentDefaultOrder != 'GalaxyTraderMK3'">
        <!-- GT order was removed â†’ send Phase 7 signal -->
        <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in main loop, old: ' + this.$trackedDefaultOrder + ', new: ' + (if $currentDefaultOrder then $currentDefaultOrder else 'NONE') + ')'" chance="100"/>
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'GT_Order_Cancelled'
        ]"/>
        
        <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
        <set_value name="$isSubordinateOfGTCommander" exact="false"/>
        <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$isSubordinateOfGTCommander" exact="true"/>
          </do_if>
        </do_if>
        
        <do_if value="not $isSubordinateOfGTCommander and this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'GT order cancelled - restoring original name',
              $OriginalName = $originalName
            ]"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (original name: ' + $originalName + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Update tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
      </do_if>
      <do_elseif value="this.$trackedDefaultOrder != $currentDefaultOrder">
        <!-- Default order changed (but not GT removal) - just update tracked order -->
        <set_value name="this.$trackedDefaultOrder" exact="$currentDefaultOrder"/>
      </do_elseif>
      
      <!-- ======================================= -->
      <!-- MANDATORY TRAINING CHECK (BLOCKS ALL TRADING) -->
      <!-- ======================================= -->
      
      <!-- Check if training was completed by interrupt handler -->
      <do_if value="this.$training_complete?">
        <remove_value name="this.$training_complete"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training completed - continuing with trading'" chance="100"/>
        </do_if>
      </do_if>
      
      <!-- Clear stale training flags when not in training -->
      <!-- These flags can persist when AI context is reused after rapid abort/restart -->
      <do_if value="this.$training_transition? or this.$training_order_created?">
        <do_if value="not this.ship.pilot or not global.$GT_Pilots.{this.ship.pilot}.$XPBlocked?">
          <!-- Pilot is not XP blocked, so training flags are stale - clear them -->
          <remove_value name="this.$training_transition"/>
          <remove_value name="this.$training_order_created"/>
          <remove_value name="this.$training_in_progress"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cleared stale training flags (pilot not XP blocked)'" chance="100"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- ======================================= -->
      <!-- PILOT CHANGE DETECTION (Event-Driven)  -->
      <!-- ======================================= -->
      <!-- NOTE: Pilot change detection moved to restart points (trade_completed, init) -->
      <!-- Polling removed - detection happens at natural restart points where GT order reruns -->
      <!-- This ensures detection happens when order naturally restarts, not constantly polling -->
      
      <!-- ======================================= -->
      <!-- Commander change detection (Main Loop) -->
      <!-- ======================================= -->
      <!-- Track the current commander and detect if it changes (assignment, removal, or change) -->
      <!-- This is more reliable than event_object_commander_set which may not fire during script restart -->
      <set_value name="$currentCommander" exact="null"/>
      <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
        <set_value name="$currentCommander" exact="this.ship.commander"/>
      </do_if>
      
      <!-- Check if commander changed (null to exists, exists to null, or different commander) -->
      <do_if value="not this.$trackedCommander?">
        <!-- First time check - initialize tracked commander -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
      </do_if>
      <do_elseif value="this.$trackedCommander != $currentCommander">
        <!-- Commander changed: nullâ†’exists, existsâ†’null, or different commander -->
        <set_value name="$oldCommander" exact="if this.$trackedCommander? then this.$trackedCommander else null"/>
        <set_value name="$newCommander" exact="$currentCommander"/>
        
        <!-- Check if old commander had GT order (for name restoration) -->
        <set_value name="$oldCommanderHasGT" exact="false"/>
        <do_if value="@$oldCommander.exists">
          <do_if value="$oldCommander.defaultorder? and @$oldCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$oldCommanderHasGT" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Check if new commander has GT order -->
        <set_value name="$newCommanderHasGT" exact="false"/>
        <do_if value="@$newCommander.exists">
          <do_if value="$newCommander.defaultorder? and @$newCommander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$newCommanderHasGT" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Send state update signal -->
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'Commander_Changed',
          $Commander = $newCommander,
          $CommanderHasGT = $newCommanderHasGT
        ]"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 6: Commander change detected for ' + this.ship.idcode + ' (old: ' + (if @$oldCommander.exists then @$oldCommander.idcode else 'NONE') + ', new: ' + (if @$newCommander.exists then @$newCommander.idcode else 'NONE') + ', has GT: ' + $newCommanderHasGT + ')'" chance="100"/>
        </do_if>
        
        <!-- If ship was subordinate to GT commander and is no longer, restore name -->
        <do_if value="$oldCommanderHasGT and not $newCommanderHasGT and this.ship.pilot?">
          <set_value name="$hasDirectGTOrder" exact="false"/>
          <do_if value="this.ship.defaultorder? and @this.ship.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$hasDirectGTOrder" exact="true"/>
          </do_if>
          <do_if value="not $hasDirectGTOrder">
            <set_value name="$originalName" exact="null"/>
            <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
              <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
            </do_if>
            <do_if value="$originalName">
              <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                $Ship = this.ship,
                $Pilot = this.ship.pilot,
                $Reason = 'Commander changed - no longer subordinate to GT commander',
                $OriginalName = $originalName
              ]"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] PHASE 6: Name restoration signal sent for ' + this.ship.idcode + ' (no longer subordinate to GT commander, original name: ' + $originalName + ')'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <!-- Update tracked commander -->
        <set_value name="this.$trackedCommander" exact="$currentCommander"/>
      </do_elseif>
      
      <!-- ======================================= -->
      <!-- Subordinate count detection (Main Loop) -->
      <!-- ======================================= -->
      <!-- Track when this ship becomes a commander (gets subordinates) or stops being one (loses all subordinates) -->
      <!-- This is important for ships that transition from subordinate â†’ commander -->
      <set_value name="$currentSubordinateCount" exact="0"/>
      <do_if value="this.ship.subordinates?">
        <set_value name="$currentSubordinateCount" exact="this.ship.subordinates.count"/>
      </do_if>
      
      <!-- Check if subordinate count changed -->
      <do_if value="not this.$trackedSubordinateCount?">
        <!-- First time check - initialize tracked count -->
        <set_value name="this.$trackedSubordinateCount" exact="$currentSubordinateCount"/>
      </do_if>
      <do_elseif value="this.$trackedSubordinateCount != $currentSubordinateCount">
        <!-- Subordinate count changed -->
        <set_value name="$oldSubordinateCount" exact="this.$trackedSubordinateCount"/>
        <set_value name="$newSubordinateCount" exact="$currentSubordinateCount"/>
        
        <!-- Determine if ship became a commander or stopped being one -->
        <set_value name="$wasCommander" exact="($oldSubordinateCount gt 0)"/>
        <set_value name="$isCommander" exact="($newSubordinateCount gt 0)"/>
        
        <!-- Send state update signal -->
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'Subordinate_Count_Changed',
          $OldSubordinateCount = $oldSubordinateCount,
          $NewSubordinateCount = $newSubordinateCount,
          $WasCommander = $wasCommander,
          $IsCommander = $isCommander
        ]"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 6: Subordinate count changed for ' + this.ship.idcode + ' (old: ' + $oldSubordinateCount + ', new: ' + $newSubordinateCount + ', was commander: ' + $wasCommander + ', is commander: ' + $isCommander + ')'" chance="100"/>
        </do_if>
        
        <!-- Update tracked count -->
        <set_value name="this.$trackedSubordinateCount" exact="$currentSubordinateCount"/>
      </do_elseif>
      
      <!-- ======================================= -->
      <!-- SUBORDINATE COMMANDER CHECK            -->
      <!-- ======================================= -->
      <!-- Check if ship was a subordinate but lost its commander completely -->
      <!-- Track if ship was a subordinate when order started -->
      <do_if value="not this.$was_subordinate?">
        <!-- First time check - store if ship is currently a subordinate -->
        <set_value name="this.$was_subordinate" exact="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship"/>
      </do_if>
      
      <!-- Check if subordinate lost its commander or commander lost GT order -->
      <!-- Unified GT order status check (inline for AI scripts) -->
      <set_value name="$hasDirectGTOrder" exact="false"/>
      <set_value name="$hasGTCommander" exact="false"/>
      <set_value name="$commanderExists" exact="false"/>
      <set_value name="$isSubordinate" exact="false"/>
      
      <!-- Check direct GT order -->
      <set_value name="$currentDefaultOrder" exact="@this.ship.defaultorder.id"/>
      <do_if value="$currentDefaultOrder == 'GalaxyTraderMK3'">
        <set_value name="$hasDirectGTOrder" exact="true"/>
      </do_if>
      
      <!-- Check commander status -->
      <do_if value="not $hasDirectGTOrder and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
        <set_value name="$commanderExists" exact="true"/>
        <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
          <set_value name="$hasGTCommander" exact="true"/>
          <do_if value="$currentDefaultOrder == 'Assist'">
            <set_value name="$isSubordinate" exact="true"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- Check if ship was subordinate and lost commander completely -->
      <do_if value="this.$was_subordinate and not $hasDirectGTOrder">
        <do_if value="not $commanderExists">
          <!-- Subordinate lost its commander completely - restore name and self-abort -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': SUBORDINATE ORPHANED: Commander assignment completely removed - restoring ship name and self-aborting'" chance="100"/>
          </do_if>
          
          <!-- Send signal to restore ship name and cleanup -->
          <do_if value="this.ship.pilot?">
            <set_value name="$originalName" exact="null"/>
            <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
              <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
            </do_if>
            
            <do_if value="$originalName">
              <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                $Ship = this.ship,
                $Pilot = this.ship.pilot,
                $Reason = 'Subordinate commander assignment removed',
                $OriginalName = $originalName
              ]"/>
            </do_if>
          </do_if>
          
          <!-- Set flag to prevent duplicate signal in on_abort handler -->
          <set_value name="this.$subordinate_cleanup_sent" exact="true"/>
          
          <!-- Self-cancel GT order since subordinate is no longer assigned -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Self-canceling GT order - commander assignment removed'" chance="100"/>
          </do_if>
          <cancel_order order="this.ship.defaultorder"/>
          <return/>
        </do_if>
      </do_if>
      
      <!-- If subordinate and commander no longer has GT order, restore ship name and self-abort -->
      <do_if value="$commanderExists and not $hasGTCommander">
        <!-- Commander no longer has GT order - subordinate will follow commander's new order via Assist -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': SUBORDINATE ORPHANED: Commander ' + this.ship.commander.idcode + ' no longer has GT order - restoring ship name and self-aborting'" chance="100"/>
        </do_if>
        
        <!-- Send signal to restore ship name and cleanup -->
        <do_if value="this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'Subordinate commander changed to non-GT order',
              $OriginalName = $originalName
            ]"/>
          </do_if>
        </do_if>
        
        <!-- Set flag to prevent duplicate signal in on_abort handler -->
        <set_value name="this.$subordinate_cleanup_sent" exact="true"/>
        
        <!-- Self-cancel GT order since X4 will make us follow commander's new order anyway -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Self-canceling GT order - will follow commander via Assist'" chance="100"/>
        </do_if>
        <cancel_order order="this.ship.defaultorder"/>
        <return/>
      </do_if>
      
      <!-- Update subordinate tracking flag -->
      <do_if value="$isSubordinate">
        <set_value name="this.$was_subordinate" exact="true"/>
      </do_if>
      <do_else>
        <!-- Not a subordinate anymore - clear flag -->
        <set_value name="this.$was_subordinate" exact="false"/>
      </do_else>
      
      <!-- MANDATORY: Check if pilot is XP blocked - NO trading allowed if blocked -->
      <set_value name="$pilotXPBlocked" exact="false"/>
      <set_value name="$pilotNameForDebug" exact="'No Pilot'"/>
      
      <do_if value="this.ship.pilot and global.$GT_Pilots.{this.ship.pilot}?">
        <!-- Treat paused-with-training-needed as blocking to avoid any trading until training resumes -->
        <set_value name="$pilotXPBlocked" exact="global.$GT_Pilots.{this.ship.pilot}.$XPBlocked? or global.$GT_Pilots.{this.ship.pilot}.$PausedWithTrainingNeeded?"/>
        <set_value name="$pilotNameForDebug" exact="this.ship.pilot.name"/>
      </do_if>
      
      <!-- BLOCKING CONDITION: If pilot is XP blocked, training is MANDATORY before any trading -->
      <!-- Get both current level and blocked level for proper decision making -->
      <set_value name="$pilotLevel" exact="1"/>
      <set_value name="$blockedLevel" exact="1"/>
      <do_if value="this.ship.pilot and global.$GT_Pilots.{this.ship.pilot}?">
        <do_if value="global.$GT_Pilots.{this.ship.pilot}.$Level?">
          <set_value name="$pilotLevel" exact="global.$GT_Pilots.{this.ship.pilot}.$Level"/>
        </do_if>
        <do_if value="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel?">
          <set_value name="$blockedLevel" exact="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel"/>
        </do_if>
      </do_if>
      
      <!-- Show the decision logic -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': DECISION LOGIC: XPBlocked=' + $pilotXPBlocked + ', ManagementLevel=' + $pilotLevel + ', BlockedLevel=' + $blockedLevel + ', Pilot=' + $pilotNameForDebug" chance="100"/>
      </do_if>
      
      <do_if value="$pilotXPBlocked">
        <!-- Check if this is a legitimate training requirement (blocked level > 1) -->
        <do_if value="$blockedLevel gt 1">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': TRAINING MANDATORY: Pilot ' + $pilotNameForDebug + ' needs Level ' + $blockedLevel + ' training - no trading allowed until training completes'" chance="100"/>
          </do_if>
          <resume label="handle_mandatory_training"/>
        </do_if>
        <do_else>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Pilot XP blocked at Level 1 (invalid) - clearing block and proceeding with trading'" chance="100"/>
          <!-- Clear the incorrect XP block for Level 1 pilots -->
          <signal_objects object="player.galaxy" param="'GT_Clear_XP_Block'" param2="table[
            $Ship = this.ship,
            $Pilot = this.ship.pilot,
            $Reason = 'Level 1 pilots should never be XP blocked'
          ]"/>
        </do_else>
      </do_if>
      <do_else>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Pilot not XP blocked - proceeding to maintenance check'" chance="100"/>
        </do_if>
        <!-- Check maintenance needs before trading starts -->
        <resume label="check_maintenance"/>
      </do_else>
      
      <!-- ======================================= -->
      <!-- INITIAL MAINTENANCE CHECK              -->
      <!-- ======================================= -->
      
      <label name="check_maintenance"/>
      
      <!-- ============================================================================= -->
      <!-- PRE-TRADE MAINTENANCE CHECK (UNIFIED SYSTEM)                                  -->
      <!-- ============================================================================= -->
      <!-- Signal unified maintenance system and wait for completion.                    -->
      <!-- MD system handles ALL logic: checking, finding stations, creating orders,     -->
      <!-- and monitoring. AI script just triggers and waits - clean separation!         -->
      <!-- ============================================================================= -->
      
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Requesting maintenance check'" chance="100"/>
      </do_if>
      
      <!-- Signal unified maintenance system to analyze and prepare data -->
      <signal_objects object="player.galaxy" param="'GT_DoMaintenance'" param2="this.ship"/>
      
      <!-- Wait for MD system to prepare data -->
      <wait exact="0.5s"/>
      
      <!-- Create Repair order if data prepared -->
      <do_if value="global.$GT_RepairOrders? and global.$GT_RepairOrders.{this.ship}?">
        <set_value name="$repairData" exact="global.$GT_RepairOrders.{this.ship}"/>
        <set_value name="$repairStation" exact="$repairData.$Station"/>
        
        <!-- FINAL DOCKING VERIFICATION: Use find_dockingbay for accurate dock size/permission check -->
        <!-- This is more accurate than dockingallowed and catches dock size mismatches -->
        <set_value name="$canDockRepair" exact="false"/>
        <do_if value="@$repairStation.exists">
          <!-- Skip docking check for capital ships unless station is a station (capital ships can dock at stations) -->
          <set_value name="$checkDocking" exact="not this.ship.iscapitalship or ($repairStation.isclass.station)"/>
          <do_if value="$checkDocking">
            <find_dockingbay name="$testRepairDock" object="$repairStation" checkoperational="true" multiple="false">
              <match_dock size="this.ship.docksize" storage="false"/>
            </find_dockingbay>
            <do_if value="$testRepairDock">
              <set_value name="$canDockRepair" exact="true"/>
            </do_if>
            <do_else>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Repair docking check FAILED: ' + @$repairStation.knownname + 
                  '\n  Sector: ' + @$repairStation.sector.knownname + 
                  '\n  Reason: No dock available for ship size ' + this.ship.docksize + ' (station may not have L/XL docks)' +
                  '\n  â†’ Clearing repair order and continuing trading...'" 
                  chance="100"/>
              </do_if>
              <!-- Clear repair order data so we don't try again -->
              <remove_value name="global.$GT_RepairOrders.{this.ship}"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Capital ship docking at non-station - skip docking check -->
            <set_value name="$canDockRepair" exact="true"/>
          </do_else>
        </do_if>
        
        <!-- Only create repair order if docking check passed -->
        <do_if value="$canDockRepair">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Creating Repair order at ' + $repairStation.knownname" chance="100"/>
        
        <!-- Set flag to indicate maintenance transition for on_abort handler -->
        <set_value name="this.$maintenance_transition" exact="true"/>
        
        <create_order object="this.ship" id="'Repair'" immediate="false">
            <param name="destination" value="$repairStation"/>
          <param name="hullpercent" value="100"/>
          <param name="repairall" value="true"/>
          <param name="acceptedcost" value="$repairData.$AcceptedCost"/>
          <param name="urgent" value="false"/>
          <param name="internalorder" value="true"/>
        </create_order>
        </do_if>
      </do_if>
      
      <!-- Create Resupply order if data prepared -->
      <do_if value="global.$GT_ResupplyOrders? and global.$GT_ResupplyOrders.{this.ship}?">
        <set_value name="$resupplyData" exact="global.$GT_ResupplyOrders.{this.ship}"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'" chance="100"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': CREATING RESUPPLY BUILD ORDER'" chance="100"/>
          <debug_text text="'[GT-AI]    Target Station: ' + $resupplyData.$Station.knownname" chance="100"/>
          <debug_text text="'[GT-AI]    Station Owner: ' + @$resupplyData.$Station.owner.knownname" chance="100"/>
          <debug_text text="'[GT-AI]    Station Sector: ' + @$resupplyData.$Station.sector.knownname" chance="100"/>
          <debug_text text="'[GT-AI]    Station exists: ' + $resupplyData.$Station.exists" chance="100"/>
          <debug_text text="'[GT-AI]    Station operational: ' + @$resupplyData.$Station.isoperational" chance="100"/>
          <debug_text text="'[GT-AI]    Distance from ship: ' + this.ship.gatedistance.{$resupplyData.$Station} + ' jumps'" chance="100"/>
        </do_if>
        
        <!-- Use vanilla's pattern: add_build_to_modify_ship with shopping list -->
        <!-- This is what actually creates the order with specific items to buy -->
        <set_value name="$buildSuccessful" exact="false"/>
        
        <!-- add_build_to_modify_ship SETS inventory, doesn't ADD to it -->
        <!-- Tables now include CURRENT equipment + NEW equipment (preserves existing) -->
        <!-- Check if tables have keys (they should always have keys now since we preserve existing equipment) -->
        <set_value name="$ammoTableKeys" exact="@$resupplyData.$AmmoTable.keys"/>
        <set_value name="$ammoTableCount" exact="@$ammoTableKeys.count"/>
        <set_value name="$unitTableKeys" exact="@$resupplyData.$UnitTable.keys"/>
        <set_value name="$unitTableCount" exact="@$unitTableKeys.count"/>
        
        <!-- Always call add_build_to_modify_ship if we have a resupply order (tables include existing + new equipment) -->
        <do_if value="$ammoTableCount? or $unitTableCount?">
          <set_value name="$resupplyStation" exact="$resupplyData.$Station"/>
          
          <!-- FINAL DOCKING VERIFICATION: Use find_dockingbay for accurate dock size/permission check -->
          <!-- This is more accurate than dockingallowed and catches dock size mismatches -->
          <set_value name="$canDockResupply" exact="false"/>
          <do_if value="@$resupplyStation.exists">
            <find_dockingbay name="$testResupplyDock" object="$resupplyStation" checkoperational="true" multiple="false">
              <match_dock size="this.ship.docksize" storage="false"/>
            </find_dockingbay>
            <do_if value="$testResupplyDock">
              <set_value name="$canDockResupply" exact="true"/>
            </do_if>
            <do_else>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Resupply docking check FAILED: ' + @$resupplyStation.knownname + 
                  '\n  Sector: ' + @$resupplyStation.sector.knownname + 
                  '\n  Reason: No dock available for ship size ' + this.ship.docksize + ' (station may not have L/XL docks)' +
                  '\n  â†’ Clearing resupply order and continuing trading...'" 
                  chance="100"/>
              </do_if>
              <!-- Clear resupply order data so we don't try again -->
              <remove_value name="global.$GT_ResupplyOrders.{this.ship}"/>
            </do_else>
          </do_if>
          
          <!-- Only create resupply order if docking check passed -->
          <do_if value="$canDockResupply">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Shopping list - Ammo types: ' + $ammoTableCount + ', Unit types: ' + $unitTableCount" chance="100"/>
          </do_if>
          
          <!-- Set flag to indicate maintenance transition for on_abort handler -->
          <set_value name="this.$maintenance_transition" exact="true"/>
          
          <!-- Use vanilla's add_build_to_modify_ship action -->
          <!-- Tables now include CURRENT equipment (preserves it) + NEW equipment (adds to it) -->
          <!-- Use immediate="false" so GT order waits for build order to complete -->
          <add_build_to_modify_ship 
              object="$resupplyStation" 
            buildobject="this.ship" 
            ammo="$resupplyData.$AmmoTable" 
            units="$resupplyData.$UnitTable" 
            immediate="false"
            internal="true"
            result="$buildSuccessful"/>
          
          <do_if value="$buildSuccessful">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Build order created successfully - waiting for completion'" chance="100"/>
              <debug_text text="'[GT-AI] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'" chance="100"/>
            </do_if>
            <!-- Build order will complete and trigger our order.build.equip patch to signal completion -->
          </do_if>
          <do_else>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FAILED to create build order!'" chance="100"/>
              <debug_text text="'[GT-AI]    This usually means the station cannot build the requested items'" chance="100"/>
              <debug_text text="'[GT-AI] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'" chance="100"/>
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Build order creation failed - station cannot fulfill order'" chance="100"/>
            </do_if>
            
            <!-- Clean up resupply data -->
            <remove_value name="global.$GT_ResupplyOrders.{this.ship}"/>
            
            <!-- Apply cooldown to prevent immediate retry -->
            <do_if value="not global.$GT_MaintenanceFailedResupply?">
              <set_value name="global.$GT_MaintenanceFailedResupply" exact="table[]"/>
            </do_if>
            <set_value name="global.$GT_MaintenanceFailedResupply.{this.ship}" exact="player.age + 300s"/>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ðŸ•’ Applied 5-minute cooldown due to failed build order'" chance="100"/>
            
            <!-- Remove maintenance order flag -->
            <do_if value="global.$GT_MaintenanceOrders? and global.$GT_MaintenanceOrders.{this.ship}?">
              <remove_value name="global.$GT_MaintenanceOrders.{this.ship}"/>
            </do_if>
            
            <!-- Signal MD that we're done (failed) -->
            <signal_objects object="this.ship" param="'GT_Maintenance_Complete'"/>
          </do_else>
          </do_if>
          <!-- End: Only create resupply order if docking check passed -->
          <!-- End: Only create resupply order if docking check passed -->
        </do_if>
        <do_else>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Empty shopping list - nothing to buy'" chance="100"/>
          </do_if>
          
          <!-- Clean up and skip -->
          <remove_value name="global.$GT_ResupplyOrders.{this.ship}"/>
          <do_if value="global.$GT_MaintenanceOrders? and global.$GT_MaintenanceOrders.{this.ship}?">
            <remove_value name="global.$GT_MaintenanceOrders.{this.ship}"/>
          </do_if>
          
          <signal_objects object="this.ship" param="'GT_Maintenance_Complete'"/>
        </do_else>
      </do_if>
      
      <!-- Wait for maintenance to complete -->
      <do_if value="(global.$GT_RepairOrders? and global.$GT_RepairOrders.{this.ship}?) or (global.$GT_ResupplyOrders? and global.$GT_ResupplyOrders.{this.ship}?)">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': â³ Waiting for maintenance orders to complete (max 900s)...'" chance="100"/>
        </do_if>
        
        <wait max="900s">
          <interrupt>
            <conditions>
              <event_object_signalled object="this.ship" param="'GT_Maintenance_Complete'"/>
            </conditions>
            <actions>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Maintenance complete signal received, proceeding to trade search'" chance="100"/>
              </do_if>
              
              <!-- Clear maintenance transition flag -->
              <remove_value name="this.$maintenance_transition"/>
            </actions>
          </interrupt>
        </wait>
        
        <!-- Timeout fallback -->
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': â±ï¸ Maintenance timeout after 900s, proceeding anyway'" chance="100"/>
        
        <!-- Clear maintenance transition flag on timeout as well -->
        <remove_value name="this.$maintenance_transition"/>
      </do_if>
      <do_else>
        <!-- No maintenance needed -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': No maintenance needed, proceeding to trade search'" chance="100"/>
        </do_if>
      </do_else>
      
      <!-- CRITICAL: Check for signal that arrived during maintenance wait -->
      <!-- This must happen AFTER maintenance completes but BEFORE proceeding to start_trading -->
      <!-- Signals can arrive during the maintenance wait block (line 2118), so we check here -->
      <do_if value="this.$tradeFoundViaInterrupt? and this.$tradeFoundViaInterrupt">
        <set_value name="this.$tradeFoundViaInterrupt" exact="false"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT_Trade_Found signal received during maintenance wait - processing from param2 data'" chance="100"/>
        </do_if>
        
        <!-- Reset retry counter on successful trade -->
        <set_value name="this.$searchFailed" exact="0"/>
        
        <!-- Clear per-ship no-trade attempt history on success -->
        <do_if value="global.$GT_NoTradeHistory? and global.$GT_NoTradeHistory.{this.ship}?">
          <remove_value name="global.$GT_NoTradeHistory.{this.ship}"/>
        </do_if>
        
        <!-- CARGO DISPOSAL: Reset cargo disposal failure counter on successful trade -->
        <do_if value="this.$cargoDisposalFailed?">
          <set_value name="this.$cargoDisposalFailed" exact="0"/>
        </do_if>
        
        <resume label="trade_found"/>
      </do_if>
      
      <!-- Proceed to trading -->
      <resume label="start_trading"/>
      
      <!-- ======================================= -->
      <!-- HIGH-PERFORMANCE TRADING LOOP          -->
      <!-- ======================================= -->
      
      <!-- ========================================= -->
      <!-- MANDATORY TRAINING HANDLER              -->
      <!-- ========================================= -->
      
      <label name="handle_mandatory_training"/>
      
      <!-- Check if ship has an active DockAndTrain order -->
      <set_value name="$hasActiveTrainingOrder" exact="false"/>
      <do_if value="this.ship.orders.count gt 0">
        <do_all exact="this.ship.orders.count" counter="$i">
          <do_if value="this.ship.orders.{$i}.id == 'DockAndTrain'">
            <set_value name="$hasActiveTrainingOrder" exact="true"/>
            <break/>
          </do_if>
        </do_all>
      </do_if>
      
      <!-- ENHANCED LOGIC: Auto-restart training if it was previously interrupted -->
      <!-- Conditions for starting/restarting training:
           1. Auto-training is enabled
           2. Ship has a pilot with GT pilot data
           3. Either: training not in progress OR no active training order (interrupted training)
      -->
      <do_if value="$gt_autotraining and this.ship.pilot and global.$GT_Pilots.{this.ship.pilot}">
        <set_value name="$shouldStartTraining" exact="false"/>
        
        <!-- Case 1: Training not currently in progress -->
        <do_if value="not this.$training_in_progress?">
          <set_value name="$shouldStartTraining" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training not in progress - can start training'" chance="100"/>
          </do_if>
        </do_if>
        <!-- Case 2: Training was marked as in progress but no active training order (interrupted) -->
        <do_elseif value="this.$training_in_progress? and not $hasActiveTrainingOrder">
          <set_value name="$shouldStartTraining" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': TRAINING INTERRUPTED: Previous training was aborted - restarting automatically'" chance="100"/>
          </do_if>
          <!-- Clear the stale flag -->
          <remove_value name="this.$training_in_progress"/>
        </do_elseif>
        
        <do_if value="$shouldStartTraining">
          <!-- CRITICAL: Only trigger training if XPBlocked is true -->
          <!-- If XPBlocked is false but BlockedLevel exists, it means training stations were not found previously -->
          <!-- In that case, don't trigger another search - ship should continue trading -->
          <set_value name="$xpBlocked" exact="false"/>
          <do_if value="global.$GT_Pilots.{this.ship.pilot}.$XPBlocked?">
            <set_value name="$xpBlocked" exact="true"/>
          </do_if>
          
          <do_if value="$xpBlocked">
            <!-- Get blocked level with safety check -->
            <set_value name="$blockedLevel" exact="1"/>
            <do_if value="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel?">
              <set_value name="$blockedLevel" exact="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel"/>
            </do_if>
            <do_else>
              <!-- Calculate current skill level as fallback -->
              <do_if value="global.$GT_Pilots.{this.ship.pilot}.$XP?">
                <set_value name="$currentXP" exact="global.$GT_Pilots.{this.ship.pilot}.$XP"/>
                <do_all exact="15" counter="$skillLevel">
                  <do_if value="$currentXP ge global.$GT_Config.$XP.$SkillThresholds.{$skillLevel}">
                    <set_value name="$blockedLevel" exact="$skillLevel"/>
                  </do_if>
                </do_all>
              </do_if>
            </do_else>
            
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ðŸŽ“ Initiating mandatory training for pilot ' + $pilotNameForDebug + ' (Level ' + $blockedLevel + ')'" chance="100"/>
            </do_if>
            
            <!-- Signal MD system to handle training -->
            <signal_objects object="player.galaxy" param="'GT_Training_Needed'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $RequiredLevel = $blockedLevel
            ]"/>
            
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training signal sent to MD system for pilot ' + $pilotNameForDebug" chance="100"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- XPBlocked is false but BlockedLevel exists - training stations were not found previously -->
            <!-- Don't trigger another search - ship should continue trading -->
            <set_value name="$blockedLevelForDebug" exact="'none'"/>
            <do_if value="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel?">
              <set_value name="$blockedLevelForDebug" exact="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel"/>
            </do_if>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training needed but XPBlocked=false (no training stations found previously) - continuing with trading. BlockedLevel=' + $blockedLevelForDebug" chance="100"/>
            </do_if>
            <!-- Break out of training handler and continue to trading -->
            <resume label="check_maintenance"/>
          </do_else>
        </do_if>
        <do_else>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': â³ Training already in progress (active order: ' + $hasActiveTrainingOrder + ') - waiting'" chance="100"/>
          </do_if>
        </do_else>
      </do_if>
      <do_else>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Auto-training disabled or no pilot data - waiting'" chance="100"/>
        </do_if>
      </do_else>
      
      <!-- Wait and check again - training is mandatory -->
      <wait max="10s">
        <interrupt>
          <conditions>
            <event_object_signalled object="this.ship" param="'GT_Training_Station_Found'"/>
          </conditions>
          <actions>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Training station found during wait - proceeding immediately'" chance="100"/>
            </do_if>
          </actions>
        </interrupt>
      </wait>
      <resume label="main_loop"/>
      
      <!-- ========================================= -->
      <!-- EVENT-DRIVEN TRADE SEARCH WITH RETRY     -->
      <!-- ========================================= -->
      
      <label name="start_trading"/>

      <!-- HARD RULE: no silent fallbacks for pilot skill timing issues. -->
      <!-- If pilot.skill.management isn't available yet, do NOT request a trade search with bogus caps. -->
      <!-- Wait is only allowed at top-level; use a bounded loop here (not inside any do_if). -->
      <set_value name="$pilotSkillMissing" exact="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship and (@this.ship.pilot == null or @this.ship.pilot.skill.management == null)"/>
      <set_value name="this.$pilotSkillWaitTries" exact="0"/>
      <do_while value="$pilotSkillMissing and this.$pilotSkillWaitTries lt 10">
        <wait exact="1s"/>
        <set_value name="$pilotSkillMissing" exact="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship and (@this.ship.pilot == null or @this.ship.pilot.skill.management == null)"/>
        <set_value name="this.$pilotSkillWaitTries" exact="this.$pilotSkillWaitTries + 1"/>
      </do_while>
      <do_if value="$pilotSkillMissing">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ERROR: pilot.skill.management unavailable after ' + this.$pilotSkillWaitTries + 's - NOT sending trade search request. Will retry on next loop (this is a timing bug we want to SEE).'" chance="100"/>
        <resume label="main_loop"/>
      </do_if>
      
      <!-- effectiveMaxBuy/effectiveMaxSell initialized in <init> block -->

      <!-- ========================================= -->
      <!-- SUBORDINATE SETTINGS REFRESH (ON REQUEST) -->
      <!-- ========================================= -->
      <!-- Problem: Commander default-order param edits do not reliably trigger event_object_order_ready.
           Solution: When a subordinate is ABOUT to request a new trade, refresh inherited commander settings if they changed.
           effectiveAutoWares/effectiveWareBasket/effectiveDistancePenalty initialized in <init> block. -->

      <set_value name="$_isSubordinateNow" exact="this.ship.commander and this.ship.commander.exists and this.ship.commander != this.ship"/>
      <do_if value="$_isSubordinateNow">
        <set_value name="$_commanderOrderNow" exact="this.ship.commander.defaultorder"/>
        <do_if value="$_commanderOrderNow?">
          <!-- Build a signature for commander settings that affect trade searching / routing -->
          <set_value name="$_cmdAutoWares" exact="if $_commanderOrderNow.$autowares? then $_commanderOrderNow.$autowares else $effectiveAutoWares"/>
          <set_value name="$_cmdDistancePenalty" exact="if $_commanderOrderNow.$distancepenalty? then $_commanderOrderNow.$distancepenalty else $effectiveDistancePenalty"/>
          <set_value name="$_cmdWareBasket" exact="if $_commanderOrderNow.$warebasket? then $_commanderOrderNow.$warebasket else $effectiveWareBasket"/>

          <set_value name="$_cmdFleetCoord" exact="if $_commanderOrderNow.$fleetcoordination? then $_commanderOrderNow.$fleetcoordination else $effectiveFleetCoordination"/>
          <set_value name="$_cmdAllowIllegal" exact="if $_commanderOrderNow.$allowillegal? then $_commanderOrderNow.$allowillegal else $effectiveAllowIllegal"/>
          <set_value name="$_cmdFactionPriority" exact="if $_commanderOrderNow.$factionpriority? then $_commanderOrderNow.$factionpriority else $effectiveFactionPriority"/>
          <set_value name="$_cmdIgnoreCarrierAux" exact="if $_commanderOrderNow.$ignorecarrieraux? then $_commanderOrderNow.$ignorecarrieraux else $effectiveIgnoreCarrierAux"/>
          <set_value name="$_cmdIgnoreBuildStorage" exact="if $_commanderOrderNow.$ignorebuildstorage? then $_commanderOrderNow.$ignorebuildstorage else $effectiveIgnoreBuildStorage"/>
          <set_value name="$_cmdIgnoreTradeRules" exact="if $_commanderOrderNow.$ignoretraderules? then $_commanderOrderNow.$ignoretraderules else $effectiveIgnoreTradeRules"/>
          <set_value name="$_cmdLogbookEntries" exact="if $_commanderOrderNow.$logbookentries? then $_commanderOrderNow.$logbookentries else $effectiveLogbookEntries"/>
          <set_value name="$_cmdNotifications" exact="if $_commanderOrderNow.$notifications? then $_commanderOrderNow.$notifications else $effectiveNotifications"/>
          <set_value name="$_cmdDebugLevel" exact="if $_commanderOrderNow.$debuglevel? then $_commanderOrderNow.$debuglevel else $effectiveDebugLevel"/>
          <set_value name="$_cmdTradeEval" exact="if $_commanderOrderNow.$tradeeval? then $_commanderOrderNow.$tradeeval else $effectiveTradeEval"/>
          <set_value name="$_cmdHome" exact="if $_commanderOrderNow.$home? then $_commanderOrderNow.$home else this.$effectiveHome"/>
          <set_value name="$_cmdMaxBuy" exact="if $_commanderOrderNow.$maxbuy? then $_commanderOrderNow.$maxbuy else $effectiveMaxBuy"/>
          <set_value name="$_cmdMaxSell" exact="if $_commanderOrderNow.$maxsell? then $_commanderOrderNow.$maxsell else $effectiveMaxSell"/>
          <set_value name="$_cmdSectorWhitelist" exact="if $_commanderOrderNow.$sectorwhitelist? then $_commanderOrderNow.$sectorwhitelist else $effectiveSectorWhitelist"/>
          
          <!-- IMPORTANT:
               In X4 AI script expressions, `?` checks existence, NOT null, and boolean `and` is not safe to rely on for short-circuiting.
               Normalize a null sectorwhitelist to an empty list so we can safely use `.count`. -->
          <do_if value="not $_cmdSectorWhitelist? or $_cmdSectorWhitelist == null">
            <set_value name="$_cmdSectorWhitelist" exact="[]"/>
          </do_if>

          <set_value name="$_cmdHomeName" exact="if $_cmdHome? then @$_cmdHome.knownname else 'NULL'"/>

          <set_value name="$_commanderSettingsSig" exact="'AW=' + $_cmdAutoWares
            + '|DP=' + $_cmdDistancePenalty
            + '|FC=' + $_cmdFleetCoord
            + '|IL=' + $_cmdAllowIllegal
            + '|FP=' + $_cmdFactionPriority
            + '|ICA=' + $_cmdIgnoreCarrierAux
            + '|IBS=' + $_cmdIgnoreBuildStorage
            + '|ITR=' + $_cmdIgnoreTradeRules
            + '|HB=' + $_cmdHomeName
            + '|MB=' + $_cmdMaxBuy
            + '|MS=' + $_cmdMaxSell
            + '|LB=' + $_cmdLogbookEntries
            + '|NT=' + $_cmdNotifications
            + '|DL=' + $_cmdDebugLevel
            + '|TE=' + $_cmdTradeEval
            + '|SW='"/>

          <!-- Include sector whitelist content -->
          <do_if value="$_cmdSectorWhitelist.count gt 0">
            <do_all exact="$_cmdSectorWhitelist.count" counter="$_sw_i">
              <set_value name="$_sw" exact="$_cmdSectorWhitelist.{$_sw_i}"/>
              <set_value name="$_swName" exact="if $_sw? then @$_sw.knownname else 'NULL'"/>
              <set_value name="$_commanderSettingsSig" exact="$_commanderSettingsSig + (if $_sw_i gt 1 then ',' else '') + $_swName"/>
            </do_all>
          </do_if>

          <!-- Include ware basket content (only when autowares is disabled) -->
          <do_if value="not $_cmdAutoWares">
            <do_all exact="$_cmdWareBasket.count" counter="$_i">
              <set_value name="$_w" exact="$_cmdWareBasket.{$_i}"/>
              <set_value name="$_wName" exact="if $_w? then @$_w.name else 'NULL'"/>
              <set_value name="$_commanderSettingsSig" exact="$_commanderSettingsSig + (if $_i gt 1 then ',' else '') + $_wName"/>
            </do_all>
          </do_if>

          <do_if value="not this.$trackedCommanderSettingsSig? or this.$trackedCommanderSettingsSig != $_commanderSettingsSig">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Commander settings changed (refreshing inherited settings). NewSig=' + $_commanderSettingsSig" chance="100"/>
            </do_if>

            <!-- Apply commander settings to this subordinate immediately -->
            <set_value name="$effectiveAutoWares" exact="$_cmdAutoWares"/>
            <set_value name="$effectiveWareBasket" exact="$_cmdWareBasket"/>
            <set_value name="$effectiveDistancePenalty" exact="$_cmdDistancePenalty"/>
            <set_value name="$effectiveFleetCoordination" exact="$_cmdFleetCoord"/>
            <set_value name="$effectiveAllowIllegal" exact="$_cmdAllowIllegal"/>
            <set_value name="$effectiveFactionPriority" exact="$_cmdFactionPriority"/>
            <set_value name="$effectiveIgnoreCarrierAux" exact="$_cmdIgnoreCarrierAux"/>
            <set_value name="$effectiveIgnoreBuildStorage" exact="$_cmdIgnoreBuildStorage"/>
            <set_value name="$effectiveIgnoreTradeRules" exact="$_cmdIgnoreTradeRules"/>
            <set_value name="$effectiveLogbookEntries" exact="$_cmdLogbookEntries"/>
            <set_value name="$effectiveNotifications" exact="$_cmdNotifications"/>
            <set_value name="$effectiveDebugLevel" exact="$_cmdDebugLevel"/>
            <set_value name="$effectiveTradeEval" exact="$_cmdTradeEval"/>
            <set_value name="$effectiveSectorWhitelist" exact="$_cmdSectorWhitelist"/>

            <!-- Home base affects distance filtering/scoring; ensure both local and persisted value update -->
            <do_if value="$_cmdHome?">
              <set_value name="$effectiveHome" exact="$_cmdHome"/>
              <set_value name="this.$effectiveHome" exact="$effectiveHome"/>
            </do_if>

            <!-- Jump distance caps: use commander's values but cap at subordinate pilot capability -->
            <set_value name="$_pilotSkill" exact="@this.ship.pilot.skill.management"/>
            <set_value name="$_pilotMaxJumps" exact="1"/>
            <do_if value="$_pilotSkill le 2"><set_value name="$_pilotMaxJumps" exact="1"/></do_if>
            <do_elseif value="$_pilotSkill le 5"><set_value name="$_pilotMaxJumps" exact="3"/></do_elseif>
            <do_elseif value="$_pilotSkill le 8"><set_value name="$_pilotMaxJumps" exact="5"/></do_elseif>
            <do_elseif value="$_pilotSkill le 11"><set_value name="$_pilotMaxJumps" exact="10"/></do_elseif>
            <do_elseif value="$_pilotSkill le 13"><set_value name="$_pilotMaxJumps" exact="15"/></do_elseif>
            <do_else><set_value name="$_pilotMaxJumps" exact="25"/></do_else>

            <do_if value="$_commanderOrderNow.$maxbuy?">
              <set_value name="$effectiveMaxBuy" exact="[$_cmdMaxBuy, $_pilotMaxJumps].min"/>
              <set_value name="this.$effectiveMaxBuy" exact="$effectiveMaxBuy"/>
            </do_if>
            <do_if value="$_commanderOrderNow.$maxsell?">
              <set_value name="$effectiveMaxSell" exact="[$_cmdMaxSell, $_pilotMaxJumps].min"/>
              <set_value name="this.$effectiveMaxSell" exact="$effectiveMaxSell"/>
            </do_if>

            <!-- Refresh derived variables used by the MD requests -->
            <set_value name="$gt_allowillegal" exact="$effectiveAllowIllegal"/>
            <set_value name="$gt_distancepenalty" exact="$effectiveDistancePenalty / 50.0"/>
            <set_value name="$gt_logbookentries" exact="$effectiveLogbookEntries"/>
            <set_value name="$warebasket" exact="if $effectiveAutoWares then [] else $effectiveWareBasket"/>

            <!-- CRITICAL: Drop stale trades awaiting validation produced under the previous commander settings.
                 Otherwise the AI can execute old trades (wrong ware filter, wrong distances, etc.) via stale data. -->
            <do_if value="global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
              <remove_value name="global.$GT_TradesAwaitingValidation.{this.ship}"/>
            </do_if>
            <do_if value="global.$GT_TradesAwaitingValidationTimestamp? and global.$GT_TradesAwaitingValidationTimestamp.{this.ship}?">
              <remove_value name="global.$GT_TradesAwaitingValidationTimestamp.{this.ship}"/>
            </do_if>
            <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
              <remove_value name="global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
            </do_if>
            <!-- Clear interrupt flag when clearing trades awaiting validation (commander settings changed) -->
            <set_value name="this.$tradeFoundViaInterrupt" exact="false"/>
            <!-- Reset retry counter: we want a clean fresh request under the new settings -->
            <do_if value="this.$searchFailed?">
              <set_value name="this.$searchFailed" exact="0"/>
            </do_if>
          </do_if>

          <!-- Track last applied signature (always) -->
          <set_value name="this.$trackedCommanderSettingsSig" exact="$_commanderSettingsSig"/>
        </do_if>
      </do_if>
      
      <!-- Initialize retry counter if not exists -->
      <do_if value="not this.$searchFailed?">
        <set_value name="this.$searchFailed" exact="0"/>
      </do_if>
      
      <!-- Signal MD system for trade opportunities -->
      <!-- Check if ship already has trade orders BEFORE requesting new trade -->
      <set_value name="$hasTradeOrders" exact="false"/>
      <do_if value="this.ship.tradeorders? and this.ship.tradeorders.count gt 0">
        <set_value name="$hasTradeOrders" exact="true"/>
      </do_if>
      
      <do_if value="$hasTradeOrders">
        <!-- Ship already has pending trade orders - wait instead of requesting more -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Ship already has ' + this.ship.tradeorders.count + ' trade orders - waiting for completion'" chance="100"/>
        </do_if>
        
        <!-- Wait for trade completion -->
        <wait max="10s">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_signalled object="this.ship" param="'GT_Trade_Completed'"/>
                <event_object_signalled object="this.ship" param="'GT_Trade_Failed'"/>
              </check_any>
            </conditions>
            <actions>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade order completed early - checking status immediately'" chance="100"/>
              </do_if>
            </actions>
          </interrupt>
        </wait>
        <resume label="main_loop"/>
      </do_if>
      <do_else>
        <!-- Ship ready for new trade - ensure ship is registered before requesting trade search -->
        <!-- This is critical when pilot is transferred to a new ship -->
        <set_value name="$shipNotRegistered" exact="false"/>
        <do_if value="not global.$GT_Ships? or not global.$GT_Ships.{this.ship}?">
          <!-- Ship not registered yet - wait a moment for registration to complete -->
          <!-- Registration happens via GT_Update_Ship signal sent in init block -->
          <set_value name="$shipNotRegistered" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Ship not yet registered - waiting for registration to complete...'" chance="100"/>
          </do_if>
        </do_if>
        <!-- Wait for registration using a top-level loop (no waits inside conditionals) -->
        <set_value name="$regPending" exact="$shipNotRegistered? and $shipNotRegistered and (not global.$GT_Ships? or not global.$GT_Ships.{this.ship}?)"/>
        <do_while value="$regPending">
          <wait exact="500ms"/>
          <set_value name="$regPending" exact="$shipNotRegistered? and $shipNotRegistered and (not global.$GT_Ships? or not global.$GT_Ships.{this.ship}?)"/>
        </do_while>
        
        <!-- Check cargo status -->
        <!-- Only trade if cargo is EMPTY -->
        <set_value name="$hasCargo" exact="this.ship.cargo.free.all lt this.ship.cargo.capacity.all"/>
        
        <do_if value="$hasCargo">
          <!-- Ship has cargo - sell it first using our trade search -->
          <!-- CARGO DISPOSAL: Only log initial message once (prevent spam) -->
          <set_value name="$isFirstCargoDisposalAttempt" exact="false"/>
          <do_if value="not this.$cargoDisposalFailed? or this.$cargoDisposalFailed == 0">
            <set_value name="$isFirstCargoDisposalAttempt" exact="true"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Ship has cargo - finding best buyer using trade search...'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Set cargo disposal flag for ship name -->
          <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}?">
            <set_value name="global.$GT_Ships.{this.ship}.$CargoDisposal" exact="true"/>
          </do_if>
          
          <!-- Trigger ship rename to show [CLEARANCE] state -->
          <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
            <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
              $ship=this.ship, 
              $pilot=this.ship.pilot, 
              $xp=global.$GT_Pilots.{this.ship.pilot}.$XP, 
              $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
              $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
              $nameType='trader'
            ]"/>
          </do_if>
          
          <!-- Write logbook entry about cargo safety - ONLY ON FIRST ATTEMPT -->
          <do_if value="$isFirstCargoDisposalAttempt and $gt_logbookentries">
            <!-- Construct logbook message using TextDB syntax (vanilla pattern) -->
            <set_value name="$logbookMessage" exact="{77000,3204}.[this.ship.knownname]"/>
            
            <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
              $Message = $logbookMessage,
              $Category = 'tips',
              $Title = 'Cargo Safety: ' + this.ship.knownname,
              $Object = this.ship,
              $Interaction = 'showonmap',
              $CheckGlobalSettings = false
            ]"/>
          </do_if>
          
          <!-- effectiveXxx variables initialized in <init> block -->
          
          <signal_objects object="player.galaxy" param="'GT_Find_Sell'" param2="table[
            $Ship = this.ship,
            $HomeBase = this.$effectiveHome,
            $MaxSell = $effectiveMaxSell,
            $DistancePenalty = $effectiveDistancePenalty,
            $FleetCoordination = $effectiveFleetCoordination,
            $IgnoreCarrierAux = $effectiveIgnoreCarrierAux,
            $IgnoreBuildStorage = $effectiveIgnoreBuildStorage,
            $IgnoreTradeRules = $effectiveIgnoreTradeRules
          ]"/>
        </do_if>
        <do_else>
          <!-- Ship cargo is EMPTY - look for buy opportunities -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cargo empty - looking for trade opportunities...'" chance="100"/>
          </do_if>

          <!-- Clear cargo disposal flag (cargo is now empty) -->
          <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$CargoDisposal?">
            <remove_value name="global.$GT_Ships.{this.ship}.$CargoDisposal"/>
            
            <!-- CARGO DISPOSAL: Reset cargo disposal failure counter when cargo is cleared -->
            <do_if value="this.$cargoDisposalFailed?">
              <set_value name="this.$cargoDisposalFailed" exact="0"/>
            </do_if>
            
            <!-- Trigger ship rename to remove [CLEARANCE] state -->
            <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship=this.ship, 
                $pilot=this.ship.pilot, 
                $xp=global.$GT_Pilots.{this.ship.pilot}.$XP, 
                $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                $nameType='trader'
              ]"/>
            </do_if>
          </do_if>
          
          <!-- ==================================================================================== -->
          <!-- MECHANIC 2: Early money gate - skip entire trade search pipeline when player is broke -->
          <!-- Threshold: MinPlayerMoney + 1000 Cr safety buffer.                                   -->
          <!-- This prevents the expensive cache search / work loop from running when there is      -->
          <!-- no meaningful budget left. Ships go directly to insufficient_funds cooldown.          -->
          <!-- Works with MECHANIC 1 (authoritative guard budget clamp at trade creation):           -->
          <!--   Mechanic 1 = clamp trade volume to fit budget  (trade creation)                    -->
          <!--   Mechanic 2 = stop searching when budget is exhausted (search start)                -->
          <!-- ==================================================================================== -->
          <set_value name="$earlyMoneyCheck" exact="player.money"/>
          <set_value name="$moneyGateThreshold" exact="(this.$minPlayerMoney + 1000)Cr"/>
          <do_if value="$earlyMoneyCheck le $moneyGateThreshold">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': EARLY MONEY GATE: player money=' + ($earlyMoneyCheck / 100) + ' Cr at or below threshold=' + (this.$minPlayerMoney + 1000) + ' Cr (MinPlayerMoney=' + this.$minPlayerMoney + ' + 1000 buffer) - skipping trade search'" chance="100"/>
            <set_value name="this.$lastNoTradeReason" exact="'insufficient_funds'"/>
            <resume label="no_trade_retry"/>
          </do_if>
          
          <!-- GLOBAL MONEY CAP: When the authoritative guard blocked a trade (0 affordable units),
               it set global.$GT_MoneyCapActive. This stops ALL ships from searching until money
               increases. Clears automatically when player.money rises above the recorded level. -->
          <do_if value="global.$GT_MoneyCapActive? and global.$GT_MoneyCapActive">
            <do_if value="$earlyMoneyCheck le global.$GT_MoneyCapMoney">
              <!-- Money hasn't increased since fleet-wide block - skip search -->
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GLOBAL MONEY CAP: player money=' + ($earlyMoneyCheck / 100) + ' Cr has not increased since cap (' + (global.$GT_MoneyCapMoney / 100) + ' Cr) - skipping trade search'" chance="100"/>
              <set_value name="this.$lastNoTradeReason" exact="'insufficient_funds'"/>
              <resume label="no_trade_retry"/>
            </do_if>
            <do_else>
              <!-- Money increased! Clear global cap so all ships can search again -->
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GLOBAL MONEY CAP CLEARED: player money=' + ($earlyMoneyCheck / 100) + ' Cr increased above cap (' + (global.$GT_MoneyCapMoney / 100) + ' Cr) - resuming fleet trade searches'" chance="100"/>
              <set_value name="global.$GT_MoneyCapActive" exact="false"/>
              <remove_value name="global.$GT_MoneyCapMoney"/>
            </do_else>
          </do_if>
          
          <!-- Wait briefly for any pending GT_Trade_Found signals before sending new request.
               Configured delay + 5ms buffer. If signal arrives during wait, interrupt processes it. -->
          <set_value name="$signalDelayMs" exact="0"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$TradeFoundSignalDelay?">
            <set_value name="$tmpDelay" exact="@global.$GT_GlobalSettings.$Performance.$TradeFoundSignalDelay"/>
            <do_if value="$tmpDelay ge 0 and $tmpDelay le 1000">
              <set_value name="$signalDelayMs" exact="$tmpDelay"/>
            </do_if>
          </do_if>
          <set_value name="this.$tradeFoundSignalWaitTime" exact="($signalDelayMs + 5) * 1ms"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Waiting ' + ($signalDelayMs + 5) + 'ms for GT_Trade_Found signal (delay=' + $signalDelayMs + 'ms + 5ms buffer)'" chance="100"/>
          </do_if>
          <wait max="this.$tradeFoundSignalWaitTime" comment="Wait for pending GT_Trade_Found signals">
            <interrupt>
              <conditions>
                <event_object_signalled object="this.ship" param="'GT_Trade_Found'"/>
              </conditions>
              <actions>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT_Trade_Found signal received during pre-request wait - processing trade'" chance="100"/>
                </do_if>
                <!-- Signal received - jump to trade_found label to process it -->
                <resume label="trade_found"/>
              </actions>
            </interrupt>
          </wait>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Pre-request wait completed - no signal received, sending new request'" chance="100"/>
          </do_if>
          
          <!-- effectiveXxx variables initialized in <init> block -->
          
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': SENDING GT_Find_Trade signal to MD at game time ' + player.age" chance="100"/>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Find_Trade'" param2="table[
            $Ship = this.ship,
            $HomeBase = this.$effectiveHome,
            $MaxBuy = if this.$effectiveMaxBuy? then this.$effectiveMaxBuy else $effectiveMaxBuy,
            $MaxSell = if this.$effectiveMaxSell? then this.$effectiveMaxSell else $effectiveMaxSell,
            $CargoTarget = $gt_cargotarget,
            $WareBasket = $warebasket,
            $AllowIllegal = $gt_allowillegal,
            $FactionPriority = $gt_factionpriority,
            $IgnoreCarrierAux = $effectiveIgnoreCarrierAux,
            $IgnoreBuildStorage = $effectiveIgnoreBuildStorage,
            $DistancePenalty = $effectiveDistancePenalty,
            $FleetCoordination = $effectiveFleetCoordination,
            $IgnoreTradeRules = $effectiveIgnoreTradeRules
          ]"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT_Find_Trade signal SENT, now at game time ' + player.age" chance="100"/>
          </do_if>
        </do_else>
      </do_else>
      
      <!-- Wait for MD system response with interrupt -->
      <!-- Under large fleets, serialized batch matching can exceed 90s. Use 60s timeout to balance reliability with responsiveness. -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Entering wait state for MD response at game time ' + player.age" chance="100"/>
      </do_if>
      <!-- Clear previous no-trade reason (prevents stale reason affecting timeout retry logic) -->
      <set_value name="this.$lastNoTradeReason" exact="''"/>
      <label name="wait_for_response"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Wait interrupt handler ACTIVE at game time ' + player.age" chance="100"/>
      </do_if>
      <!-- IMPORTANT: In X4, wait without min is RANDOM (0..max). Use min=max to avoid instant timeouts. -->
      <wait min="60s" max="60s" comment="Wait for MD system response (60s; interrupted immediately on response)">
        <interrupt>
          <conditions>
            <check_any>
              <event_object_signalled object="this.ship" param="'GT_Trade_Found'"/>
              <event_object_signalled object="this.ship" param="'GT_No_Trade_Found'"/>
              <!-- Duplicate request while MD search lock is still held:
                   MD responds with a non-backoff "still working" or "reset" signal to prevent AI cooldown escalation under fleet load. -->
              <event_object_signalled object="this.ship" param="'GT_TradeSearch_InProgress'"/>
              <event_object_signalled object="this.ship" param="'GT_TradeSearch_Reset'"/>
              <!-- Destination threatened â†’ abort and restart main loop -->
              <event_object_signalled object="this.ship" param="'GT_Destination_Threatened'"/>
              <!-- Work unit processing - interrupt wait to process work unit immediately -->
              <event_object_signalled object="this.ship" param="'GT_ProcessWorkUnit'"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.param == 'GT_Trade_Found'">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: GT_Trade_Found received at game time ' + player.age" chance="100"/>
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade found by MD system - proceeding with execution'" chance="100"/>
              </do_if>
              <!-- Reset retry counter on successful trade -->
              <set_value name="this.$searchFailed" exact="0"/>
              
              <!-- Clear per-ship no-trade attempt history on success (prevents stale attempts from polluting later reports) -->
              <do_if value="global.$GT_NoTradeHistory? and global.$GT_NoTradeHistory.{this.ship}?">
                <remove_value name="global.$GT_NoTradeHistory.{this.ship}"/>
              </do_if>
              
              <!-- CARGO DISPOSAL: Reset cargo disposal failure counter on successful trade -->
              <do_if value="this.$cargoDisposalFailed?">
                <set_value name="this.$cargoDisposalFailed" exact="0"/>
              </do_if>
              
              <!-- Clear reroute flag (new destination found) -->
              <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$Rerouting?">
                <remove_value name="global.$GT_Ships.{this.ship}.$Rerouting"/>
                
                <!-- Trigger ship rename to remove [REROUTE] state -->
                <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
                  <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                    $ship=this.ship, 
                    $pilot=this.ship.pilot, 
                    $xp=global.$GT_Pilots.{this.ship.pilot}.$XP, 
                    $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                    $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                    $nameType='trader'
                  ]"/>
                </do_if>
              </do_if>
              
              <resume label="trade_found"/>
            </do_if>
            <do_elseif value="event.param == 'GT_TradeSearch_InProgress'">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: GT_TradeSearch_InProgress received at game time ' + player.age + ' - continuing to wait (no backoff)'" chance="100"/>
              </do_if>
              <resume label="wait_for_response"/>
            </do_elseif>
            <do_elseif value="event.param == 'GT_TradeSearch_Reset'">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: GT_TradeSearch_Reset received at game time ' + player.age + ' - retrying request immediately (no backoff)'" chance="100"/>
              </do_if>
              <resume label="main_loop"/>
            </do_elseif>
            <do_elseif value="event.param == 'GT_ProcessWorkUnit'">
              <!-- Work unit received while waiting - process it in main loop -->
              <set_value name="this.$workUnitPending" exact="true"/>
              <set_value name="this.$workUnitData" exact="event.param2"/>
              <set_value name="$workUnit" exact="event.param2"/>
              <set_value name="$workType" exact="if $workUnit? and $workUnit.$WorkType? then $workUnit.$WorkType else 'unknown'"/>
              <set_value name="$traceId" exact="if $workUnit? and $workUnit.$TraceId? then $workUnit.$TraceId else '0'"/>
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: GT_ProcessWorkUnit received while waiting - resuming to main_loop type=' + $workType + ' traceId=' + $traceId" chance="100"/>
              <resume label="main_loop"/>
            </do_elseif>
            <do_elseif value="event.param == 'GT_No_Trade_Found'">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: GT_No_Trade_Found received at game time ' + player.age" chance="100"/>
              </do_if>
              <!-- Capture reason (MD may pass param2='busy' for cache-search slots busy, etc.) -->
              <set_value name="this.$lastNoTradeReason" exact="if event.param2? and event.param2 != null then event.param2 else ''"/>
              
              <!-- ESCAPE FALLBACK:
                   If we are stuck in a blacklisted sector and got "no trade found", move toward home sector
                   (skipping blacklisted sectors along the route until we hit a non-blacklisted sector OR the home sector). -->
              <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
              <set_value name="$currentSector" exact="this.ship.sector"/>
              <set_value name="$needsEscape" exact="false"/>
              <do_if value="$currentSector? and $currentSector.exists">
                <set_value name="$curActivityBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$curTravelBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$needsEscape" exact="$curActivityBL or $curTravelBL"/>
              </do_if>
              <do_if value="$needsEscape">
                <!-- Set escape flag for ship naming -->
                <do_if value="global.$GT_Ships?">
                  <do_if value="not global.$GT_Ships.{this.ship}?">
                    <set_value name="global.$GT_Ships.{this.ship}" exact="table[]"/>
                  </do_if>
                  <set_value name="global.$GT_Ships.{this.ship}.$Escaping" exact="true"/>
                </do_if>
                <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
                  <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                    $ship=this.ship,
                    $pilot=this.ship.pilot,
                    $xp=global.$GT_Pilots.{this.ship.pilot}.$XP,
                    $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                    $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                    $nameType='trader'
                  ]"/>
                </do_if>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE FALLBACK: No trade found while in blacklisted sector (' + @$currentSector.knownname + ') - moving toward home sector'" chance="100"/>
                </do_if>
                <resume label="escape_from_blacklisted"/>
              </do_if>
              
              <!-- Check if this is a cargo disposal attempt -->
              <set_value name="$isCargoDisposal" exact="false"/>
              <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$CargoDisposal?">
                <set_value name="$isCargoDisposal" exact="true"/>
              </do_if>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': RECEIVED GT_No_Trade_Found signal - starting retry logic (cargo disposal: ' + $isCargoDisposal + ')'" chance="100"/>
              </do_if>
              <resume label="no_trade_retry"/>
            </do_elseif>
            <do_elseif value="event.param == 'GT_Destination_Threatened'">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': INTERRUPT FIRED: Destination threatened - aborting current trade'" chance="100"/>
              
              <!-- Set reroute flag for ship name -->
              <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}?">
                <set_value name="global.$GT_Ships.{this.ship}.$Rerouting" exact="true"/>
              </do_if>
              
              <!-- Trigger ship rename to show [REROUTE] state -->
              <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
                <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                  $ship=this.ship, 
                  $pilot=this.ship.pilot, 
                  $xp=global.$GT_Pilots.{this.ship.pilot}.$XP, 
                  $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                  $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                  $nameType='trader'
                ]"/>
              </do_if>
              
              <!-- Player logbook notification about route threat -->
              <do_if value="$gt_logbookentries">
                <set_value name="$threatData" exact="event.param2"/>
                <set_value name="$threatenedSector" exact="@$threatData.$Sector"/>
                <set_value name="$threatLevel" exact="@$threatData.$ThreatLevel"/>
                <set_value name="$hasCargo" exact="this.ship.cargo.free.all lt this.ship.cargo.capacity.all"/>
                
                <!-- Construct logbook message using TextDB syntax (vanilla pattern) -->
                <set_value name="$logbookMessage" exact="{77000,3209}.[@$threatenedSector.knownname, $threatLevel, this.ship.knownname]"/>
                
                <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
                  $Message = $logbookMessage,
                  $Category = 'alerts',
                  $Title = 'Route Threat Detected: ' + this.ship.knownname,
                  $Object = this.ship,
                  $Interaction = 'showonmap',
                  $Highlighted = true,
                  $CheckGlobalSettings = false
                ]"/>
              </do_if>
              
              <!-- Abort current trade, go back to main loop -->
              <!-- Cargo check will detect cargo and send GT_Find_Sell automatically -->
              <cancel_all_orders object="this.ship"/>
              <resume label="main_loop"/>
            </do_elseif>
          </actions>
        </interrupt>
      </wait>
      
      <!-- Timeout fallback - treat as no trade found -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': TIMEOUT: MD system response timeout at game time ' + player.age + ' - assuming no trades'" chance="100"/>
      </do_if>
      <resume label="no_trade_retry"/>
      
      <!-- ========================================= -->
      <!-- TRADE FOUND - VALIDATE BLACKLIST FIRST   -->
      <!-- ========================================= -->
      <label name="trade_found"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': REACHED trade_found label - starting blacklist validation at game time ' + player.age" chance="100"/>
      </do_if>
      
      <!-- FAST MONEY CHECK: Short-circuit the expensive 20-trade validation loop when player
           money has dropped below the threshold since this ship's search started.
           Checks static threshold (MinPlayerMoney + 1000 buffer) OR global money cap. -->
      <set_value name="$fastMoneyThreshold" exact="(this.$minPlayerMoney + 1000)Cr"/>
      <do_if value="player.money le $fastMoneyThreshold or (global.$GT_MoneyCapActive? and global.$GT_MoneyCapActive and player.money le global.$GT_MoneyCapMoney)">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FAST MONEY CHECK at trade_found: player.money=' + (player.money / 100) + ' Cr, threshold=' + (this.$minPlayerMoney + 1000) + ' Cr, globalCap=' + (if global.$GT_MoneyCapActive? and global.$GT_MoneyCapActive then (global.$GT_MoneyCapMoney / 100) else 'off') + ' - skipping validation, backing off'" chance="100"/>
        </do_if>
        <set_value name="this.$lastNoTradeReason" exact="'insufficient_funds'"/>
        <resume label="no_trade_retry"/>
      </do_if>
      
      <!-- Initialize validation variables BEFORE do_if block to ensure they always exist -->
      <set_value name="$validTradeFound" exact="false"/>
      <set_value name="$pendingTrade" exact="null"/>
      <set_value name="$buyStation" exact="null"/>
      <set_value name="$sellStation" exact="null"/>
      <set_value name="$tradesChecked" exact="0"/>
      <set_value name="$tradesBlacklisted" exact="0"/>
      <set_value name="$tradesRejectedDocking" exact="0"/>
      <set_value name="$tradesRejectedOfferInvalid" exact="0"/>
      <set_value name="$tradesRejectedPath" exact="0"/>
      <set_value name="$tradesRejectedDistance" exact="0"/>
      <set_value name="$tradesRejectedCargo" exact="0"/>
      <set_value name="$tradesRejectedProfit" exact="0"/>
      
      <!-- Iterate through trade list and validate each one -->
      <!-- Priority order: Signal param2 (from cache search work unit or live search) > Global storage (for threat intelligence compatibility) -->
      <!-- Cache search work units filter entries and signal results via GT_Trade_Found with param2 -->
      <!-- Initialize $tradeList and $searchMethod to prevent property lookup failures -->
      <set_value name="$tradeList" exact="[]"/>
      <set_value name="$searchMethod" exact="''"/>

      <!-- Priority 1: Use trade list from signal param2 (from cache search work unit or live search) -->
      <do_if value="this.$tradeListFromSignal? and this.$tradeListFromSignal.count gt 0">
        <set_value name="$tradeList" exact="this.$tradeListFromSignal"/>
        <set_value name="$searchMethod" exact="if this.$searchMethodFromSignal? then this.$searchMethodFromSignal else ''"/>
        <!-- Clear instance variables after use -->
        <remove_value name="this.$tradeListFromSignal"/>
        <remove_value name="this.$searchMethodFromSignal"/>
      </do_if>
      <do_else>
        <!-- Priority 2: Fallback to global storage (for threat intelligence compatibility) -->
        <do_if value="global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
          <set_value name="$tradeList" exact="global.$GT_TradesAwaitingValidation.{this.ship}"/>
          <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
            <set_value name="$searchMethod" exact="@global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
          </do_if>
        </do_if>
      </do_else>

      <!-- Ensure it's a list -->
      <do_if value="typeof $tradeList != datatype.list">
        <!-- Backward compat: single trade stored as table -->
        <set_value name="$tradeList" exact="[$tradeList]"/>
      </do_if>
      
      <!-- Use safe access for debug text -->
      <set_value name="$tradeListCountForDebug" exact="if $tradeList != null then $tradeList.count else 0"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Received ' + $tradeListCountForDebug + ' trades to validate (source: ' + (if $searchMethod == 'cache' then 'CACHE' else if $searchMethod == 'live' then 'LIVE' else if $searchMethod != '' then $searchMethod else 'UNKNOWN') + ')'" chance="100"/>
      </do_if>
      
      <!-- Cap extra cache-detail logs to avoid spam -->
      <set_value name="$cacheDetailLogMax" exact="8"/>
      <set_value name="$cacheDetailLogCount" exact="0"/>
      
      <!-- gatedistance memoization: cache results per (fromSector, toSector) to avoid
           redundant C++ pathfinding calls when multiple trades share the same sectors.
           Separate tables for non-blacklist vs blacklist-aware variants.
           Valid for the duration of this validation loop (ship doesn't move). -->
      <set_value name="$gdCache" exact="table[]"/>
      <set_value name="$gdCacheBL" exact="table[]"/>
      
      <!-- Iterate through trade list -->
      <!-- Check if tradeList exists and has items before looping -->
      <do_if value="(if $tradeList != null then $tradeList.count else 0) gt 0">
        <do_all exact="$tradeList.count" counter="$tradeIdx">
          <set_value name="$currentTrade" exact="$tradeList.{$tradeIdx}"/>
          <set_value name="$tradesChecked" operation="add"/>
          
          <!-- Cooperative multitasking: yield CPU between trade validations -->
          <!-- Use global Performance.ValidationDelay setting (default: 50ms) -->
          <!-- Ensure validationDelay is never null -->
          <set_value name="$validationDelay" exact="50"/>
          <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$ValidationDelay?">
            <set_value name="$tempDelay" exact="@global.$GT_GlobalSettings.$Performance.$ValidationDelay"/>
            <!-- Only use if tempDelay is not null and is a valid number -->
            <do_if value="$tempDelay? and $tempDelay != null and $tempDelay gt 0">
              <set_value name="$validationDelay" exact="$tempDelay"/>
            </do_if>
          </do_if>
          <!-- Convert to time value (milliseconds) - ensure result is never null -->
          <!-- Add small jitter to desynchronize many ships validating in parallel (reduces frame spikes). -->
          <set_value name="$validationDelayJitter" min="0" max="20"/>
          <set_value name="$validationDelayTime" exact="($validationDelay + $validationDelayJitter) * 1ms"/>
          <!-- Fallback to 50ms if validationDelayTime is null -->
          <do_if value="not $validationDelayTime? or $validationDelayTime == null">
            <set_value name="$validationDelayTime" exact="50ms"/>
          </do_if>
          <!-- CRITICAL: wait must be at top level of loop, NOT inside conditionals -->
          <wait exact="$validationDelayTime"/>
          
          <!-- Check if currentTrade is valid before processing -->
          <do_if value="$currentTrade? and $currentTrade != null">
              <!-- Extract stations from trade (handle both new list format and old single-trade format) -->
              <!-- Initialize stations to null first, then extract -->
              <set_value name="$buyStation" exact="null"/>
              <set_value name="$sellStation" exact="null"/>
              
              <!-- Check if this is a sell-only trade first -->
              <set_value name="$isSellOnlyTrade" exact="false"/>
              <do_if value="$currentTrade.$IsSellOnly? and $currentTrade.$IsSellOnly">
                <set_value name="$isSellOnlyTrade" exact="true"/>
              </do_if>
              
              <!-- Extract buy station (may be null for sell-only trades) -->
              <do_if value="$currentTrade.$BuyStation?">
                <set_value name="$buyStation" exact="$currentTrade.$BuyStation"/>
              </do_if>
              <do_else>
                <do_if value="$currentTrade.$BuyOffer?">
                  <set_value name="$buyStation" exact="@$currentTrade.$BuyOffer.owner"/>
                </do_if>
              </do_else>
              
              <!-- Extract sell station (always required) -->
              <do_if value="$currentTrade.$SellStation?">
                <set_value name="$sellStation" exact="$currentTrade.$SellStation"/>
              </do_if>
              <do_else>
                <do_if value="$currentTrade.$SellOffer?">
                  <set_value name="$sellStation" exact="@$currentTrade.$SellOffer.owner"/>
                </do_if>
              </do_else>
              
              <!-- For sell-only trades, only require sellStation; for normal trades, require both -->
              <do_if value="$isSellOnlyTrade">
                <!-- Sell-only trade: only sellStation required -->
                <do_if value="$sellStation? and $sellStation != null">
                  <!-- Use safe access for tradeIdx in debug text -->
                  <set_value name="$tradeIdxSafe" exact="if $tradeIdx? then $tradeIdx else 0"/>
                  <set_value name="$tradeListCountSafe" exact="if $tradeList != null then $tradeList.count else 0"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Validating SELL-ONLY trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ': ' + (if $currentTrade.$Ware? then @$currentTrade.$Ware.name else 'Unknown') + ' (Ship cargo â†’ ' + (if $sellStation? then @$sellStation.knownname else 'Unknown') + ')'" chance="100"/>
                  </do_if>
                  
                  <!-- Check docking permissions FIRST (most common failure, cheapest check) -->
                  <!-- Skip buy-station checks for sell-only trades (ship already has cargo) -->
                  <!-- Also check if BuyStation is not a station (could be ship for sell-only trades) -->
                  <set_value name="$buyStationIsStation" exact="false"/>
                  <do_if value="$buyStation?">
                    <set_value name="$buyStationIsStation" exact="@$buyStation.isclass.station"/>
                  </do_if>
                  
                  <!-- Only check buy-station docking if it's NOT a sell-only trade (always true for sell-only) -->
                  <set_value name="$canDockAtBuyStation" exact="true"/>
                  
                  <!-- Always check sell-station docking -->
                  <set_value name="$canDockAtSellStation" exact="@$sellStation.dockingallowed.{this.assignedcontrolled}"/>
        
                <do_if value="not $canDockAtBuyStation or not $canDockAtSellStation">
                  <!-- DOCKING NOT ALLOWED - Skip to next trade -->
                  <set_value name="$tradesRejectedDocking" operation="add"/>
                  <set_value name="$deniedStation" exact="if not $canDockAtBuyStation then $buyStation else $sellStation"/>
                  <set_value name="$deniedType" exact="if not $canDockAtBuyStation then 'BUY' else 'SELL'"/>
                  
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' DOCKING DENIED:' +
                      '\n  Station: ' + @$deniedStation.knownname + 
                      '\n  Sector: ' + @$deniedStation.sector.knownname + 
                      '\n  Type: ' + $deniedType + 
                      '\n  Reason: Docking not allowed (reputation, war, or permissions)' + 
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>

                    <!-- Extra cache-only detail (capped): log raw docking flags + dockbay match test -->
                    <do_if value="$searchMethod == 'cache' and $cacheDetailLogCount lt $cacheDetailLogMax">
                      <set_value name="$cacheDetailLogCount" operation="add"/>
                      <set_value name="$dockAllowedBuyText" exact="if $canDockAtBuyStation? then $canDockAtBuyStation else 'null'"/>
                      <set_value name="$dockAllowedSellText" exact="if $canDockAtSellStation? then $canDockAtSellStation else 'null'"/>
                      <set_value name="$sellOfferId" exact="null"/>
                      <do_if value="$currentTrade.$SellOffer?">
                        <set_value name="$sellOfferId" exact="@$currentTrade.$SellOffer.id"/>
                      </do_if>
                      <find_dockingbay name="$cacheDeniedDock" object="$deniedStation" checkoperational="true" multiple="false">
                        <match_dock size="this.ship.docksize" trading="true" storage="false"/>
                        <match_relation_to object="this.ship" comparison="not" relation="enemy"/>
                      </find_dockingbay>
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': [CACHE-DETAIL] DockingDenied trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe +
                        '\n  DeniedType: ' + $deniedType +
                        '\n  DockingAllowed BUY=' + $dockAllowedBuyText + ' SELL=' + $dockAllowedSellText +
                        '\n  ShipDocksize: ' + this.ship.docksize +
                        '\n  SellOfferId: ' + (if $sellOfferId? and $sellOfferId != null then $sellOfferId else 'null') +
                        '\n  find_dockingbay(trading+not-enemy): ' + (if $cacheDeniedDock then 'FOUND' else 'NONE')"
                        chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <!-- Continue to next trade in list -->
                  <continue/>
                </do_if>
                
                <!-- Use cached blacklistgroup from init -->
                <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
                
                <!-- Check path reachability BEFORE blacklist (faster to fail on unreachable) -->
                <!-- For sell-only trades, skip buy-station pathfinding (ship already has cargo) -->
                <set_value name="$currentSector" exact="this.ship.sector"/>
                <!-- For sell-only trades, buySector is current sector (ship already has cargo) -->
                <set_value name="$buySector" exact="$currentSector"/>
                <do_if value="not $isSellOnlyTrade and $buyStation?">
                  <set_value name="$buySector" exact="$buyStation.sector"/>
                </do_if>
                <set_value name="$sellSector" exact="$sellStation.sector"/>
                
                <!-- Check if ship is in a blacklisted sector (needed for escape path calculation) -->
                <set_value name="$currentSectorIsBlacklisted" exact="false"/>
                <do_if value="$blacklistgroup?">
                  <set_value name="$currentSectorActivityBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                  <set_value name="$currentSectorTravelBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                  <set_value name="$currentSectorIsBlacklisted" exact="$currentSectorActivityBlacklisted or $currentSectorTravelBlacklisted"/>
                </do_if>
        
        <!-- Calculate path distances with escape support -->
        <!-- Buy path calculation with escape support -->
        <!-- For sell-only trades, buy distance is always 0 (ship already has cargo, no buy travel needed) -->
        <set_value name="$buyDistance" exact="-1"/>
        <do_if value="$isSellOnlyTrade">
          <set_value name="$buyDistance" exact="0"/>
        </do_if>
        <do_elseif value="$buySector == $currentSector">
          <set_value name="$buyDistance" exact="0"/>
        </do_elseif>
        <do_elseif value="$currentSectorIsBlacklisted">
          <!-- Escape: non-blacklist gatedistance (memoized) -->
          <do_if value="$gdCache.{$currentSector}? and $gdCache.{$currentSector}.{$buySector}?">
            <set_value name="$buyDistance" exact="$gdCache.{$currentSector}.{$buySector}"/>
          </do_if>
          <do_else>
            <set_value name="$buyDistance" exact="this.ship.gatedistance.{$buySector}"/>
            <do_if value="not $gdCache.{$currentSector}?"><set_value name="$gdCache.{$currentSector}" exact="table[]"/></do_if>
            <set_value name="$gdCache.{$currentSector}.{$buySector}" exact="$buyDistance"/>
          </do_else>
        </do_elseif>
        <do_else>
          <!-- Normal: blacklist-aware gatedistance (memoized) -->
          <do_if value="$gdCacheBL.{$currentSector}? and $gdCacheBL.{$currentSector}.{$buySector}?">
            <set_value name="$buyDistance" exact="$gdCacheBL.{$currentSector}.{$buySector}"/>
          </do_if>
          <do_else>
            <set_value name="$buyDistance" exact="this.ship.gatedistance.{$buySector}.{$blacklistgroup}.{this.ship}"/>
            <do_if value="not $gdCacheBL.{$currentSector}?"><set_value name="$gdCacheBL.{$currentSector}" exact="table[]"/></do_if>
            <set_value name="$gdCacheBL.{$currentSector}.{$buySector}" exact="$buyDistance"/>
          </do_else>
        </do_else>
        
        <!-- Sell path: Calculate based on buy location -->
        <set_value name="$sellDistance" exact="-1"/>
        <do_if value="$sellSector == $buySector">
          <set_value name="$sellDistance" exact="0"/>
        </do_if>
        <do_elseif value="$buySector == $currentSector">
          <!-- Ship in buy sector: escape vs normal path to sell sector -->
          <do_if value="$currentSectorIsBlacklisted">
            <!-- Escape: non-blacklist gatedistance (memoized) -->
            <do_if value="$gdCache.{$currentSector}? and $gdCache.{$currentSector}.{$sellSector}?">
              <set_value name="$sellDistance" exact="$gdCache.{$currentSector}.{$sellSector}"/>
            </do_if>
            <do_else>
              <set_value name="$sellDistance" exact="this.ship.gatedistance.{$sellSector}"/>
              <do_if value="not $gdCache.{$currentSector}?"><set_value name="$gdCache.{$currentSector}" exact="table[]"/></do_if>
              <set_value name="$gdCache.{$currentSector}.{$sellSector}" exact="$sellDistance"/>
            </do_else>
          </do_if>
          <do_else>
            <!-- Normal: blacklist-aware gatedistance (memoized) -->
            <do_if value="$gdCacheBL.{$currentSector}? and $gdCacheBL.{$currentSector}.{$sellSector}?">
              <set_value name="$sellDistance" exact="$gdCacheBL.{$currentSector}.{$sellSector}"/>
            </do_if>
            <do_else>
              <set_value name="$sellDistance" exact="this.ship.gatedistance.{$sellSector}.{$blacklistgroup}.{this.ship}"/>
              <do_if value="not $gdCacheBL.{$currentSector}?"><set_value name="$gdCacheBL.{$currentSector}" exact="table[]"/></do_if>
              <set_value name="$gdCacheBL.{$currentSector}.{$sellSector}" exact="$sellDistance"/>
            </do_else>
          </do_else>
        </do_elseif>
        <do_else>
          <!-- Normal: buyâ†’sell blacklist-aware gatedistance (memoized) -->
          <do_if value="$gdCacheBL.{$buySector}? and $gdCacheBL.{$buySector}.{$sellSector}?">
            <set_value name="$sellDistance" exact="$gdCacheBL.{$buySector}.{$sellSector}"/>
          </do_if>
          <do_else>
            <set_value name="$sellDistance" exact="$buySector.gatedistance.{$sellSector}.{$blacklistgroup}.{this.ship}"/>
            <do_if value="not $gdCacheBL.{$buySector}?"><set_value name="$gdCacheBL.{$buySector}" exact="table[]"/></do_if>
            <set_value name="$gdCacheBL.{$buySector}.{$sellSector}" exact="$sellDistance"/>
          </do_else>
        </do_else>
        
        <!-- Always log distance check to diagnose issues -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$buyStationNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.knownname else 'Unknown')"/>
          <set_value name="$buySectorNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.sector.knownname else 'Unknown')"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': PATH check (blacklist-aware):' +
            '\n  Current sector: ' + @$currentSector.knownname +
            '\n  BUY: ' + $buyStationNameForDebug + ' (Sector: ' + $buySectorNameForDebug + ', Distance: ' + $buyDistance + ')' +
            '\n  SELL: ' + @$sellStation.knownname + ' (Sector: ' + @$sellStation.sector.knownname + ', Distance: ' + $sellDistance + ')' +
            '\n  Blacklist group: ' + $blacklistgroup +
            '\n  Result: ' + (if ($buyDistance lt 0 and not $isSellOnlyTrade) or $sellDistance lt 0 then 'BLOCKED' else 'OK')" 
            chance="100"/>
        </do_if>
        
        <!-- For sell-only trades, only check sell path (buy path is always 0) -->
        <set_value name="$pathBlocked" exact="false"/>
        <do_if value="not $isSellOnlyTrade">
          <do_if value="$buyDistance lt 0">
            <set_value name="$pathBlocked" exact="true"/>
          </do_if>
        </do_if>
        <do_if value="$sellDistance lt 0">
          <set_value name="$pathBlocked" exact="true"/>
        </do_if>
        
        <do_if value="$pathBlocked">
          <!-- PATH BLOCKED - Skip to next trade -->
          <set_value name="$tradesRejectedPath" operation="add"/>
          <set_value name="$unreachableStation" exact="if ($buyDistance lt 0 and not $isSellOnlyTrade) then $buyStation else $sellStation"/>
          <set_value name="$unreachableType" exact="if ($buyDistance lt 0 and not $isSellOnlyTrade) then 'BUY' else 'SELL'"/>
          
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ':   Trade ' + $tradeIdx + '/' + (if $tradeList != null then $tradeList.count else 0) + ' PATH BLOCKED:' +
              '\n  Station: ' + @$unreachableStation.knownname + 
              '\n  Type: ' + $unreachableType + 
              '\n  Reason: No path exists (disconnected sectors, war, or gates destroyed)' + 
              '\n  â†’ Trying next trade in list...'" 
              chance="100"/>
          </do_if>
          
          <!-- Continue to next trade in list -->
          <continue/>
        </do_if>
              </do_if>
              <do_else>
                <!-- Sell-only trade missing sellStation - skip this trade -->
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade ' + (if $tradeIdx? then $tradeIdx else 0) + ' MISSING SELL STATION (sell-only trade requires sellStation)'" chance="100"/>
                <continue/>
              </do_else>
            </do_if>
            <do_else>
                <!-- Normal trade: require both buyStation and sellStation -->
                <do_if value="$buyStation? and $buyStation != null and $sellStation? and $sellStation != null">
                  <!-- Normal trade validation continues here - same as before but with buy checks -->
                  <!-- Use safe access for tradeIdx in debug text -->
                  <set_value name="$tradeIdxSafe" exact="if $tradeIdx? then $tradeIdx else 0"/>
                  <set_value name="$tradeListCountSafe" exact="if $tradeList != null then $tradeList.count else 0"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Validating trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ': ' + (if $currentTrade.$BuyOffer? then @$currentTrade.$BuyOffer.ware.name else 'Unknown') + ' (' + (if $buyStation? then @$buyStation.knownname else 'Unknown') + ' â†’ ' + (if $sellStation? then @$sellStation.knownname else 'Unknown') + ')'" chance="100"/>
                  </do_if>
                  
                  <!-- Check docking permissions FIRST (most common failure, cheapest check) -->
                  <set_value name="$canDockAtBuyStation" exact="@$buyStation.dockingallowed.{this.assignedcontrolled}"/>
                  <set_value name="$canDockAtSellStation" exact="@$sellStation.dockingallowed.{this.assignedcontrolled}"/>
                  
                  <do_if value="not $canDockAtBuyStation or not $canDockAtSellStation">
                    <!-- DOCKING NOT ALLOWED - Skip to next trade -->
                    <set_value name="$tradesRejectedDocking" operation="add"/>
                    <set_value name="$deniedStation" exact="if not $canDockAtBuyStation then $buyStation else $sellStation"/>
                    <set_value name="$deniedType" exact="if not $canDockAtBuyStation then 'BUY' else 'SELL'"/>
                    
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' DOCKING DENIED:' +
                      '\n  Station: ' + @$deniedStation.knownname + 
                      '\n  Sector: ' + @$deniedStation.sector.knownname + 
                      '\n  Type: ' + $deniedType + 
                      '\n  Reason: Docking not allowed (reputation, war, or permissions)' + 
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>

                    <!-- Extra cache-only detail (capped): log raw docking flags + dockbay match test -->
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $searchMethod == 'cache' and $cacheDetailLogCount lt $cacheDetailLogMax">
                      <set_value name="$cacheDetailLogCount" operation="add"/>
                      <set_value name="$dockAllowedBuyText" exact="if $canDockAtBuyStation? then $canDockAtBuyStation else 'null'"/>
                      <set_value name="$dockAllowedSellText" exact="if $canDockAtSellStation? then $canDockAtSellStation else 'null'"/>
                      <set_value name="$buyOfferId" exact="null"/>
                      <set_value name="$sellOfferId" exact="null"/>
                      <do_if value="$currentTrade.$BuyOffer?">
                        <set_value name="$buyOfferId" exact="@$currentTrade.$BuyOffer.id"/>
                      </do_if>
                      <do_if value="$currentTrade.$SellOffer?">
                        <set_value name="$sellOfferId" exact="@$currentTrade.$SellOffer.id"/>
                      </do_if>
                      <find_dockingbay name="$cacheDeniedDock" object="$deniedStation" checkoperational="true" multiple="false">
                        <match_dock size="this.ship.docksize" trading="true" storage="false"/>
                        <match_relation_to object="this.ship" comparison="not" relation="enemy"/>
                      </find_dockingbay>
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': [CACHE-DETAIL] DockingDenied trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe +
                        '\n  DeniedType: ' + $deniedType +
                        '\n  DockingAllowed BUY=' + $dockAllowedBuyText + ' SELL=' + $dockAllowedSellText +
                        '\n  ShipDocksize: ' + this.ship.docksize +
                        '\n  BuyOfferId: ' + (if $buyOfferId? and $buyOfferId != null then $buyOfferId else 'null') +
                        '\n  SellOfferId: ' + (if $sellOfferId? and $sellOfferId != null then $sellOfferId else 'null') +
                        '\n  find_dockingbay(trading+not-enemy): ' + (if $cacheDeniedDock then 'FOUND' else 'NONE')"
                        chance="100"/>
                    </do_if>
                    
                    <!-- Continue to next trade in list -->
                    <continue/>
                  </do_if>
                  
                  <!-- Use cached blacklistgroup from init -->
                  <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
                  
                  <!-- Check path reachability BEFORE blacklist (faster to fail on unreachable) -->
                  <set_value name="$currentSector" exact="this.ship.sector"/>
                  <set_value name="$buySector" exact="$buyStation.sector"/>
                  <set_value name="$sellSector" exact="$sellStation.sector"/>
                  
                  <!-- Check if ship is in a blacklisted sector (needed for escape path calculation) -->
                  <set_value name="$currentSectorIsBlacklisted" exact="false"/>
                  <do_if value="$blacklistgroup?">
                    <set_value name="$currentSectorActivityBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                    <set_value name="$currentSectorTravelBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                    <set_value name="$currentSectorIsBlacklisted" exact="$currentSectorActivityBlacklisted or $currentSectorTravelBlacklisted"/>
                  </do_if>
                  
                  <!-- Calculate path distances with escape support -->
                  <!-- Buy path calculation with escape support -->
                  <!-- Buy path: If ship is already in buy sector, distance is 0 (no travel needed) -->
                  <set_value name="$buyDistance" exact="-1"/>
                  <do_if value="$buySector == $currentSector">
                    <set_value name="$buyDistance" exact="0"/>
                  </do_if>
                  <do_elseif value="$currentSectorIsBlacklisted">
                    <!-- Escape: non-blacklist gatedistance (memoized) -->
                    <do_if value="$gdCache.{$currentSector}? and $gdCache.{$currentSector}.{$buySector}?">
                      <set_value name="$buyDistance" exact="$gdCache.{$currentSector}.{$buySector}"/>
                    </do_if>
                    <do_else>
                      <set_value name="$buyDistance" exact="this.ship.gatedistance.{$buySector}"/>
                      <do_if value="not $gdCache.{$currentSector}?"><set_value name="$gdCache.{$currentSector}" exact="table[]"/></do_if>
                      <set_value name="$gdCache.{$currentSector}.{$buySector}" exact="$buyDistance"/>
                    </do_else>
                  </do_elseif>
                  <do_else>
                    <!-- Normal: blacklist-aware gatedistance (memoized) -->
                    <do_if value="$gdCacheBL.{$currentSector}? and $gdCacheBL.{$currentSector}.{$buySector}?">
                      <set_value name="$buyDistance" exact="$gdCacheBL.{$currentSector}.{$buySector}"/>
                    </do_if>
                    <do_else>
                      <set_value name="$buyDistance" exact="this.ship.gatedistance.{$buySector}.{$blacklistgroup}.{this.ship}"/>
                      <do_if value="not $gdCacheBL.{$currentSector}?"><set_value name="$gdCacheBL.{$currentSector}" exact="table[]"/></do_if>
                      <set_value name="$gdCacheBL.{$currentSector}.{$buySector}" exact="$buyDistance"/>
                    </do_else>
                  </do_else>
                  
                  <!-- Sell path: Calculate based on buy location -->
                  <set_value name="$sellDistance" exact="-1"/>
                  <do_if value="$sellSector == $buySector">
                    <set_value name="$sellDistance" exact="0"/>
                  </do_if>
                  <do_elseif value="$buySector == $currentSector">
                    <!-- Ship in buy sector: escape vs normal path to sell sector -->
                    <do_if value="$currentSectorIsBlacklisted">
                      <!-- Escape: non-blacklist gatedistance (memoized) -->
                      <do_if value="$gdCache.{$currentSector}? and $gdCache.{$currentSector}.{$sellSector}?">
                        <set_value name="$sellDistance" exact="$gdCache.{$currentSector}.{$sellSector}"/>
                      </do_if>
                      <do_else>
                        <set_value name="$sellDistance" exact="this.ship.gatedistance.{$sellSector}"/>
                        <do_if value="not $gdCache.{$currentSector}?"><set_value name="$gdCache.{$currentSector}" exact="table[]"/></do_if>
                        <set_value name="$gdCache.{$currentSector}.{$sellSector}" exact="$sellDistance"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <!-- Normal: blacklist-aware gatedistance (memoized) -->
                      <do_if value="$gdCacheBL.{$currentSector}? and $gdCacheBL.{$currentSector}.{$sellSector}?">
                        <set_value name="$sellDistance" exact="$gdCacheBL.{$currentSector}.{$sellSector}"/>
                      </do_if>
                      <do_else>
                        <set_value name="$sellDistance" exact="this.ship.gatedistance.{$sellSector}.{$blacklistgroup}.{this.ship}"/>
                        <do_if value="not $gdCacheBL.{$currentSector}?"><set_value name="$gdCacheBL.{$currentSector}" exact="table[]"/></do_if>
                        <set_value name="$gdCacheBL.{$currentSector}.{$sellSector}" exact="$sellDistance"/>
                      </do_else>
                    </do_else>
                  </do_elseif>
                  <do_else>
                    <!-- Normal: buyâ†’sell blacklist-aware gatedistance (memoized) -->
                    <do_if value="$gdCacheBL.{$buySector}? and $gdCacheBL.{$buySector}.{$sellSector}?">
                      <set_value name="$sellDistance" exact="$gdCacheBL.{$buySector}.{$sellSector}"/>
                    </do_if>
                    <do_else>
                      <set_value name="$sellDistance" exact="$buySector.gatedistance.{$sellSector}.{$blacklistgroup}.{this.ship}"/>
                      <do_if value="not $gdCacheBL.{$buySector}?"><set_value name="$gdCacheBL.{$buySector}" exact="table[]"/></do_if>
                      <set_value name="$gdCacheBL.{$buySector}.{$sellSector}" exact="$sellDistance"/>
                    </do_else>
                  </do_else>
                  
                  <!-- Always log distance check to diagnose issues -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': PATH check (blacklist-aware):' +
                      '\n  Current sector: ' + @$currentSector.knownname +
                      '\n  BUY: ' + @$buyStation.knownname + ' (Sector: ' + @$buyStation.sector.knownname + ', Distance: ' + $buyDistance + ')' +
                      '\n  SELL: ' + @$sellStation.knownname + ' (Sector: ' + @$sellStation.sector.knownname + ', Distance: ' + $sellDistance + ')' +
                      '\n  Blacklist group: ' + $blacklistgroup +
                      '\n  Result: ' + (if $buyDistance lt 0 or $sellDistance lt 0 then 'BLOCKED' else 'OK')" 
                      chance="100"/>
                  </do_if>
                  
                  <do_if value="$buyDistance lt 0 or $sellDistance lt 0">
                    <!-- PATH BLOCKED - Skip to next trade -->
                    <set_value name="$tradesRejectedPath" operation="add"/>
                    <set_value name="$unreachableStation" exact="if $buyDistance lt 0 then $buyStation else $sellStation"/>
                    <set_value name="$unreachableType" exact="if $buyDistance lt 0 then 'BUY' else 'SELL'"/>
                    
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ':   Trade ' + $tradeIdx + '/' + (if $tradeList != null then $tradeList.count else 0) + ' PATH BLOCKED:' +
                        '\n  Station: ' + @$unreachableStation.knownname + 
                        '\n  Type: ' + $unreachableType + 
                        '\n  Reason: No path exists (disconnected sectors, war, or gates destroyed)' + 
                        '\n  â†’ Trying next trade in list...'" 
                        chance="100"/>
                    </do_if>
                    
                    <!-- Continue to next trade in list -->
                    <continue/>
                  </do_if>
                </do_if>
                <do_else>
                  <!-- Normal trade missing stations - skip this trade -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade ' + (if $tradeIdx? then $tradeIdx else 0) + ' MISSING STATIONS (normal trade requires both buy and sell stations)'" chance="100"/>
                  </do_if>
                  <continue/>
                </do_else>
              </do_else>
              
              <!-- Both sell-only and normal trades continue here (only if they passed initial checks) -->
              <!-- Validate distance from HOME SECTOR (not ship position) -->
              <!-- Subordinates ALWAYS use commander's home sector (via $effectiveHome) -->
              <!-- For non-subordinates: Always use defaultorder.$home as PRIMARY source (fixed value in order) -->
              <!-- Home sector is a fixed value in the order settings and should NEVER drift -->
              <!-- Ships must only trade with stations within maxbuy/maxsell from home sector -->
              <!-- Note: $effectiveHome already handles subordinates correctly (set at initialization) -->
              <set_value name="$homeBase" exact="this.$effectiveHome"/>
              
              <!-- Fallback: Only if effectiveHome is not available, check defaultorder.$home -->
              <do_if value="not $homeBase? or not $homeBase.exists">
                <set_value name="$homeBase" exact="@this.ship.defaultorder.$home"/>
                <do_if value="not $homeBase? or not $homeBase.exists">
                  <!-- REMOVED: Never fall back to ship.sector (causes cascading drift) -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI-ERROR] Home sector not found for ' + this.ship.idcode + ' - effectiveHome and defaultorder.$home are null! This should never happen.'" chance="100"/>
                  </do_if>
                  <!-- Emergency fallback only - this should never happen -->
                  <set_value name="$homeBase" exact="this.ship.sector"/>
                </do_if>
              </do_if>
              
              <!-- Extract home sector -->
              <set_value name="$homeSector" exact="null"/>
              <do_if value="@$homeBase.exists">
                <do_if value="$homeBase.isclass.station">
                  <set_value name="$homeSector" exact="$homeBase.sector"/>
                </do_if>
                <do_elseif value="$homeBase.isclass.sector">
                  <set_value name="$homeSector" exact="$homeBase"/>
                </do_elseif>
              </do_if>
              
              <do_if value="not $homeSector? or not $homeSector.exists">
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI-ERROR] Failed to extract home sector from homeBase for ' + this.ship.idcode + ' - using ship.sector as emergency fallback (THIS WILL CAUSE DRIFT!)'" chance="100"/>
                </do_if>
                <!-- Emergency fallback only - this should never happen -->
                <set_value name="$homeSector" exact="this.ship.sector"/>
              </do_if>
              
              <!-- Calculate distance from HOME SECTOR to stations (range-only, no blacklist) -->
              <!-- For sell-only trades, skip buy distance check (no buy station) -->
              <set_value name="$buyDistanceFromHome" exact="0"/>
              <set_value name="$sellDistanceFromHome" exact="-1"/>
              
              <do_if value="not $isSellOnlyTrade">
                <!-- Normal trade: check buy distance from home (memoized) -->
                <set_value name="$buyDistanceFromHome" exact="-1"/>
                <do_if value="$buySector == $homeSector">
                  <set_value name="$buyDistanceFromHome" exact="0"/>
                </do_if>
                <do_else>
                  <do_if value="$gdCache.{$homeSector}? and $gdCache.{$homeSector}.{$buySector}?">
                    <set_value name="$buyDistanceFromHome" exact="$gdCache.{$homeSector}.{$buySector}"/>
                  </do_if>
                  <do_else>
                    <set_value name="$buyDistanceFromHome" exact="$homeSector.gatedistance.{$buySector}"/>
                    <do_if value="not $gdCache.{$homeSector}?"><set_value name="$gdCache.{$homeSector}" exact="table[]"/></do_if>
                    <set_value name="$gdCache.{$homeSector}.{$buySector}" exact="$buyDistanceFromHome"/>
                  </do_else>
                </do_else>
              </do_if>
              
              <!-- Always check sell distance from home (memoized) -->
              <do_if value="$sellSector == $homeSector">
                <set_value name="$sellDistanceFromHome" exact="0"/>
              </do_if>
              <do_else>
                <do_if value="$gdCache.{$homeSector}? and $gdCache.{$homeSector}.{$sellSector}?">
                  <set_value name="$sellDistanceFromHome" exact="$gdCache.{$homeSector}.{$sellSector}"/>
                </do_if>
                <do_else>
                  <set_value name="$sellDistanceFromHome" exact="$homeSector.gatedistance.{$sellSector}"/>
                  <do_if value="not $gdCache.{$homeSector}?"><set_value name="$gdCache.{$homeSector}" exact="table[]"/></do_if>
                  <set_value name="$gdCache.{$homeSector}.{$sellSector}" exact="$sellDistanceFromHome"/>
                </do_else>
              </do_else>
              
              <!-- Show calculated distances for diagnosis -->
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <set_value name="$buyStationNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.knownname else 'Unknown')"/>
                <set_value name="$buySectorNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.sector.knownname else 'Unknown')"/>
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': HOME SECTOR distance check (trade ' + $tradeIdx + '):' +
                  '\n  Home sector: ' + @$homeSector.knownname +
                  '\n  BUY station: ' + $buyStationNameForDebug + ' (Sector: ' + $buySectorNameForDebug + ', Distance from home: ' + $buyDistanceFromHome + '/' + this.$effectiveMaxBuy + ' jumps)' +
                  '\n  SELL station: ' + @$sellStation.knownname + ' (Sector: ' + @$sellStation.sector.knownname + ', Distance from home: ' + $sellDistanceFromHome + '/' + this.$effectiveMaxSell + ' jumps)' +
                  '\n  Ship position: ' + @this.ship.sector.knownname +
                  '\n  Validation: ' + (if ($buyDistanceFromHome lt 0 or $sellDistanceFromHome lt 0 or ($buyDistanceFromHome gt this.$effectiveMaxBuy and not $isSellOnlyTrade) or $sellDistanceFromHome gt this.$effectiveMaxSell) then 'REJECTED' else 'PASSED')"
                  chance="100"/>
              </do_if>
              
              <!-- Reject if stations exceed maxDistance from home -->
              <!-- For sell-only trades, only check sell distance -->
              <set_value name="$distanceCheckFailed" exact="false"/>
              <do_if value="not $isSellOnlyTrade">
                <do_if value="$buyDistanceFromHome lt 0 or $buyDistanceFromHome gt this.$effectiveMaxBuy">
                  <set_value name="$distanceCheckFailed" exact="true"/>
                </do_if>
              </do_if>
              <do_if value="$sellDistanceFromHome lt 0 or $sellDistanceFromHome gt this.$effectiveMaxSell">
                <set_value name="$distanceCheckFailed" exact="true"/>
              </do_if>
              
              <do_if value="$distanceCheckFailed">
                <set_value name="$tradesRejectedDistance" operation="add"/>
                
                <set_value name="$buyStationNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.knownname else 'Unknown')"/>
                <set_value name="$buySectorNameForDebug" exact="if $isSellOnlyTrade then 'N/A (sell-only)' else (if $buyStation? then @$buyStation.sector.knownname else 'Unknown')"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdx + '/' + (if $tradeList != null then $tradeList.count else 0) + ' DISTANCE EXCEEDED:' +
                    '\n  BUY: ' + $buyStationNameForDebug + ' (Sector: ' + $buySectorNameForDebug + ', Distance from home: ' + $buyDistanceFromHome + '/' + this.$effectiveMaxBuy + ' jumps)' +
                    '\n  SELL: ' + @$sellStation.knownname + ' (Sector: ' + @$sellStation.sector.knownname + ', Distance from home: ' + $sellDistanceFromHome + '/' + this.$effectiveMaxSell + ' jumps)' +
                    '\n  Home sector: ' + @$homeSector.knownname +
                    '\n  Ship position: ' + @this.ship.sector.knownname +
                    '\n  Reason: Station(s) exceed maximum distance from home sector' +
                    '\n  â†’ Trying next trade in list...'"
                    chance="100"/>
                </do_if>
                
                <!-- Continue to next trade in list -->
                <continue/>
              </do_if>
              
              <!-- Check if ship is in a blacklisted sector -->
              <set_value name="$currentSectorIsBlacklisted" exact="false"/>
              <do_if value="$blacklistgroup?">
                <set_value name="$currentSectorActivityBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$currentSectorTravelBlacklisted" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$currentSectorIsBlacklisted" exact="$currentSectorActivityBlacklisted or $currentSectorTravelBlacklisted"/>
              </do_if>
              
              <!-- Check if buy station OR its sector is blacklisted -->
              <!-- Always check target sector blacklist - escape only affects PATH, not destination -->
              <!-- For sell-only trades, skip buy station blacklist check (no buy station) -->
              <set_value name="$buyBlacklisted" exact="false"/>
              <do_if value="not $isSellOnlyTrade and $blacklistgroup? and $buyStation?">
                <!-- Check station itself (objectactivity) -->
                <set_value name="$buyStationBlacklisted" exact="@$buyStation.isblacklisted.{blacklisttype.objectactivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <!-- Check sector (sectoractivity AND sectortravel - same as vanilla) -->
                <set_value name="$buySectorActivityBlacklisted" exact="@$buyStation.sector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$buySectorTravelBlacklisted" exact="@$buyStation.sector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                
                <!-- Block buying in blacklisted sector (force escape) -->
                <!-- Ship in blacklisted sector must NOT buy in that sector -->
                <!-- Ship must escape by buying from a different (non-blacklisted) sector -->
                <do_if value="$buySectorActivityBlacklisted or $buySectorTravelBlacklisted">
                  <!-- Block buying in blacklisted sector (even if ship is already there) -->
                  <set_value name="$buyBlacklisted" exact="true"/>
                </do_if>
                <do_else>
                  <!-- Target sector is not blacklisted - only check station -->
                  <set_value name="$buyBlacklisted" exact="$buyStationBlacklisted"/>
                </do_else>
                
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$buyStationNameForDebug" exact="if $buyStation? then @$buyStation.knownname else 'Unknown'"/>
                  <set_value name="$buySectorNameForDebug" exact="if $buyStation? then @$buyStation.sector.knownname else 'Unknown'"/>
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': BUY blacklist check:' +
                    '\n  Current sector: ' + @$currentSector.knownname + ' (blacklisted: ' + $currentSectorIsBlacklisted + ')' +
                    '\n  Station: ' + $buyStationNameForDebug + 
                    '\n  Sector: ' + $buySectorNameForDebug + 
                    '\n  Station (objectactivity): ' + $buyStationBlacklisted + 
                    '\n  Sector (sectoractivity): ' + $buySectorActivityBlacklisted + 
                    '\n  Sector (sectortravel): ' + $buySectorTravelBlacklisted + 
                    '\n  Ship in buy sector: ' + ($buySector == $currentSector) +
                    '\n  Final result: ' + $buyBlacklisted" 
                    chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Check if sell station OR its sector is blacklisted -->
              <!-- Always check target sector blacklist - escape only affects PATH, not destination -->
              <set_value name="$sellBlacklisted" exact="false"/>
              <do_if value="$blacklistgroup?">
                <!-- Check station itself (objectactivity) -->
                <set_value name="$sellStationBlacklisted" exact="@$sellStation.isblacklisted.{blacklisttype.objectactivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <!-- Check sector (sectoractivity AND sectortravel - same as vanilla) -->
                <set_value name="$sellSectorActivityBlacklisted" exact="@$sellStation.sector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                <set_value name="$sellSectorTravelBlacklisted" exact="@$sellStation.sector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
                
                <!-- Always check if target sector is blacklisted -->
                <!-- Escape exception: Allow sell sector if ship is already IN it (escape FROM) -->
                <!-- But still block if ship needs to travel TO a blacklisted sector -->
                <do_if value="$sellSectorActivityBlacklisted or $sellSectorTravelBlacklisted">
                  <do_if value="$sellSector == $currentSector">
                    <!-- Ship is already in sell sector - allow escape FROM blacklisted sector -->
                    <!-- Only block if station itself is blacklisted -->
                    <set_value name="$sellBlacklisted" exact="$sellStationBlacklisted"/>
                  </do_if>
                  <do_else>
                    <!-- Ship needs to travel TO a blacklisted sector - BLOCK -->
                    <set_value name="$sellBlacklisted" exact="true"/>
                  </do_else>
                </do_if>
                <do_else>
                  <!-- Target sector is not blacklisted - only check station -->
                  <set_value name="$sellBlacklisted" exact="$sellStationBlacklisted"/>
                </do_else>
                
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': SELL blacklist check:' +
                    '\n  Current sector: ' + @$currentSector.knownname + ' (blacklisted: ' + $currentSectorIsBlacklisted + ')' +
                    '\n  Station: ' + @$sellStation.knownname + 
                    '\n  Sector: ' + @$sellStation.sector.knownname + 
                    '\n  Station (objectactivity): ' + $sellStationBlacklisted + 
                    '\n  Sector (sectoractivity): ' + $sellSectorActivityBlacklisted + 
                    '\n  Sector (sectortravel): ' + $sellSectorTravelBlacklisted + 
                    '\n  Ship in sell sector: ' + ($sellSector == $currentSector) +
                    '\n  Final result: ' + $sellBlacklisted" 
                    chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Block intra-sector trades in blacklisted sectors -->
              <!-- If ship is in blacklisted sector and both buy/sell are in same sector, block to force escape -->
              <set_value name="$isIntraSectorTradeInBlacklisted" exact="false"/>
              <do_if value="$currentSectorIsBlacklisted and $buySector == $currentSector and $sellSector == $currentSector">
                <set_value name="$isIntraSectorTradeInBlacklisted" exact="true"/>
                <set_value name="$buyBlacklisted" exact="true"/>  <!-- Block by marking as blacklisted -->
                
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ':   Intra-sector trade BLOCKED (escape required):' +
                    '\n  Current sector: ' + @$currentSector.knownname + ' (BLACKLISTED)' +
                    '\n  Buy/Sell: Both in ' + @$currentSector.knownname +
                    '\n  Reason: Ship must escape from blacklisted sector'"
                    chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Check if trade is blacklisted -->
              <do_if value="$buyBlacklisted or $sellBlacklisted">
                <!-- BLACKLISTED - Skip to next trade in list -->
                <set_value name="$tradesBlacklisted" operation="add"/>
                <set_value name="$blacklistedStation" exact="if $buyBlacklisted then $buyStation else $sellStation"/>
                <set_value name="$tradeType" exact="if $buyBlacklisted then 'BUY' else 'SELL'"/>
                
                <!-- Determine what was blacklisted (station or sector) -->
                <set_value name="$blacklistReason" exact="'Sector (sectortravel)'"/>  <!-- Default to most common case -->
                <do_if value="$buyBlacklisted">
                  <do_if value="$buyStationBlacklisted">
                    <set_value name="$blacklistReason" exact="'Station (objectactivity)'"/>
                  </do_if>
                  <do_elseif value="$buySectorActivityBlacklisted">
                    <set_value name="$blacklistReason" exact="'Sector (sectoractivity)'"/>
                  </do_elseif>
                </do_if>
                <do_else>
                  <do_if value="$sellStationBlacklisted">
                    <set_value name="$blacklistReason" exact="'Station (objectactivity)'"/>
                  </do_if>
                  <do_elseif value="$sellSectorActivityBlacklisted">
                    <set_value name="$blacklistReason" exact="'Sector (sectoractivity)'"/>
                  </do_elseif>
                </do_else>
                
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdx + '/' + (if $tradeList != null then $tradeList.count else 0) + ' BLACKLISTED:' +
                    '\n  Station: ' + @$blacklistedStation.knownname + 
                    '\n  Sector: ' + @$blacklistedStation.sector.knownname + 
                    '\n  Type: ' + $tradeType + 
                    '\n  Reason: ' + $blacklistReason + 
                    '\n  â†’ Trying next trade in list...'" 
                    chance="100"/>
                </do_if>
                
                <!-- Record failed sector for future filtering -->
                <signal_objects object="player.galaxy" param="'GT_Trade_Failed'" param2="table[
                  $Ship = this.ship,
                  $Reason = 'TRADEPARTNER_BLACKLISTED',
                  $FailureText = 'Trade partner is blacklisted (pre-validation)',
                  $Partner = $blacklistedStation,
                  $IsBuying = $buyBlacklisted,
                  $Ware = @$currentTrade.$Ware
                ]"/>
                
                <!-- Continue to next trade in list -->
                <continue/>
              </do_if>
              
              <!-- Check if ship can carry this ware type (cargo bay compatibility) -->
              <!-- Some wares (like Methane/gas) require special cargo bays that normal ships don't have -->
              <!-- For sell-only trades, use $Ware instead of $BuyOffer.ware -->
              <set_value name="$ware" exact="null"/>
              <do_if value="$isSellOnlyTrade and $currentTrade.$Ware?">
                <set_value name="$ware" exact="$currentTrade.$Ware"/>
              </do_if>
              <do_elseif value="$currentTrade.$BuyOffer?">
                <set_value name="$ware" exact="@$currentTrade.$BuyOffer.ware"/>
              </do_elseif>
              
              <do_if value="$ware? and $ware != null">
                <set_value name="$canCarryWareType" exact="this.ship.cargo.{$ware}.max gt 0"/>
                
                <do_if value="not $canCarryWareType">
                  <!-- SHIP CANNOT CARRY THIS WARE TYPE - Skip to next trade -->
                  <set_value name="$tradesRejectedCargo" operation="add"/>
                  
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade ' + $tradeIdx + '/' + (if $tradeList != null then $tradeList.count else 0) + ' INCOMPATIBLE CARGO TYPE:' +
                      '\n  Ware: ' + @$ware.name + 
                      '\n  Reason: Ship does not have required cargo bay type (e.g., liquid/gas requires special containment)' +
                      '\n  Ship cargo max for this ware: ' + this.ship.cargo.{$ware}.max +
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>
                  </do_if>
                  
                  <!-- Continue to next trade in list -->
                  <continue/>
                </do_if>
                
                <!-- Validation passed - this trade is valid -->
                <!-- Note: Cargo space and money validation will be handled by clamp_trade_amount before order creation -->
                <!-- Use safe access for tradeIdx -->
                <set_value name="$tradeIdxSafe" exact="if $tradeIdx? then $tradeIdx else 0"/>
                <set_value name="$tradeListCountSafe" exact="if $tradeList != null then $tradeList.count else 0"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' passed validation - checking offer availability...'" chance="100"/>
                </do_if>
                
                <!-- Check offer validity INSIDE loop before breaking -->
                <!-- This allows us to try the next trade if offers are consumed -->
                <!-- Initialize variables before conditionals to prevent property lookup errors -->
                <set_value name="$buyOfferStillValid" exact="true"/>
                <set_value name="$sellOfferStillValid" exact="false"/>
                <set_value name="$buyOfferAvailable" exact="null"/>
                <set_value name="$buyOfferAmount" exact="null"/>
                <set_value name="$sellOfferAvailable" exact="null"/>
                <set_value name="$sellOfferAmount" exact="null"/>
                
                <do_if value="$isSellOnlyTrade">
                  <!-- Sell-only trade: only check sell offer -->
                  <do_if value="$currentTrade.$SellOffer?">
                    <set_value name="$sellOfferAvailable" exact="$currentTrade.$SellOffer.available"/>
                    <set_value name="$sellOfferAmount" exact="@$currentTrade.$SellOffer.offeramount.{this.assignedcontrolled}"/>
                    <!-- Only reject if offer is unavailable OR amount is 0/null - let clamping handle partial amounts -->
                    <set_value name="$sellOfferStillValid" exact="$sellOfferAvailable and ($sellOfferAmount? and $sellOfferAmount gt 0)"/>
                    <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <set_value name="$sellDesiredBefore" exact="@$currentTrade.$SellOffer.desiredamount"/>
                      <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': pre-validate SELL-ONLY' +
                        '\n  needed=' + $currentTrade.$Amount +
                        '\n  sell offeramount(ship)=' + (if $sellOfferAmount? then $sellOfferAmount else 'null') +
                        '\n  sell desiredamount=' + (if $sellDesiredBefore? then $sellDesiredBefore else 'null')"
                        chance="100"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <!-- Sell-only trade but no sell offer - invalid -->
                    <set_value name="$sellOfferStillValid" exact="false"/>
                  </do_else>
                </do_if>
                <do_else>
                  <!-- Normal trade: check both offers -->
                  <do_if value="$currentTrade.$BuyOffer? and $currentTrade.$SellOffer?">
                    <!-- Check buy offer: available AND has SOME amount (clamping will handle exact amount reduction) -->
                    <set_value name="$buyOfferAvailable" exact="$currentTrade.$BuyOffer.available"/>
                    <set_value name="$buyOfferAmount" exact="@$currentTrade.$BuyOffer.offeramount.{this.assignedcontrolled}"/>
                    <!-- Only reject if offer is unavailable OR amount is 0/null - let clamping handle partial amounts -->
                    <set_value name="$buyOfferStillValid" exact="$buyOfferAvailable and ($buyOfferAmount? and $buyOfferAmount gt 0)"/>
                    
                    <!-- Check sell offer: available AND has SOME amount (clamping will handle exact amount reduction) -->
                    <set_value name="$sellOfferAvailable" exact="$currentTrade.$SellOffer.available"/>
                    <set_value name="$sellOfferAmount" exact="@$currentTrade.$SellOffer.offeramount.{this.assignedcontrolled}"/>
                    <!-- Only reject if offer is unavailable OR amount is 0/null - let clamping handle partial amounts -->
                    <set_value name="$sellOfferStillValid" exact="$sellOfferAvailable and ($sellOfferAmount? and $sellOfferAmount gt 0)"/>
                    
                    <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <set_value name="$buyDesiredBefore" exact="@$currentTrade.$BuyOffer.desiredamount"/>
                      <set_value name="$sellDesiredBefore" exact="@$currentTrade.$SellOffer.desiredamount"/>
                      <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': pre-validate NORMAL' +
                        '\n  needed=' + $currentTrade.$Amount +
                        '\n  buy offeramount(ship)=' + (if $buyOfferAmount? then $buyOfferAmount else 'null') +
                        '\n  buy desiredamount=' + (if $buyDesiredBefore? then $buyDesiredBefore else 'null') +
                        '\n  sell offeramount(ship)=' + (if $sellOfferAmount? then $sellOfferAmount else 'null') +
                        '\n  sell desiredamount=' + (if $sellDesiredBefore? then $sellDesiredBefore else 'null')"
                        chance="100"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <!-- Normal trade but missing offers - invalid -->
                    <set_value name="$buyOfferStillValid" exact="false"/>
                    <set_value name="$sellOfferStillValid" exact="false"/>
                  </do_else>
                </do_else>
                
                <!-- Check if offers are valid - conditional based on trade type -->
                <set_value name="$offersInvalid" exact="false"/>
                <do_if value="$isSellOnlyTrade">
                  <!-- Sell-only trade: only check sell offer -->
                  <set_value name="$offersInvalid" exact="not $sellOfferStillValid"/>
                </do_if>
                <do_else>
                  <!-- Normal trade: check both offers -->
                  <set_value name="$offersInvalid" exact="not $buyOfferStillValid or not $sellOfferStillValid"/>
                </do_else>
                
                <do_if value="$offersInvalid">
                  <!-- Offer became invalid - try next trade in list -->
                  <set_value name="$tradesRejectedOfferInvalid" operation="add"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <!-- Compute precise invalid reason (buy/sell availability vs amount shortfall) -->
                    <set_value name="$offerInvalidReason" exact="''"/>
                    <do_if value="$isSellOnlyTrade">
                      <do_if value="not $sellOfferAvailable">
                        <set_value name="$offerInvalidReason" exact="'sell_not_available'"/>
                      </do_if>
                      <do_elseif value="not $sellOfferAmount?">
                        <set_value name="$offerInvalidReason" exact="'sell_amount_null'"/>
                      </do_elseif>
                      <do_elseif value="$sellOfferAmount lt $currentTrade.$Amount">
                        <set_value name="$offerInvalidReason" exact="'sell_amount_lt_needed'"/>
                      </do_elseif>
                      <do_else>
                        <set_value name="$offerInvalidReason" exact="'sell_unknown'"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <set_value name="$buyInvalidReason" exact="'ok'"/>
                      <set_value name="$sellInvalidReason" exact="'ok'"/>
                      <do_if value="not $buyOfferAvailable">
                        <set_value name="$buyInvalidReason" exact="'buy_not_available'"/>
                      </do_if>
                      <do_elseif value="not $buyOfferAmount?">
                        <set_value name="$buyInvalidReason" exact="'buy_amount_null'"/>
                      </do_elseif>
                      <do_elseif value="$buyOfferAmount lt $currentTrade.$Amount">
                        <set_value name="$buyInvalidReason" exact="'buy_amount_lt_needed'"/>
                      </do_elseif>
                      <do_if value="not $sellOfferAvailable">
                        <set_value name="$sellInvalidReason" exact="'sell_not_available'"/>
                      </do_if>
                      <do_elseif value="not $sellOfferAmount?">
                        <set_value name="$sellInvalidReason" exact="'sell_amount_null'"/>
                      </do_elseif>
                      <do_elseif value="$sellOfferAmount lt $currentTrade.$Amount">
                        <set_value name="$sellInvalidReason" exact="'sell_amount_lt_needed'"/>
                      </do_elseif>
                      <set_value name="$offerInvalidReason" exact="'buy=' + $buyInvalidReason + ', sell=' + $sellInvalidReason"/>
                    </do_else>

                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' offer became invalid:' +
                      '\n  Trade type: ' + (if $isSellOnlyTrade then 'SELL-ONLY' else 'NORMAL') +
                      '\n  Buy offer: ' + (if $isSellOnlyTrade then 'N/A' else (if $buyOfferAvailable? then ('available=' + $buyOfferAvailable + ', amount=' + (if $buyOfferAmount? then $buyOfferAmount else 'null') + ' (needed: ' + $currentTrade.$Amount + ')') else 'MISSING')) +
                      '\n  Sell offer: available=' + (if $sellOfferAvailable? then $sellOfferAvailable else 'null') + ', amount=' + (if $sellOfferAmount? then $sellOfferAmount else 'null') + ' (needed: ' + $currentTrade.$Amount + ')' +
                      '\n  Failure: ' + $offerInvalidReason +
                      '\n  Reason: offer unavailable or amount is 0/null (clamping would handle partial amounts, but offer is completely unavailable)' +
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>
                  </do_if>
                  
                  <!-- Continue to next trade in list -->
                  <continue/>
                </do_if>
                
                <!-- HYBRID APPROACH: Use clamp_trade_amount for final amount validation BEFORE breaking -->
                <!-- This handles cargo space, money, and offer availability automatically -->
                <!-- If clamping results in 0, continue to next trade instead of breaking -->
                <set_value name="$finalBuyAmount" exact="$currentTrade.$Amount"/>
                <set_value name="$finalSellAmount" exact="$currentTrade.$Amount"/>
                <set_value name="$buyClampReason" exact="null"/>
                <set_value name="$sellClampReason" exact="null"/>
                <set_value name="$clampFailed" exact="false"/>
                
                <!-- PROFIT DEBUG: Log original amount before clamping -->
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <set_value name="$wareName" exact="if $currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.ware? then @$currentTrade.$BuyOffer.ware.name else (if $currentTrade.$SellOffer? and $currentTrade.$SellOffer.ware? then @$currentTrade.$SellOffer.ware.name else 'NULL')"/>
                  <debug_text text="'[GT-AI-PROFIT] (' + this.ship.idcode + ') AMOUNT CLAMPING START:' + 
                    '\n  Ware: ' + $wareName +
                    '\n  Original Amount (from trade object): ' + $currentTrade.$Amount + ' units' +
                    '\n  Trade Profit (RAW): ' + (if $currentTrade.$Profit? then $currentTrade.$Profit else 'NULL') + ' = ' + (if $currentTrade.$Profit? then ($currentTrade.$Profit/100) + ' Cr' else 'NULL') +
                    '\n  Trade BuyPrice (RAW): ' + (if $currentTrade.$BuyPrice? then $currentTrade.$BuyPrice else 'NULL') + ' = ' + (if $currentTrade.$BuyPrice? then ($currentTrade.$BuyPrice/100) + ' Cr' else 'NULL') +
                    '\n  Trade SellPrice (RAW): ' + (if $currentTrade.$SellPrice? then $currentTrade.$SellPrice else 'NULL') + ' = ' + (if $currentTrade.$SellPrice? then ($currentTrade.$SellPrice/100) + ' Cr' else 'NULL')" chance="100"/>
                </do_if>
                
                <!-- Clamp buy order amount (for non-sell-only trades) -->
                <do_if value="not $isSellOnlyTrade and $currentTrade.$BuyOffer?">
                  <clamp_trade_amount 
                    trade="$currentTrade.$BuyOffer" 
                    amount="$finalBuyAmount" 
                    buyer="this.ship" 
                    seller="@$currentTrade.$BuyOffer.seller" 
                    result="$finalBuyAmount"
                    reason="$buyClampReason"/>
                  <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$buyOfferAmountAfterClamp" exact="@$currentTrade.$BuyOffer.offeramount.{this.assignedcontrolled}"/>
                    <set_value name="$buyDesiredAfterClamp" exact="@$currentTrade.$BuyOffer.desiredamount"/>
                    <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': post-clamp BUY' +
                      '\n  original=' + $currentTrade.$Amount +
                      '\n  clamped=' + $finalBuyAmount +
                      '\n  buy offeramount(ship)=' + (if $buyOfferAmountAfterClamp? then $buyOfferAmountAfterClamp else 'null') +
                      '\n  buy desiredamount=' + (if $buyDesiredAfterClamp? then $buyDesiredAfterClamp else 'null') +
                      '\n  clampReason=' + (if $buyClampReason? then $buyClampReason else 'null')"
                      chance="100"/>
                  </do_if>
                  
                  <do_if value="not $finalBuyAmount? or $finalBuyAmount == 0 or $finalBuyAmount lt 0">
                    <!-- Amount clamped to 0 or invalid - try next trade -->
                    <set_value name="$tradesRejectedCargo" operation="add"/>
                    <set_value name="$clampFailed" exact="true"/>
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <set_value name="$clampReasonText" exact="if $buyClampReason? then $buyClampReason else 'unknown'"/>
                      <set_value name="$amountStatus" exact="if not $finalBuyAmount? then 'null' else if $finalBuyAmount lt 0 then 'negative (' + $finalBuyAmount + ')' else 'zero'"/>
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' buy amount clamped to invalid value:' +
                        '\n  Original amount: ' + $currentTrade.$Amount +
                        '\n  Clamped amount: ' + $amountStatus +
                        '\n  Clamp reason: ' + $clampReasonText +
                        '\n  Reason: ' + (if $buyClampReason == 'buyer_cargo' then 'Insufficient cargo space' else if $buyClampReason == 'buyer_money' then 'Insufficient funds' else if $buyClampReason == 'seller_cargo' then 'Seller has insufficient stock' else 'Offer constraints') +
                        '\n  â†’ Trying next trade in list...'" 
                        chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <do_if value="not $clampFailed and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $finalBuyAmount != $currentTrade.$Amount">
                    <set_value name="$clampReasonText" exact="if $buyClampReason? then $buyClampReason else 'unknown'"/>
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' buy amount adjusted:' +
                      '\n  Original: ' + $currentTrade.$Amount +
                      '\n  Clamped: ' + $finalBuyAmount +
                      '\n  Reason: ' + $clampReasonText"
                      chance="100"/>
                  </do_if>
                </do_if>
                
                <!-- Clamp sell order amount -->
                <do_if value="not $clampFailed and $currentTrade.$SellOffer?">
                  <do_if value="$isSellOnlyTrade">
                    <!-- Sell-only trade: Ship already has cargo, validate against ship cargo -->
                    <clamp_trade_amount 
                      trade="$currentTrade.$SellOffer" 
                      amount="$finalSellAmount" 
                      buyer="@$currentTrade.$SellOffer.buyer" 
                      seller="this.ship" 
                      result="$finalSellAmount"
                      reason="$sellClampReason"/>
                  </do_if>
                  <do_else>
                    <!-- Normal trade: Ship doesn't have cargo yet (will buy first), don't check seller cargo -->
                    <!-- Match vanilla pattern: clamp without seller parameter (only checks buyer constraints) -->
                    <!-- Vanilla comment: "it is possible that this doesn't have the wares yet if they still need to be bought" -->
                    <clamp_trade_amount 
                      trade="$currentTrade.$SellOffer" 
                      amount="$finalSellAmount" 
                      buyer="@$currentTrade.$SellOffer.buyer" 
                      result="$finalSellAmount"
                      reason="$sellClampReason"/>
                  </do_else>
                  
                  <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$sellOfferAmountAfterClamp" exact="@$currentTrade.$SellOffer.offeramount.{this.assignedcontrolled}"/>
                    <set_value name="$sellDesiredAfterClamp" exact="@$currentTrade.$SellOffer.desiredamount"/>
                    <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': post-clamp SELL' +
                      '\n  original=' + $currentTrade.$Amount +
                      '\n  clamped=' + $finalSellAmount +
                      '\n  sell offeramount(ship)=' + (if $sellOfferAmountAfterClamp? then $sellOfferAmountAfterClamp else 'null') +
                      '\n  sell desiredamount=' + (if $sellDesiredAfterClamp? then $sellDesiredAfterClamp else 'null') +
                      '\n  clampReason=' + (if $sellClampReason? then $sellClampReason else 'null')"
                      chance="100"/>
                  </do_if>
                  
                  <do_if value="not $finalSellAmount? or $finalSellAmount == 0 or $finalSellAmount lt 0">
                    <!-- Amount clamped to 0 or invalid - try next trade -->
                    <set_value name="$tradesRejectedCargo" operation="add"/>
                    <set_value name="$clampFailed" exact="true"/>
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <set_value name="$clampReasonText" exact="if $sellClampReason? then $sellClampReason else 'unknown'"/>
                      <set_value name="$amountStatus" exact="if not $finalSellAmount? then 'null' else if $finalSellAmount lt 0 then 'negative (' + $finalSellAmount + ')' else 'zero'"/>
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' sell amount clamped to invalid value:' +
                        '\n  Trade type: ' + (if $isSellOnlyTrade then 'SELL-ONLY' else 'NORMAL') +
                        '\n  Original amount: ' + $currentTrade.$Amount +
                        '\n  Clamped amount: ' + $amountStatus +
                        '\n  Clamp reason: ' + $clampReasonText +
                        '\n  Reason: ' + (if $sellClampReason == 'buyer_cargo' then 'Buyer has insufficient cargo space' else if $sellClampReason == 'buyer_money' then 'Buyer has insufficient funds' else if $sellClampReason == 'seller_cargo' then 'Ship has insufficient cargo' else 'Offer constraints') +
                        '\n  â†’ Trying next trade in list...'" 
                        chance="100"/>
                    </do_if>
                  </do_if>
                  
                  <do_if value="not $clampFailed and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $finalSellAmount != $currentTrade.$Amount">
                    <set_value name="$clampReasonText" exact="if $sellClampReason? then $sellClampReason else 'unknown'"/>
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' sell amount adjusted:' +
                      '\n  Trade type: ' + (if $isSellOnlyTrade then 'SELL-ONLY' else 'NORMAL') +
                      '\n  Original: ' + $currentTrade.$Amount +
                      '\n  Clamped: ' + $finalSellAmount +
                      '\n  Reason: ' + $clampReasonText"
                      chance="100"/>
                  </do_if>
                </do_if>
                
                <!-- If clamping failed, continue to next trade -->
                <do_if value="$clampFailed">
                  <continue/>
                </do_if>

                <!-- CRITICAL: For NORMAL trades, BUY and SELL amounts must match.
                     clamp_trade_amount can clamp BUY (ship cargo/money) and SELL (buyer constraints) independently.
                     Final executed amount must be the minimum of both. -->
                <do_if value="not $isSellOnlyTrade">
                  <set_value name="$finalAmount" exact="[$finalBuyAmount, $finalSellAmount].min"/>
                  
                  <!-- PROFIT DEBUG: Log amount syncing details -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$wareName" exact="if $currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.ware? then @$currentTrade.$BuyOffer.ware.name else (if $currentTrade.$SellOffer? and $currentTrade.$SellOffer.ware? then @$currentTrade.$SellOffer.ware.name else 'NULL')"/>
                    <debug_text text="'[GT-AI-PROFIT] (' + this.ship.idcode + ') AMOUNT SYNCING:' + 
                      '\n  Ware: ' + $wareName +
                      '\n  Original Amount: ' + $currentTrade.$Amount + ' units' +
                      '\n  Clamped Buy Amount: ' + $finalBuyAmount + ' units' +
                      '\n  Clamped Sell Amount: ' + $finalSellAmount + ' units' +
                      '\n  Final Amount (min): ' + $finalAmount + ' units' +
                      '\n  Amount changed: ' + (if $finalAmount != $currentTrade.$Amount then 'YES (was ' + $currentTrade.$Amount + ', now ' + $finalAmount + ')' else 'NO') +
                      '\n  Trade Profit (unchanged): ' + (if $currentTrade.$Profit? then ($currentTrade.$Profit/100) + ' Cr' else 'NULL')" chance="100"/>
                  </do_if>
                  
                  <set_value name="$finalBuyAmount" exact="$finalAmount"/>
                  <set_value name="$finalSellAmount" exact="$finalAmount"/>
                </do_if>
                
                <!-- CRITICAL FIX: Always recalculate profit using current prices and final amount -->
                <!-- Cache is only a hint - market prices change constantly, so we must always validate -->
                <!-- Extract prices from offers if missing from trade object (handles old cache entries) -->
                <set_value name="$buyPriceForRecalc" exact="null"/>
                <set_value name="$sellPriceForRecalc" exact="null"/>
                
                <!-- Try to get prices from trade object first -->
                <do_if value="$currentTrade.$BuyPrice?">
                  <set_value name="$buyPriceForRecalc" exact="$currentTrade.$BuyPrice"/>
                </do_if>
                <do_else>
                  <!-- Extract from buy offer if missing (handles old cache entries without stored prices) -->
                  <do_if value="$currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.unitprice?">
                    <set_value name="$buyPriceForRecalc" exact="$currentTrade.$BuyOffer.unitprice"/>
                  </do_if>
                </do_else>
                
                <do_if value="$currentTrade.$SellPrice?">
                  <set_value name="$sellPriceForRecalc" exact="$currentTrade.$SellPrice"/>
                </do_if>
                <do_else>
                  <!-- Extract from sell offer if missing (handles old cache entries without stored prices) -->
                  <do_if value="$currentTrade.$SellOffer? and $currentTrade.$SellOffer.unitprice?">
                    <set_value name="$sellPriceForRecalc" exact="$currentTrade.$SellOffer.unitprice"/>
                  </do_if>
                </do_else>
                
                <!-- ALWAYS recalculate profit when prices are available (regardless of amount change) -->
                <!-- This ensures cached trades with wrong profit are caught and validated -->
                <set_value name="$amountChanged" exact="if $isSellOnlyTrade then ($finalSellAmount != $currentTrade.$Amount) else ($finalBuyAmount != $currentTrade.$Amount)"/>
                <set_value name="$finalProfitRAW" exact="null"/>
                <set_value name="$profitRecalculated" exact="false"/>
                
                <do_if value="$currentTrade.$Amount? and $buyPriceForRecalc? and $sellPriceForRecalc?">
                  <!-- Store original values before recalculation -->
                  <set_value name="$originalAmount" exact="$currentTrade.$Amount"/>
                  <set_value name="$originalProfitRAW" exact="$currentTrade.$Profit"/>
                  
                  <!-- Calculate final amount for profit calculation -->
                  <set_value name="$finalAmountForProfit" exact="if $isSellOnlyTrade then $finalSellAmount else $finalBuyAmount"/>
                  
                  <!-- ALWAYS recalculate profit: (sellPrice - buyPrice) * finalAmount -->
                  <!-- This validates against current market prices, not cached values -->
                  <set_value name="$recalculatedProfitRAW" exact="($sellPriceForRecalc - $buyPriceForRecalc) * $finalAmountForProfit"/>
                  <set_value name="$finalProfitRAW" exact="$recalculatedProfitRAW"/>
                  <set_value name="$profitRecalculated" exact="true"/>
                  
                  <!-- Update trade object profit (for logbook display) -->
                  <set_value name="$currentTrade.$Profit" exact="$recalculatedProfitRAW"/>
                  
                  <!-- Also update prices in trade object if they were missing (for future use) -->
                  <do_if value="not $currentTrade.$BuyPrice?">
                    <set_value name="$currentTrade.$BuyPrice" exact="$buyPriceForRecalc"/>
                  </do_if>
                  <do_if value="not $currentTrade.$SellPrice?">
                    <set_value name="$currentTrade.$SellPrice" exact="$sellPriceForRecalc"/>
                  </do_if>
                  
                  <!-- PROFIT DEBUG: Log profit recalculation -->
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$wareName" exact="if $currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.ware? then @$currentTrade.$BuyOffer.ware.name else (if $currentTrade.$SellOffer? and $currentTrade.$SellOffer.ware? then @$currentTrade.$SellOffer.ware.name else 'NULL')"/>
                    <set_value name="$priceSource" exact="if $currentTrade.$BuyPrice? then 'trade_object' else 'extracted_from_offers'"/>
                    <set_value name="$amountStatus" exact="if $amountChanged then 'YES (was ' + $originalAmount + ', now ' + $finalAmountForProfit + ')' else 'NO (unchanged: ' + $finalAmountForProfit + ')'"/>
                    <debug_text text="'[GT-AI-PROFIT] (' + this.ship.idcode + ') PROFIT RECALCULATION (ALWAYS):' + 
                      '\n  Ware: ' + $wareName +
                      '\n  Price Source: ' + $priceSource +
                      '\n  Amount Changed: ' + $amountStatus +
                      '\n  Original Amount: ' + $originalAmount + ' units' +
                      '\n  Final Amount: ' + $finalAmountForProfit + ' units' +
                      '\n  Original Profit (cached): ' + ($originalProfitRAW/100) + ' Cr (RAW: ' + $originalProfitRAW + ')' +
                      '\n  Recalculated Profit (validated): ' + ($recalculatedProfitRAW/100) + ' Cr (RAW: ' + $recalculatedProfitRAW + ')' +
                      '\n  Buy Price: ' + ($buyPriceForRecalc/100) + ' Cr (RAW: ' + $buyPriceForRecalc + ')' +
                      '\n  Sell Price: ' + ($sellPriceForRecalc/100) + ' Cr (RAW: ' + $sellPriceForRecalc + ')' +
                      '\n  Verification: (' + ($sellPriceForRecalc/100) + ' - ' + ($buyPriceForRecalc/100) + ') * ' + $finalAmountForProfit + ' = ' + (($sellPriceForRecalc - $buyPriceForRecalc) * $finalAmountForProfit / 100) + ' Cr'" chance="100"/>
                  </do_if>
                </do_if>
                <do_else>
                  <!-- Prices missing - cannot recalculate profit, reject trade -->
                  <set_value name="$tradesRejectedProfit" operation="add"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$wareName" exact="if $currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.ware? then @$currentTrade.$BuyOffer.ware.name else (if $currentTrade.$SellOffer? and $currentTrade.$SellOffer.ware? then @$currentTrade.$SellOffer.ware.name else 'NULL')"/>
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' REJECTED: Cannot validate profit' +
                      '\n  Ware: ' + $wareName +
                      '\n  Reason: Prices missing from trade object and offers, cannot recalculate/validate profit' +
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>
                  </do_if>
                  <continue/>
                </do_else>
                
                <!-- CRITICAL: Validate recalculated profit - reject negative or zero profit trades -->
                <do_if value="not $finalProfitRAW? or $finalProfitRAW le 0">
                  <set_value name="$tradesRejectedProfit" operation="add"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <set_value name="$wareName" exact="if $currentTrade.$BuyOffer? and $currentTrade.$BuyOffer.ware? then @$currentTrade.$BuyOffer.ware.name else (if $currentTrade.$SellOffer? and $currentTrade.$SellOffer.ware? then @$currentTrade.$SellOffer.ware.name else 'NULL')"/>
                    <set_value name="$profitStatus" exact="if not $finalProfitRAW? then 'NULL' else if $finalProfitRAW == 0 then 'ZERO' else 'NEGATIVE (' + ($finalProfitRAW/100) + ' Cr)'"/>
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' REJECTED: Profit validation failed' +
                      '\n  Ware: ' + $wareName +
                      '\n  Final Profit (recalculated): ' + $profitStatus +
                      '\n  Reason: Trade is unprofitable (market prices changed or cached profit was wrong)' +
                      '\n  â†’ Trying next trade in list...'" 
                      chance="100"/>
                  </do_if>
                  <continue/>
                </do_if>
                
                <!-- FINAL DOCKING VERIFICATION: Use find_dockingbay for accurate dock size/permission check -->
                <!-- This is more accurate than dockingallowed and catches dock size mismatches -->
                <!-- Check BEFORE breaking so we can continue to next trade if docking fails -->
                <set_value name="$finalDockingCheck" exact="true"/>
                <!-- Mirror vanilla order.dock.xml: use $thisship for match_relation_to + match_dock -->
                <set_value name="$thisship" exact="this.ship"/>
                
                <!-- Check buy station docking (for non-sell-only trades) -->
                <!-- Mirror vanilla order.dock.xml: include trading="true" + match_relation_to (enemy not) -->
                <do_if value="not $isSellOnlyTrade and $finalDockingCheck and $buyStation?">
                  <find_dockingbay name="$testBuyDock" object="$buyStation" checkoperational="true" multiple="false">
                    <match_dock size="$thisship.docksize" trading="true" storage="false"/>
                    <match_relation_to object="$thisship" comparison="not" relation="enemy"/>
                  </find_dockingbay>
                  <do_if value="not $testBuyDock">
                    <set_value name="$finalDockingCheck" exact="false"/>
                    <set_value name="$tradesRejectedDocking" operation="add"/>
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' Final docking check FAILED (buy station): ' + @$buyStation.knownname + 
                        '\n  Sector: ' + @$buyStation.sector.knownname + 
                        '\n  Reason: No dock available for ship size ' + this.ship.docksize + ' (station may not have L/XL docks)' +
                        '\n  â†’ Trying next trade in list...'" 
                        chance="100"/>
                    </do_if>
                  </do_if>
                </do_if>
                
                <!-- Check sell station docking -->
                <!-- Mirror vanilla order.dock.xml: include trading="true" + match_relation_to (enemy not) -->
                <do_if value="$finalDockingCheck and $sellStation?">
                  <find_dockingbay name="$testSellDock" object="$sellStation" checkoperational="true" multiple="false">
                    <match_dock size="$thisship.docksize" trading="true" storage="false"/>
                    <match_relation_to object="$thisship" comparison="not" relation="enemy"/>
                  </find_dockingbay>
                  <do_if value="not $testSellDock">
                    <set_value name="$finalDockingCheck" exact="false"/>
                    <set_value name="$tradesRejectedDocking" operation="add"/>
                    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' Final docking check FAILED (sell station): ' + @$sellStation.knownname + 
                        '\n  Sector: ' + @$sellStation.sector.knownname + 
                        '\n  Reason: No dock available for ship size ' + this.ship.docksize + ' (station may not have L/XL docks)' +
                        '\n  â†’ Trying next trade in list...'" 
                        chance="100"/>
                    </do_if>
                  </do_if>
                </do_if>
                
                <!-- If final docking check failed, continue to next trade -->
                <do_if value="not $finalDockingCheck">
                  <continue/>
                </do_if>
                
                <!-- All checks passed including clamping and final docking verification - this trade is valid -->
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade ' + $tradeIdxSafe + '/' + $tradeListCountSafe + ' is VALID - using this trade!'" chance="100"/>
                </do_if>
                <set_value name="$validTradeFound" exact="true"/>
                <set_value name="$pendingTrade" exact="$currentTrade"/>
                <!-- Store clamped amounts in pendingTrade for use after loop -->
                <set_value name="$pendingTrade.$FinalBuyAmount" exact="$finalBuyAmount"/>
                <set_value name="$pendingTrade.$FinalSellAmount" exact="$finalSellAmount"/>
                <!-- Break out of loop - we found a valid trade -->
                <break/>
              </do_if>
              <do_else>
                <!-- Ware couldn't be extracted - skip this trade -->
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade ' + (if $tradeIdx? then $tradeIdx else 0) + ' SKIPPED: Could not extract ware from trade data'" chance="100"/>
                </do_if>
                <continue/>
              </do_else>
            </do_if>
          
          <!-- Skip trade if currentTrade is null -->
          <do_else>
            <!-- Don't access $tradeIdx here - it might not exist if loop didn't execute -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade SKIPPED: Trade data is null'" chance="100"/>
            </do_if>
            <!-- Only use continue if we're actually in the loop -->
            <do_if value="$tradeIdx?">
              <continue/>
            </do_if>
          </do_else>
          </do_all>
        </do_if>
        <do_else>
          <!-- Trade list is empty or null - no trades to validate -->
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  Trade list is empty or null - no trades to validate'" chance="100"/>
          <set_value name="$validTradeFound" exact="false"/>
        </do_else>
        
        <!-- After loop: Check if we found a valid trade -->
        <!-- Use safe access and check existence before accessing -->
        <do_if value="$validTradeFound? and $validTradeFound">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Validation PASSED - creating trade orders (checked ' + $tradesChecked + ' trades, ' + $tradesRejectedPath + ' unreachable, ' + $tradesRejectedDocking + ' docking denied, ' + $tradesRejectedDistance + ' distance exceeded, ' + $tradesRejectedCargo + ' insufficient cargo, ' + $tradesBlacklisted + ' blacklisted)'" chance="100"/>
          </do_if>
          
          <!-- Update pending trade entry with ACTUAL trade being executed -->
          <!-- Failure handler expects table with $BuyStation, $SellStation, $Ware -->
          <!-- Replace trade list with specific trade data for failure tracking -->
          <!-- Handle sell-only trades (BuyOffer may be null) -->
          <!-- Extract values from pendingTrade since loop variables may be out of scope -->
          <set_value name="$isSellOnlyTradeForPending" exact="false"/>
          <do_if value="$pendingTrade.$IsSellOnly? and $pendingTrade.$IsSellOnly">
            <set_value name="$isSellOnlyTradeForPending" exact="true"/>
          </do_if>
          
          <!-- Extract stations from pendingTrade (may have been set in loop, but extract to be safe) -->
          <set_value name="$buyStationForPending" exact="null"/>
          <set_value name="$sellStationForPending" exact="null"/>
          <do_if value="$pendingTrade.$BuyStation?">
            <set_value name="$buyStationForPending" exact="$pendingTrade.$BuyStation"/>
          </do_if>
          <do_elseif value="$pendingTrade.$BuyOffer?">
            <set_value name="$buyStationForPending" exact="@$pendingTrade.$BuyOffer.owner"/>
          </do_elseif>
          <do_else>
            <!-- Use loop variable if available, otherwise null (for sell-only trades) -->
            <set_value name="$buyStationForPending" exact="$buyStation"/>
          </do_else>
          
          <do_if value="$pendingTrade.$SellStation?">
            <set_value name="$sellStationForPending" exact="$pendingTrade.$SellStation"/>
          </do_if>
          <do_elseif value="$pendingTrade.$SellOffer?">
            <set_value name="$sellStationForPending" exact="@$pendingTrade.$SellOffer.owner"/>
          </do_elseif>
          <do_else>
            <!-- Use loop variable if available -->
            <set_value name="$sellStationForPending" exact="$sellStation"/>
          </do_else>
          
          <set_value name="$wareForPendingTrade" exact="null"/>
          <do_if value="$isSellOnlyTradeForPending and $pendingTrade.$Ware?">
            <set_value name="$wareForPendingTrade" exact="$pendingTrade.$Ware"/>
          </do_if>
          <do_elseif value="$pendingTrade.$BuyOffer?">
            <set_value name="$wareForPendingTrade" exact="@$pendingTrade.$BuyOffer.ware"/>
          </do_elseif>
          
          <!-- Store the ACTIVE trade for failure tracking (do NOT overwrite the pending-results list). -->
          <do_if value="not global.$GT_ActiveTrade?">
            <set_value name="global.$GT_ActiveTrade" exact="table[]"/>
          </do_if>
          <set_value name="global.$GT_ActiveTrade.{this.ship}" exact="table[
            $BuyStation = $buyStationForPending,
            $SellStation = $sellStationForPending,
            $Ware = $wareForPendingTrade
          ]"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$buyStationNameForDebug" exact="if $isSellOnlyTradeForPending then 'N/A (sell-only)' else (if $buyStationForPending? then @$buyStationForPending.knownname else 'Unknown')"/>
            <set_value name="$sellStationNameForDebug" exact="if $sellStationForPending? then @$sellStationForPending.knownname else 'Unknown'"/>
            <set_value name="$wareNameForDebug" exact="if $wareForPendingTrade? then @$wareForPendingTrade.name else 'Unknown'"/>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Updated pending trade entry for failure tracking:' +
              '\n  Buy: ' + $buyStationNameForDebug +
              '\n  Sell: ' + $sellStationNameForDebug +
              '\n  Ware: ' + $wareNameForDebug"
              chance="100"/>
          </do_if>
          
          <!-- Final offer validity check and clamping moved inside loop -->
          <!-- Offers are validated and clamped before breaking out of the loop -->
          <!-- Final docking verification also moved inside loop - allows trying next trade if docking fails -->
          <!-- All checks passed including final docking verification (checked in loop) - safe to create orders with clamped amounts -->
          <!-- Clamped amounts are stored in $pendingTrade.$FinalBuyAmount and $pendingTrade.$FinalSellAmount -->
          <!-- Create X4 native TradePerform orders with blacklist routing -->
          <!-- CRITICAL: internal="true" is REQUIRED for vanilla to track pending trades and display count -->
          <!-- Without internal="true", vanilla won't set $internalorder in TradePerform, and pending trades won't be displayed -->
          <!-- For sell-only trades, skip buy order (ship already has cargo) -->
          <set_value name="$finalBuyAmount" exact="if $pendingTrade.$FinalBuyAmount? then $pendingTrade.$FinalBuyAmount else $pendingTrade.$Amount"/>
          <set_value name="$finalSellAmount" exact="if $pendingTrade.$FinalSellAmount? then $pendingTrade.$FinalSellAmount else $pendingTrade.$Amount"/>
          
          <!-- Enforce buildstorage/carrier-aux restrictions before creating orders -->
          <!-- Resolve effective flags (prefer MD-stored AI parameters, fallback to local effective flags) -->
          <set_value name="$enfIgnoreBuildStorage" exact="false"/>
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{this.ship}? and global.$GT_AIParameters.{this.ship}.$IgnoreBuildStorage?">
            <set_value name="$enfIgnoreBuildStorage" exact="global.$GT_AIParameters.{this.ship}.$IgnoreBuildStorage"/>
          </do_if>
          <do_if value="not $enfIgnoreBuildStorage">
            <set_value name="$enfIgnoreBuildStorage" exact="$effectiveIgnoreBuildStorage"/>
          </do_if>
          
          <set_value name="$enfIgnoreCarrierAux" exact="false"/>
          <do_if value="global.$GT_AIParameters? and global.$GT_AIParameters.{this.ship}? and global.$GT_AIParameters.{this.ship}.$IgnoreCarrierAux?">
            <set_value name="$enfIgnoreCarrierAux" exact="global.$GT_AIParameters.{this.ship}.$IgnoreCarrierAux"/>
          </do_if>
          <do_if value="not $enfIgnoreCarrierAux">
            <set_value name="$enfIgnoreCarrierAux" exact="$effectiveIgnoreCarrierAux"/>
          </do_if>
          
          <!-- Extract stations if needed (debug section later also uses these vars) -->
          <set_value name="$buyStationForPending" exact="if $pendingTrade.$BuyStation? then $pendingTrade.$BuyStation else (if $pendingTrade.$BuyOffer? then @$pendingTrade.$BuyOffer.owner else null)"/>
          <set_value name="$sellStationForPending" exact="if $pendingTrade.$SellStation? then $pendingTrade.$SellStation else (if $pendingTrade.$SellOffer? then @$pendingTrade.$SellOffer.owner else null)"/>
          
          <!-- Buildstorage enforcement -->
          <do_if value="$enfIgnoreBuildStorage">
            <set_value name="$buyIsBuildStorage" exact="false"/>
            <do_if value="$buyStationForPending?">
              <set_value name="$buyIsBuildStorage" exact="$buyStationForPending.isclass.buildstorage"/>
            </do_if>
            <set_value name="$sellIsBuildStorage" exact="false"/>
            <do_if value="$sellStationForPending?">
              <set_value name="$sellIsBuildStorage" exact="$sellStationForPending.isclass.buildstorage"/>
            </do_if>
            <do_if value="$buyIsBuildStorage or $sellIsBuildStorage">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade rejected by buildstorage restriction (buy=' + $buyIsBuildStorage + ', sell=' + $sellIsBuildStorage + ')'" chance="100"/>
              </do_if>
              <signal_objects object="this.ship" param="'GT_No_Trade_Found'" param2="'trade_rules_violation'"/>
              <return/>
            </do_if>
          </do_if>
          
          <!-- Carrier/Aux enforcement (stations only) -->
          <do_if value="$enfIgnoreCarrierAux">
            <set_value name="$rejectCarrierAux" exact="false"/>
            <do_if value="$buyStationForPending? and $buyStationForPending.isclass.station">
              <set_value name="$buyPrimaryPurpose" exact="@$buyStationForPending.primarypurpose"/>
              <do_if value="$buyPrimaryPurpose == purpose.auxiliary or $buyPrimaryPurpose == purpose.fight">
                <set_value name="$rejectCarrierAux" exact="true"/>
              </do_if>
            </do_if>
            <do_if value="not $rejectCarrierAux and $sellStationForPending? and $sellStationForPending.isclass.station">
              <set_value name="$sellPrimaryPurpose" exact="@$sellStationForPending.primarypurpose"/>
              <do_if value="$sellPrimaryPurpose == purpose.auxiliary or $sellPrimaryPurpose == purpose.fight">
                <set_value name="$rejectCarrierAux" exact="true"/>
              </do_if>
            </do_if>
            <do_if value="$rejectCarrierAux">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade rejected by carrier/aux restriction'" chance="100"/>
              </do_if>
              <signal_objects object="this.ship" param="'GT_No_Trade_Found'" param2="'trade_rules_violation'"/>
              <return/>
            </do_if>
          </do_if>
          
          <!-- CRITICAL FIX: Final validation immediately before order creation -->
          <!-- This catches cases where trade rules changed between earlier validation and order creation -->
          <!-- Re-check offers with tradepartner to ensure trade rules are still respected -->
          <set_value name="$finalBuyOfferValid" exact="true"/>
          <set_value name="$finalSellOfferValid" exact="true"/>
          
          <do_if value="not $isSellOnlyTradeForPending and $pendingTrade.$BuyOffer?">
            <set_value name="$finalBuyStation" exact="if $pendingTrade.$BuyStation? then $pendingTrade.$BuyStation else (if $pendingTrade.$BuyOffer.owner? then @$pendingTrade.$BuyOffer.owner else null)"/>
            <set_value name="$finalBuyWare" exact="if $pendingTrade.$BuyOffer.ware? then @$pendingTrade.$BuyOffer.ware else null"/>
            
            <do_if value="$finalBuyStation? and $finalBuyStation.exists and $finalBuyWare != null">
              <find_sell_offer seller="$finalBuyStation" wares="$finalBuyWare" tradepartner="this.ship" result="$finalValidatedBuyOffer"/>
              <do_if value="not $finalValidatedBuyOffer.available">
                <set_value name="$finalBuyOfferValid" exact="false"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FINAL VALIDATION FAILED - Buy offer invalid (trade rules?) - station: ' + @$finalBuyStation.knownname + ', ware: ' + @$finalBuyWare.name" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          
          <do_if value="$pendingTrade.$SellOffer?">
            <set_value name="$finalSellStation" exact="if $pendingTrade.$SellStation? then $pendingTrade.$SellStation else (if $pendingTrade.$SellOffer.owner? then @$pendingTrade.$SellOffer.owner else null)"/>
            <set_value name="$finalSellWare" exact="if $pendingTrade.$SellOffer.ware? then @$pendingTrade.$SellOffer.ware else null"/>
            
            <do_if value="$finalSellStation? and $finalSellStation.exists and $finalSellWare != null">
              <find_buy_offer buyer="$finalSellStation" wares="$finalSellWare" tradepartner="this.ship" result="$finalValidatedSellOffer"/>
              <do_if value="not $finalValidatedSellOffer.available">
                <set_value name="$finalSellOfferValid" exact="false"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FINAL VALIDATION FAILED - Sell offer invalid (trade rules?) - station: ' + @$finalSellStation.knownname + ', ware: ' + @$finalSellWare.name" chance="100"/>
                </do_if>
              </do_if>
            </do_if>
          </do_if>
          
          <!-- If final validation failed, abort order creation -->
          <do_if value="not $finalBuyOfferValid or not $finalSellOfferValid">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': FINAL VALIDATION FAILED - Trade rules violation detected immediately before order creation - aborting'" chance="100"/>
            </do_if>
            <signal_objects object="this.ship" param="'GT_No_Trade_Found'" param2="'trade_rules_violation'"/>
            <return/>
          </do_if>
          
          <!-- Offers valid - proceed with order creation -->
          <!-- CRITICAL FIX: Explicitly set internal="false" to ensure vanilla counts trade orders in "credits due from trades" -->
          <!-- Vanilla's GetCreditsDueFromPlayerTrades() only counts trade orders with internal="false" -->
          <!-- INVESTIGATION: Subordinates still not counted - may be vanilla limitation (excludes ships with commanders) -->
          <!-- Vanilla TradeRoutine pattern: internal="not $blacklist_override?" (usually false) -->
          <!-- NOTE: Even with internal="false", vanilla may exclude subordinates from credits due count -->
          <!-- This appears to be a vanilla design decision - subordinates' finances are part of commander's finances -->
          <set_value name="$tradeOrderInternal" exact="false"/>

          <!-- AUTHORITATIVE MinPlayerMoney guard â€” BUDGET CLAMP (race-free) -->
          <!-- This runs in the AI script with NO yield between check and create_trade_order,
               so player.money is guaranteed to reflect all prior create_trade_order deductions.
               Mechanic 1: If the full trade would drain below MinPlayerMoney, reduce volume
               to fit (player.money - MinPlayerMoney). If even 1 unit is unaffordable, block
               and back off via no_trade_retry with insufficient_funds. -->
          <set_value name="$aiBuyPrice" exact="0"/>
          <do_if value="$pendingTrade.$BuyPrice?">
            <set_value name="$aiBuyPrice" exact="$pendingTrade.$BuyPrice"/>
          </do_if>
          <do_elseif value="$pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.unitprice?">
            <set_value name="$aiBuyPrice" exact="$pendingTrade.$BuyOffer.unitprice"/>
          </do_elseif>
          <set_value name="$aiPurchaseCost" exact="if $isSellOnlyTradeForPending then 0 else ($aiBuyPrice * $finalBuyAmount)"/>
          <set_value name="$aiMinPlayerMoney" exact="this.$minPlayerMoney"/>
          <do_if value="(player.money - $aiPurchaseCost) lt ($aiMinPlayerMoney)Cr">
            <!-- Full clamped amount would drain below MinPlayerMoney.
                 Try to reduce amount further to fit the available budget.
                 availableBudget = player.money - MinPlayerMoney (in cents). -->
            <do_if value="not $isSellOnlyTradeForPending and $aiBuyPrice gt 0">
              <set_value name="$aiAvailableBudget" exact="player.money - ($aiMinPlayerMoney)Cr"/>
              <set_value name="$aiAffordableUnits" exact="$aiAvailableBudget / $aiBuyPrice"/>
              <do_if value="$aiAffordableUnits ge 1">
                <!-- Player can afford a reduced amount - clamp and proceed -->
                <set_value name="$finalBuyAmount" exact="$aiAffordableUnits"/>
                <set_value name="$finalSellAmount" exact="$aiAffordableUnits"/>
                <set_value name="$aiPurchaseCost" exact="$aiBuyPrice * $aiAffordableUnits"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': BUDGET CLAMP (authoritative guard): reduced from original to ' + $aiAffordableUnits + ' units, cost=' + ($aiPurchaseCost / 100) + ' Cr, player.money=' + (player.money / 100) + ' Cr, remaining=' + ((player.money - $aiPurchaseCost) / 100) + ' Cr (threshold: ' + $aiMinPlayerMoney + ' Cr)'" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- Can't afford even 1 unit - truly insufficient funds -->
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': BLOCKED trade (authoritative guard): player.money=' + (player.money / 100) + ' Cr, unitPrice=' + ($aiBuyPrice / 100) + ' Cr -- cannot afford even 1 unit above MinPlayerMoney threshold (' + $aiMinPlayerMoney + ' Cr)'" chance="100"/>
                </do_if>
                <!-- GLOBAL MONEY CAP: If even 1 unit is unaffordable, stop ALL ships from searching.
                     Record player.money so the flag auto-clears when money increases from any source. -->
                <set_value name="global.$GT_MoneyCapActive" exact="true"/>
                <set_value name="global.$GT_MoneyCapMoney" exact="player.money"/>
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GLOBAL MONEY CAP SET: player.money=' + (player.money / 100) + ' Cr â€” all ships blocked until money increases'" chance="100"/>
                <set_value name="this.$lastNoTradeReason" exact="'insufficient_funds'"/>
                <resume label="no_trade_retry"/>
              </do_else>
            </do_if>
            <do_else>
              <!-- Sell-only trade should never fail this check (cost=0), but block as safety -->
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': BLOCKED trade (authoritative guard, edge case): player.money=' + (player.money / 100) + ' Cr, purchaseCost=' + ($aiPurchaseCost / 100) + ' Cr -- below MinPlayerMoney threshold (' + $aiMinPlayerMoney + ' Cr)'" chance="100"/>
              </do_if>
              <set_value name="global.$GT_MoneyCapActive" exact="true"/>
              <set_value name="global.$GT_MoneyCapMoney" exact="player.money"/>
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GLOBAL MONEY CAP SET: player.money=' + (player.money / 100) + ' Cr â€” all ships blocked until money increases'" chance="100"/>
              <set_value name="this.$lastNoTradeReason" exact="'insufficient_funds'"/>
              <resume label="no_trade_retry"/>
            </do_else>
          </do_if>

          <do_if value="$pendingTrade.$SellOffer?">
            <create_trade_order object="this.ship" tradeoffer="$pendingTrade.$SellOffer" amount="$finalSellAmount" immediate="true" internal="$tradeOrderInternal"/>
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$sellOfferAmountAfterOrder" exact="@$pendingTrade.$SellOffer.offeramount.{this.assignedcontrolled}"/>
              <set_value name="$sellDesiredAfterOrder" exact="@$pendingTrade.$SellOffer.desiredamount"/>
              <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': after create_trade_order SELL' +
                '\n  orderAmount=' + $finalSellAmount +
                '\n  sell offeramount(ship)=' + (if $sellOfferAmountAfterOrder? then $sellOfferAmountAfterOrder else 'null') +
                '\n  sell desiredamount=' + (if $sellDesiredAfterOrder? then $sellDesiredAfterOrder else 'null')"
                chance="100"/>
            </do_if>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Created SELL trade order (internal=' + $tradeOrderInternal + ', isSubordinate=' + $isSubordinate + ', hasCommander=' + (if this.ship.commander? and this.ship.commander.exists then 'true' else 'false') + ')'" chance="100"/>
            </do_if>
          </do_if>
          <do_if value="not $isSellOnlyTradeForPending and $pendingTrade.$BuyOffer?">
            <create_trade_order object="this.ship" tradeoffer="$pendingTrade.$BuyOffer" amount="$finalBuyAmount" immediate="true" internal="$tradeOrderInternal"/>
            <do_if value="@global.$GT_Config.$Debug.$Enabled and @global.$GT_Config.$Debug.$TradeSearch and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$buyOfferAmountAfterOrder" exact="@$pendingTrade.$BuyOffer.offeramount.{this.assignedcontrolled}"/>
              <set_value name="$buyDesiredAfterOrder" exact="@$pendingTrade.$BuyOffer.desiredamount"/>
              <debug_text text="'[GT-Reserve] ' + this.ship.idcode + ': after create_trade_order BUY' +
                '\n  orderAmount=' + $finalBuyAmount +
                '\n  buy offeramount(ship)=' + (if $buyOfferAmountAfterOrder? then $buyOfferAmountAfterOrder else 'null') +
                '\n  buy desiredamount=' + (if $buyDesiredAfterOrder? then $buyDesiredAfterOrder else 'null')"
                chance="100"/>
            </do_if>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Created BUY trade order (internal=' + $tradeOrderInternal + ', isSubordinate=' + $isSubordinate + ', hasCommander=' + (if this.ship.commander? and this.ship.commander.exists then 'true' else 'false') + ')'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Purge trades awaiting validation after we successfully queued trade orders.
               Keeping them causes stale execution via old trade data. -->
          <do_if value="global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidation.{this.ship}"/>
          </do_if>
          <do_if value="global.$GT_TradesAwaitingValidationTimestamp? and global.$GT_TradesAwaitingValidationTimestamp.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidationTimestamp.{this.ship}"/>
          </do_if>
          <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
          </do_if>
          <!-- Clear interrupt flag when clearing trades awaiting validation (trades successfully processed) -->
          <set_value name="this.$tradeFoundViaInterrupt" exact="false"/>

          <!-- Add state update signal AFTER order creation -->
          <!-- This tests if sending a signal immediately after create_trade_order interferes with TradePerform initialization -->
          <!-- NOTE: No handler exists yet (Phase 3) - signal will be sent but not processed -->
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'Trade_Order_Created',
            $TradeOrderCount = this.ship.tradeorders.count
          ]"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': PHASE 2: State update signal sent (Trade_Order_Created)'" chance="100"/>
            
            <!-- Handle sell-only trades in debug output -->
              <set_value name="$buyOrderText" exact="if $isSellOnlyTradeForPending then 'N/A (sell-only - ship already has cargo)' else (if $buyStationForPending? then @$buyStationForPending.knownname + ' â†’ ' + (if $wareForPendingTrade? then @$wareForPendingTrade.name else 'Unknown') + ' (x' + $finalBuyAmount + ')' else 'Unknown')"/>
            <set_value name="$sellOrderText" exact="if $sellStationForPending? then @$sellStationForPending.knownname else 'Unknown'"/>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade orders created:' +
              '\n  BUY: ' + $buyOrderText +
              '\n  SELL: ' + $sellOrderText"
              chance="100"/>
          </do_if>
          
          <!-- Send logbook message when ship is escaping from blacklisted sector -->
          <set_value name="$isEscapeTrade" exact="false"/>
          <do_if value="$currentSectorIsBlacklisted">
            <!-- Check if trade leads to a different sector (escape route) -->
            <set_value name="$isEscapeTrade" exact="($buySector != $currentSector) or ($sellSector != $currentSector)"/>
          </do_if>
          
          <do_if value="$isEscapeTrade">
            <!-- Set escape flag for ship naming -->
            <do_if value="global.$GT_Ships?">
              <do_if value="not global.$GT_Ships.{this.ship}?">
                <set_value name="global.$GT_Ships.{this.ship}" exact="table[]"/>
              </do_if>
              <set_value name="global.$GT_Ships.{this.ship}.$Escaping" exact="true"/>
            </do_if>
            <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship=this.ship,
                $pilot=this.ship.pilot,
                $xp=global.$GT_Pilots.{this.ship.pilot}.$XP,
                $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                $nameType='trader'
              ]"/>
            </do_if>

            <!-- Build escape route message using translation -->
            <!-- Extract values safely with null checks -->
            <set_value name="$escapeWare" exact="null"/>
            <set_value name="$escapeAmount" exact="0"/>
            <set_value name="$escapeProfit" exact="0"/>
            
            <!-- Extract ware from BuyOffer (more reliable than $Ware property) -->
            <do_if value="$pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.ware?">
              <set_value name="$escapeWare" exact="$pendingTrade.$BuyOffer.ware.name"/>
            </do_if>
            <do_elseif value="$pendingTrade.$Ware?">
              <set_value name="$escapeWare" exact="$pendingTrade.$Ware.name"/>
            </do_elseif>
            
            <!-- Extract amount -->
            <set_value name="$escapeAmount" exact="if $isSellOnlyTradeForPending then $finalSellAmount else $finalBuyAmount"/>
            
            <!-- Extract profit -->
            <do_if value="$pendingTrade.$Profit?">
              <set_value name="$escapeProfit" exact="$pendingTrade.$Profit"/>
            </do_if>
            
            <!-- Safe defaults for missing values -->
            <set_value name="$currentSectorName" exact="'Unknown Sector'"/>
            <do_if value="$currentSector?">
              <set_value name="$currentSectorNameTemp" exact="@$currentSector.knownname"/>
              <do_if value="$currentSectorNameTemp?">
                <set_value name="$currentSectorName" exact="$currentSectorNameTemp"/>
              </do_if>
            </do_if>
            
            <set_value name="$buyStationName" exact="'Unknown Station'"/>
            <do_if value="$buyStation?">
              <set_value name="$buyStationNameTemp" exact="@$buyStation.knownname"/>
              <do_if value="$buyStationNameTemp?">
                <set_value name="$buyStationName" exact="$buyStationNameTemp"/>
              </do_if>
            </do_if>
            
            <set_value name="$buySectorName" exact="'Unknown Sector'"/>
            <do_if value="$buySector?">
              <set_value name="$buySectorNameTemp" exact="@$buySector.knownname"/>
              <do_if value="$buySectorNameTemp?">
                <set_value name="$buySectorName" exact="$buySectorNameTemp"/>
              </do_if>
            </do_if>
            
            <set_value name="$sellStationName" exact="'Unknown Station'"/>
            <do_if value="$sellStation?">
              <set_value name="$sellStationNameTemp" exact="@$sellStation.knownname"/>
              <do_if value="$sellStationNameTemp?">
                <set_value name="$sellStationName" exact="$sellStationNameTemp"/>
              </do_if>
            </do_if>
            
            <set_value name="$sellSectorName" exact="'Unknown Sector'"/>
            <do_if value="$sellSector?">
              <set_value name="$sellSectorNameTemp" exact="@$sellSector.knownname"/>
              <do_if value="$sellSectorNameTemp?">
                <set_value name="$sellSectorName" exact="$sellSectorNameTemp"/>
              </do_if>
            </do_if>
            
            <set_value name="$wareInfo" exact="'Unknown Ware'"/>
            <do_if value="$escapeWare?">
              <set_value name="$wareInfo" exact="$escapeWare"/>
            </do_if>
            
            <!-- Build message using translation ID 3210 with 8 parameters -->
            <!-- Parameters: currentSector, buyStation, buySector, sellStation, sellSector, ware, amount, profit -->
            <set_value name="$escapeMessage" exact="{77000,3210}.[$currentSectorName,$buyStationName,$buySectorName,$sellStationName,$sellSectorName,$wareInfo,$escapeAmount,($escapeProfit / 100)]"/>
            
            <!-- Log the message being written -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE ROUTE LOGBOOK DEBUG:' + '\n  Current Sector: ' + $currentSectorName + '\n  Buy: ' + $buyStationName + ' (' + $buySectorName + ')' + '\n  Sell: ' + $sellStationName + ' (' + $sellSectorName + ')' + '\n  Ware: ' + $wareInfo + ' (x' + $escapeAmount + ')' + '\n  Profit: ' + ($escapeProfit / 100) + ' Cr'" chance="100"/>
            </do_if>
            
            <!-- Log the full message text that will be written to logbook -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE ROUTE LOGBOOK MESSAGE:' + '\n' + $escapeMessage" chance="100"/>
            </do_if>
            
            <!-- Construct logbook message using TextDB syntax (vanilla pattern) -->
            <set_value name="$logbookMessage" exact="{77000,3210}.[$currentSectorName,$buyStationName,$buySectorName,$sellStationName,$sellSectorName,$wareInfo,$escapeAmount,($escapeProfit / 100)]"/>
            
            <!-- Write to ship logbook -->
            <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
              $Message = $logbookMessage,
              $Category = 'general',
              $Title = 'Escape Route: ' + this.ship.knownname,
              $Object = this.ship,
              $Interaction = 'showonmap',
              $CheckGlobalSettings = false
            ]"/>
            
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Escape route logbook entry created'" chance="100"/>
            </do_if>
          </do_if>
          
          <!-- Log to ship logbook if enabled (moved from MD execution to after validation) -->
          <set_value name="$logbookEnabled" exact="false"/>
          <do_if value="@this.ship.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.defaultorder.$logbookentries">
            <set_value name="$logbookEnabled" exact="true"/>
          </do_if>
          <do_elseif value="@this.ship.defaultorder.id == 'Assist' and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.commander.defaultorder.$logbookentries">
            <set_value name="$logbookEnabled" exact="true"/>
          </do_elseif>
          
          <do_if value="$logbookEnabled">
            <set_value name="$logAmount" exact="if $isSellOnlyTradeForPending then $finalSellAmount else $finalBuyAmount"/>
            
            <!-- PROFIT DEBUG: Log trade data before sending to logbook -->
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <set_value name="$wareName" exact="if $pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.ware? then @$pendingTrade.$BuyOffer.ware.name else (if $pendingTrade.$SellOffer? and $pendingTrade.$SellOffer.ware? then @$pendingTrade.$SellOffer.ware.name else 'NULL')"/>
              <set_value name="$buyStationName" exact="if $pendingTrade.$BuyStation? then @$pendingTrade.$BuyStation.knownname else (if $pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.owner? then @$pendingTrade.$BuyOffer.owner.knownname else 'NULL')"/>
              <set_value name="$sellStationName" exact="if $pendingTrade.$SellStation? then @$pendingTrade.$SellStation.knownname else (if $pendingTrade.$SellOffer? and $pendingTrade.$SellOffer.owner? then @$pendingTrade.$SellOffer.owner.knownname else 'NULL')"/>
              <set_value name="$originalAmount" exact="if $pendingTrade.$Amount? then $pendingTrade.$Amount else 'NULL'"/>
              <!-- Safe access to BuyPrice/SellPrice - may not exist in older trade objects -->
              <set_value name="$buyPrice" exact="if $pendingTrade.$BuyPrice? then $pendingTrade.$BuyPrice else (if $pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.unitprice? then $pendingTrade.$BuyOffer.unitprice else 0)"/>
              <set_value name="$sellPrice" exact="if $pendingTrade.$SellPrice? then $pendingTrade.$SellPrice else (if $pendingTrade.$SellOffer? and $pendingTrade.$SellOffer.unitprice? then $pendingTrade.$SellOffer.unitprice else 0)"/>
              <debug_text text="'[GT-AI-PROFIT] (' + this.ship.idcode + ') LOGBOOK ENTRY PREPARATION:' + 
                '\n  Ware: ' + $wareName +
                '\n  Buy Station: ' + $buyStationName + ' @ ' + ($buyPrice/100) + ' Cr (RAW: ' + $buyPrice + ')' +
                '\n  Sell Station: ' + $sellStationName + ' @ ' + ($sellPrice/100) + ' Cr (RAW: ' + $sellPrice + ')' +
                '\n  Original Amount (from trade): ' + $originalAmount + ' units' +
                '\n  Final Buy Amount (clamped): ' + $finalBuyAmount + ' units' +
                '\n  Final Sell Amount (clamped): ' + $finalSellAmount + ' units' +
                '\n  Log Amount (used for display): ' + $logAmount + ' units' +
                '\n  Profit (RAW): ' + (if $pendingTrade.$Profit? then $pendingTrade.$Profit else 'NULL') + ' = ' + (if $pendingTrade.$Profit? then ($pendingTrade.$Profit/100) + ' Cr' else 'NULL') +
                '\n  Verification with original amount: (' + ($sellPrice/100) + ' - ' + ($buyPrice/100) + ') * ' + $originalAmount + ' = ' + (if $originalAmount != 'NULL' then (($sellPrice - $buyPrice) * $originalAmount / 100) + ' Cr' else 'N/A') +
                '\n  Verification with log amount: (' + ($sellPrice/100) + ' - ' + ($buyPrice/100) + ') * ' + $logAmount + ' = ' + (($sellPrice - $buyPrice) * $logAmount / 100) + ' Cr'" chance="100"/>
            </do_if>
            
            <!-- Safe access to BuyPrice/SellPrice - may not exist in older trade objects -->
            <set_value name="$buyPriceForSignal" exact="if $pendingTrade.$BuyPrice? then ($pendingTrade.$BuyPrice / 100) else (if $pendingTrade.$BuyOffer? and $pendingTrade.$BuyOffer.unitprice? then ($pendingTrade.$BuyOffer.unitprice / 100) else 0)"/>
            <set_value name="$sellPriceForSignal" exact="if $pendingTrade.$SellPrice? then ($pendingTrade.$SellPrice / 100) else (if $pendingTrade.$SellOffer? and $pendingTrade.$SellOffer.unitprice? then ($pendingTrade.$SellOffer.unitprice / 100) else 0)"/>
            
            <signal_objects object="player.galaxy" param="'GT_TradeLogging_LogTradeOrder'" param2="table[
              $Ship = this.ship,
              $BuyOffer = $pendingTrade.$BuyOffer,
              $SellOffer = $pendingTrade.$SellOffer,
              $Amount = $logAmount,
              $Profit = if $pendingTrade.$Profit? then $pendingTrade.$Profit else 0,
              $BuyPrice = $buyPriceForSignal,
              $SellPrice = $sellPriceForSignal,
              $IsSellOnly = $isSellOnlyTradeForPending
            ]"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Logbook entry queued (sell-only: ' + $isSellOnlyTradeForPending + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
        <do_else>
          <!-- All trades in list were rejected - check reason -->
          <!-- Use safe access for variables that might not exist -->
          <set_value name="$tradesRejectedPathSafe" exact="if $tradesRejectedPath? then $tradesRejectedPath else 0"/>
          <set_value name="$tradesRejectedDockingSafe" exact="if $tradesRejectedDocking? then $tradesRejectedDocking else 0"/>
          <set_value name="$tradesRejectedOfferInvalidSafe" exact="if $tradesRejectedOfferInvalid? then $tradesRejectedOfferInvalid else 0"/>
          <set_value name="$tradesRejectedDistanceSafe" exact="if $tradesRejectedDistance? then $tradesRejectedDistance else 0"/>
          <set_value name="$tradesRejectedCargoSafe" exact="if $tradesRejectedCargo? then $tradesRejectedCargo else 0"/>
          <set_value name="$tradesBlacklistedSafe" exact="if $tradesBlacklisted? then $tradesBlacklisted else 0"/>
          <!-- Use safe access for $tradeList.count -->
          <set_value name="$tradeListCountSafe" exact="if $tradeList != null then $tradeList.count else 0"/>
          
          <!-- Search method already captured earlier in trade_found label -->
          <!-- (from cache, signal param2, or global storage) -->
          
          <!-- Enhanced logging for cache trade rejections -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$searchSource" exact="if $searchMethod == 'cache' then 'CACHE' else if $searchMethod == 'live' then 'LIVE' else 'UNKNOWN'"/>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ALL ' + $tradeListCountSafe + ' trades from ' + $searchSource + ' were rejected:' +
              '\n  Path blocked: ' + $tradesRejectedPathSafe +
              '\n  Docking denied: ' + $tradesRejectedDockingSafe +
              '\n  Offer invalid: ' + $tradesRejectedOfferInvalidSafe +
              '\n  Distance unreachable: ' + $tradesRejectedDistanceSafe +
              '\n  Cargo insufficient: ' + $tradesRejectedCargoSafe +
              '\n  Blacklisted: ' + $tradesBlacklistedSafe +
              '\n  Total rejected: ' + $tradeListCountSafe +
              (if $searchMethod == 'cache' then '\n  âš  CACHE STALE: All cached trades invalid - likely offers changed or stations became unreachable' else '') +
              ' - entering retry logic'" chance="100"/>
          </do_if>
          
          <!-- CRITICAL:
               If ALL trades were rejected (often because offers changed), we MUST purge trades awaiting validation.
               Otherwise the ship can loop forever on stale global.$GT_TradesAwaitingValidation.{this.ship} and never request fresh trades. -->
          <do_if value="global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidation.{this.ship}"/>
          </do_if>
          <do_if value="global.$GT_TradesAwaitingValidationTimestamp? and global.$GT_TradesAwaitingValidationTimestamp.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidationTimestamp.{this.ship}"/>
          </do_if>
          <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
            <remove_value name="global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
          </do_if>
          <!-- Clear interrupt flag when clearing trades awaiting validation to prevent re-entry loop -->
          <set_value name="this.$tradeFoundViaInterrupt" exact="false"/>
          <!-- Reduce escalating backoff after purging stale results: next retry will start at 10s again -->
          <set_value name="this.$searchFailed" exact="0"/>
          
          <!-- If ALL trades rejected due to cargo space, trigger cargo disposal -->
          <!-- Use safe access for variable check -->
          <do_if value="$tradesRejectedCargoSafe gt 0 and $tradesRejectedCargoSafe == $tradeListCountSafe">
            <set_value name="$hasCargo" exact="this.ship.cargo.free.all lt this.ship.cargo.capacity.all"/>
            <do_if value="$hasCargo">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ':  ALL trades rejected due to insufficient cargo space - triggering cargo disposal'" chance="100"/>
              </do_if>
              <!-- Ship has cargo but not enough space for any trade - find buyer for existing cargo -->
              <signal_objects object="player.galaxy" param="'GT_Find_Sell'" param2="table[
                $Ship = this.ship,
                $IgnoreCarrierAux = $effectiveIgnoreCarrierAux,
                $IgnoreBuildStorage = $effectiveIgnoreBuildStorage,
                $IgnoreTradeRules = $effectiveIgnoreTradeRules
              ]"/>
              <!-- Wait for cargo sale to complete before retrying -->
              <resume label="main_loop"/>
            </do_if>
          </do_if>

          <!-- ESCAPE FALLBACK (trade list exists but none can move us out safely):
               If we are in a blacklisted sector and we have no non-blacklisted escape trade, force a move toward home. -->
          <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
          <set_value name="$currentSector" exact="this.ship.sector"/>
          <set_value name="$needsEscape" exact="false"/>
          <do_if value="$currentSector? and $currentSector.exists">
            <set_value name="$curActivityBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
            <set_value name="$curTravelBL" exact="@$currentSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
            <set_value name="$needsEscape" exact="$curActivityBL or $curTravelBL"/>
          </do_if>
          <do_if value="$needsEscape and ($tradeListCountSafe == 0 or $tradesBlacklistedSafe == $tradeListCountSafe)">
            <!-- Set escape flag for ship naming -->
            <do_if value="global.$GT_Ships?">
              <do_if value="not global.$GT_Ships.{this.ship}?">
                <set_value name="global.$GT_Ships.{this.ship}" exact="table[]"/>
              </do_if>
              <set_value name="global.$GT_Ships.{this.ship}.$Escaping" exact="true"/>
            </do_if>
            <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
              <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
                $ship=this.ship,
                $pilot=this.ship.pilot,
                $xp=global.$GT_Pilots.{this.ship.pilot}.$XP,
                $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
                $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
                $nameType='trader'
              ]"/>
            </do_if>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE FALLBACK: No valid escape trade found (all trades blacklisted) - moving toward home sector'" chance="100"/>
            </do_if>
            <resume label="escape_from_blacklisted"/>
          </do_if>
          
          <!-- Check if trades came from cache - if so, trigger live search instead of retrying cache -->
          <do_if value="$searchMethod == 'cache'">
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': All cached trades rejected - triggering LIVE market search instead of retrying cache' +
                '\n  Rejection breakdown: Path=' + $tradesRejectedPathSafe + ', Docking=' + $tradesRejectedDockingSafe + ', OfferInvalid=' + $tradesRejectedOfferInvalidSafe + ', Distance=' + $tradesRejectedDistanceSafe + ', Cargo=' + $tradesRejectedCargoSafe + ', Blacklist=' + $tradesBlacklistedSafe +
                '\n  âš  CACHE STALE: All ' + $tradeListCountSafe + ' cached trades invalid - likely offers changed, stations became unreachable, or docking permissions revoked'" chance="100"/>
            </do_if>
            <!-- Send signal to force live search (bypass cache) -->
            <!-- Include MaxBuy/MaxSell - use effective values if available, otherwise use defaults from order params -->
            <set_value name="$signalMaxBuy" exact="$maxbuy"/>
            <set_value name="$signalMaxSell" exact="$maxsell"/>
            <do_if value="this.$effectiveMaxBuy?">
              <set_value name="$signalMaxBuy" exact="this.$effectiveMaxBuy"/>
            </do_if>
            <do_if value="this.$effectiveMaxSell?">
              <set_value name="$signalMaxSell" exact="this.$effectiveMaxSell"/>
            </do_if>
            <!-- effectiveIgnoreCarrierAux/BuildStorage/TradeRules initialized in <init> -->
            
            <signal_objects object="player.galaxy" param="'GT_Find_Trade'" param2="table[
              $Ship = this.ship,
              $HomeBase = this.$effectiveHome,
              $MaxBuy = $signalMaxBuy,
              $MaxSell = $signalMaxSell,
              $IgnoreCarrierAux = $effectiveIgnoreCarrierAux,
              $IgnoreBuildStorage = $effectiveIgnoreBuildStorage,
              $IgnoreTradeRules = $effectiveIgnoreTradeRules,
              $ForceLiveSearch = true
            ]"/>
            <!-- CRITICAL: Resume to wait_for_response instead of main_loop -->
            <!-- This ensures the ship waits for the live search result instead of sending a duplicate request -->
            <!-- The wait block will catch GT_Trade_Found signal when live search completes -->
            <resume label="wait_for_response"/>
          </do_if>
          <do_else>
            <!-- Trades came from live search or search method unknown - use normal retry -->
            <resume label="no_trade_retry"/>
          </do_else>
        </do_else>
      
      <!-- Stability: vanilla-style micro-yield after creating trade orders -->
      <!-- NOTE: wait must be at top level (not inside any do_if/do_else) -->
      <wait exact="1ms"/>
      
      <!-- Non-blocking XP update signal -->
      <do_if value="this.ship.pilot">
        <signal_objects object="player.galaxy" param="'GT_Update_Pilot_XP'" param2="table[
          $Ship = this.ship,
          $Pilot = this.ship.pilot
        ]"/>
      </do_if>
      
      <!-- Set ship to trading state -->
      <set_command command="command.trade"/>
      
      <!-- Wait for trade completion or failure signal from diff patch (event-driven, no polling) -->
      <wait max="300s" comment="Wait for trade completion or failure signal">
        <interrupt>
          <conditions>
            <check_any>
              <event_object_signalled object="this.ship" param="'GT_Trade_Completed'"/>
              <event_object_signalled object="this.ship" param="'GT_Trade_Failed'"/>
            </check_any>
          </conditions>
          <actions>
            <!-- Check which signal was received -->
            <do_if value="event.param == 'GT_Trade_Completed'">
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] Trade completed signal received for ' + this.ship.idcode" chance="100"/>
              </do_if>
              <set_value name="this.$tradeComplete" exact="true"/>
              
              <!-- Restore XPBlocked if BlockedLevel still exists (training stations may have become available) -->
              <do_if value="this.ship.pilot and global.$GT_Pilots.{this.ship.pilot}?">
                <do_if value="global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel? and not global.$GT_Pilots.{this.ship.pilot}.$XPBlocked?">
                  <set_value name="global.$GT_Pilots.{this.ship.pilot}.$XPBlocked" exact="true"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                    <debug_text text="'[GT-AI] ðŸ”’ Restored XPBlocked for pilot ' + this.ship.pilot.name + ' after trade completion (BlockedLevel: ' + global.$GT_Pilots.{this.ship.pilot}.$BlockedLevel + ')'" chance="100"/>
                  </do_if>
                </do_if>
              </do_if>
            </do_if>
            <do_elseif value="event.param == 'GT_Trade_Failed'">
              <!-- CRITICAL: Check current state before clearing flags on trade failure -->
              <!-- Fallback flag: Always clear on trade failure (fallback is only active during trade execution) -->
              <!-- Isolated flag: Will be checked by batch processor on next state check -->
              <!-- Clear fallback flag on trade failure (fallback is only active during trade execution) -->
              <do_if value="global.$GT_FallbackTradeActive? and global.$GT_FallbackTradeActive.{this.ship}?">
                <remove_value name="global.$GT_FallbackTradeActive.{this.ship}"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] (' + this.ship.idcode + ') Cleared [FALLBACK] flag - trade failed'" chance="100"/>
                </do_if>
              </do_if>
              
              <!-- Note: Isolated flag state will be verified by batch processor on next state check -->
              <!-- The batch processor (GT_CheckAndHandleIsolation) checks actual isolation state and clears flag if ship is no longer isolated -->
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] (' + this.ship.idcode + ') Trade failed - cleared [FALLBACK] flag, isolation state will be checked by batch processor'" chance="100"/>
              </do_if>
              <!-- Read structured payload (with legacy guard for backward compatibility) -->
              <set_value name="$failurePayload" exact="event.param2"/>
              
              <!-- Handle legacy payloads (string) vs new structured payloads (table) -->
              <set_value name="$isLegacyPayload" exact="false"/>
              <do_if value="typeof $failurePayload == datatype.string">
                <set_value name="$isLegacyPayload" exact="true"/>
                <set_value name="this.$failureReason" exact="$failurePayload"/>
                <set_value name="this.$tradeFailed" exact="true"/>
                <set_value name="this.$tryNextTrade" exact="false"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                  <debug_text text="'[GT-AI] Trade failed (legacy payload) for ' + this.ship.idcode + ': ' + this.$failureReason" chance="100"/>
                </do_if>
              </do_if>
              <do_else>
                <!-- New structured payload -->
                <!-- Extract properties with safe access, then check if they exist -->
                <set_value name="$reasonTypeValue" exact="@$failurePayload.$ReasonType"/>
                <set_value name="$shouldTryNextValue" exact="@$failurePayload.$ShouldTryNext"/>
                <set_value name="$reasonType" exact="if $reasonTypeValue? then $reasonTypeValue else 'MARKET'"/>
                <set_value name="$shouldTryNext" exact="if $shouldTryNextValue? then $shouldTryNextValue else false"/>
                
                <set_value name="this.$failureReason" exact="$failurePayload.$Reason"/>
                <set_value name="this.$tradeFailed" exact="true"/>
                <set_value name="this.$tryNextTrade" exact="$shouldTryNext"/>
                
                <do_if value="$shouldTryNext">
                  <debug_text text="'[GT-AI] Pathfinding failed for ' + this.ship.idcode + ': ' + this.$failureReason + ' - trying next cached alternative'" chance="100"/>
                </do_if>
                <do_else>
                  <debug_text text="'[GT-AI] Trade failed for ' + this.ship.idcode + ': ' + this.$failureReason + ' - will search for new trade'" chance="100"/>
                </do_else>
              </do_else>
            </do_elseif>
            <resume label="trade_completed"/>
          </actions>
        </interrupt>
      </wait>
      
      <!-- Timeout fallback -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade completion timeout after 300s - resuming anyway'" chance="100"/>
      </do_if>
      
      <label name="trade_completed"/>
      
      <!-- NOTE: Global money cap (global.$GT_MoneyCapActive) auto-clears in the early money gate
           when player.money rises above global.$GT_MoneyCapMoney. No per-ship clearing needed. -->
      
      <!-- CRITICAL: Clear trades awaiting validation after trade execution completes -->
      <!-- This ensures ships always check cache first on next search, not stale pending trades -->
      <do_if value="global.$GT_TradesAwaitingValidation? and global.$GT_TradesAwaitingValidation.{this.ship}?">
        <remove_value name="global.$GT_TradesAwaitingValidation.{this.ship}"/>
      </do_if>
      <do_if value="global.$GT_TradesAwaitingValidationTimestamp? and global.$GT_TradesAwaitingValidationTimestamp.{this.ship}?">
        <remove_value name="global.$GT_TradesAwaitingValidationTimestamp.{this.ship}"/>
      </do_if>
      <do_if value="global.$GT_TradesAwaitingValidationSearchMethod? and global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}?">
        <remove_value name="global.$GT_TradesAwaitingValidationSearchMethod.{this.ship}"/>
      </do_if>
      <!-- Clear active trade tracking -->
      <do_if value="global.$GT_ActiveTrade? and global.$GT_ActiveTrade.{this.ship}?">
        <remove_value name="global.$GT_ActiveTrade.{this.ship}"/>
      </do_if>
      
      <!-- ======================================= -->
      <!-- PILOT CHANGE DETECTION (After Trade)   -->
      <!-- ======================================= -->
      <!-- Check for pilot changes after successful trade completion -->
      <!-- This is a natural restart point where the GT default order reruns -->
      <set_value name="$currentPilot" exact="this.ship.pilot"/>
      <do_if value="this.$trackedPilot? and $currentPilot != this.$trackedPilot">
        <!-- Pilot changed! Send signal to MD system -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': PILOT CHANGE DETECTED after trade completion! Old: ' + @this.$trackedPilot.name + ', New: ' + @$currentPilot.name" chance="100"/>
        </do_if>
        
        <signal_objects object="player.galaxy" param="'GT_Update_Ship'" param2="table[
          $updateType = 'pilot_change',
          $ship = this.ship,
          $pilot = $currentPilot,
          $oldPilot = this.$trackedPilot
        ]"/>
      </do_if>
      <!-- Update tracked pilot (always, even if no change) -->
      <set_value name="this.$trackedPilot" exact="$currentPilot"/>
      
      <!-- CRITICAL: Check if pilot is missing (pilot was transferred away) -->
      <!-- If GT order is running but ship has no pilot, cleanup and self-cancel -->
      <do_if value="not $currentPilot">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': MISSING PILOT DETECTED after trade completion - pilot was transferred away, cleaning up and self-canceling GT order'" chance="100"/>
        </do_if>
        
        <!-- Get original ship name from ship registry -->
        <set_value name="$originalName" exact="null"/>
        <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$OriginalShipName?">
          <set_value name="$originalName" exact="global.$GT_Ships.{this.ship}.$OriginalShipName"/>
        </do_if>
        
        <!-- Send cleanup signal (name restoration handled by MD system) -->
        <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
          $Ship = this.ship,
          $Pilot = null,
          $Reason = 'Pilot transferred away - GT order cannot run without pilot',
          $OriginalName = $originalName
        ]"/>
        
        <!-- Cancel all active orders (trade orders, etc.) -->
        <cancel_all_orders object="this.ship"/>
        
        <!-- Self-cancel GT order -->
        <cancel_order order="this.ship.defaultorder"/>
        <return/>
      </do_if>
      
      <!-- Check if this is a pathfinding retry (try next cached alternative) -->
      <do_if value="this.$tryNextTrade?">
        <remove_value name="this.$tryNextTrade"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Immediately requesting next trade (cache will skip failed trades)'" chance="100"/>
        </do_if>
        <!-- Skip market update wait - immediately try next cached trade -->
        <resume label="main_loop"/>
      </do_if>
      
      <!-- NOTE: Auto-repair check has been moved to MD system (gt_trading_ai.xml TradeCompleted cue) -->
      <!-- This ensures it runs even when the order is aborted/replaced during trade execution -->
      
      <!-- Update market data interval -->
      <wait max="$gt_marketupdatefreq">
        <interrupt>
          <conditions>
            <check_any>
              <event_object_signalled object="this.ship" param="'GT_Trade_Found'" comment="New trade found"/>
              <event_object_signalled object="this.ship" param="'GT_No_Trade_Found'" comment="Wake-up signal"/>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Signal received during market update wait - resuming immediately'" chance="100"/>
          </actions>
        </interrupt>
      </wait>
      <resume label="main_loop"/>
      
      <!-- ========================================= -->
      <!-- NO TRADE FOUND - ESCALATING RETRY LOGIC  -->
      <!-- ========================================= -->
      <label name="escape_from_blacklisted"/>
      
      <!-- Determine home sector -->
      <set_value name="$homeBase" exact="this.$effectiveHome"/>
      <set_value name="$homeSector" exact="null"/>
      <do_if value="$homeBase? and $homeBase.exists">
        <do_if value="$homeBase.isclass.station">
          <set_value name="$homeSector" exact="$homeBase.sector"/>
        </do_if>
        <do_elseif value="$homeBase.isclass.sector">
          <set_value name="$homeSector" exact="$homeBase"/>
        </do_elseif>
      </do_if>
      <do_if value="not $homeSector? or not $homeSector.exists">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE FALLBACK: Home sector not available - cannot escape, continuing retry logic'" chance="100"/>
        </do_if>
        <resume label="no_trade_retry"/>
      </do_if>
      
      <set_value name="$currentSector" exact="this.ship.sector"/>
      <do_if value="$currentSector == $homeSector">
        <!-- Already in home sector; just retry normally -->
        <resume label="main_loop"/>
      </do_if>
      
      <!-- Use cached blacklist group from init -->
      <set_value name="$blacklistgroup" exact="this.$blacklistgroup"/>
      
      <!-- Build a jump path to home (ignoring blacklist so we can walk 'toward home') -->
      <get_jump_path component="$jumppath" multiple="true" uselocalhighways="true">
        <start object="this.ship"/>
        <end object="$homeSector"/>
      </get_jump_path>
      
      <!-- Choose the first non-blacklisted sector along the route (or the home sector) -->
      <set_value name="$escapeSector" exact="$homeSector"/>
      <do_all exact="$jumppath.count" counter="$pi">
        <set_value name="$entry" exact="$jumppath.{$pi}"/>
        <do_if value="$entry? and ($entry.isclass.gate or $entry.isclass.highwayentrygate)">
          <set_value name="$candidateSector" exact="$entry.destination.sector"/>
          <set_value name="$candActivityBL" exact="@$candidateSector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled}"/>
          <set_value name="$candTravelBL" exact="@$candidateSector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}"/>
          <set_value name="$candBL" exact="$candActivityBL or $candTravelBL"/>
          <do_if value="not $candBL or $candidateSector == $homeSector">
            <set_value name="$escapeSector" exact="$candidateSector"/>
            <break/>
          </do_if>
        </do_if>
      </do_all>
      
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': ESCAPE FALLBACK: Moving toward home sector' +
          '\n  Current: ' + @$currentSector.knownname +
          '\n  Home:    ' + @$homeSector.knownname +
          '\n  Target:  ' + @$escapeSector.knownname" chance="100"/>
      </do_if>
      
      <!-- Logbook: escape fallback (rate-limited, respects per-ship logbook setting) -->
      <set_value name="$logEnabled" exact="false"/>
      <do_if value="@this.ship.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.defaultorder.$logbookentries">
        <set_value name="$logEnabled" exact="true"/>
      </do_if>
      <!-- Subordinates inherit logbook setting from commander -->
      <do_elseif value="@this.ship.defaultorder.id == 'Assist' and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.commander.defaultorder.$logbookentries">
        <set_value name="$logEnabled" exact="true"/>
      </do_elseif>
      
      <do_if value="$logEnabled">
        <set_value name="$lastEscapeLogbookTime" exact="0"/>
        <do_if value="this.$lastEscapeFallbackLogbookEntryTime?">
          <set_value name="$lastEscapeLogbookTime" exact="this.$lastEscapeFallbackLogbookEntryTime"/>
        </do_if>
        <set_value name="$timeSinceLastEscapeLogbook" exact="player.age - $lastEscapeLogbookTime"/>
        <do_if value="$timeSinceLastEscapeLogbook ge 300s or $lastEscapeLogbookTime == 0">
          <set_value name="$logbookMessage" exact="'Commander,\n\nI am currently in a blacklisted sector and could not find any trade route that safely moves me out.\n\nEscape fallback activated: moving toward my home sector.\n\nCurrent: ' + @$currentSector.knownname + '\nHome: ' + @$homeSector.knownname + '\nTarget: ' + @$escapeSector.knownname + '\n\nStatus: Escaping blacklist lock\n\nAboard ' + this.ship.knownname"/>
          <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
            $Message = $logbookMessage,
            $Category = 'general',
            $Title = 'Escape Fallback: ' + this.ship.knownname,
            $Object = this.ship,
            $Interaction = 'showonmap',
            $CheckGlobalSettings = false
          ]"/>
          <set_value name="this.$lastEscapeFallbackLogbookEntryTime" exact="player.age"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Escape fallback logbook entry created'" chance="100"/>
          </do_if>
        </do_if>
      </do_if>
      
      <!-- Create a visible, native navigation order for the player ("Fly and Wait") toward the escape sector.
           Use a small timeout so GT resumes shortly after arrival. -->
      <!-- CRITICAL: Set escape flag RIGHT BEFORE creating order to ensure it's set when ship starts fleeing -->
      <do_if value="global.$GT_Ships?">
        <do_if value="not global.$GT_Ships.{this.ship}?">
          <set_value name="global.$GT_Ships.{this.ship}" exact="table[]"/>
        </do_if>
        <set_value name="global.$GT_Ships.{this.ship}.$Escaping" exact="true"/>
      </do_if>
      <do_if value="@this.ship.pilot and global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}?">
        <signal_objects object="player.galaxy" param="'GT_Update_Ship_Name'" param2="table[
          $ship=this.ship,
          $pilot=this.ship.pilot,
          $xp=global.$GT_Pilots.{this.ship.pilot}.$XP,
          $level=global.$GT_Pilots.{this.ship.pilot}.$Level,
          $rank=@global.$GT_Pilots.{this.ship.pilot}.$CurrentRank,
          $nameType='trader'
        ]"/>
      </do_if>
      
      <create_order object="this.ship" id="'MoveWait'" immediate="true">
        <param name="destination" value="[$escapeSector, position.[0,0,0]]"/>
        <param name="timeout" value="1s"/>
        <param name="debugchance" value="if @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging then 100 else 0"/>
      </create_order>
      
      <!-- After moving (or attempting to), retry trading immediately -->
      <resume label="main_loop"/>
      
      <label name="no_trade_retry"/>

      <!-- CRITICAL: Initialize retryCooldown with safe default FIRST to prevent property lookup errors -->
      <!-- Purpose B: No-trade retry cooldown (seconds) -->
      <!-- IMPORTANT (AI script lifetime): local $vars may not persist across <wait/> yields. -->
      <!-- Persist the computed cooldown time on the order instance for any post-wait logic. -->
      <set_value name="this.$retryCooldown" exact="10s"/>

      <!-- SPECIAL CASE: system busy / home refresh in progress (MD queues are saturated OR a home-sector cache refresh is running)
           â†’ fixed retry, do NOT escalate cooldown.
           Smooth gameplay > throughput: wait longer here to reduce request churn and let the scheduler/queues drain.
           TODO: keep hardcoded for now; consider exposing as tuning later. -->
      <set_value name="$noTradeReason" exact="if this.$lastNoTradeReason? then this.$lastNoTradeReason else ''"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': no_trade_retry entered: reason=\'' + $noTradeReason + '\' player.money=' + (player.money / 100) + ' Cr'" chance="100"/>
      </do_if>
      <do_if value="$noTradeReason == 'busy' or $noTradeReason == 'busy_batch' or $noTradeReason == 'home_refresh' or $noTradeReason == 'insufficient_funds'">
        <set_value name="this.$lastNoTradeReason" exact="''"/>
        <!-- NOTE: Global money cap (global.$GT_MoneyCapActive) is set by the authoritative guard
             when blocking. No per-ship state needed here â€” the global flag stops all ships. -->
        <!-- Fixed retry for special reasons (do NOT use escalating cooldown). -->
        <!-- For home_refresh: shorter wait (3s) to allow cache retry while home refresh populates cache -->
        <!-- For busy/busy_batch: longer wait (8-12s) to let queues drain -->
        <!-- For insufficient_funds: long wait (90-150s) - budget exhausted, no point retrying quickly.
             Jitter prevents thundering herd: ships spread across 60s window instead of all waking simultaneously.
             On wake-up, the early money gate and global money cap prevent futile searches. -->
        <set_value name="this.$retryCooldown" exact="if $noTradeReason == 'home_refresh' then 3s else (if $noTradeReason == 'insufficient_funds' then 120s else 10s)"/>
        <!-- JITTER: Compute per-ship min/max wait for <wait> element.
             insufficient_funds: 90s-150s (Â±25%), busy: 8s-12s (Â±20%), home_refresh: 3s (no jitter, needs responsiveness) -->
        <set_value name="this.$retryWaitMin" exact="if $noTradeReason == 'insufficient_funds' then 90s else (if $noTradeReason == 'home_refresh' then 3s else 8s)"/>
        <set_value name="this.$retryWaitMax" exact="if $noTradeReason == 'insufficient_funds' then 150s else (if $noTradeReason == 'home_refresh' then 3s else 12s)"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': System busy/home refresh/insufficient funds - waiting ' + (this.$retryWaitMin/1s) + '-' + (this.$retryWaitMax/1s) + 's then retrying cache (reason: ' + $noTradeReason + ')'" chance="100"/>
        </do_if>
        
        <!-- Record attempt summary (bounded history) -->
        <do_if value="not global.$GT_NoTradeHistory?">
          <set_value name="global.$GT_NoTradeHistory" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_NoTradeHistory.{this.ship}? or global.$GT_NoTradeHistory.{this.ship} == null or typeof global.$GT_NoTradeHistory.{this.ship} != datatype.list">
          <set_value name="global.$GT_NoTradeHistory.{this.ship}" exact="[]"/>
        </do_if>
        <append_to_list name="global.$GT_NoTradeHistory.{this.ship}" exact="table[
          $Time = player.age,
          $Reason = $noTradeReason,
          $Wait = this.$retryCooldown,
          $Sector = @this.ship.sector.knownname,
          $Home = if @this.$effectiveHome != null then @this.$effectiveHome.knownname else (if @this.ship.defaultorder.$home != null then @this.ship.defaultorder.$home.knownname else ''),
          $MaxDistance = if this.$effectiveMaxDistance? then this.$effectiveMaxDistance else null
        ]"/>
        <!-- Keep last 12 entries max -->
        <do_if value="global.$GT_NoTradeHistory.{this.ship}.count gt 12">
          <set_value name="$old" exact="global.$GT_NoTradeHistory.{this.ship}.{1}"/>
          <remove_from_list name="global.$GT_NoTradeHistory.{this.ship}" exact="$old"/>
        </do_if>
        
        <!-- Logbook entry for insufficient funds (throttled: once per 5 minutes per ship) -->
        <do_if value="$noTradeReason == 'insufficient_funds' and $gt_logbookentries">
          <set_value name="$lastInsufficientFundsLogbook" exact="0"/>
          <do_if value="this.$lastInsufficientFundsLogbookTime?">
            <set_value name="$lastInsufficientFundsLogbook" exact="this.$lastInsufficientFundsLogbookTime"/>
          </do_if>
          <set_value name="$timeSinceLastInsufficientFundsLogbook" exact="player.age - $lastInsufficientFundsLogbook"/>
          <do_if value="$timeSinceLastInsufficientFundsLogbook ge 300s or $lastInsufficientFundsLogbook == 0">
            <set_value name="$playerMoneyDisplay" exact="player.money / 100"/>
            <set_value name="$thresholdDisplay" exact="this.$minPlayerMoney"/>
            <set_value name="$logbookMessage" exact="'Commander,\n\nTrading operations paused â€” insufficient funds.\n\nPlayer account: ' + $playerMoneyDisplay + ' Cr\nMinimum required: ' + $thresholdDisplay + ' Cr\n\nI will resume trading automatically once funds are above the threshold.\n\nYou can adjust the minimum in:\nGalaxyTrader Settings &gt; Fleet &gt; Min Player Money\n\nStanding by,\nAboard ' + this.ship.knownname"/>
            <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
              $Message = $logbookMessage,
              $Category = 'alerts',
              $Title = 'Insufficient Funds: ' + this.ship.knownname,
              $Object = this.ship,
              $Interaction = 'showonmap',
              $CheckGlobalSettings = false
            ]"/>
            <set_value name="this.$lastInsufficientFundsLogbookTime" exact="player.age"/>
          </do_if>
        </do_if>

        <set_command command="command.wait"/>
        <set_command_action commandaction="commandaction.standingby"/>
        <!-- JITTER: Use per-ship min/max to spread retries across a time window (prevents thundering herd).
             For insufficient_funds: 90s-150s window. For busy: 8s-12s. For home_refresh: fixed 3s. -->
        <wait min="if @this.$retryWaitMin != null then @this.$retryWaitMin else 10s" max="if @this.$retryWaitMax != null then @this.$retryWaitMax else 10s"/>
        <resume label="main_loop"/>
      </do_if>
      
      <!-- CARGO DISPOSAL: Track cargo disposal failures separately -->
      <set_value name="$isCargoDisposal" exact="false"/>
      <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}? and global.$GT_Ships.{this.ship}.$CargoDisposal?">
        <set_value name="$isCargoDisposal" exact="true"/>
        <!-- Initialize cargo disposal failure counter if not exists -->
        <do_if value="not this.$cargoDisposalFailed?">
          <set_value name="this.$cargoDisposalFailed" exact="0"/>
        </do_if>
        <!-- Increment cargo disposal failure counter -->
        <set_value name="this.$cargoDisposalFailed" exact="this.$cargoDisposalFailed + 1"/>
      </do_if>
      <do_else>
        <!-- Normal trade search failure - increment normal counter -->
        <!-- Increment failure counter -->
        <set_value name="this.$searchFailed" exact="this.$searchFailed + 1"/>
      </do_else>
      
      <!-- Calculate escalating wait time: ~10s, ~20s, ~30s, ~40s, ~50s, ~60s (max) -->
      <!-- Use cargo disposal counter if this is cargo disposal, otherwise use normal counter -->
      <set_value name="$failureCount" exact="if $isCargoDisposal then this.$cargoDisposalFailed else this.$searchFailed"/>
      <!-- Escalating cooldown (cap 60s). This is also required for "no trade found" logbook notifications (they trigger at 60s). -->
      <!-- Purpose B: No-trade retry cooldown (seconds) -->
      <set_value name="this.$retryCooldown" exact="([$failureCount, 6].min) * 10s"/>
      <!-- JITTER: Â±20% around the base cooldown to prevent ships at the same escalation level
           from all retrying in the same frame (thundering herd prevention).
           Example: failureCount=3 â†’ base=30s â†’ min=24s, max=36s -->
      <set_value name="this.$retryCooldownMin" exact="[this.$retryCooldown * 0.8, 5s].max"/>
      <set_value name="this.$retryCooldownMax" exact="this.$retryCooldown * 1.2"/>
      
      <!-- Record attempt summary (bounded history).
           We capture the most recent MD rejection statistics (if available) so the 60s logbook report can show a timeline. -->
      <do_if value="not global.$GT_NoTradeHistory?">
        <set_value name="global.$GT_NoTradeHistory" exact="table[]"/>
      </do_if>
      <do_if value="not global.$GT_NoTradeHistory.{this.ship}? or global.$GT_NoTradeHistory.{this.ship} == null or typeof global.$GT_NoTradeHistory.{this.ship} != datatype.list">
        <set_value name="global.$GT_NoTradeHistory.{this.ship}" exact="[]"/>
      </do_if>
      <set_value name="$lastRejectionStats" exact="null"/>
      <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.$LastRejectionStats? and global.$GT_SearchResult.$LastRejectionStats.{this.ship}?">
        <set_value name="$lastRejectionStats" exact="@global.$GT_SearchResult.$LastRejectionStats.{this.ship}"/>
      </do_if>
      <set_value name="$rsTotal" exact="if $lastRejectionStats != null and @$lastRejectionStats.$Total != null then @$lastRejectionStats.$Total else null"/>
      <set_value name="$rsDock" exact="if $lastRejectionStats != null and @$lastRejectionStats.$Docking != null then @$lastRejectionStats.$Docking else null"/>
      <set_value name="$rsProfit" exact="if $lastRejectionStats != null and @$lastRejectionStats.$Profit != null then @$lastRejectionStats.$Profit else null"/>
      <set_value name="$rsAmount" exact="if $lastRejectionStats != null and @$lastRejectionStats.$Amount != null then @$lastRejectionStats.$Amount else null"/>
      <set_value name="$rsBlacklist" exact="if $lastRejectionStats != null and @$lastRejectionStats.$Blacklist != null then @$lastRejectionStats.$Blacklist else null"/>
      <set_value name="$rsSector" exact="if $lastRejectionStats != null and @$lastRejectionStats.$SectorName != null then @$lastRejectionStats.$SectorName else @this.ship.sector.knownname"/>
      <set_value name="$rsMaxDist" exact="if $lastRejectionStats != null and @$lastRejectionStats.$MaxDistance != null then @$lastRejectionStats.$MaxDistance else null"/>
      <set_value name="$rsMinProfit" exact="if $lastRejectionStats != null and @$lastRejectionStats.$MinAbsoluteProfit != null then @$lastRejectionStats.$MinAbsoluteProfit else null"/>
      <set_value name="$rsDistance" exact="0"/>
      <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.{this.ship}? and global.$GT_SearchResult.{this.ship}.$TradesRejectedDistance?">
        <set_value name="$rsDistance" exact="global.$GT_SearchResult.{this.ship}.$TradesRejectedDistance"/>
      </do_if>
      <append_to_list name="global.$GT_NoTradeHistory.{this.ship}" exact="table[
        $Time = player.age,
        $Reason = $noTradeReason,
        $Wait = this.$retryCooldown,
        $Sector = $rsSector,
        $Home = if @this.$effectiveHome != null then @this.$effectiveHome.knownname else (if @this.ship.defaultorder.$home != null then @this.ship.defaultorder.$home.knownname else ''),
        $MaxDistance = $rsMaxDist,
        $MinAbsoluteProfit = $rsMinProfit,
        $Total = $rsTotal,
        $Docking = $rsDock,
        $Profit = $rsProfit,
        $Amount = $rsAmount,
        $Blacklist = $rsBlacklist,
        $Distance = $rsDistance
      ]"/>
      <!-- Keep last 12 entries max -->
      <do_if value="global.$GT_NoTradeHistory.{this.ship}.count gt 12">
        <set_value name="$old" exact="global.$GT_NoTradeHistory.{this.ship}.{1}"/>
        <remove_from_list name="global.$GT_NoTradeHistory.{this.ship}" exact="$old"/>
      </do_if>
      
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': No ' + (if $isCargoDisposal then 'cargo buyer' else 'profitable trades') + ' found (attempt ' + $failureCount + ') - waiting ' + (this.$retryCooldown/1s) + 's before retry'" chance="100"/>
      </do_if>
      
      <!-- Set ship to waiting state -->
      <set_command command="command.wait"/>
      <set_command_action commandaction="commandaction.standingby"/>
      
      <!-- Persist $isCargoDisposal and $noTradeReason before wait (local variables lost across wait yields) -->
      <set_value name="this.$isCargoDisposal" exact="$isCargoDisposal"/>
      <set_value name="this.$noTradeReason" exact="$noTradeReason"/>
      
      <!-- Wait with escalating delay -->
      <!-- Track if wait was interrupted (so we don't write logbook if interrupted) -->
      <set_value name="$waitInterrupted" exact="false"/>
      <set_value name="$tradeFoundDuringWait" exact="false"/>
      <set_value name="this.$waitInterrupted" exact="$waitInterrupted"/>
      <set_value name="this.$tradeFoundDuringWait" exact="$tradeFoundDuringWait"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Entering wait for ' + (this.$retryCooldownMin/1s) + '-' + (this.$retryCooldownMax/1s) + 's at game time ' + player.age" chance="100"/>
      </do_if>
      <!-- JITTER: Use min/max range (Â±20%) to spread ships across a time window instead of all waking together -->
      <wait min="if @this.$retryCooldownMin != null then @this.$retryCooldownMin else 8s" max="if @this.$retryCooldownMax != null then @this.$retryCooldownMax else 12s" comment="Jittered escalating wait with interrupt">
        <interrupt>
          <conditions>
            <!-- Only GT_Trade_Found should interrupt retry wait -->
            <!-- GT_No_Trade_Found signals during retry wait are ignored to preserve escalating cooldown -->
            <event_object_signalled object="this.ship" param="'GT_Trade_Found'" comment="MD found a trade"/>
          </conditions>
          <actions>
            <set_value name="this.$waitInterrupted" exact="true"/>
            <set_value name="this.$tradeFoundDuringWait" exact="true"/>
            <set_value name="$waitInterrupted" exact="true"/>
            <set_value name="$tradeFoundDuringWait" exact="true"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Trade found during retry wait - resuming immediately'" chance="100"/>
            </do_if>
            <!-- Resume to trade_found label to process the trade -->
            <resume label="trade_found"/>
          </actions>
        </interrupt>
      </wait>
      <!-- Restore variables after wait (they may have been lost across yield) -->
      <set_value name="$waitInterrupted" exact="this.$waitInterrupted"/>
      <set_value name="$tradeFoundDuringWait" exact="this.$tradeFoundDuringWait"/>
      <set_value name="$isCargoDisposal" exact="this.$isCargoDisposal"/>
      <set_value name="$noTradeReason" exact="if this.$noTradeReason? then this.$noTradeReason else ''"/>
      <!-- Recompute $failureCount from persisted instance variables (local was lost across wait) -->
      <set_value name="$failureCount" exact="if $isCargoDisposal then (if this.$cargoDisposalFailed? then this.$cargoDisposalFailed else 0) else (if this.$searchFailed? then this.$searchFailed else 0)"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Wait completed at game time ' + player.age + ' - continuing retry logic (trade found: ' + this.$tradeFoundDuringWait + ')'" chance="100"/>
      </do_if>
      
      <!-- Write logbook entry only if we've reached max wait (60s) AND wait completed naturally (not interrupted by trade found) -->
      <!-- Also check if we've already written a logbook entry recently to prevent duplicates -->
      <set_value name="$shouldWriteLogbook" exact="false"/>
      <set_value name="$shouldWriteCargoDisposalLogbook" exact="false"/>
      
      <!-- CARGO DISPOSAL: Separate logbook entry for cargo disposal failures -->
      <do_if value="this.$isCargoDisposal and this.$retryCooldown == 60s and not this.$tradeFoundDuringWait">
        <!-- Check if we've already written a cargo disposal failure logbook entry in the last 5 minutes (300s) -->
        <set_value name="$lastCargoDisposalLogbookTime" exact="0"/>
        <do_if value="this.$lastCargoDisposalLogbookEntryTime?">
          <set_value name="$lastCargoDisposalLogbookTime" exact="this.$lastCargoDisposalLogbookEntryTime"/>
        </do_if>
        <set_value name="$timeSinceLastCargoDisposalLogbook" exact="player.age - $lastCargoDisposalLogbookTime"/>
        <do_if value="$timeSinceLastCargoDisposalLogbook ge 300s or $lastCargoDisposalLogbookTime == 0">
          <!-- Haven't written cargo disposal failure logbook recently (or never) - OK to write -->
          <set_value name="$shouldWriteCargoDisposalLogbook" exact="true"/>
        </do_if>
      </do_if>
      
      <!-- Determine if this is a "critical persistent" reason that should trigger logbook earlier -->
      <!-- Critical reasons: ship is fundamentally unable to trade, not just temporarily busy -->
      <set_value name="$isCriticalReason" exact="$noTradeReason == 'blacklist' or $noTradeReason == 'all_rejected' or $noTradeReason == 'trade_rules_violation'"/>
      
      <!-- Normal trade search logbook entry -->
      <!-- Trigger conditions:
           - Standard: 60s cooldown reached (6th failure)
           - Critical: 2nd consecutive failure with a persistent reason (blacklist/all_rejected/trade_rules) 
           Either way, wait must have completed naturally (not interrupted by trade found) -->
      <do_if value="not $isCargoDisposal and not $tradeFoundDuringWait and (this.$retryCooldown == 60s or ($isCriticalReason and $failureCount ge 2))">
        <!-- Check if we've already written a logbook entry in the last 5 minutes (300s) -->
        <set_value name="$lastLogbookTime" exact="0"/>
        <do_if value="this.$lastLogbookEntryTime?">
          <set_value name="$lastLogbookTime" exact="this.$lastLogbookEntryTime"/>
        </do_if>
        <set_value name="$timeSinceLastLogbook" exact="player.age - $lastLogbookTime"/>
        <do_if value="$timeSinceLastLogbook ge 300s or $lastLogbookTime == 0">
          <!-- Haven't written logbook recently (or never) - OK to write -->
          <set_value name="$shouldWriteLogbook" exact="true"/>
        </do_if>
      </do_if>
      
      <!-- CARGO DISPOSAL: Write separate failure message for cargo disposal -->
      <do_if value="$shouldWriteCargoDisposalLogbook">
        <!-- Check if logbook enabled -->
        <set_value name="$logEnabled" exact="false"/>
        <do_if value="@this.ship.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.defaultorder.$logbookentries">
          <set_value name="$logEnabled" exact="true"/>
        </do_if>
        <!-- Subordinates inherit logbook setting from commander -->
        <do_elseif value="@this.ship.defaultorder.id == 'Assist' and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3' and @this.ship.commander.defaultorder.$logbookentries">
          <set_value name="$logEnabled" exact="true"/>
        </do_elseif>
        
        <do_if value="$logEnabled">
          <!-- Get cargo info for logbook message -->
          <set_value name="$cargoList" exact="this.ship.cargo.list"/>
          <set_value name="$cargoTypes" exact="[]"/>
          <do_all exact="$cargoList.count" counter="$i">
            <set_value name="$ware" exact="$cargoList.{$i}"/>
            <set_value name="$amount" exact="this.ship.cargo.{$ware}.count"/>
            <append_to_list name="$cargoTypes" exact="@$ware.name + ' x' + $amount"/>
          </do_all>
          <set_value name="$cargoDescription" exact="if $cargoTypes.count gt 0 then $cargoTypes.{1} + (if $cargoTypes.count gt 1 then ', ' + $cargoTypes.{2} else '') + (if $cargoTypes.count gt 2 then ', ...' else '') else 'Unknown'"/>
          
          <!-- Write cargo disposal failure logbook entry -->
          <set_value name="$logbookMessage" exact="'Commander,\n\nI have been unable to find a buyer for my cargo after multiple attempts. My cargo hold contains: ' + $cargoDescription + '\n\nI have tried ' + $failureCount + ' times but cannot locate a suitable buyer within my trading range. This may be due to:\n- No stations buying these wares nearby\n- All potential buyers are blacklisted\n- Docking restrictions at available stations\n\nI will continue waiting and retrying periodically. You may want to manually assign a sell order or adjust my trading parameters.\n\nStatus: Waiting for buyer opportunity\n\nWith patience,\nAboard ' + this.ship.knownname"/>
          
          <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
            $Message = $logbookMessage,
            $Category = 'alerts',
            $Title = 'Cargo Disposal Failed: ' + this.ship.knownname,
            $Object = this.ship,
            $Interaction = 'showonmap',
            $CheckGlobalSettings = false
          ]"/>
          
          <!-- Update last cargo disposal logbook entry time -->
          <set_value name="this.$lastCargoDisposalLogbookEntryTime" exact="player.age"/>
        </do_if>
      </do_if>
      
      <do_if value="$shouldWriteLogbook">
        <!-- Check if logbook enabled -->
        <set_value name="$logEnabled" exact="false"/>
        <!-- Use the already-computed effective logbook flag (matches other GT logbook messages). -->
        <do_if value="$gt_logbookentries">
          <set_value name="$logEnabled" exact="true"/>
        </do_if>
        
        <do_if value="$logEnabled">
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
               COMMON DATA RETRIEVAL: Gather rejection stats, sector info, etc.
               Used by ALL logbook message templates below.
               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          <set_value name="$lastRejectionStats" exact="null"/>
          <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.$LastRejectionStats? and global.$GT_SearchResult.$LastRejectionStats != null and global.$GT_SearchResult.$LastRejectionStats.{this.ship}?">
            <set_value name="$lastRejectionStats" exact="global.$GT_SearchResult.$LastRejectionStats.{this.ship}"/>
          </do_if>
          <set_value name="$totalRejected" exact="0"/>
          <set_value name="$tradesRejectedDocking" exact="0"/>
          <set_value name="$tradesRejectedProfit" exact="0"/>
          <set_value name="$tradesRejectedAmount" exact="0"/>
          <set_value name="$tradesRejectedBlacklist" exact="0"/>
          <set_value name="$sectorName" exact="''"/>
          <set_value name="$maxDistance" exact="10"/>
          <set_value name="$minAbsoluteProfit" exact="100"/>
          
          <do_if value="$lastRejectionStats != null">
            <set_value name="$tradesRejectedDockingTemp" exact="@$lastRejectionStats.$Docking"/>
            <set_value name="$tradesRejectedDocking" exact="if $tradesRejectedDockingTemp? and $tradesRejectedDockingTemp != null then $tradesRejectedDockingTemp else 0"/>
            <set_value name="$tradesRejectedProfitTemp" exact="@$lastRejectionStats.$Profit"/>
            <set_value name="$tradesRejectedProfit" exact="if $tradesRejectedProfitTemp? and $tradesRejectedProfitTemp != null then $tradesRejectedProfitTemp else 0"/>
            <set_value name="$tradesRejectedAmountTemp" exact="@$lastRejectionStats.$Amount"/>
            <set_value name="$tradesRejectedAmount" exact="if $tradesRejectedAmountTemp? and $tradesRejectedAmountTemp != null then $tradesRejectedAmountTemp else 0"/>
            <set_value name="$tradesRejectedBlacklistTemp" exact="@$lastRejectionStats.$Blacklist"/>
            <set_value name="$tradesRejectedBlacklist" exact="if $tradesRejectedBlacklistTemp? and $tradesRejectedBlacklistTemp != null then $tradesRejectedBlacklistTemp else 0"/>
            <set_value name="$totalRejectedTemp" exact="@$lastRejectionStats.$Total"/>
            <set_value name="$totalRejectedFromStats" exact="if $totalRejectedTemp? and $totalRejectedTemp != null then $totalRejectedTemp else 0"/>
            <set_value name="$sumOfRejections" exact="$tradesRejectedDocking + $tradesRejectedProfit + $tradesRejectedAmount + $tradesRejectedBlacklist"/>
            <set_value name="$totalRejected" exact="if $totalRejectedFromStats gt $sumOfRejections then $totalRejectedFromStats else $sumOfRejections"/>
            
            <set_value name="$sectorNameTemp" exact="@$lastRejectionStats.$SectorName"/>
            <do_if value="$sectorNameTemp? and $sectorNameTemp != null and $sectorNameTemp != ''">
              <set_value name="$sectorName" exact="$sectorNameTemp"/>
            </do_if>
            <do_else>
              <set_value name="$sectorName" exact="@this.ship.sector.knownname"/>
            </do_else>
            <set_value name="$maxDistanceTemp" exact="@$lastRejectionStats.$MaxDistance"/>
            <do_if value="$maxDistanceTemp? and $maxDistanceTemp != null">
              <set_value name="$maxDistance" exact="$maxDistanceTemp"/>
            </do_if>
            <set_value name="$minAbsoluteProfitTemp" exact="@$lastRejectionStats.$MinAbsoluteProfit"/>
            <do_if value="$minAbsoluteProfitTemp? and $minAbsoluteProfitTemp != null">
              <set_value name="$minAbsoluteProfit" exact="$minAbsoluteProfitTemp"/>
            </do_if>
          </do_if>
          <do_else>
            <set_value name="$sectorName" exact="@this.ship.sector.knownname"/>
          </do_else>
          
          <!-- Final safety check: Ensure sector name is not null -->
          <do_if value="not $sectorName? or $sectorName == null or $sectorName == ''">
            <set_value name="$sectorName" exact="@this.ship.sector.knownname"/>
            <do_if value="not $sectorName? or $sectorName == null or $sectorName == ''">
              <set_value name="$sectorName" exact="'Unknown Sector'"/>
            </do_if>
          </do_if>
          
          <set_value name="$hasRejectionStats" exact="false"/>
          <do_if value="$lastRejectionStats != null">
            <do_if value="($lastRejectionStats.$Total? and $lastRejectionStats.$Total != null) or ($lastRejectionStats.$Profit? and $lastRejectionStats.$Profit != null) or ($lastRejectionStats.$Docking? and $lastRejectionStats.$Docking != null) or ($lastRejectionStats.$Amount? and $lastRejectionStats.$Amount != null) or ($lastRejectionStats.$Blacklist? and $lastRejectionStats.$Blacklist != null)">
              <set_value name="$hasRejectionStats" exact="true"/>
            </do_if>
          </do_if>
          <set_value name="$totalEvaluated" exact="0"/>
          <do_if value="$hasRejectionStats and $lastRejectionStats.$Total? and $lastRejectionStats.$Total != null">
            <set_value name="$totalEvaluated" exact="$lastRejectionStats.$Total"/>
          </do_if>
          <set_value name="$tradesRejectedDistance" exact="0"/>
          <do_if value="global.$GT_SearchResult? and global.$GT_SearchResult.{this.ship}? and global.$GT_SearchResult.{this.ship}.$TradesRejectedDistance?">
            <set_value name="$tradesRejectedDistance" exact="global.$GT_SearchResult.{this.ship}.$TradesRejectedDistance"/>
          </do_if>
          
          <!-- Log the logbook message data before generating -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': LOGBOOK (reason=' + $noTradeReason + ', attempt=' + $failureCount + ', critical=' + $isCriticalReason + ')'" chance="100"/>
          </do_if>
          
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
               LOGBOOK TITLE â€” reason-specific for clarity in the logbook list
               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          <set_value name="$logbookTitle" exact="'No Trades: ' + this.ship.knownname"/>
          <do_if value="$noTradeReason == 'blacklist'">
            <set_value name="$logbookTitle" exact="'Routes Blocked: ' + this.ship.knownname"/>
          </do_if>
          <do_elseif value="$noTradeReason == 'all_rejected'">
            <set_value name="$logbookTitle" exact="'All Trades Rejected: ' + this.ship.knownname"/>
          </do_elseif>
          <do_elseif value="$noTradeReason == 'trade_rules_violation'">
            <set_value name="$logbookTitle" exact="'Trade Rules Violation: ' + this.ship.knownname"/>
          </do_elseif>
          
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
               LOGBOOK MESSAGE â€” reason-specific templates
               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          
          <!-- â”€â”€â”€ BLACKLIST: All viable routes pass through blocked sectors â”€â”€â”€ -->
          <do_if value="$noTradeReason == 'blacklist'">
            <set_value name="$logbookMessage" exact="'Commander,\n\nTrading blocked â€” all viable routes pass through blacklisted sectors.\n\n' +
              'Ship: ' + this.ship.knownname + '\n' +
              'Sector: ' + $sectorName + '\n' +
              'Range: ' + $maxDistance + ' jump(s)\n' +
              'Attempts: ' + $failureCount + '\n\n' +
              'All trade routes within range are blocked by threat intelligence or blacklist settings. ' +
              'The ship cannot reach any profitable stations safely.\n\n' +
              'Suggestions:\n' +
              '- Review blacklist settings (GalaxyTrader Settings &gt; Trade)\n' +
              '- Increase trading range to find routes around blocked sectors\n' +
              '- Relocate this ship to a sector with better connectivity\n' +
              '- Check if threat levels have changed recently'"/>
          </do_if>
          
          <!-- â”€â”€â”€ ALL_REJECTED: Every trade candidate was filtered out â”€â”€â”€ -->
          <do_elseif value="$noTradeReason == 'all_rejected'">
            <!-- Display strings -->
            <set_value name="$evalDisplay" exact="if $hasRejectionStats then $totalEvaluated else 'â€”'"/>
            <set_value name="$profitDisplay" exact="if $hasRejectionStats then $tradesRejectedProfit else 'â€”'"/>
            <set_value name="$dockDisplay" exact="if $hasRejectionStats then $tradesRejectedDocking else 'â€”'"/>
            <set_value name="$amountDisplay" exact="if $hasRejectionStats then $tradesRejectedAmount else 'â€”'"/>
            <set_value name="$distDisplay" exact="if $hasRejectionStats then $tradesRejectedDistance else 'â€”'"/>
            <set_value name="$blDisplay" exact="if $hasRejectionStats then $tradesRejectedBlacklist else 'â€”'"/>
            
            <set_value name="$logbookMessage" exact="'Commander,\n\nAll trade candidates were rejected after evaluation.\n\n' +
              'Ship: ' + this.ship.knownname + '\n' +
              'Sector: ' + $sectorName + '\n' +
              'Range: ' + $maxDistance + ' jump(s)\n' +
              'Min profit: ' + ($minAbsoluteProfit/100) + ' Cr\n' +
              'Attempts: ' + $failureCount + '\n\n' +
              'Rejection breakdown (evaluated ' + $evalDisplay + '):\n' +
              '  Profit too low: ' + $profitDisplay + '\n' +
              '  Docking restricted: ' + $dockDisplay + '\n' +
              '  Amount too small: ' + $amountDisplay + '\n' +
              '  Out of range: ' + $distDisplay + '\n' +
              '  Blacklisted/path blocked: ' + $blDisplay + '\n'"/>
            
            <!-- Add targeted hint based on dominant rejection reason -->
            <set_value name="$hint" exact="''"/>
            <do_if value="not $hasRejectionStats or $totalEvaluated == 0">
              <set_value name="$hint" exact="'No offers were evaluated. Check if markets are discovered and unblocked.'"/>
            </do_if>
            <do_elseif value="$tradesRejectedProfit gt ($tradesRejectedDocking + $tradesRejectedBlacklist + $tradesRejectedDistance)">
              <set_value name="$hint" exact="'Most candidates failed profit checks. Lower min profit/ROI or increase range.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedDocking gt 0 and $tradesRejectedDocking ge $tradesRejectedProfit">
              <set_value name="$hint" exact="'Many candidates failed docking checks. Check docking restrictions at stations.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedBlacklist gt 0 and $tradesRejectedBlacklist ge $tradesRejectedProfit">
              <set_value name="$hint" exact="'Blacklist restrictions filtered many routes. Review threat settings.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedDistance gt 0 and $tradesRejectedDistance ge $tradesRejectedProfit">
              <set_value name="$hint" exact="'Many candidates were out of range. Increase max distance if appropriate.'"/>
            </do_elseif>
            <do_if value="$hint != ''">
              <set_value name="$logbookMessage" exact="$logbookMessage + '\nHint: ' + $hint"/>
            </do_if>
          </do_elseif>
          
          <!-- â”€â”€â”€ TRADE_RULES_VIOLATION: Station trade rules prevent trading â”€â”€â”€ -->
          <do_elseif value="$noTradeReason == 'trade_rules_violation'">
            <set_value name="$logbookMessage" exact="'Commander,\n\nTrade rules violation â€” target stations reject trades from this ship.\n\n' +
              'Ship: ' + this.ship.knownname + '\n' +
              'Sector: ' + $sectorName + '\n' +
              'Attempts: ' + $failureCount + '\n\n' +
              'This may be caused by:\n' +
              '- Build storage restrictions (station is a build storage)\n' +
              '- Carrier/auxiliary station trading restrictions\n' +
              '- Trade rule changes after search started\n' +
              '- Station ownership or faction restrictions\n\n' +
              'Suggestions:\n' +
              '- Check station trade rule settings\n' +
              '- Review IgnoreCarrierAux / IgnoreBuildStorage in GT Settings\n' +
              '- Increase trading range to find alternative stations'"/>
          </do_elseif>
          
          <!-- â”€â”€â”€ GENERIC: Standard "no profitable trades" with full diagnostics â”€â”€â”€ -->
          <do_else>
            <!-- Display strings (show 'â€”' when stats were not recorded) -->
            <set_value name="$evalDisplay" exact="if $hasRejectionStats then $totalEvaluated else 'â€”'"/>
            <set_value name="$profitDisplay" exact="if $hasRejectionStats then $tradesRejectedProfit else 'â€”'"/>
            <set_value name="$dockDisplay" exact="if $hasRejectionStats then $tradesRejectedDocking else 'â€”'"/>
            <set_value name="$amountDisplay" exact="if $hasRejectionStats then $tradesRejectedAmount else 'â€”'"/>
            <set_value name="$distDisplay" exact="if $hasRejectionStats then $tradesRejectedDistance else 'â€”'"/>
            <set_value name="$blDisplay" exact="if $hasRejectionStats then $tradesRejectedBlacklist else 'â€”'"/>
            
            <!-- Friendly reason string for the generic header -->
            <set_value name="$reasonFriendly" exact="
              if $noTradeReason == 'reserved' then 'all trades reserved by fleet'
              else if $noTradeReason == 'offers_expired' then 'trade offers expired during validation'
              else if $noTradeReason == 'no_trade' then 'no profitable trades found'
              else if $noTradeReason == 'invalid_trade' then 'trade data became invalid'
              else 'no profitable trades found'"/>
            
            <set_value name="$logbookMessage" exact="'Commander,\n\nNo trades available â€” ' + $reasonFriendly + '.\n\n' +
              'Ship: ' + this.ship.knownname + '\n' +
              'Sector: ' + $sectorName + '\n' +
              'Range: ' + $maxDistance + ' jump(s)\n' +
              'Min profit: ' + ($minAbsoluteProfit/100) + ' Cr\n' +
              'Attempts: ' + $failureCount + ' (cooldown reached ' + (this.$retryCooldown/1s) + 's)\n\n' +
              'Latest rejection stats (evaluated ' + $evalDisplay + '):\n' +
              '  Profit too low: ' + $profitDisplay + '\n' +
              '  Docking restricted: ' + $dockDisplay + '\n' +
              '  Amount too small: ' + $amountDisplay + '\n' +
              '  Out of range: ' + $distDisplay + '\n' +
              '  Blacklisted/path blocked: ' + $blDisplay +
              (if not $hasRejectionStats then '\n  (no stats recorded for this attempt)' else '') + '\n\n' +
              'Recent attempts (newest first):'"/>

            <!-- Append up to last 4 history rows (most recent first) -->
            <set_value name="$hist" exact="null"/>
            <do_if value="global.$GT_NoTradeHistory? and global.$GT_NoTradeHistory.{this.ship}?">
              <set_value name="$hist" exact="global.$GT_NoTradeHistory.{this.ship}"/>
            </do_if>
            <set_value name="$histCount" exact="if $hist != null then $hist.count else 0"/>
            <set_value name="$linesToShow" exact="[$histCount, 4].min"/>
            <do_all exact="$linesToShow" counter="$li">
              <!-- Reverse index: last entry is most recent -->
              <set_value name="$idx" exact="$histCount - ($li - 1)"/>
              <set_value name="$h" exact="$hist.{$idx}"/>
              
              <!-- Age formatting: mm:ss ago -->
              <set_value name="$ageSec" exact="0"/>
              <do_if value="$h.$Time? and $h.$Time != null">
                <set_value name="$ageSec" exact="((player.age - $h.$Time) / 1s)i"/>
              </do_if>
              <do_if value="$ageSec lt 0">
                <set_value name="$ageSec" exact="0"/>
              </do_if>
              <set_value name="$ageMin" exact="($ageSec / 60)i"/>
              <set_value name="$ageRem" exact="$ageSec - ($ageMin * 60)"/>
              <set_value name="$ageRemStr" exact="if $ageRem lt 10 then '0' + $ageRem else $ageRem"/>
              <set_value name="$ageStr" exact="$ageMin + ':' + $ageRemStr + ' ago'"/>
              
              <!-- Reason (friendly) -->
              <set_value name="$rRaw" exact="if $h.$Reason? and $h.$Reason != null and $h.$Reason != '' then $h.$Reason else 'none'"/>
              <set_value name="$r" exact="
                if $rRaw == 'busy' then 'busy'
                else if $rRaw == 'busy_batch' then 'busy (batch)'
                else if $rRaw == 'home_refresh' then 'home refresh'
                else if $rRaw == 'reserved' then 'reserved (fleet)'
                else if $rRaw == 'blacklist' then 'BLACKLISTED'
                else if $rRaw == 'all_rejected' then 'all rejected'
                else if $rRaw == 'trade_rules_violation' then 'trade rules'
                else if $rRaw == 'offers_expired' then 'offers expired'
                else if $rRaw == 'insufficient_funds' then 'low funds'
                else if $rRaw == 'invalid_trade' then 'invalid trade'
                else if $rRaw == 'no_trade' then 'no trade'
                else if $rRaw == 'no_cargo' then 'no cargo'
                else if $rRaw == 'no_gt_order' then 'no GT order'
                else if $rRaw == 'forced_sell_failed' then 'sell failed'
                else if $rRaw == 'no_training_stations' then 'no training'
                else $rRaw"/>
              
              <!-- Build compact rejection summary -->
              <set_value name="$p" exact="if $h.$Profit? and $h.$Profit != null then $h.$Profit else 0"/>
              <set_value name="$d" exact="if $h.$Docking? and $h.$Docking != null then $h.$Docking else 0"/>
              <set_value name="$a" exact="if $h.$Amount? and $h.$Amount != null then $h.$Amount else 0"/>
              <set_value name="$bl" exact="if $h.$Blacklist? and $h.$Blacklist != null then $h.$Blacklist else 0"/>
              <set_value name="$dist" exact="if $h.$Distance? and $h.$Distance != null then $h.$Distance else 0"/>
              <set_value name="$w" exact="if $h.$Wait? and $h.$Wait != null then (($h.$Wait / 1s)i) else 0"/>
              
              <set_value name="$rej" exact="''"/>
              <do_if value="$p gt 0"><set_value name="$rej" exact="$rej + (if $rej == '' then '' else ', ') + 'profit ' + $p"/></do_if>
              <do_if value="$d gt 0"><set_value name="$rej" exact="$rej + (if $rej == '' then '' else ', ') + 'dock ' + $d"/></do_if>
              <do_if value="$a gt 0"><set_value name="$rej" exact="$rej + (if $rej == '' then '' else ', ') + 'amount ' + $a"/></do_if>
              <do_if value="$dist gt 0"><set_value name="$rej" exact="$rej + (if $rej == '' then '' else ', ') + 'dist ' + $dist"/></do_if>
              <do_if value="$bl gt 0"><set_value name="$rej" exact="$rej + (if $rej == '' then '' else ', ') + 'blacklist ' + $bl"/></do_if>
              <do_if value="$rej == ''"><set_value name="$rej" exact="'â€”'"/></do_if>
              
              <set_value name="$logbookMessage" exact="$logbookMessage + '\n  ' + $ageStr + ' | ' + $r + ' | rej: ' + $rej"/>
            </do_all>

            <!-- Quick hints (bounded) -->
            <set_value name="$hint" exact="''"/>
            <do_if value="not $hasRejectionStats">
              <set_value name="$hint" exact="'No rejection stats were recorded yet (likely no evaluation completed for this ship).'" />
            </do_if>
            <do_elseif value="$totalEvaluated == 0">
              <set_value name="$hint" exact="'No offers were evaluated. Consider increasing range or checking if markets are visible/unblocked.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedProfit gt ($tradesRejectedDocking + $tradesRejectedBlacklist + $tradesRejectedDistance)">
              <set_value name="$hint" exact="'Most candidates failed profit checks. Lower min profit/ROI or increase range.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedDocking gt 0 and $tradesRejectedDocking ge $tradesRejectedProfit">
              <set_value name="$hint" exact="'Many candidates failed docking checks. Check docking restrictions at stations.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedBlacklist gt 0">
              <set_value name="$hint" exact="'Blacklist/path restrictions filtered many routes. Review blacklists/threat settings.'"/>
            </do_elseif>
            <do_elseif value="$tradesRejectedDistance gt 0">
              <set_value name="$hint" exact="'Many candidates were out of range. Increase max distance (buy/sell) if appropriate.'"/>
            </do_elseif>
            <do_if value="$hint != ''">
              <set_value name="$logbookMessage" exact="$logbookMessage + '\n\nHint: ' + $hint"/>
            </do_if>
          </do_else>
          
          <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
               SEND LOGBOOK ENTRY (common for all reason-specific templates)
               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
          
          <!-- Dump the final logbook message to DebugLog for diagnosis/copy-paste.
               Rate-limited by the existing escalation + 5min per-ship logbook cooldown. -->
          <debug_text text="'[GT-LogbookDump] (' + this.ship.idcode + ') reason=' + $noTradeReason + ':\n' + $logbookMessage" chance="100"/>
          
          <signal_objects object="player.galaxy" param="'GT_WriteLogbook'" param2="table[
            $Message = $logbookMessage,
            $Category = 'tips',
            $Title = $logbookTitle,
            $Object = this.ship,
            $Interaction = 'showonmap',
            $CheckGlobalSettings = false
          ]"/>
          
          <!-- Log that logbook entry was created -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Logbook entry created (reason=' + $noTradeReason + ', title=' + $logbookTitle + ')'" chance="100"/>
          </do_if>
          
          <!-- Mark that we've written a logbook entry now -->
          <set_value name="this.$lastLogbookEntryTime" exact="player.age"/>
        </do_if>
      </do_if>
      
      <!-- Reset command state and resume search -->
      <set_command command="command.searchtrades"/>
      <set_command_action commandaction="commandaction.searchingtrades"/>
      
      <!-- Resume main trading loop -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Resuming main_loop label'" chance="100"/>
      </do_if>
      <resume label="main_loop"/>
      
      <!-- ========================================= -->
      <!-- AUTO-REPAIR HANDLING                     -->
      <!-- ========================================= -->
      <label name="start_repair"/>
      
      <!-- Retrieve repair destination from global data -->
      <set_value name="$repairStation" exact="global.$GT_AutoRepair.{this.ship}.$Station"/>
      
      <do_if value="$repairStation and $repairStation.exists">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Hull at ' + this.ship.hullpercentage + '% - going for repairs at ' + $repairStation.knownname" chance="100"/>
        </do_if>
        
        <!-- Set repair command state -->
        <set_command command="command.repair"/>
        <set_command_action commandaction="commandaction.calculating"/>
        
        <!-- Create repair order -->
        <create_order object="this.ship" id="'Repair'" immediate="true">
          <param name="destination" value="$repairStation"/>
          <param name="repairall" value="true"/>
        </create_order>
        
        <!-- Wait for repair completion -->
        <set_value name="$repairComplete" exact="false"/>
        <set_value name="this.$repairComplete" exact="$repairComplete"/>
        <wait max="3600s">
          <interrupt>
            <conditions>
              <event_object_signalled object="this.ship" param="'GT_RepairCompleted'"/>
            </conditions>
            <actions>
              <set_value name="this.$repairComplete" exact="true"/>
              <set_value name="$repairComplete" exact="true"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Repairs completed (hull now at ' + this.ship.hullpercentage + '%) - resuming trading'" chance="100"/>
              </do_if>
            </actions>
          </interrupt>
        </wait>
        
        <!-- Restore variable after wait (local variables lost across wait yields) -->
        <set_value name="$repairComplete" exact="this.$repairComplete"/>
        
        <!-- Check if we timed out -->
        <do_if value="not this.$repairComplete">
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Repair timeout after 1 hour - resuming trading anyway'" chance="100"/>
          </do_if>
        </do_if>
        
        <!-- Clean up repair tracking -->
        <do_if value="global.$GT_AutoRepair.{this.ship}?">
          <remove_value name="global.$GT_AutoRepair.{this.ship}"/>
        </do_if>
        
        <!-- Reset search failure counter since we're starting fresh -->
        <set_value name="this.$searchFailed" exact="0"/>
      </do_if>
      <do_else>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Repair station not found or no longer exists - resuming trading'" chance="100"/>
        </do_if>
      </do_else>
      
      <!-- Resume normal trading loop -->
      <resume label="main_loop"/>
      
      <!-- ========================================================================= -->
      <!-- CARGO SAFETY HANDLERS (In-Parallel Monitoring)                           -->
      <!-- These run in parallel with main trading loop via interrupt-based waits   -->
      <!-- ========================================================================= -->
      
      <!-- ========================================================================= -->
      <!-- DEAD CODE REMOVED: Emergency/Alternative Cargo & Threat Handlers         -->
      <!-- These complex systems were replaced with simple inline cargo check        -->
      <!-- Current implementation: Cargo check at line ~844 sends GT_Find_Sell      -->
      <!-- Threat handler now in interrupt section at lines ~917-941                -->
      <!-- ========================================================================= -->
      
      <!-- ========================================= -->
      <!-- WORK UNIT PROCESSING                      -->
      <!-- ========================================= -->
      
      <!-- Process cache search work unit -->
      <label name="process_cache_workunit"/>
      
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': STARTING cache_search work unit processing'" chance="100"/>
      
      <!-- Extract parameters -->
      <set_value name="$homeSector" exact="@$workUnit.$HomeSector"/>
      <set_value name="$maxDistance" exact="@$workUnit.$MaxDistance"/>
      <set_value name="$minROI" exact="@$workUnit.$MinROI"/>
      <set_value name="$minAbsoluteProfit" exact="@$workUnit.$MinAbsoluteProfit"/>
      <set_value name="$ignoreBuildStorage" exact="if $workUnit.$IgnoreBuildStorage? then $workUnit.$IgnoreBuildStorage else false"/>
      <set_value name="$ignoreCarrierAux" exact="if $workUnit.$IgnoreCarrierAux? then $workUnit.$IgnoreCarrierAux else false"/>
      
      <!-- Get ship settings for filtering -->
      <!-- Use safe access with defaults in case effective variables aren't initialized in this code path -->
      <set_value name="$allowIllegal" exact="if $workUnit.$AllowIllegal? then $workUnit.$AllowIllegal else (if $effectiveAllowIllegal? then @$effectiveAllowIllegal else false)"/>
      <set_value name="$ignoreTradeRules" exact="if $workUnit.$IgnoreTradeRules? then $workUnit.$IgnoreTradeRules else (if $effectiveIgnoreTradeRules? then @$effectiveIgnoreTradeRules else false)"/>
      <set_value name="$shipDockSize" exact="this.ship.docksize"/>
      
      <!-- Get cache list -->
      <set_value name="$rawCacheList" exact="[]"/>
      <do_if value="global.$GT_TradeCache? and global.$GT_TradeCache.{$homeSector}?">
        <set_value name="$rawCacheList" exact="global.$GT_TradeCache.{$homeSector}"/>
      </do_if>
      
      <!-- CRITICAL: Check if cache max distance covers ship's required max distance -->
      <!-- This prevents ships with larger max distance from using incomplete cache populated by ships with smaller max distance -->
      <set_value name="$cacheMaxDistance" exact="0"/>
      <do_if value="global.$GT_TradeCacheMaxDistance? and global.$GT_TradeCacheMaxDistance.{$homeSector}?">
        <set_value name="$cacheMaxDistance" exact="global.$GT_TradeCacheMaxDistance.{$homeSector}"/>
      </do_if>
      <!-- If cache was populated with smaller max distance than ship needs, treat as cache miss -->
      <do_if value="$cacheMaxDistance gt 0 and $cacheMaxDistance lt $maxDistance">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cache max distance insufficient: cached=' + $cacheMaxDistance + ', required=' + $maxDistance + ' - returning empty results'" chance="100"/>
        </do_if>
        <!-- Return empty results (cache miss) - signal to player.galaxy so work unit coordinator receives it -->
        <signal_objects object="player.galaxy" param="'GT_WorkUnit_Complete'" param2="table[
          $Ship = this.ship,
          $WorkType = 'cache_search',
          $Result = table[
            $Found = false,
            $Trade = null,
            $BestScore = 0,
            $Trades = [],
            $ScanDone = true
          ]
        ]"/>
        <!-- CRITICAL: Go to wait_for_response so AI catches MD's GT_Trade_Found/GT_No_Trade_Found -->
        <resume label="wait_for_response"/>
      </do_if>
      
      <!-- CRITICAL: Load GT_FailedSectorPairs for ship's current sector (prefilter failed sector pairs) -->
      <!-- This prevents revalidating entries that previously failed due to blacklisted routes -->
      <!-- Ships in the same sector share failed sector pairs (same connectivity/blacklist context) -->
      <!-- Ships in different sectors may still try (different path might exist) -->
      <set_value name="$currentSector" exact="this.ship.sector"/>
      <set_value name="$failedTrades" exact="table[]"/>
      <do_if value="$currentSector? and $currentSector.exists and global.$GT_FailedSectorPairs? and global.$GT_FailedSectorPairs.{$currentSector}?">
        <set_value name="$failedTradesRaw" exact="global.$GT_FailedSectorPairs.{$currentSector}"/>
        <set_value name="$expiredCount" exact="0"/>
        <set_value name="$keptCount" exact="0"/>
        <set_value name="$expirationTime" exact="1800s"/> <!-- 30 minutes -->
        
        <!-- Filter expired entries from nested table: {buySector} -> {sellSector} -> record -->
        <set_value name="$buyKeys" exact="$failedTradesRaw.keys"/>
        <do_all exact="$buyKeys.count" counter="$bki">
          <set_value name="$buyKey" exact="$buyKeys.{$bki}"/>
          <do_if value="$failedTradesRaw.{$buyKey}?">
            <set_value name="$innerTable" exact="$failedTradesRaw.{$buyKey}"/>
            <set_value name="$sellKeys" exact="$innerTable.keys"/>
            <do_all exact="$sellKeys.count" counter="$ski">
              <set_value name="$sellKey" exact="$sellKeys.{$ski}"/>
              <set_value name="$record" exact="@$innerTable.{$sellKey}"/>
              <do_if value="$record? and $record.$Timestamp?">
                <set_value name="$tradeAge" exact="player.age - $record.$Timestamp"/>
                <do_if value="$tradeAge le $expirationTime">
                  <!-- Entry still valid - copy to local table -->
                  <do_if value="not $failedTrades.{$buyKey}?">
                    <set_value name="$failedTrades.{$buyKey}" exact="table[]"/>
                  </do_if>
                  <set_value name="$failedTrades.{$buyKey}.{$sellKey}" exact="$record"/>
                  <set_value name="$keptCount" exact="$keptCount + 1"/>
                </do_if>
                <do_else>
                  <set_value name="$expiredCount" exact="$expiredCount + 1"/>
                </do_else>
              </do_if>
            </do_all>
          </do_if>
        </do_all>
        
        <!-- Update global storage with cleaned table -->
        <do_if value="$expiredCount gt 0 and $keptCount gt 0">
          <set_value name="global.$GT_FailedSectorPairs.{$currentSector}" exact="$failedTrades"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <set_value name="$sectorName" exact="@$currentSector.knownname"/>
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cleaned ' + $expiredCount + ' expired failed sector pairs for sector ' + (if $sectorName? then $sectorName else 'Unknown') + ' (kept ' + $keptCount + ')'" chance="100"/>
          </do_if>
        </do_if>
        <do_elseif value="$keptCount == 0">
          <!-- All entries expired - clear the table entirely -->
          <remove_value name="global.$GT_FailedSectorPairs.{$currentSector}"/>
        </do_elseif>
      </do_if>
      
      <!-- NOTE: Removed redundant cache pre-filter money check.
           The Early Money Gate and Fast Money Check already prevent reaching this point
           when player money is below threshold. The old check also had a unit bug
           (compared cents to credits). -->
      
      <!-- ==================================================================================== -->
      <!-- CRITICAL: Pre-filter cache entries by ALL cheap restrictions BEFORE processing -->
      <!-- This prevents validating entries that will never pass these checks -->
      <!-- ==================================================================================== -->
      <set_value name="$cacheList" exact="[]"/>
      <set_value name="$rawCount" exact="$rawCacheList.count"/>
      <set_value name="$filterRejectCount" exact="table[
        $Distance = 0,
        $IllegalWare = 0,
        $TradeRules = 0,
        $FailedSectorPairs = 0,
        $FailedShips = 0,
        $TargetType = 0
      ]"/>
      <!-- Chunked pre-filter: process 50 entries per chunk with cooperative yielding to prevent frame spikes -->
      <set_value name="$pfProcessed" exact="0"/>
      <label name="prefilter_work_loop"/>
      <set_value name="$pfChunkStart" exact="$pfProcessed + 1"/>
      <set_value name="$pfChunkEnd" exact="[$pfProcessed + 50, $rawCount].min"/>
      
      <do_if value="$pfChunkStart le $rawCount">
        <do_all exact="($pfChunkEnd - $pfChunkStart + 1)" counter="$pfIdx">
          <set_value name="$rawIdx" exact="$pfChunkStart + $pfIdx - 1"/>
          <!-- Safe access: global cache list may shrink during cooperative yield between chunks -->
          <set_value name="$rawEntry" exact="@$rawCacheList.{$rawIdx}"/>
          <do_if value="$rawEntry?">
            <set_value name="$entryPassesFilters" exact="true"/>
            
            <!-- 1. Distance filter (using precomputed values from cache entry) -->
            <do_if value="$entryPassesFilters">
              <set_value name="$entryHomeToBuy" exact="@$rawEntry.$HomeToBuyDistance"/>
              <set_value name="$entryHomeToSell" exact="@$rawEntry.$HomeToSellDistance"/>
              <do_if value="$entryHomeToBuy? and $entryHomeToSell?">
                <set_value name="$entryMaxDist" exact="[$entryHomeToBuy, $entryHomeToSell].max"/>
                <do_if value="$entryHomeToBuy lt 0 or $entryHomeToSell lt 0 or $entryMaxDist gt $maxDistance">
                  <set_value name="$entryPassesFilters" exact="false"/>
                  <set_value name="$filterRejectCount.$Distance" operation="add"/>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and ($filterRejectCount.$Distance le 20 or ($entryMaxDist le $maxDistance + 1 and $filterRejectCount.$Distance le 50))">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Pre-filter REJECTED (distance): entryMaxDist=' + $entryMaxDist + ', allowed=' + $maxDistance + ', homeToBuy=' + $entryHomeToBuy + ', homeToSell=' + $entryHomeToSell + ', rawIdx=' + $rawIdx" chance="100"/>
                  </do_if>
                </do_if>
                <do_else>
                  <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $rawIdx le 5">
                    <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Pre-filter PASSED (distance): entryMaxDist=' + $entryMaxDist + ', allowed=' + $maxDistance + ', homeToBuy=' + $entryHomeToBuy + ', homeToSell=' + $entryHomeToSell + ', rawIdx=' + $rawIdx" chance="100"/>
                  </do_if>
                </do_else>
              </do_if>
              <do_else>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and ($rawIdx le 3)">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Pre-filter WARNING: distances not cached for entry (will validate later)'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            
            <!-- 2. Illegal ware filter (if ship doesn't allow illegal) -->
            <do_if value="$entryPassesFilters and not $allowIllegal">
              <set_value name="$buyOffer" exact="@$rawEntry.$BuyOffer"/>
              <do_if value="$buyOffer? and $buyOffer.exists">
                <set_value name="$ware" exact="@$buyOffer.ware"/>
                <do_if value="$ware != null and @$ware.illegal gt 0">
                  <set_value name="$entryPassesFilters" exact="false"/>
                  <set_value name="$filterRejectCount.$IllegalWare" operation="add"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- 3. Trade rules filter (if ship requires trade rules) -->
            <do_if value="$entryPassesFilters and not $ignoreTradeRules">
              <set_value name="$tradeRulesRespected" exact="if $rawEntry.$TradeRulesRespected? then $rawEntry.$TradeRulesRespected else false"/>
              <do_if value="not $tradeRulesRespected">
                <set_value name="$entryPassesFilters" exact="false"/>
                <set_value name="$filterRejectCount.$TradeRules" operation="add"/>
              </do_if>
            </do_if>
            
            <!-- 4. Failed sector pairs filter â€” O(1) nested table lookup (matching B2 pattern) -->
            <do_if value="$entryPassesFilters and $failedTrades.keys.count gt 0">
              <set_value name="$buyOffer" exact="@$rawEntry.$BuyOffer"/>
              <set_value name="$sellOffer" exact="@$rawEntry.$SellOffer"/>
              <do_if value="$buyOffer? and $buyOffer.exists and $sellOffer? and $sellOffer.exists">
                <set_value name="$entryBuySector" exact="$buyOffer.owner.sector"/>
                <set_value name="$entrySellSector" exact="$sellOffer.owner.sector"/>
                <do_if value="$failedTrades.{$entryBuySector}? and $failedTrades.{$entryBuySector}.{$entrySellSector}?">
                  <set_value name="$entryPassesFilters" exact="false"/>
                  <set_value name="$filterRejectCount.$FailedSectorPairs" operation="add"/>
                </do_if>
              </do_if>
            </do_if>
            
            <!-- 5. Ship already failed filter (check FailedShips list in cache entry) -->
            <do_if value="$entryPassesFilters">
              <set_value name="$failedShips" exact="@$rawEntry.$FailedShips"/>
              <do_if value="$failedShips != null and $failedShips.count gt 0">
                <do_all exact="$failedShips.count" counter="$f">
                  <do_if value="$failedShips.{$f} == this.ship">
                    <set_value name="$entryPassesFilters" exact="false"/>
                    <set_value name="$filterRejectCount.$FailedShips" operation="add"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_if>
            </do_if>
            
            <!-- 6. Target type filters (build storage, carrier/aux) -->
            <do_if value="$entryPassesFilters and ($ignoreBuildStorage or $ignoreCarrierAux)">
              <set_value name="$buyType" exact="@$rawEntry.$BuyTargetType"/>
              <set_value name="$sellType" exact="@$rawEntry.$SellTargetType"/>
              <do_if value="$ignoreBuildStorage and ($buyType == 'Buildstorage' or $sellType == 'Buildstorage')">
                <set_value name="$entryPassesFilters" exact="false"/>
                <set_value name="$filterRejectCount.$TargetType" operation="add"/>
              </do_if>
              <do_elseif value="$ignoreCarrierAux and (($buyType == 'Aux' or $buyType == 'Carrier') or ($sellType == 'Aux' or $sellType == 'Carrier'))">
                <set_value name="$entryPassesFilters" exact="false"/>
                <set_value name="$filterRejectCount.$TargetType" operation="add"/>
              </do_elseif>
            </do_if>
            
            <!-- Add entry to filtered list if it passed all pre-filters -->
            <do_if value="$entryPassesFilters">
              <append_to_list name="$cacheList" exact="$rawEntry"/>
            </do_if>
          </do_if>
        </do_all>
        
        <set_value name="$pfProcessed" exact="$pfChunkEnd"/>
        
        <!-- Cooperative yield between pre-filter chunks -->
        <wait exact="1ms"/>
        
        <!-- Continue if more entries to process -->
        <do_if value="$pfProcessed lt $rawCount">
          <resume label="prefilter_work_loop"/>
        </do_if>
      </do_if>
      
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cache search params: homeSector=' + (if $homeSector? then $homeSector.knownname else 'null') + ', maxDistance=' + $maxDistance + ', cacheMaxDistance=' + $cacheMaxDistance + ', minProfit=' + $minAbsoluteProfit + ', minROI=' + $minROI + ', rawEntries=' + $rawCount + ', preFilteredEntries=' + $cacheList.count + ', filterRejections: Distance=' + $filterRejectCount.$Distance + ', IllegalWare=' + $filterRejectCount.$IllegalWare + ', TradeRules=' + $filterRejectCount.$TradeRules + ', FailedSectorPairs=' + $filterRejectCount.$FailedSectorPairs + ', FailedShips=' + $filterRejectCount.$FailedShips + ', TargetType=' + $filterRejectCount.$TargetType" chance="100"/>
      
      <!-- Process cache entries with frame budgeting -->
      <!-- Get chunk size from global settings (default: 20) -->
      <set_value name="$chunkSize" exact="20"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$CacheQueryChunkSize?">
        <set_value name="$tmpChunk" exact="@global.$GT_GlobalSettings.$Performance.$CacheQueryChunkSize"/>
        <do_if value="$tmpChunk? and $tmpChunk != null and $tmpChunk gt 0">
          <set_value name="$chunkSize" exact="$tmpChunk"/>
        </do_if>
      </do_if>
      <!-- Clamp to reasonable bounds -->
      <do_if value="$chunkSize lt 10">
        <set_value name="$chunkSize" exact="10"/>
      </do_if>
      <do_if value="$chunkSize gt 200">
        <set_value name="$chunkSize" exact="200"/>
      </do_if>
      
      <!-- Get max trades to return from global settings -->
      <set_value name="$maxTradesToReturn" exact="20"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn?">
        <set_value name="$tmpMax" exact="@global.$GT_GlobalSettings.$Performance.$MaxTradesToReturn"/>
        <do_if value="$tmpMax? and $tmpMax != null and $tmpMax gt 0">
          <set_value name="$maxTradesToReturn" exact="$tmpMax"/>
        </do_if>
      </do_if>
      
      <set_value name="$processedCount" exact="0"/>
      <set_value name="$validTrades" exact="[]"/>
      <set_value name="$bestTrade" exact="null"/>
      <set_value name="$bestScore" exact="0"/>
      
      <label name="cache_work_loop"/>
      <set_value name="$startTime" exact="player.age"/>
      <set_value name="$chunkStart" exact="$processedCount + 1"/>
      <set_value name="$chunkEnd" exact="[$processedCount + $chunkSize, $cacheList.count].min"/>
      
      <do_if value="$chunkStart le $cacheList.count">
        <do_all exact="($chunkEnd - $chunkStart + 1)" counter="$i">
          <set_value name="$cacheIndex" exact="$chunkStart + $i - 1"/>
          <set_value name="$cacheEntry" exact="$cacheList.{$cacheIndex}"/>
          
          <!-- Validate cache entry -->
          <do_if value="$cacheEntry?">
            <set_value name="$cacheAge" exact="player.age - $cacheEntry.$Timestamp"/>
            <do_if value="$cacheAge le 600s">
              <!-- Validate cache entry with full filtering (matching MD script's GT_TS_CachePickBest) -->
              <!-- Use ship-agnostic fields for validation -->
              <set_value name="$buyOffer" exact="@$cacheEntry.$BuyOffer"/>
              <set_value name="$sellOffer" exact="@$cacheEntry.$SellOffer"/>
              
              <!-- Get ship-agnostic fields from cache entry -->
              <set_value name="$offerMaxAmount" exact="@$cacheEntry.$OfferMaxAmount"/>
              <set_value name="$profitPerUnit" exact="@$cacheEntry.$ProfitPerUnit"/>
              <set_value name="$volumePerUnit" exact="@$cacheEntry.$VolumePerUnit"/>
              <set_value name="$buyPrice" exact="@$cacheEntry.$BuyPrice"/>
              <set_value name="$sellPrice" exact="@$cacheEntry.$SellPrice"/>
              
              <!-- Fallback to ship-biased fields for old cache entries (backward compatibility) -->
              <do_if value="not $offerMaxAmount? or $offerMaxAmount == null or $offerMaxAmount le 0">
                <set_value name="$offerMaxAmount" exact="@$cacheEntry.$Amount"/>
              </do_if>
              <do_if value="not $profitPerUnit? or $profitPerUnit == null">
                <set_value name="$cachedProfit" exact="@$cacheEntry.$Profit"/>
                <set_value name="$cachedAmount" exact="@$cacheEntry.$Amount"/>
                <do_if value="$cachedAmount? and $cachedAmount gt 0">
                  <set_value name="$profitPerUnit" exact="$cachedProfit / $cachedAmount"/>
                </do_if>
                <do_else>
                  <set_value name="$profitPerUnit" exact="0"/>
                </do_else>
              </do_if>
              <do_if value="not $volumePerUnit? or $volumePerUnit == null">
                <set_value name="$ware" exact="@$buyOffer.ware"/>
                <set_value name="$volumePerUnit" exact="if $ware? and $ware.volume? then $ware.volume else 1"/>
              </do_if>
              <do_if value="not $buyPrice? or $buyPrice == null">
                <set_value name="$buyPrice" exact="if $buyOffer? and $buyOffer.price? then $buyOffer.price else 0"/>
              </do_if>
              <do_if value="not $sellPrice? or $sellPrice == null">
                <set_value name="$sellPrice" exact="if $sellOffer? and $sellOffer.price? then $sellOffer.price else 0"/>
                <do_if value="$profitPerUnit == 0 and $sellPrice gt 0 and $buyPrice gt 0">
                  <set_value name="$profitPerUnit" exact="$sellPrice - $buyPrice"/>
                </do_if>
              </do_if>
              
              <!-- Track rejection reason for debugging -->
              <set_value name="$rejectReason" exact="''"/>
              <set_value name="$isValid" exact="true"/>
              
              <!-- Basic structure checks -->
              <do_if value="not $buyOffer? or not $buyOffer.exists or not $sellOffer? or not $sellOffer.exists">
                <set_value name="$isValid" exact="false"/>
                <set_value name="$rejectReason" exact="'offers_invalid'"/>
              </do_if>
              <do_elseif value="not @$buyOffer.owner.isoperational or not @$sellOffer.owner.isoperational">
                <set_value name="$isValid" exact="false"/>
                <set_value name="$rejectReason" exact="'station_not_operational'"/>
              </do_elseif>
              
              <!-- NOTE: Distance, illegal ware, trade rules, failed sector pairs, failed ships,
                   and target type checks are SKIPPED here â€” already verified by the pre-filter
                   loop (prefilter_work_loop). Only time-sensitive and ship-specific expensive
                   checks remain below (docking, dock size, offer availability, profit/ROI). -->
              
              <!-- ==================================================================================== -->
              <!-- EXPENSIVE CHECKS LAST: Property lookups on ship/station objects -->
              <!-- ==================================================================================== -->
              
              <!-- Docking permission (ship-specific) - expensive property lookup -->
              <do_if value="$isValid">
                <do_if value="not @$buyOffer.owner.dockingallowed.{this.ship} or not @$sellOffer.owner.dockingallowed.{this.ship}">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'docking_not_allowed'"/>
                </do_if>
              </do_if>
              
              <!-- Dock size compatibility (use cached caps - should always be present) -->
              <do_if value="$isValid">
                <set_value name="$buyCaps" exact="@$cacheEntry.$BuyDockCaps"/>
                <set_value name="$sellCaps" exact="@$cacheEntry.$SellDockCaps"/>
                <do_if value="$buyCaps == null or $sellCaps == null">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'dock_caps_missing'"/>
                </do_if>
                <do_elseif value="$shipDockSize == tag.dock_s and (not $buyCaps.$S or not $sellCaps.$S)">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'dock_size_s_incompatible'"/>
                </do_elseif>
                <do_elseif value="$shipDockSize == tag.dock_m and (not $buyCaps.$M or not $sellCaps.$M)">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'dock_size_m_incompatible'"/>
                </do_elseif>
                <do_elseif value="$shipDockSize == tag.dock_l and (not $buyCaps.$L or not $sellCaps.$L)">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'dock_size_l_incompatible'"/>
                </do_elseif>
                <do_elseif value="$shipDockSize == tag.dock_xl and (not $buyCaps.$XL or not $sellCaps.$XL)">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'dock_size_xl_incompatible'"/>
                </do_elseif>
              </do_if>
              
              <!-- ==================================================================================== -->
              <!-- SHIP-AGNOSTIC CACHE VALIDATION: Use ship-agnostic fields for prefiltering -->
              <!-- ==================================================================================== -->
              
              <!-- Validate offers are still available -->
              <do_if value="$isValid">
                <set_value name="$buyOfferObj" exact="@$cacheEntry.$BuyOffer"/>
                <set_value name="$sellOfferObj" exact="@$cacheEntry.$SellOffer"/>
                <do_if value="not $buyOfferObj? or $buyOfferObj == null or not $buyOfferObj.exists or not $sellOfferObj? or $sellOfferObj == null or not $sellOfferObj.exists">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'offers_no_longer_exist'"/>
                </do_if>
                <do_else>
                  <set_value name="$buyAvailNow" exact="@$buyOfferObj.available"/>
                  <set_value name="$sellAvailNow" exact="@$sellOfferObj.available"/>
                  <set_value name="$buyAmtNow" exact="@$buyOfferObj.amount"/>
                  <set_value name="$sellAmtNow" exact="@$sellOfferObj.amount"/>
                  <do_if value="$buyAmtNow == null">
                    <set_value name="$buyAmtNow" exact="0"/>
                  </do_if>
                  <do_if value="$sellAmtNow == null">
                    <set_value name="$sellAmtNow" exact="0"/>
                  </do_if>
                  <do_if value="not $buyAvailNow or not $sellAvailNow or $buyAmtNow le 0 or $sellAmtNow le 0">
                    <set_value name="$isValid" exact="false"/>
                    <set_value name="$rejectReason" exact="'offers_insufficient_amount buyAvail=' + $buyAvailNow + ' buyAmt=' + $buyAmtNow + ' sellAvail=' + $sellAvailNow + ' sellAmt=' + $sellAmtNow + ' (both stations must have stock > 0)'"/>
                  </do_if>
                  <do_else>
                    <!-- Update offerMaxAmount with current offer amounts (may have changed since cache creation) -->
                    <set_value name="$currentOfferMaxAmount" exact="[$buyAmtNow, $sellAmtNow].min"/>
                    <do_if value="$currentOfferMaxAmount lt $offerMaxAmount">
                      <set_value name="$offerMaxAmount" exact="$currentOfferMaxAmount"/>
                    </do_if>
                  </do_else>
                </do_else>
              </do_if>
              
              <!-- ==================================================================================== -->
              <!-- SHIP-SPECIFIC PREFILTERING: Calculate max tradeable amount for THIS ship -->
              <!-- ==================================================================================== -->
              
              <!-- Calculate ship's max tradeable amount based on cargo capacity -->
              <do_if value="$isValid">
                <set_value name="$shipMaxByCargo" exact="0"/>
                <do_if value="$volumePerUnit gt 0">
                  <set_value name="$shipCargoCapacity" exact="this.ship.cargo.capacity.all"/>
                  <set_value name="$shipCargoFree" exact="this.ship.cargo.free.all"/>
                  <set_value name="$shipMaxByCargo" exact="$shipCargoFree / $volumePerUnit"/>
                </do_if>
                
                <!-- Calculate ship's max tradeable amount based on money (if applicable) -->
                <set_value name="$shipMaxByMoney" exact="999999999"/>
                <do_if value="$buyPrice gt 0">
                  <set_value name="$playerMoney" exact="player.money"/>
                  <set_value name="$shipMaxByMoney" exact="$playerMoney / $buyPrice"/>
                </do_if>
                
                <!-- Calculate ship's actual max tradeable amount -->
                <set_value name="$shipMaxAmount" exact="[$offerMaxAmount, $shipMaxByCargo, $shipMaxByMoney].min"/>
                
                <!-- Early rejection: ship cannot trade any amount -->
                <do_if value="$shipMaxAmount le 0">
                  <set_value name="$isValid" exact="false"/>
                  <set_value name="$rejectReason" exact="'ship_cannot_carry_amount cargoMax=' + $shipMaxByCargo + ' moneyMax=' + $shipMaxByMoney + ' offerMax=' + $offerMaxAmount"/>
                </do_if>
                <do_else>
                  <!-- Calculate ship-specific profit and ROI -->
                  <set_value name="$shipMaxProfit" exact="$profitPerUnit * $shipMaxAmount"/>
                  <set_value name="$shipROI" exact="0"/>
                  <do_if value="$buyPrice gt 0 and $shipMaxAmount gt 0">
                    <set_value name="$shipInvestment" exact="$buyPrice * $shipMaxAmount"/>
                    <do_if value="$shipInvestment gt 0">
                      <set_value name="$shipROI" exact="($shipMaxProfit * 100) / $shipInvestment"/>
                    </do_if>
                  </do_if>
                  
                  <!-- Profit thresholds: use ship-specific calculated values -->
                  <do_if value="$shipMaxProfit lt $minAbsoluteProfit or $shipROI lt $minROI">
                    <set_value name="$isValid" exact="false"/>
                    <set_value name="$rejectReason" exact="'profit_too_low profit=' + $shipMaxProfit + ' min=' + $minAbsoluteProfit + ' roi=' + $shipROI + ' minROI=' + $minROI"/>
                  </do_if>
                </do_else>
              </do_if>
              
              <!-- CRITICAL: Re-validate offers with tradepartner to ensure trade rules are respected -->
              <do_if value="$isValid and not $ignoreTradeRules">
                <set_value name="$buyStation" exact="@$cacheEntry.$BuyOffer.owner"/>
                <set_value name="$buyWare" exact="@$cacheEntry.$BuyOffer.ware"/>
                <set_value name="$sellStation" exact="@$cacheEntry.$SellOffer.owner"/>
                <set_value name="$sellWare" exact="@$cacheEntry.$SellOffer.ware"/>
                
                <do_if value="$buyStation? and $buyStation.exists and $buyWare != null">
                  <find_sell_offer seller="$buyStation" wares="$buyWare" tradepartner="this.ship" result="$validatedBuyOffer"/>
                  <do_if value="not $validatedBuyOffer.available">
                    <set_value name="$isValid" exact="false"/>
                    <set_value name="$rejectReason" exact="'trade_rules_buy_violation'"/>
                  </do_if>
                </do_if>
                
                <do_if value="$isValid and $sellStation? and $sellStation.exists and $sellWare != null">
                  <find_buy_offer buyer="$sellStation" wares="$sellWare" tradepartner="this.ship" result="$validatedSellOffer"/>
                  <do_if value="not $validatedSellOffer.available">
                    <set_value name="$isValid" exact="false"/>
                    <set_value name="$rejectReason" exact="'trade_rules_sell_violation'"/>
                  </do_if>
                </do_if>
              </do_if>
              
              <!-- Debug first few entries -->
              <do_if value="$processedCount + $i le 3">
                <!-- Log cache entry with distance information for debugging -->
                <set_value name="$entryHomeToBuy" exact="@$cacheEntry.$HomeToBuyDistance"/>
                <set_value name="$entryHomeToSell" exact="@$cacheEntry.$HomeToSellDistance"/>
                <set_value name="$entryMaxDist" exact="if ($entryHomeToBuy? and $entryHomeToSell? and $entryHomeToBuy ge 0 and $entryHomeToSell ge 0) then [$entryHomeToBuy, $entryHomeToSell].max else -1"/>
                <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cache entry ' + ($processedCount + $i) + ': profit=' + (if $shipMaxProfit? then $shipMaxProfit else 'null') + ', minProfit=' + $minAbsoluteProfit + ', roi=' + (if $shipROI? then $shipROI else 'null') + ', minROI=' + $minROI + ', shipMaxAmount=' + (if $shipMaxAmount? then $shipMaxAmount else 'null') + ', homeToBuy=' + (if $entryHomeToBuy? then $entryHomeToBuy else 'null') + ', homeToSell=' + (if $entryHomeToSell? then $entryHomeToSell else 'null') + ', maxDist=' + $entryMaxDist + ', allowed=' + $maxDistance + ', valid=' + $isValid + (if not $isValid then ' reason=' + $rejectReason else '')" chance="100"/>
              </do_if>
              
              <!-- Add to valid trades if all checks passed -->
              <do_if value="$isValid">
                <!-- Limit trades collected based on maxTradesToReturn -->
                <do_if value="$validTrades.count lt $maxTradesToReturn">
                  <append_to_list name="$validTrades" exact="$cacheEntry"/>
                  <set_value name="$entryScore" exact="if $cacheEntry.$Score? then $cacheEntry.$Score else (if $shipMaxProfit? then $shipMaxProfit else 0)"/>
                  <do_if value="$entryScore gt $bestScore">
                    <set_value name="$bestTrade" exact="$cacheEntry"/>
                    <set_value name="$bestScore" exact="$entryScore"/>
                  </do_if>
                </do_if>
                <do_else>
                  <!-- Early exit if we have enough trades -->
                  <break/>
                </do_else>
              </do_if>
              <do_else>
                <!-- Log rejection reason for first few rejected entries -->
                <do_if value="$processedCount + $i le 5 and $rejectReason != ''">
                  <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cache entry ' + ($processedCount + $i) + ' REJECTED: ' + $rejectReason" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
          </do_if>
        </do_all>
        
        <!-- Early exit if we have enough trades -->
        <do_if value="$validTrades.count ge $maxTradesToReturn">
          <break/>
        </do_if>
        
        <set_value name="$processedCount" exact="$chunkEnd"/>
        
        <!-- BUG C5 FIX: Unconditional cooperative yield (wait must be top-level in AI scripts, not inside do_if) -->
        <wait exact="1ms"/>
        <set_value name="$startTime" exact="player.age"/>
        
        <!-- Continue if more to process -->
        <do_if value="$processedCount lt $cacheList.count">
          <resume label="cache_work_loop"/>
        </do_if>
      </do_if>
      
      <!-- Signal completion -->
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cache search complete: processed=' + $processedCount + '/' + $cacheList.count + ', validTrades=' + $validTrades.count + ', bestTrade=' + (if $bestTrade != null then 'found' else 'null') + ', bestScore=' + $bestScore" chance="100"/>
      
      <signal_objects object="player.galaxy" param="'GT_WorkUnit_Complete'" param2="table[
        $Ship = this.ship,
        $WorkType = 'cache_search',
        $Result = table[
          $Found = ($bestTrade != null),
          $Trade = $bestTrade,
          $Trades = $validTrades,
          $BestScore = $bestScore
        ]
      ]"/>
      <!-- CRITICAL: Go to wait_for_response (NOT main_loop) so the AI is in a wait state
           when the MD sends GT_Trade_Found or GT_No_Trade_Found after processing the results.
           Previously resumed to main_loop, which ran synchronously and missed the delayed signal. -->
      <resume label="wait_for_response"/>
      
      <!-- Process live offers work unit -->
      <label name="process_live_offers_workunit"/>
      
      <!-- Extract parameters -->
      <set_value name="$homeSector" exact="@$workUnit.$HomeSector"/>
      <set_value name="$sectors" exact="@$workUnit.$Sectors"/>
      <set_value name="$maxDistance" exact="@$workUnit.$MaxDistance"/>
      <set_value name="$wareBasket" exact="if $workUnit.$WareBasket? then $workUnit.$WareBasket else []"/>
      <set_value name="$allowIllegal" exact="if $workUnit.$AllowIllegal? then $workUnit.$AllowIllegal else false"/>
      <set_value name="$ignoreBuildStorage" exact="if $workUnit.$IgnoreBuildStorage? then $workUnit.$IgnoreBuildStorage else false"/>
      <set_value name="$ignoreCarrierAux" exact="if $workUnit.$IgnoreCarrierAux? then $workUnit.$IgnoreCarrierAux else false"/>
      
      <!-- Initialize work state -->
      <!-- Get chunk size from global settings (default: 3 sectors per chunk) -->
      <set_value name="$chunkSize" exact="3"/>
      <!-- Use LiveOfferSliceInterval to determine chunk size (convert ms to sectors) -->
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval?">
        <set_value name="$sliceInterval" exact="@global.$GT_GlobalSettings.$Performance.$LiveOfferSliceInterval"/>
        <!-- Smaller interval = smaller chunks for smoother performance -->
        <do_if value="$sliceInterval? and $sliceInterval != null">
          <do_if value="$sliceInterval le 100">
            <set_value name="$chunkSize" exact="1"/>
          </do_if>
          <do_elseif value="$sliceInterval le 300">
            <set_value name="$chunkSize" exact="2"/>
          </do_elseif>
          <do_elseif value="$sliceInterval le 500">
            <set_value name="$chunkSize" exact="3"/>
          </do_elseif>
          <do_else>
            <set_value name="$chunkSize" exact="5"/>
          </do_else>
        </do_if>
      </do_if>
      
      <!-- Get max offers per ware from global settings -->
      <set_value name="$maxOffersPerWare" exact="200"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare?">
        <set_value name="$tmpMax" exact="@global.$GT_GlobalSettings.$Performance.$MaxOffersPerWare"/>
        <do_if value="$tmpMax? and $tmpMax != null and $tmpMax gt 0">
          <set_value name="$maxOffersPerWare" exact="$tmpMax"/>
        </do_if>
      </do_if>
      
      <set_value name="$processedSectors" exact="0"/>
      <set_value name="$sellOffers" exact="[]"/>
      <set_value name="$buyOffers" exact="[]"/>
      
      <!-- Track offers per ware to enforce MaxOffersPerWare limit -->
      <set_value name="$sellOffersPerWare" exact="table[]"/>
      <set_value name="$buyOffersPerWare" exact="table[]"/>
      
      <!-- Process sectors in chunks with frame budgeting -->
      <label name="offers_work_loop"/>
      <set_value name="$startTime" exact="player.age"/>
      <set_value name="$chunkStart" exact="$processedSectors + 1"/>
      <set_value name="$chunkEnd" exact="[$processedSectors + $chunkSize, $sectors.count].min"/>
      
      <do_if value="$chunkStart le $sectors.count">
        <do_all exact="($chunkEnd - $chunkStart + 1)" counter="$i">
          <set_value name="$sectorIndex" exact="$chunkStart + $i - 1"/>
          <set_value name="$sector" exact="$sectors.{$sectorIndex}"/>
          
          <!-- Collect offers from sector -->
          <do_if value="$sector? and $sector.exists">
            <!-- Find sell offers (for buying) -->
            <find_sell_offer space="$sector" result="$sectorSellOffers"/>
            <do_if value="$sectorSellOffers?">
              <do_all exact="$sectorSellOffers.count" counter="$j">
                <set_value name="$offer" exact="$sectorSellOffers.{$j}"/>
                <set_value name="$isValid" exact="true"/>
                
                <!-- Check station type filters -->
                <do_if value="$isValid and $offer.owner?">
                  <set_value name="$station" exact="$offer.owner"/>
                  <do_if value="$ignoreBuildStorage and $station.isbuildstorage">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                  <do_if value="$isValid and $ignoreCarrierAux">
                    <do_if value="$station.isauxiliary or $station.iscarrier">
                      <set_value name="$isValid" exact="false"/>
                    </do_if>
                  </do_if>
                </do_if>
                
                <!-- Check ware basket filter -->
                <do_if value="$isValid and $wareBasket.count gt 0">
                  <set_value name="$wareMatch" exact="false"/>
                  <do_all exact="$wareBasket.count" counter="$k">
                    <do_if value="$wareBasket.{$k} == $offer.ware">
                      <set_value name="$wareMatch" exact="true"/>
                      <break/>
                    </do_if>
                  </do_all>
                  <do_if value="not $wareMatch">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                </do_if>
                
                <!-- Check illegal goods filter -->
                <do_if value="$isValid and not $allowIllegal">
                  <do_if value="$offer.ware != null and @$offer.ware.illegal gt 0">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                </do_if>
                
                <do_if value="$isValid">
                  <!-- Limit offers per ware -->
                  <set_value name="$ware" exact="@$offer.ware"/>
                  <set_value name="$wareOfferCount" exact="if $sellOffersPerWare.{$ware}? then $sellOffersPerWare.{$ware} else 0"/>
                  <do_if value="$wareOfferCount lt $maxOffersPerWare">
                    <append_to_list name="$sellOffers" exact="$offer"/>
                    <set_value name="$sellOffersPerWare.{$ware}" exact="$wareOfferCount + 1"/>
                  </do_if>
                </do_if>
              </do_all>
            </do_if>
            
            <!-- Find buy offers (for selling) -->
            <find_buy_offer space="$sector" result="$sectorBuyOffers"/>
            <do_if value="$sectorBuyOffers?">
              <do_all exact="$sectorBuyOffers.count" counter="$j">
                <set_value name="$offer" exact="$sectorBuyOffers.{$j}"/>
                <set_value name="$isValid" exact="true"/>
                
                <!-- Check station type filters -->
                <do_if value="$isValid and $offer.owner?">
                  <set_value name="$station" exact="$offer.owner"/>
                  <do_if value="$ignoreBuildStorage and $station.isbuildstorage">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                  <do_if value="$isValid and $ignoreCarrierAux">
                    <do_if value="$station.isauxiliary or $station.iscarrier">
                      <set_value name="$isValid" exact="false"/>
                    </do_if>
                  </do_if>
                </do_if>
                
                <!-- Check ware basket filter -->
                <do_if value="$isValid and $wareBasket.count gt 0">
                  <set_value name="$wareMatch" exact="false"/>
                  <do_all exact="$wareBasket.count" counter="$k">
                    <do_if value="$wareBasket.{$k} == $offer.ware">
                      <set_value name="$wareMatch" exact="true"/>
                      <break/>
                    </do_if>
                  </do_all>
                  <do_if value="not $wareMatch">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                </do_if>
                
                <!-- Check illegal goods filter -->
                <do_if value="$isValid and not $allowIllegal">
                  <do_if value="$offer.ware != null and @$offer.ware.illegal gt 0">
                    <set_value name="$isValid" exact="false"/>
                  </do_if>
                </do_if>
                
                <do_if value="$isValid">
                  <!-- Limit offers per ware -->
                  <set_value name="$ware" exact="@$offer.ware"/>
                  <set_value name="$wareOfferCount" exact="if $buyOffersPerWare.{$ware}? then $buyOffersPerWare.{$ware} else 0"/>
                  <do_if value="$wareOfferCount lt $maxOffersPerWare">
                    <append_to_list name="$buyOffers" exact="$offer"/>
                    <set_value name="$buyOffersPerWare.{$ware}" exact="$wareOfferCount + 1"/>
                  </do_if>
                </do_if>
              </do_all>
            </do_if>
          </do_if>
        </do_all>
        
        <set_value name="$processedSectors" exact="$chunkEnd"/>
        
        <!-- BUG C5 FIX: Unconditional cooperative yield (wait must be top-level in AI scripts, not inside do_if) -->
        <wait exact="1ms"/>
        <set_value name="$startTime" exact="player.age"/>
        
        <!-- Continue if more to process -->
        <do_if value="$processedSectors lt $sectors.count">
          <resume label="offers_work_loop"/>
        </do_if>
      </do_if>
      
      <!-- Filter offers by distance using MD library (via signal) -->
      <!-- Store offers in global state for MD to filter -->
      <set_value name="global.$GT_WorkUnitOffers.{$ship}" exact="table[
        $SellOffers = $sellOffers,
        $BuyOffers = $buyOffers,
        $HomeSector = $homeSector,
        $MaxDistance = $maxDistance
      ]"/>
      
      <!-- Signal MD to filter offers by distance -->
      <signal_objects object="player.galaxy" param="'GT_FilterWorkUnitOffers'" param2="table[$Ship = this.ship]"/>
      
      <!-- Wait for filtering to complete (will be signaled back) -->
      <wait max="5s">
        <interrupt>
          <conditions>
            <event_object_signalled object="this.ship" param="'GT_WorkUnitOffersFiltered'"/>
          </conditions>
          <actions>
            <!-- Get filtered results -->
            <set_value name="$filteredResult" exact="@global.$GT_WorkUnitOffersFiltered.{$ship}"/>
            <remove_value name="global.$GT_WorkUnitOffersFiltered.{$ship}"/>
            
            <!-- Signal completion -->
            <signal_objects object="player.galaxy" param="'GT_WorkUnit_Complete'" param2="table[
              $Ship = this.ship,
              $WorkType = 'live_offers',
              $Result = if $filteredResult? then $filteredResult else table[$SellOffers = [], $BuyOffers = []]
            ]"/>
            <!-- CRITICAL: Go to wait_for_response so AI catches MD's GT_Trade_Found/GT_No_Trade_Found -->
            <resume label="wait_for_response"/>
          </actions>
        </interrupt>
      </wait>
      
      <!-- Timeout fallback -->
      <set_value name="$filteredResult" exact="@global.$GT_WorkUnitOffersFiltered.{$ship}"/>
      <do_if value="not $filteredResult?">
        <set_value name="$filteredResult" exact="table[$SellOffers = $sellOffers, $BuyOffers = $buyOffers]"/>
      </do_if>
      <remove_value name="global.$GT_WorkUnitOffersFiltered.{$ship}"/>
      <signal_objects object="player.galaxy" param="'GT_WorkUnit_Complete'" param2="table[
        $Ship = this.ship,
        $WorkType = 'live_offers',
        $Result = $filteredResult
      ]"/>
      <!-- CRITICAL: Go to wait_for_response so AI catches MD's GT_Trade_Found/GT_No_Trade_Found -->
      <resume label="wait_for_response"/>
      
      <!-- Process trade matching work unit -->
      <label name="process_trade_matching_workunit"/>
      
      <!-- Extract parameters -->
      <set_value name="$sellOffers" exact="@$workUnit.$SellOffers"/>
      <set_value name="$buyOffers" exact="@$workUnit.$BuyOffers"/>
      <set_value name="$homeSector" exact="@$workUnit.$HomeSector"/>
      <set_value name="$maxDistance" exact="@$workUnit.$MaxDistance"/>
      <set_value name="$minROI" exact="@$workUnit.$MinROI"/>
      <set_value name="$minAbsoluteProfit" exact="@$workUnit.$MinAbsoluteProfit"/>
      <set_value name="$distancePenaltyMultiplier" exact="if $workUnit.$DistancePenaltyMultiplier? then $workUnit.$DistancePenaltyMultiplier else 0.5"/>
      
      <!-- Initialize work state -->
      <!-- Get chunk size from global settings (default: 10 trade pairs per chunk) -->
      <set_value name="$chunkSize" exact="10"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$BatchChunkSize?">
        <set_value name="$tmpChunk" exact="@global.$GT_GlobalSettings.$Performance.$BatchChunkSize"/>
        <do_if value="$tmpChunk? and $tmpChunk != null and $tmpChunk gt 0">
          <!-- BatchChunkSize is for offers, scale for trade pairs (roughly square) -->
          <set_value name="$chunkSize" exact="$tmpChunk * 2"/>
        </do_if>
      </do_if>
      <!-- Clamp to reasonable bounds -->
      <do_if value="$chunkSize lt 5">
        <set_value name="$chunkSize" exact="5"/>
      </do_if>
      <do_if value="$chunkSize gt 50">
        <set_value name="$chunkSize" exact="50"/>
      </do_if>
      
      <!-- Get max trades per ware from global settings -->
      <set_value name="$maxTradesPerWare" exact="20"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare?">
        <set_value name="$tmpMax" exact="@global.$GT_GlobalSettings.$Performance.$MaxTradesPerWare"/>
        <do_if value="$tmpMax? and $tmpMax != null and $tmpMax gt 0">
          <set_value name="$maxTradesPerWare" exact="$tmpMax"/>
        </do_if>
      </do_if>
      
      <!-- Get early exit threshold from global settings -->
      <set_value name="$earlyExitThreshold" exact="2000"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold?">
        <set_value name="$tmpThreshold" exact="@global.$GT_GlobalSettings.$Performance.$EarlyExitThreshold"/>
        <do_if value="$tmpThreshold? and $tmpThreshold != null and $tmpThreshold gt 0">
          <set_value name="$earlyExitThreshold" exact="$tmpThreshold"/>
        </do_if>
      </do_if>
      
      <set_value name="$processedPairs" exact="0"/>
      <set_value name="$validTrades" exact="[]"/>
      <set_value name="$bestTrade" exact="null"/>
      <set_value name="$bestScore" exact="0"/>
      
      <!-- Initialize rejection counters for logging -->
      <set_value name="$profitRejectionCount" exact="0"/>
      <set_value name="$roiRejectionCount" exact="0"/>
      
      <!-- Get max offers per ware for matching from global settings -->
      <set_value name="$maxOffersPerWareForMatching" exact="20"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$MaxOffersPerWareForMatching?">
        <set_value name="$tmpMaxOffers" exact="@global.$GT_GlobalSettings.$Performance.$MaxOffersPerWareForMatching"/>
        <do_if value="$tmpMaxOffers? and $tmpMaxOffers != null and $tmpMaxOffers gt 0">
          <set_value name="$maxOffersPerWareForMatching" exact="$tmpMaxOffers"/>
        </do_if>
      </do_if>
      
      <!-- Track trades per ware for limiting -->
      <set_value name="$tradesPerWare" exact="table[]"/>
      
      <!-- Index offers by ware (simplified - no MD library call) -->
      <!-- Limit offers per ware using MaxOffersPerWareForMatching -->
      <!-- FIX: Validate offers are available before indexing (prevents NULL owner/price issues) -->
      <set_value name="$sellOffersByWare" exact="table[]"/>
      <do_all exact="$sellOffers.count" counter="$i">
        <set_value name="$offer" exact="$sellOffers.{$i}"/>
        <!-- Validate offer exists and is available before indexing -->
        <do_if value="$offer? and $offer.available">
          <set_value name="$ware" exact="@$offer.ware"/>
          <do_if value="$ware?">
            <do_if value="not $sellOffersByWare.{$ware}?">
              <set_value name="$sellOffersByWare.{$ware}" exact="[]"/>
            </do_if>
            <!-- Limit offers per ware -->
            <do_if value="$sellOffersByWare.{$ware}.count lt $maxOffersPerWareForMatching">
              <append_to_list name="$sellOffersByWare.{$ware}" exact="$offer"/>
            </do_if>
          </do_if>
        </do_if>
      </do_all>
      
      <set_value name="$buyOffersByWare" exact="table[]"/>
      <do_all exact="$buyOffers.count" counter="$i">
        <set_value name="$offer" exact="$buyOffers.{$i}"/>
        <!-- Validate offer exists and is available before indexing -->
        <do_if value="$offer? and $offer.available">
          <set_value name="$ware" exact="@$offer.ware"/>
          <do_if value="$ware?">
            <do_if value="not $buyOffersByWare.{$ware}?">
              <set_value name="$buyOffersByWare.{$ware}" exact="[]"/>
            </do_if>
            <!-- Limit offers per ware -->
            <do_if value="$buyOffersByWare.{$ware}.count lt $maxOffersPerWareForMatching">
              <append_to_list name="$buyOffersByWare.{$ware}" exact="$offer"/>
            </do_if>
          </do_if>
        </do_if>
      </do_all>
      
      <!-- OPTIMIZATION: Lazy pair generation - generate pairs on-demand instead of upfront -->
      <!-- Get list of wares that have both sell and buy offers -->
      <set_value name="$wareKeys" exact="[]"/>
      <do_all exact="$sellOffersByWare.keys.count" counter="$i">
        <set_value name="$ware" exact="$sellOffersByWare.keys.{$i}"/>
        <do_if value="$buyOffersByWare.{$ware}? and $buyOffersByWare.{$ware}.count gt 0">
          <append_to_list name="$wareKeys" exact="$ware"/>
        </do_if>
      </do_all>
      
      <!-- Initialize lazy generation state -->
      <set_value name="$currentWareIndex" exact="0"/>
      <set_value name="$currentSellIndex" exact="0"/>
      <set_value name="$currentBuyIndex" exact="0"/>
      
      <!-- Process trade pairs in chunks with frame budgeting (lazy generation) -->
      <label name="matching_work_loop"/>
      <set_value name="$startTime" exact="player.age"/>
      <set_value name="$pairsProcessedThisChunk" exact="0"/>
      
      <!-- Generate and process pairs on-demand -->
      <do_if value="$wareKeys.count gt 0">
        <do_while value="$pairsProcessedThisChunk lt $chunkSize and ($currentWareIndex lt $wareKeys.count)">
        <!-- Check early exit threshold -->
        <do_if value="$validTrades.count ge $earlyExitThreshold">
          <break/>
        </do_if>
        
        <!-- Get current ware with safe access -->
        <set_value name="$ware" exact="@$wareKeys.{$currentWareIndex}"/>
        <do_if value="not $ware?">
          <!-- Invalid ware index, skip to next -->
          <set_value name="$currentWareIndex" exact="$currentWareIndex + 1"/>
          <set_value name="$currentSellIndex" exact="0"/>
          <set_value name="$currentBuyIndex" exact="0"/>
          <continue/>
        </do_if>
        
        <!-- Validate lists exist and have items before accessing -->
        <set_value name="$listsValid" exact="false"/>
        <do_if value="$sellOffersByWare.{$ware}?">
          <do_if value="$buyOffersByWare.{$ware}?">
            <set_value name="$sellList" exact="$sellOffersByWare.{$ware}"/>
            <set_value name="$buyList" exact="$buyOffersByWare.{$ware}"/>
            <do_if value="$sellList.count gt 0">
              <do_if value="$buyList.count gt 0">
                <set_value name="$listsValid" exact="true"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        
        <do_if value="not $listsValid">
          <!-- Invalid lists, skip to next ware -->
          <set_value name="$currentWareIndex" exact="$currentWareIndex + 1"/>
          <set_value name="$currentSellIndex" exact="0"/>
          <set_value name="$currentBuyIndex" exact="0"/>
          <continue/>
        </do_if>
        
        <!-- At this point, $sellList and $buyList are guaranteed to be set and valid -->
        
        <!-- Check if current ware is complete (reached MaxTradesPerWare limit) -->
        <set_value name="$wareTradeCount" exact="if $tradesPerWare.{$ware}? then $tradesPerWare.{$ware} else 0"/>
        <do_if value="$wareTradeCount ge $maxTradesPerWare">
          <!-- OPTIMIZATION: Early termination per ware - skip to next ware immediately -->
          <set_value name="$currentWareIndex" exact="$currentWareIndex + 1"/>
          <set_value name="$currentSellIndex" exact="0"/>
          <set_value name="$currentBuyIndex" exact="0"/>
          <continue/>
        </do_if>
        
        <!-- Generate next pair on-demand -->
        <do_if value="$listsValid and $currentSellIndex lt $sellList.count and $currentBuyIndex lt $buyList.count">
          <set_value name="$sellOffer" exact="@$sellList.{$currentSellIndex}"/>
          <set_value name="$buyOffer" exact="@$buyList.{$currentBuyIndex}"/>
          
          <!-- Validate offers exist AND are available (prevents NULL owner/price issues) -->
          <!-- FIX: Check offer.available - offers can exist but not be available, causing NULL owner/price -->
          <do_if value="$sellOffer? and $buyOffer? and $sellOffer.available and $buyOffer.available">
            <!-- OPTIMIZATION: Quick profit pre-filtering before full evaluation -->
            <!-- FIX: Use unitprice (price per unit) instead of price (total price) - price is total for entire offer amount -->
            <set_value name="$buyPrice" exact="@$sellOffer.unitprice"/>
            <set_value name="$sellPrice" exact="@$buyOffer.unitprice"/>
            <set_value name="$profitPerUnit" exact="$sellPrice - $buyPrice"/>
            <set_value name="$amount" exact="[@$sellOffer.amount, @$buyOffer.amount].min"/>
            <set_value name="$quickProfit" exact="$profitPerUnit * $amount"/>
            
            <!-- Increment processed pairs counter -->
            <set_value name="$processedPairs" exact="$processedPairs + 1"/>
            
            <!-- Quick profit check - skip if can't meet minimum -->
            <do_if value="$quickProfit ge $minAbsoluteProfit">
              <!-- Full evaluation -->
              <!-- Calculate ROI -->
              <set_value name="$investment" exact="$buyPrice * $amount"/>
              <set_value name="$roi" exact="if $investment gt 0 then (($quickProfit * 100) / $investment) else 0"/>
              
              <do_if value="$roi ge $minROI">
                <!-- Simplified distance calculation (use sector distance if available) -->
                <set_value name="$buyDistance" exact="0"/>
                <set_value name="$sellDistance" exact="0"/>
                <do_if value="$sellOffer.owner? and $sellOffer.owner.sector? and $homeSector?">
                  <set_value name="$buySector" exact="$sellOffer.owner.sector"/>
                  <do_if value="$buySector != $homeSector">
                    <set_value name="$buyDistance" exact="1"/> <!-- Simplified - assume 1 jump if different sector -->
                  </do_if>
                </do_if>
                <do_if value="$buyOffer.owner? and $buyOffer.owner.sector? and $homeSector?">
                  <set_value name="$sellSector" exact="$buyOffer.owner.sector"/>
                  <do_if value="$sellSector != $homeSector">
                    <set_value name="$sellDistance" exact="1"/> <!-- Simplified - assume 1 jump if different sector -->
                  </do_if>
                </do_if>
                
                <set_value name="$totalDistance" exact="$buyDistance + $sellDistance"/>
                <set_value name="$distancePenalty" exact="$totalDistance * $distancePenaltyMultiplier * 100"/> <!-- Scale penalty -->
                <set_value name="$score" exact="$quickProfit - $distancePenalty"/>
                
                <!-- Check trades per ware limit -->
                <do_if value="$wareTradeCount lt $maxTradesPerWare">
                  <!-- Create trade entry -->
                  <!-- FIX: Store BuyPrice and SellPrice in trade object for profit recalculation -->
                  <set_value name="$trade" exact="table[
                    $BuyOffer = $sellOffer,
                    $SellOffer = $buyOffer,
                    $BuyPrice = $buyPrice,
                    $SellPrice = $sellPrice,
                    $Profit = $quickProfit,
                    $ROI = $roi,
                    $Amount = $amount,
                    $Score = $score,
                    $Distance = $totalDistance
                  ]"/>
                  
                  <append_to_list name="$validTrades" exact="$trade"/>
                  <set_value name="$tradesPerWare.{$ware}" exact="$wareTradeCount + 1"/>
                  
                  <!-- Track best trade -->
                  <do_if value="$score gt $bestScore">
                    <set_value name="$bestTrade" exact="$trade"/>
                    <set_value name="$bestScore" exact="$score"/>
                  </do_if>
                </do_if>
              </do_if>
              <do_else>
                <!-- ROI check failed - log first few rejections -->
                <set_value name="$roiRejectionCount" exact="$roiRejectionCount + 1"/>
                <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $roiRejectionCount le 10">
                  <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                  <set_value name="$buyStationName" exact="if $sellOffer.owner? then @$sellOffer.owner.knownname else 'NULL'"/>
                  <set_value name="$sellStationName" exact="if $buyOffer.owner? then @$buyOffer.owner.knownname else 'NULL'"/>
                  <debug_text text="'[GT-AI-TradeMatching] ' + this.ship.idcode + ': Pair REJECTED (ROI): #' + $roiRejectionCount +
                    '\n  Ware: ' + $wareName +
                    '\n  Buy: ' + $buyStationName + ' @ ' + ($buyPrice/100) + ' Cr' +
                    '\n  Sell: ' + $sellStationName + ' @ ' + ($sellPrice/100) + ' Cr' +
                    '\n  ProfitPerUnit: ' + ($profitPerUnit/100) + ' Cr' +
                    '\n  Amount: ' + $amount + ' units' +
                    '\n  QuickProfit: ' + ($quickProfit/100) + ' Cr' +
                    '\n  Investment: ' + ($investment/100) + ' Cr' +
                    '\n  ROI: ' + $roi + '%' +
                    '\n  MinROI: ' + $minROI + '%'" chance="100"/>
                </do_if>
              </do_else>
            </do_if>
            <do_else>
              <!-- Quick profit check failed - log first few rejections -->
              <set_value name="$profitRejectionCount" exact="$profitRejectionCount + 1"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging and $profitRejectionCount le 10">
                <set_value name="$wareName" exact="if $ware? then @$ware.name else 'NULL'"/>
                <set_value name="$buyStationName" exact="if $sellOffer.owner? then @$sellOffer.owner.knownname else 'NULL'"/>
                <set_value name="$sellStationName" exact="if $buyOffer.owner? then @$buyOffer.owner.knownname else 'NULL'"/>
                <debug_text text="'[GT-AI-TradeMatching] ' + this.ship.idcode + ': Pair REJECTED (profit): #' + $profitRejectionCount +
                  '\n  Ware: ' + $wareName +
                  '\n  Buy: ' + $buyStationName + ' @ ' + ($buyPrice/100) + ' Cr' +
                  '\n  Sell: ' + $sellStationName + ' @ ' + ($sellPrice/100) + ' Cr' +
                  '\n  ProfitPerUnit: ' + ($profitPerUnit/100) + ' Cr' +
                  '\n  Amount: ' + $amount + ' units' +
                  '\n  QuickProfit: ' + ($quickProfit/100) + ' Cr' +
                  '\n  MinProfit: ' + ($minAbsoluteProfit/100) + ' Cr'" chance="100"/>
              </do_if>
            </do_else>
          </do_if>
          
          <!-- Advance to next pair -->
          <set_value name="$currentBuyIndex" exact="$currentBuyIndex + 1"/>
          <do_if value="$currentBuyIndex ge $buyList.count">
            <set_value name="$currentBuyIndex" exact="0"/>
            <set_value name="$currentSellIndex" exact="$currentSellIndex + 1"/>
            <do_if value="$currentSellIndex ge $sellList.count">
              <!-- Move to next ware -->
              <set_value name="$currentWareIndex" exact="$currentWareIndex + 1"/>
              <set_value name="$currentSellIndex" exact="0"/>
              <set_value name="$currentBuyIndex" exact="0"/>
            </do_if>
          </do_if>
          
          <set_value name="$pairsProcessedThisChunk" exact="$pairsProcessedThisChunk + 1"/>
        </do_if>
        <do_else>
          <!-- Current ware exhausted, move to next -->
          <set_value name="$currentWareIndex" exact="$currentWareIndex + 1"/>
          <set_value name="$currentSellIndex" exact="0"/>
          <set_value name="$currentBuyIndex" exact="0"/>
        </do_else>
        </do_while>
      </do_if>
      
      <!-- BUG C5 FIX: Unconditional cooperative yield (wait must be top-level in AI scripts, not inside do_if) -->
      <wait exact="1ms"/>
      <set_value name="$startTime" exact="player.age"/>
      
      <!-- Continue if more to process -->
      <do_if value="$currentWareIndex lt $wareKeys.count">
        <resume label="matching_work_loop"/>
      </do_if>
      
      <!-- Signal completion -->
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI-TradeMatching] ' + this.ship.idcode + ': Trade matching complete:' +
          '\n  ProcessedPairs: ' + $processedPairs +
          '\n  ValidTrades: ' + $validTrades.count +
          '\n  BestTrade: ' + (if $bestTrade != null then 'found' else 'null') +
          '\n  BestScore: ' + $bestScore +
          '\n  WareKeys: ' + $wareKeys.count +
          '\n  Rejected (profit): ' + $profitRejectionCount +
          '\n  Rejected (ROI): ' + $roiRejectionCount" chance="100"/>
      </do_if>
      <signal_objects object="player.galaxy" param="'GT_WorkUnit_Complete'" param2="table[
        $Ship = this.ship,
        $WorkType = 'trade_matching',
        $Result = table[
          $Found = ($bestTrade != null),
          $Trade = $bestTrade,
          $Trades = $validTrades,
          $BestScore = $bestScore
        ]
      ]"/>
      <!-- CRITICAL: Go to wait_for_response so AI catches MD's GT_Trade_Found/GT_No_Trade_Found -->
      <resume label="wait_for_response"/>
      
    </actions>
  </attention>
  
  <on_abort>
    <!-- Enhanced cleanup when order is aborted/replaced -->
    <!-- Preserve pilot XP data when order is manually replaced by player -->
    <!-- Only completely wipe data in genuine cleanup scenarios (ship destroyed, pilot changed, etc.) -->
    <set_value name="$isActivelyTrading" exact="false"/>
    <set_value name="$isTrainingTransition" exact="false"/>
    
    <!-- Clean up resupply tracking if order aborted mid-resupply -->
    <!-- IMPORTANT: Do NOT clear during maintenance transitions (subordinates can be aborted/replaced while resupply order is active) -->
    <do_if value="not this.$maintenance_transition? and global.$GT_ResupplyOrders? and global.$GT_ResupplyOrders.{this.ship}?">
      <remove_value name="global.$GT_ResupplyOrders.{this.ship}"/>
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Cleaned up resupply tracking on order abort'" chance="100"/>
      </do_if>
    </do_if>
    
    <!-- Check if ship has active TradePerform orders -->
    <do_if value="this.ship.orders.count gt 1">
      <do_all exact="this.ship.orders.count" counter="$i">
        <do_if value="this.ship.orders.{$i}.id == 'TradePerform'">
          <set_value name="$isActivelyTrading" exact="true"/>
          <break/>
        </do_if>
      </do_all>
    </do_if>
    
    <!-- Check if a training order was recently created (within last 5 seconds) -->
    <do_if value="this.$training_order_created? and (player.age - this.$training_order_created) lt 5s">
      <set_value name="$isTrainingTransition" exact="true"/>
    </do_if>
    
    <!-- Also check the flag-based detection -->
    <do_if value="this.$training_transition?">
      <set_value name="$isTrainingTransition" exact="true"/>
    </do_if>
    
    <!-- Check if a maintenance order was recently created (repair/resupply) -->
    <set_value name="$isMaintenanceTransition" exact="false"/>
    <do_if value="this.$maintenance_transition?">
      <set_value name="$isMaintenanceTransition" exact="true"/>
    </do_if>
    
    <!-- Ship state and orders at removal detection -->
    <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
      <set_value name="$debugShip" exact="this.ship"/>
      <set_value name="$debugDefaultOrder" exact="@$debugShip.defaultorder.id"/>
      <set_value name="$debugCommander" exact="@$debugShip.commander"/>
      <set_value name="$debugCommanderId" exact="if @$debugCommander.exists then @$debugCommander.idcode else 'NONE'"/>
      <set_value name="$debugCommanderOrder" exact="if @$debugCommander.exists and @$debugCommander.defaultorder != null then @$debugCommander.defaultorder.id else 'NONE'"/>
      <set_value name="$debugPilot" exact="@$debugShip.pilot"/>
      <set_value name="$debugPilotName" exact="if $debugPilot != null then @$debugPilot.knownname else 'NONE'"/>
      
      <!-- Build orders list -->
      <set_value name="$debugOrdersList" exact="[]"/>
      <set_value name="$debugOrdersCount" exact="$debugShip.orders.count"/>
      <do_all exact="$debugOrdersCount" counter="$i">
        <set_value name="$orderId" exact="@$debugShip.orders.{$i}.id"/>
        <append_to_list name="$debugOrdersList" exact="if $orderId then $orderId else 'UNKNOWN'"/>
      </do_all>
      <set_value name="$debugOrdersStr" exact="if $debugOrdersList.count gt 0 then $debugOrdersList.{1} + (if $debugOrdersList.count gt 1 then ', ' + $debugOrdersList.{2} else '') + (if $debugOrdersList.count gt 2 then ', ' + $debugOrdersList.{3} else '') + (if $debugOrdersList.count gt 3 then ', ' + $debugOrdersList.{4} else '') + (if $debugOrdersList.count gt 4 then ', ...' else '') else 'NONE'"/>
      
      <!-- Check GT order status -->
      <set_value name="$debugHasDirectGT" exact="false"/>
      <do_if value="$debugDefaultOrder == 'GalaxyTraderMK3'">
        <set_value name="$debugHasDirectGT" exact="true"/>
      </do_if>
      <set_value name="$debugHasGTCommander" exact="false"/>
      <do_if value="@$debugCommander.exists and $debugCommanderOrder == 'GalaxyTraderMK3'">
        <set_value name="$debugHasGTCommander" exact="true"/>
      </do_if>
      
      <!-- Check if in GT_Ships registry -->
      <set_value name="$debugInRegistry" exact="global.$GT_Ships? and global.$GT_Ships.{$debugShip}?"/>
      
      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-AI] REMOVAL DETECTION DEBUG: ' + $debugShip.idcode + ' - COMPREHENSIVE STATE'" chance="100"/>
        <debug_text text="'[GT-AI]   Ship: ' + $debugShip.idcode + ' (' + (if $debugShip.knownname then $debugShip.knownname else 'UNNAMED') + ')'" chance="100"/>
        <debug_text text="'[GT-AI]   Pilot: ' + $debugPilotName + (if $debugPilot != null then ' (exists)' else ' (NONE)')" chance="100"/>
        <debug_text text="'[GT-AI]   Default Order: ' + (if $debugDefaultOrder then $debugDefaultOrder else 'NONE')" chance="100"/>
        <debug_text text="'[GT-AI]   Active Orders (' + $debugOrdersCount + '): ' + $debugOrdersStr" chance="100"/>
        <debug_text text="'[GT-AI]   Commander: ' + $debugCommanderId + ' (Order: ' + $debugCommanderOrder + ')'" chance="100"/>
        <debug_text text="'[GT-AI]   GT Status: Direct=' + $debugHasDirectGT + ', ViaCommander=' + $debugHasGTCommander + ', InRegistry=' + $debugInRegistry" chance="100"/>
        <debug_text text="'[GT-AI]   Flags: ActivelyTrading=' + $isActivelyTrading + ', TrainingTransition=' + $isTrainingTransition + ', MaintenanceTransition=' + $isMaintenanceTransition" chance="100"/>
      </do_if>
    </do_if>
    
    <!-- Order cancellation detection -->
    <!-- Only send signal if GT default order is actually cancelled -->
    <!-- on_abort can fire when trade orders are cancelled, but GT order might still be active -->
    <!-- Unified GT order status check (inline for AI scripts) -->
    <set_value name="$currentDefaultOrder" exact="@this.ship.defaultorder.id"/>
    <set_value name="$hasDirectGTOrder" exact="false"/>
    <set_value name="$hasGTCommander" exact="false"/>
    <set_value name="$isGTControlled" exact="false"/>
    
    <!-- Check direct GT order -->
    <do_if value="$currentDefaultOrder == 'GalaxyTraderMK3'">
      <set_value name="$hasDirectGTOrder" exact="true"/>
      <set_value name="$isGTControlled" exact="true"/>
    </do_if>
    
    <!-- Check commander status -->
    <do_if value="not $hasDirectGTOrder and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
      <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
        <set_value name="$hasGTCommander" exact="true"/>
        <do_if value="$currentDefaultOrder == 'Assist'">
          <set_value name="$isGTControlled" exact="true"/>
        </do_if>
      </do_if>
    </do_if>
    
    <set_value name="$isGTOrderCancelled" exact="false"/>
    
    <!-- If GT order is gone, process cleanup REGARDLESS of training/maintenance transitions -->
    <!-- Only skip Phase 7 if GT order is STILL ACTIVE AND there's a training/maintenance transition -->
    <do_if value="not $isGTControlled">
      <!-- GT order is gone - process cleanup even if training/maintenance/disposal orders exist -->
      <!-- Check if GT default order is still active -->
      <!-- If defaultorder.id is null, different, or not GalaxyTraderMK3, GT order was cancelled -->
      <do_if value="not $currentDefaultOrder">
        <!-- No default order â†’ GT order was cancelled -->
        <set_value name="$isGTOrderCancelled" exact="true"/>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in on_abort, default order: NONE)'" chance="100"/>
        </do_if>
        <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
          $Ship = this.ship,
          $UpdateType = 'GT_Order_Cancelled'
        ]"/>
        
        <!-- EVENT-DRIVEN: Trigger orphaned ship check -->
        <do_if value="global.$GT_Ships? and global.$GT_Ships.{this.ship}?">
          <signal_objects object="player.galaxy" param="'GT_Check_Ship_Orphaned'" param2="table[$Ship = this.ship]"/>
        </do_if>
        
        <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
        <!-- Check if ship WAS a subordinate BEFORE GT order was cancelled -->
        <!-- Use this.$was_subordinate flag or check state manager state -->
        <set_value name="$wasSubordinateBeforeCancellation" exact="false"/>
        <do_if value="this.$was_subordinate?">
          <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
        </do_if>
        <do_elseif value="global.$GT_Ship_State? and global.$GT_Ship_State.{this.ship}?">
          <!-- Check state manager to see if ship was a subordinate -->
          <set_value name="$state" exact="global.$GT_Ship_State.{this.ship}"/>
          <do_if value="$state.$SubordinateState? and $state.$SubordinateState == 'subordinate'">
            <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
          </do_if>
        </do_elseif>
        
        <!-- Check if ship is CURRENTLY subordinate to GT commander -->
        <set_value name="$isSubordinateOfGTCommander" exact="false"/>
        <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$isSubordinateOfGTCommander" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Restore name if:
             1. Ship was NOT a subordinate before cancellation, OR
             2. Ship was a subordinate but is NO LONGER subordinate to GT commander -->
        <set_value name="$shouldRestoreName" exact="false"/>
        <do_if value="not $wasSubordinateBeforeCancellation">
          <!-- Ship was not a subordinate - restore name if not currently subordinate to GT commander -->
          <do_if value="not $isSubordinateOfGTCommander">
            <set_value name="$shouldRestoreName" exact="true"/>
          </do_if>
        </do_if>
        <do_elseif value="$wasSubordinateBeforeCancellation and not $isSubordinateOfGTCommander">
          <!-- Ship WAS a subordinate but is NO LONGER subordinate to GT commander - restore name -->
          <set_value name="$shouldRestoreName" exact="true"/>
        </do_elseif>
        
        <do_if value="$shouldRestoreName and this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'GT order cancelled - restoring original name',
              $OriginalName = $originalName
            ]"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (was subordinate: ' + $wasSubordinateBeforeCancellation + ', currently subordinate: ' + $isSubordinateOfGTCommander + ', original name: ' + $originalName + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
      </do_if>
      <do_elseif value="$currentDefaultOrder != 'GalaxyTraderMK3'">
        <!-- Different default order â†’ Check if GT order was actually cancelled -->
        <!-- For subordinates with Assist order, trade order termination is NORMAL -->
        <!-- Only emit cleanup if ship NO LONGER has GT order (direct or via commander) -->
        <set_value name="$actualDefaultOrder" exact="@this.ship.defaultorder.id"/>
        
        <!-- Check if ship has direct GT order -->
        <set_value name="$hasDirectGTOrder" exact="false"/>
        <do_if value="$actualDefaultOrder == 'GalaxyTraderMK3'">
          <set_value name="$hasDirectGTOrder" exact="true"/>
        </do_if>
        
        <!-- Check if ship is subordinate to GT commander (current commander, not old) -->
        <set_value name="$hasGTCommander" exact="false"/>
        <do_if value="not $hasDirectGTOrder and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$hasGTCommander" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Only emit cleanup if ship NO LONGER has GT order (direct or via commander) -->
        <!-- For subordinates, Assist order termination is handled by Assist order's on_abort -->
        <!-- Trade order termination is NORMAL and should NOT trigger cleanup -->
        <set_value name="$shouldEmitCleanup" exact="false"/>
        <do_if value="not $hasDirectGTOrder and not $hasGTCommander">
          <!-- No direct GT order and no GT commander = GT order truly gone -->
          <set_value name="$shouldEmitCleanup" exact="true"/>
        </do_if>
        
        <!-- Emit cleanup signal if GT order is gone -->
        <do_if value="$shouldEmitCleanup">
          <set_value name="$isGTOrderCancelled" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in on_abort, default order: ' + $currentDefaultOrder + ', has direct GT: ' + $hasDirectGTOrder + ', has GT commander: ' + $hasGTCommander + ')'" chance="100"/>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'GT_Order_Cancelled'
          ]"/>
        </do_if>
        <do_else>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI]  PHASE 7: Trade order aborted but GT order still active for ' + this.ship.idcode + ' (default order: ' + $currentDefaultOrder + ', has direct GT: ' + $hasDirectGTOrder + ', has GT commander: ' + $hasGTCommander + ') - NOT sending GT_Order_Cancelled'" chance="100"/>
          </do_if>
        </do_else>
        
        <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
        <!-- Check if ship WAS a subordinate BEFORE GT order was cancelled -->
        <!-- Use this.$was_subordinate flag or check state manager state -->
        <set_value name="$wasSubordinateBeforeCancellation" exact="false"/>
        <do_if value="this.$was_subordinate?">
          <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
        </do_if>
        <do_elseif value="global.$GT_Ship_State? and global.$GT_Ship_State.{this.ship}?">
          <!-- Check state manager to see if ship was a subordinate -->
          <set_value name="$state" exact="global.$GT_Ship_State.{this.ship}"/>
          <do_if value="$state.$SubordinateState? and $state.$SubordinateState == 'subordinate'">
            <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
          </do_if>
        </do_elseif>
        
        <!-- Check if ship is CURRENTLY subordinate to GT commander -->
        <set_value name="$isSubordinateOfGTCommander" exact="false"/>
        <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
          <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
            <set_value name="$isSubordinateOfGTCommander" exact="true"/>
          </do_if>
        </do_if>
        
        <!-- Restore name if:
             1. Ship was NOT a subordinate before cancellation, OR
             2. Ship was a subordinate but is NO LONGER subordinate to GT commander -->
        <set_value name="$shouldRestoreName" exact="false"/>
        <do_if value="not $wasSubordinateBeforeCancellation">
          <!-- Ship was not a subordinate - restore name if not currently subordinate to GT commander -->
          <do_if value="not $isSubordinateOfGTCommander">
            <set_value name="$shouldRestoreName" exact="true"/>
          </do_if>
        </do_if>
        <do_elseif value="$wasSubordinateBeforeCancellation and not $isSubordinateOfGTCommander">
          <!-- Ship WAS a subordinate but is NO LONGER subordinate to GT commander - restore name -->
          <set_value name="$shouldRestoreName" exact="true"/>
        </do_elseif>
        
        <do_if value="$shouldRestoreName and this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'GT order cancelled - restoring original name',
              $OriginalName = $originalName
            ]"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (was subordinate: ' + $wasSubordinateBeforeCancellation + ', currently subordinate: ' + $isSubordinateOfGTCommander + ', original name: ' + $originalName + ')'" chance="100"/>
            </do_if>
          </do_if>
        </do_if>
      </do_elseif>
    </do_if>
    <do_elseif value="$hasDirectGTOrder or $hasGTCommander">
      <!-- GT order still active - only skip Phase 7 if there's a training/maintenance transition -->
      <!-- This prevents cleanup when GT order creates training/maintenance orders (normal behavior) -->
      <do_if value="not $isTrainingTransition and not $isMaintenanceTransition">
        <!-- GT order active, no transitions - check if default order changed -->
        <!-- (This is the original Phase 7 logic for when GT order is still active) -->
        <!-- Check if GT default order is still active -->
        <!-- If defaultorder.id is null, different, or not GalaxyTraderMK3, GT order was cancelled -->
        <do_if value="not $currentDefaultOrder">
          <!-- No default order â†’ GT order was cancelled -->
          <set_value name="$isGTOrderCancelled" exact="true"/>
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in on_abort, default order: NONE)'" chance="100"/>
          </do_if>
          <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
            $Ship = this.ship,
            $UpdateType = 'GT_Order_Cancelled'
          ]"/>
          
          <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
          <!-- Check if ship WAS a subordinate BEFORE GT order was cancelled -->
          <!-- Use this.$was_subordinate flag or check state manager state -->
          <set_value name="$wasSubordinateBeforeCancellation" exact="false"/>
          <do_if value="this.$was_subordinate?">
            <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
          </do_if>
          <do_elseif value="global.$GT_Ship_State? and global.$GT_Ship_State.{this.ship}?">
            <!-- Check state manager to see if ship was a subordinate -->
            <set_value name="$state" exact="global.$GT_Ship_State.{this.ship}"/>
            <do_if value="$state.$SubordinateState? and $state.$SubordinateState == 'subordinate'">
              <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
            </do_if>
          </do_elseif>
          
          <!-- Check if ship is CURRENTLY subordinate to GT commander -->
          <set_value name="$isSubordinateOfGTCommander" exact="false"/>
          <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
            <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
              <set_value name="$isSubordinateOfGTCommander" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Restore name if:
               1. Ship was NOT a subordinate before cancellation, OR
               2. Ship was a subordinate but is NO LONGER subordinate to GT commander -->
          <set_value name="$shouldRestoreName" exact="false"/>
          <do_if value="not $wasSubordinateBeforeCancellation">
            <!-- Ship was not a subordinate - restore name if not currently subordinate to GT commander -->
            <do_if value="not $isSubordinateOfGTCommander">
              <set_value name="$shouldRestoreName" exact="true"/>
            </do_if>
          </do_if>
          <do_elseif value="$wasSubordinateBeforeCancellation and not $isSubordinateOfGTCommander">
            <!-- Ship WAS a subordinate but is NO LONGER subordinate to GT commander - restore name -->
            <set_value name="$shouldRestoreName" exact="true"/>
          </do_elseif>
          
          <do_if value="$shouldRestoreName and this.ship.pilot?">
            <set_value name="$originalName" exact="null"/>
            <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
              <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
            </do_if>
            
            <do_if value="$originalName">
              <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                $Ship = this.ship,
                $Pilot = this.ship.pilot,
                $Reason = 'GT order cancelled - restoring original name',
                $OriginalName = $originalName
              ]"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (was subordinate: ' + $wasSubordinateBeforeCancellation + ', currently subordinate: ' + $isSubordinateOfGTCommander + ', original name: ' + $originalName + ')'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
        <do_elseif value="$currentDefaultOrder != 'GalaxyTraderMK3'">
          <!-- Different default order â†’ Check if GT order was actually cancelled -->
          <!-- For subordinates with Assist order, trade order termination is NORMAL -->
          <!-- Only emit cleanup if ship NO LONGER has GT order (direct or via commander) -->
          <set_value name="$actualDefaultOrder" exact="@this.ship.defaultorder.id"/>
          
          <!-- Check if ship has direct GT order -->
          <set_value name="$hasDirectGTOrder" exact="false"/>
          <do_if value="$actualDefaultOrder == 'GalaxyTraderMK3'">
            <set_value name="$hasDirectGTOrder" exact="true"/>
          </do_if>
          
          <!-- Check if ship is subordinate to GT commander (current commander, not old) -->
          <set_value name="$hasGTCommander" exact="false"/>
          <do_if value="not $hasDirectGTOrder and this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
            <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
              <set_value name="$hasGTCommander" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Only emit cleanup if ship NO LONGER has GT order (direct or via commander) -->
          <!-- For subordinates, Assist order termination is handled by Assist order's on_abort -->
          <!-- Trade order termination is NORMAL and should NOT trigger cleanup -->
          <set_value name="$shouldEmitCleanup" exact="false"/>
          <do_if value="not $hasDirectGTOrder and not $hasGTCommander">
            <!-- No direct GT order and no GT commander = GT order truly gone -->
            <set_value name="$shouldEmitCleanup" exact="true"/>
          </do_if>
          
          <!-- Emit cleanup signal if GT order is gone -->
          <do_if value="$shouldEmitCleanup">
            <set_value name="$isGTOrderCancelled" exact="true"/>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI] PHASE 7: GT order cancelled for ' + this.ship.idcode + ' (detected in on_abort, default order: ' + $currentDefaultOrder + ', has direct GT: ' + $hasDirectGTOrder + ', has GT commander: ' + $hasGTCommander + ')'" chance="100"/>
            </do_if>
            <signal_objects object="player.galaxy" param="'GT_Ship_State_Update'" param2="table[
              $Ship = this.ship,
              $UpdateType = 'GT_Order_Cancelled'
            ]"/>
          </do_if>
          <do_else>
            <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
              <debug_text text="'[GT-AI]  PHASE 7: Trade order aborted but GT order still active for ' + this.ship.idcode + ' (default order: ' + $currentDefaultOrder + ', has direct GT: ' + $hasDirectGTOrder + ', has GT commander: ' + $hasGTCommander + ') - NOT sending GT_Order_Cancelled'" chance="100"/>
            </do_if>
          </do_else>
          
          <!-- Restore ship name if not GT-controlled (direct or subordinate) -->
          <!-- Check if ship WAS a subordinate BEFORE GT order was cancelled -->
          <!-- Use this.$was_subordinate flag or check state manager state -->
          <set_value name="$wasSubordinateBeforeCancellation" exact="false"/>
          <do_if value="this.$was_subordinate?">
            <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
          </do_if>
          <do_elseif value="global.$GT_Ship_State? and global.$GT_Ship_State.{this.ship}?">
            <!-- Check state manager to see if ship was a subordinate -->
            <set_value name="$state" exact="global.$GT_Ship_State.{this.ship}"/>
            <do_if value="$state.$SubordinateState? and $state.$SubordinateState == 'subordinate'">
              <set_value name="$wasSubordinateBeforeCancellation" exact="true"/>
            </do_if>
          </do_elseif>
          
          <!-- Check if ship is CURRENTLY subordinate to GT commander -->
          <set_value name="$isSubordinateOfGTCommander" exact="false"/>
          <do_if value="this.ship.commander? and this.ship.commander.exists and this.ship.commander != this.ship">
            <do_if value="this.ship.commander.defaultorder? and @this.ship.commander.defaultorder.id == 'GalaxyTraderMK3'">
              <set_value name="$isSubordinateOfGTCommander" exact="true"/>
            </do_if>
          </do_if>
          
          <!-- Restore name if:
               1. Ship was NOT a subordinate before cancellation, OR
               2. Ship was a subordinate but is NO LONGER subordinate to GT commander -->
          <set_value name="$shouldRestoreName" exact="false"/>
          <do_if value="not $wasSubordinateBeforeCancellation">
            <!-- Ship was not a subordinate - restore name if not currently subordinate to GT commander -->
            <do_if value="not $isSubordinateOfGTCommander">
              <set_value name="$shouldRestoreName" exact="true"/>
            </do_if>
          </do_if>
          <do_elseif value="$wasSubordinateBeforeCancellation and not $isSubordinateOfGTCommander">
            <!-- Ship WAS a subordinate but is NO LONGER subordinate to GT commander - restore name -->
            <set_value name="$shouldRestoreName" exact="true"/>
          </do_elseif>
          
          <do_if value="$shouldRestoreName and this.ship.pilot?">
            <set_value name="$originalName" exact="null"/>
            <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
              <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
            </do_if>
            
            <do_if value="$originalName">
              <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
                $Ship = this.ship,
                $Pilot = this.ship.pilot,
                $Reason = 'GT order cancelled - restoring original name',
                $OriginalName = $originalName
              ]"/>
              <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
                <debug_text text="'[GT-AI] PHASE 7: Name restoration signal sent for ' + this.ship.idcode + ' (was subordinate: ' + $wasSubordinateBeforeCancellation + ', currently subordinate: ' + $isSubordinateOfGTCommander + ', original name: ' + $originalName + ')'" chance="100"/>
              </do_if>
            </do_if>
          </do_if>
        </do_elseif>
        <do_else>
          <!-- GT order still active - this is just trade order cancellation, not GT order cancellation -->
          <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
            <debug_text text="'[GT-AI] ' + this.ship.idcode + ': on_abort fired but GT order still active (default order: ' + $currentDefaultOrder + ') - skipping Phase 7 (trade order cancellation, not GT order cancellation)'" chance="100"/>
          </do_if>
        </do_else>
      </do_if>
      <do_else>
        <!-- GT order still active AND training/maintenance transition - skip Phase 7 (normal behavior) -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT order still active with training/maintenance transition - skipping Phase 7 (normal transition, not removal)'" chance="100"/>
        </do_if>
      </do_else>
    </do_elseif>
    
    <!-- Check if subordinate cleanup already sent signal (to avoid duplicate) -->
    <do_if value="this.$subordinate_cleanup_sent?">
      <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Subordinate cleanup signal already sent - skipping duplicate'" chance="100"/>
    </do_if>
    <do_else>
      <!-- Check for permanent removal FIRST, regardless of trading state -->
      <!-- When player stops order, we MUST restore name even if TradePerform orders are still active -->
      <!-- Unified GT order status check (inline for AI scripts) -->
      <!-- If GT order is gone (no direct, no commander), it's permanent removal REGARDLESS of trading state -->
      <set_value name="$isPermanentRemoval" exact="not $hasDirectGTOrder and not $hasGTCommander"/>
      
      <do_if value="$isPermanentRemoval">
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <set_value name="$debugOrdersCount" exact="this.ship.orders.count"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT order removed (no direct GT, no GT commander) â†’ PERMANENT REMOVAL (actively trading: ' + $isActivelyTrading + ', orders count: ' + $debugOrdersCount + ')'" chance="100"/>
        </do_if>
      </do_if>
      <do_else>
        <!-- GT order still active - check other conditions -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': GT order still active (direct: ' + $hasDirectGTOrder + ', commander: ' + $hasGTCommander + ') - checking other removal conditions'" chance="100"/>
        </do_if>
        
        <!-- Additional checks: no default order, different order, or not registered -->
        <do_if value="not $currentDefaultOrder">
          <!-- No default order at all â†’ PERMANENT REMOVAL -->
          <set_value name="$isPermanentRemoval" exact="true"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': No default order detected â†’ PERMANENT REMOVAL'" chance="100"/>
        </do_if>
        <do_elseif value="$currentDefaultOrder and $currentDefaultOrder != 'GalaxyTraderMK3' and $currentDefaultOrder != 'Assist'">
          <!-- Ship has a DIFFERENT permanent default order â†’ PERMANENT REMOVAL -->
          <set_value name="$isPermanentRemoval" exact="true"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Different default order (' + $currentDefaultOrder + ') detected â†’ PERMANENT REMOVAL'" chance="100"/>
        </do_elseif>
        <do_elseif value="not (global.$GT_Ships? and global.$GT_Ships.{this.ship}?)">
          <!-- Ship was removed from GT (unregistered), definitely restore name -->
          <set_value name="$isPermanentRemoval" exact="true"/>
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Ship no longer registered in GT_Ships â†’ PERMANENT REMOVAL (even if actively trading)'" chance="100"/>
        </do_elseif>
      </do_else>
      
      <!-- Calculate subordinate status (needed for both permanent removal and pause checks) -->
      <set_value name="$isSubordinate" exact="$currentDefaultOrder == 'Assist' and $hasGTCommander"/>
      
      <!-- Always restore name on permanent removal, even if actively trading -->
      <do_if value="$isPermanentRemoval">
        <!-- Send ABORT signal: Restore ship name and clean up completely -->
        <do_if value="this.ship.pilot?">
          <set_value name="$originalName" exact="null"/>
          <do_if value="global.$GT_Pilots? and global.$GT_Pilots.{this.ship.pilot}? and global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName?">
            <set_value name="$originalName" exact="global.$GT_Pilots.{this.ship.pilot}.$OriginalShipName"/>
          </do_if>
          
          <do_if value="$originalName">
            <signal_objects object="player.galaxy" param="'GT_Ship_Order_Aborted'" param2="table[
              $Ship = this.ship,
              $Pilot = this.ship.pilot,
              $Reason = 'Order permanently removed by player',
              $OriginalName = $originalName
            ]"/>
          </do_if>
        </do_if>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Sending ABORT signal (restore name, preserve XP) - permanent removal detected'" chance="100"/>
        </do_if>
        
        <!-- Clear training and maintenance flags -->
        <remove_value name="this.$training_in_progress"/>
        <remove_value name="this.$training_order_created"/>
        <remove_value name="this.$training_transition"/>
        <remove_value name="this.$maintenance_transition"/>
      </do_if>
      <!-- Only send PAUSE signal if NOT permanently removed AND NOT actively trading AND NOT transitioning -->
      <!-- CRITICAL: Don't pause subordinates with Assist order - they should stay registered -->
      <do_elseif value="not $isActivelyTrading and not $isTrainingTransition and not $isMaintenanceTransition and not $isSubordinate">
        <!-- Send PAUSE signal: Preserve everything (name and XP) for potential resume -->
        <set_value name="$pauseData" exact="table[
          $Ship = this.ship,
          $Pilot = this.ship.pilot,
          $Reason = 'Order temporarily replaced - preserving pilot data',
          $PreserveData = true
        ]"/>
        
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Sending PAUSE signal (preserve everything for resume)'" chance="100"/>
        </do_if>
        <signal_objects object="player.galaxy" param="'GT_Ship_Order_Paused'" param2="$pauseData"/>
        
        <!-- Clear training and maintenance flags -->
        <remove_value name="this.$training_in_progress"/>
        <remove_value name="this.$training_order_created"/>
        <remove_value name="this.$training_transition"/>
        <remove_value name="this.$maintenance_transition"/>
      </do_elseif>
      <do_elseif value="$isSubordinate">
        <!-- Subordinate with Assist order - don't pause, stay registered -->
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Subordinate with Assist order - NOT sending PAUSE (staying registered)'" chance="100"/>
        </do_if>
      </do_elseif>
      <do_else>
        <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
          <debug_text text="'[GT-AI] ' + this.ship.idcode + ': Ship still actively trading/training/maintenance - NOT sending signals (will handle when orders complete)'" chance="100"/>
        </do_if>
      </do_else>
    </do_else>
  </on_abort>
  
</aiscript> 