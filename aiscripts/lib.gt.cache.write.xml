<?xml version="1.0" encoding="utf-8"?>
<aiscript name="lib.gt.cache.write" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../ORIGINAL_MODS_DO NOT_MODIFY/X4Original/libraries/aiscripts.xsd" version="1">
  <!-- Writes trade results into the global trade cache with sorted insertion (by Score descending).
       Runs in AI script context so <wait> can be used to yield between insertions,
       preventing frame drops while maintaining sort order atomically per entry.

       Each insertion (linear search + insert) runs without yielding = atomic.
       Yields happen only BETWEEN entries, so concurrent writers to the same
       home sector cache see consistent state at each insertion boundary.

       Also performs write-time cleanup of expired/dead entries before insertion. -->
  <params>
    <param name="tradeList" default="[]"/>
    <param name="homeSector"/>
    <param name="cacheTTL" default="300s"/>
    <param name="maxSearchDistance" default="0"/> <!-- For GT_TradeCacheMaxDistance tracking -->
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <!-- Read performance settings from global settings -->
      <set_value name="this.$gt_yieldMs" exact="1"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$AIYieldInterval?">
        <set_value name="this.$gt_yieldMs" exact="[1, @global.$GT_GlobalSettings.$Performance.$AIYieldInterval].max"/>
      </do_if>
      <set_value name="this.$writeBatchSize" exact="1"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$CacheWriteBatchSize?">
        <set_value name="this.$writeBatchSize" exact="[1, @global.$GT_GlobalSettings.$Performance.$CacheWriteBatchSize].max"/>
      </do_if>
      <set_value name="this.$writeBatchSize" exact="(this.$writeBatchSize)i"/>
      <set_value name="this.$cleanupBatchSize" exact="50"/>
      <do_if value="global.$GT_GlobalSettings? and global.$GT_GlobalSettings.$Performance? and global.$GT_GlobalSettings.$Performance.$CacheCleanupBatchSize?">
        <set_value name="this.$cleanupBatchSize" exact="[10, @global.$GT_GlobalSettings.$Performance.$CacheCleanupBatchSize].max"/>
      </do_if>
      <set_value name="this.$cleanupBatchSize" exact="(this.$cleanupBatchSize)i"/>

      <!-- Early exit if nothing to write -->
      <do_if value="$tradeList.count == 0 or not $homeSector?">
        <return value="table[$Written = 0, $Cleaned = 0, $CacheSize = 0]"/>
      </do_if>

      <!-- Ensure cache structure exists -->
      <do_if value="not global.$GT_TradeCache?">
        <set_value name="global.$GT_TradeCache" exact="table[]"/>
      </do_if>
      <do_if value="not global.$GT_TradeCache.{$homeSector}?">
        <set_value name="global.$GT_TradeCache.{$homeSector}" exact="[]"/>
      </do_if>

      <set_value name="$cacheNow" exact="player.age"/>

      <!-- ══════════════════════════════════════════════════════════════════
           Phase 1: Write-time cleanup — remove expired/dead entries
           Iterate reverse so remove_value index shifts don't affect remaining indices.
           Yield every 50 entries to stay frame-friendly on large caches.
           ══════════════════════════════════════════════════════════════════ -->
      <set_value name="$expiredCount" exact="0"/>
      <set_value name="$cleanupSize" exact="global.$GT_TradeCache.{$homeSector}.count"/>
      <do_all exact="$cleanupSize" counter="$ci" reverse="true">
        <set_value name="$oldEntry" exact="@global.$GT_TradeCache.{$homeSector}.{$ci}"/>
        <do_if value="not $oldEntry?">
          <remove_value name="global.$GT_TradeCache.{$homeSector}.{$ci}"/>
          <set_value name="$expiredCount" operation="add"/>
          <continue/>
        </do_if>

        <!-- Timestamp: $CachedAt (new pipeline) with $Timestamp fallback (legacy) -->
        <set_value name="$oldTs" exact="@$oldEntry.$CachedAt"/>
        <do_if value="$oldTs == null">
          <set_value name="$oldTs" exact="@$oldEntry.$Timestamp"/>
        </do_if>

        <set_value name="$isStale" exact="false"/>
        <!-- TTL expired -->
        <do_if value="$oldTs != null and ($cacheNow - $oldTs) gt $cacheTTL">
          <set_value name="$isStale" exact="true"/>
        </do_if>
        <!-- Buy offer dead -->
        <do_if value="not $isStale and @$oldEntry.$BuyOffer != null and not @$oldEntry.$BuyOffer.exists">
          <set_value name="$isStale" exact="true"/>
        </do_if>
        <!-- Sell offer dead -->
        <do_if value="not $isStale and @$oldEntry.$SellOffer != null and not @$oldEntry.$SellOffer.exists">
          <set_value name="$isStale" exact="true"/>
        </do_if>

        <do_if value="$isStale">
          <remove_value name="global.$GT_TradeCache.{$homeSector}.{$ci}"/>
          <set_value name="$expiredCount" operation="add"/>
        </do_if>

        <!-- Yield every $cleanupBatchSize entries during cleanup -->
        <set_value name="$ciInt" exact="($ci)i"/>
        <do_if value="($ciInt % this.$cleanupBatchSize) == 0">
          <wait exact="this.$gt_yieldMs * 1ms" comment="Yield cleanup loop"/>
        </do_if>
      </do_all>

      <do_if value="$expiredCount gt 0 and @global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-CacheWrite] ' + this.ship.idcode + ': Write-time cleanup removed ' + $expiredCount + ' expired/stale entries from ' + $homeSector.knownname + ' (remaining: ' + global.$GT_TradeCache.{$homeSector}.count + ')'" chance="100"/>
      </do_if>

      <!-- ══════════════════════════════════════════════════════════════════
           Phase 2: Sorted insertion by $Score descending.
           For each new trade:
             1. Linear search the cache for the first entry with a lower Score (with break)
             2. Insert at that position (or append if lowest)
             3. Yield (wait) — this is the ONLY yield point; search+insert is atomic.
           ══════════════════════════════════════════════════════════════════ -->
      <do_all exact="$tradeList.count" counter="$ti">
        <set_value name="$newTrade" exact="$tradeList.{$ti}"/>
        <set_value name="$newTrade.$CachedAt" exact="$cacheNow"/>
        <set_value name="$newTrade.$Timestamp" exact="$cacheNow"/> <!-- Legacy compat: some MD code checks $Timestamp -->
        <set_value name="$newScore" exact="if $newTrade.$Score? then @$newTrade.$Score else 0"/>

        <!-- Linear search: find first existing entry with Score < newScore -->
        <set_value name="$insertIdx" exact="0"/>
        <set_value name="$insertFound" exact="false"/>
        <set_value name="$cacheSize" exact="global.$GT_TradeCache.{$homeSector}.count"/>
        <do_if value="$cacheSize gt 0">
          <do_all exact="$cacheSize" counter="$si">
            <set_value name="$existingScore" exact="if global.$GT_TradeCache.{$homeSector}.{$si}.$Score? then @global.$GT_TradeCache.{$homeSector}.{$si}.$Score else 0"/>
            <do_if value="$newScore gt $existingScore">
              <set_value name="$insertIdx" exact="$si"/>
              <set_value name="$insertFound" exact="true"/>
              <break/>
            </do_if>
          </do_all>
        </do_if>

        <!-- Insert at position or append at end — ATOMIC with the search above (no yield between) -->
        <do_if value="$insertFound">
          <set_value name="global.$GT_TradeCache.{$homeSector}.{$insertIdx}" exact="$newTrade" operation="insert"/>
        </do_if>
        <do_else>
          <append_to_list name="global.$GT_TradeCache.{$homeSector}" exact="$newTrade"/>
        </do_else>

        <!-- Yield every $writeBatchSize insertions — each insertion is atomic (no yield during search+insert) -->
        <set_value name="$tiInt" exact="($ti)i"/>
        <do_if value="($tiInt % this.$writeBatchSize) == 0">
          <wait exact="this.$gt_yieldMs * 1ms" comment="Yield between sorted insertions"/>
        </do_if>
      </do_all>

      <do_if value="@global.$GT_GlobalSettings.$Debug.$EnableDebugLogging">
        <debug_text text="'[GT-CacheWrite] ' + this.ship.idcode + ': Wrote ' + $tradeList.count + ' trades (sorted) into ' + $homeSector.knownname + ' cache (total: ' + global.$GT_TradeCache.{$homeSector}.count + ', cleaned: ' + $expiredCount + ')'" chance="100"/>
      </do_if>

      <!-- ══════════════════════════════════════════════════════════════════
           Phase 3: Update GT_TradeCacheMaxDistance
           ══════════════════════════════════════════════════════════════════ -->
      <do_if value="$maxSearchDistance gt 0">
        <do_if value="not global.$GT_TradeCacheMaxDistance?">
          <set_value name="global.$GT_TradeCacheMaxDistance" exact="table[]"/>
        </do_if>
        <do_if value="not global.$GT_TradeCacheMaxDistance.{$homeSector}? or $maxSearchDistance gt global.$GT_TradeCacheMaxDistance.{$homeSector}">
          <set_value name="global.$GT_TradeCacheMaxDistance.{$homeSector}" exact="$maxSearchDistance"/>
        </do_if>
      </do_if>

      <return value="table[
        $Written = $tradeList.count,
        $Cleaned = $expiredCount,
        $CacheSize = global.$GT_TradeCache.{$homeSector}.count
      ]"/>
    </actions>
  </attention>
</aiscript>
